<tool id="__MERGE_COLLECTION__"
      name="Merge Collections"
      version="1.0.0"
      tool_type="merge_collection">
  <description>into single list of datasets</description>
  <type class="MergeCollectionTool" module="galaxy.tools" />
  <action module="galaxy.tools.actions.model_operations"
          class="ModelOperationToolAction"/>
  <inputs>
    <macros>
        <macro name="suffix_param">
            <param name="suffix_pattern" label="Use the follow suffix pattern:" help="Describe the suffix pattern to use when joing element name and data copy number. For instance, the default is '_#', which will produce _1 as the first suffix used." value="_#">
                <sanitizer invalid_char="">
                    <valid initial="string.letters,string.digits">
                        <add value="_" />
                        <add value="-" />
                        <add value=":" />
                        <add value="#" />
                    </valid>
                </sanitizer>
            </param>
        </macro>
    </macros>
    <repeat name="inputs" title="Input Collections" min="2">
        <param name="input" type="data_collection" label="Input Collection" />
    </repeat>
    <section name="advanced" title="Advanced Options">
        <conditional name="conflict">
          <param name="duplicate_options" type="select" label="How should conflicts (or potential conflicts) be handled?"
                 help="Collection elements must have unique element identifiers, when appending how should unique identifiers be assured.">
            <option value="suffix_conflict">Append suffix to conflicted element identifers</option>
            <option value="suffix_every">Append suffix to every element identifer</option>
            <option value="keep_first" selected="true">Keep first instance</option>
            <option value="keep_last">Keep last instance</option>
            <option value="fail">Fail collection creation</option>
          </param>      
          <when value="suffix_conflict">
            <expand macro="suffix_param" />
          </when>
          <when value="suffix_conflict_rest">
            <expand macro="suffix_param" />
          </when>
          <when value="suffix_every">
            <expand macro="suffix_param" />
          </when>
          <when value="keep_first" />
          <when value="kee_last" />
          <when value="fail" />
        </conditional>
    </section>
  </inputs>
  <outputs>
    <collection name="output" format_source="input" type_source="inputs_0|input" label="${on_string} (merged)" >
    </collection>
  </outputs>
  <tests>
    <test>
      <repeat name="inputs">
        <param name="input">
          <collection type="list:paired">
            <element name="i1">
              <collection type="paired">
                <element name="forward" value="simple_line.txt" />
                <element name="reverse" value="simple_line_alternative.txt" />
              </collection>
            </element>          
          </collection>
        </param>
      </repeat>
      <repeat name="inputs">
        <param name="input">
          <collection type="list:paired">
            <element name="i2">
              <collection type="paired">
                <element name="forward" value="simple_line.txt" />
                <element name="reverse" value="simple_line_alternative.txt" />
              </collection>
            </element>           
          </collection>
        </param>
      </repeat>
      <output_collection name="output" type="list:paired">
        <element name="i1">
          <element name="forward">
            <assert_contents>
              <has_text_matching expression="^This is a line of text.\n$" />
            </assert_contents>
          </element>
          <element name="reverse">
            <assert_contents>
              <has_text_matching expression="^This is a different line of text.\n$" />
            </assert_contents>
          </element>
        </element>
        <element name="i2">
          <element name="forward">
            <assert_contents>
              <has_text_matching expression="^This is a line of text.\n$" />
            </assert_contents>
          </element>
          <element name="reverse">
            <assert_contents>
              <has_text_matching expression="^This is a different line of text.\n$" />
            </assert_contents>
          </element>
        </element>        
      </output_collection>
    </test>
    <test>
      <repeat name="inputs">
        <param name="input">
          <collection type="list">
            <element name="sample1" value ="simple_line.txt"/>
            <element name="sample2" value ="simple_line_alternative.txt"/>
          </collection>
        </param>
      </repeat>
      <repeat name="inputs">
        <param name="input">
          <collection type="list">
            <element name="sample1" value ="simple_line.txt"/>
            <element name="sample2" value ="simple_line_alternative.txt"/>
          </collection>
        </param>      
      </repeat>
      <section name="advanced">
        <conditional name="conflict">
          <param name="duplicate_options" value="suffix_every" />
          <param name="suffix_pattern" value="__#" />
        </conditional>
      </section>
      <output_collection name="output" type="list">
        <element name="sample1__1">
          <assert_contents>
            <has_text_matching expression="^This is a line of text.\n$"/>
          </assert_contents>
        </element>
        <element name="sample2__2">
          <assert_contents>
            <has_text_matching expression="^This is a different line of text.\n$"/>
          </assert_contents>
        </element>
        <element name="sample1__1">
          <assert_contents>
            <has_text_matching expression="^This is a line of text.\n$"/>
          </assert_contents>
        </element>
        <element name="sample2__1">
          <assert_contents>
            <has_text_matching expression="^This is a different line of text.\n$"/>
          </assert_contents>
        </element>                
      </output_collection>
    </test>
    <test>
      <repeat name="inputs">
        <param name="input">
          <collection type="list">
            <element name="sample1" value ="simple_line.txt"/>
            <element name="sample2" value ="simple_line_alternative.txt"/>
          </collection>
        </param>
      </repeat>
      <section name="advanced">
        <conditional name="conflict">
          <param name="duplicate_options" value="suffix_conflict" />
          <param name="suffix_pattern" value=":#" />
        </conditional>
      </section>
      <repeat name="inputs">
        <param name="input">
          <collection type="list">
            <element name="sample1" value ="simple_line.txt"/>
            <element name="sample2" value ="simple_line_alternative.txt"/>
          </collection>
        </param>      
      </repeat>
      <output_collection name="output" type="list">
        <element name="sample1">
          <assert_contents>
            <has_text_matching expression="^This is a line of text.\n$"/>
          </assert_contents>
        </element>
        <element name="sample2">
          <assert_contents>
            <has_text_matching expression="^This is a different line of text.\n$"/>
          </assert_contents>
        </element>
        <element name="sample1:1">
          <assert_contents>
            <has_text_matching expression="^This is a line of text.\n$"/>
          </assert_contents>
        </element>
        <element name="sample2:1">
          <assert_contents>
            <has_text_matching expression="^This is a different line of text.\n$"/>
          </assert_contents>
        </element>                
      </output_collection>
    </test>    
    <test>
      <param name="duplicate_options" value="first"/>
      <repeat name="inputs">
        <param name="input">
          <collection type="list">
            <element name="sample1" value ="simple_line.txt"/>
            <element name="sample2" value ="simple_line_alternative.txt"/>
          </collection>
        </param>
      </repeat>
      <repeat name="inputs">
        <param name="input">
          <collection type="list">
            <element name="sample1" value ="simple_line_alternative.txt"/>
            <element name="sample2" value ="simple_line.txt"/>
          </collection>
        </param>      
      </repeat>
      <output_collection name="output" type="list">
        <element name="sample1">
          <assert_contents>
            <has_text_matching expression="^This is a line of text.\n$"/>
          </assert_contents>
        </element>
        <element name="sample2">
          <assert_contents>
            <has_text_matching expression="^This is a different line of text.\n$"/>
          </assert_contents>
        </element>
      </output_collection>
    </test>
    <test>
      <section name="advanced">
        <conditional name="conflict">
          <param name="duplicate_options" value="keep_last" />
        </conditional>
      </section>
      <repeat name="inputs">
        <param name="input">
          <collection type="list">
            <element name="sample1" value ="simple_line.txt"/>
            <element name="sample2" value ="simple_line_alternative.txt"/>
          </collection>
        </param>
      </repeat>
      <repeat name="inputs">
        <param name="input">
          <collection type="list">
            <element name="sample1" value ="simple_line_alternative.txt"/>
            <element name="sample2" value ="simple_line.txt"/>
          </collection>
        </param>
      </repeat>
      <output_collection name="output" type="list">
        <element name="sample1">
          <assert_contents>
            <has_text_matching expression="^This is a different line of text.\n$"/>
          </assert_contents>
        </element>
        <element name="sample2">
          <assert_contents>
            <has_text_matching expression="^This is a line of text.\n$"/>
          </assert_contents>
        </element>
      </output_collection>
    </test>
  </tests>
  <help>
    This tool takes two list and creates a single unified list.
    
    This tool will create new history datasets for your collection
    but your quota usage will not increase.
  </help>
</tool>
