{"version":3,"sources":["viz/trackster/painters.js"],"names":["define","_","compute_overlap","first_region","second_region","CONTAINS","first_end","OVERLAP_START","second_end","CONTAINED_BY","AFTER","second_start","overlap","is_overlap","dashedLine","ctx","x1","y1","x2","y2","dashLen","undefined","dX","dY","dashes","Math","floor","sqrt","dashY","q","dashX","down_vertex_x","down_vertex_y","side_len","y","beginPath","moveTo","lineTo","this","fillStyle","closePath","default_val","Scaler","prototype","DrawResults","incomplete_features","options","feature_mapper","Painter","data","view_start","view_end","prefs","mode","extend","default_prefs","draw","width","height","w_scale","get_start_draw_pos","chrom_pos","get_end_draw_pos","_chrom_pos_to_draw_pos","get_draw_pos","offset","max","LinePainter","min_value","max_value","color","overflow_color","in_path","vertical_range","save","y_zero","round","delta_x_pxs","fillRect","map","slice","d","i","ceil","delta_x_px","block_color","pref_color","parseInt","painter_color","pref_r","pref_g","pref_b","top_overflow","bot_overflow","length","len","x_scaled","strokeStyle","height_px","saturation","new_r","new_g","new_b","overflow_x","stroke","restore","FeaturePositionMapper","feature_positions","slot_height","translation","y_translation","feature_data","slot","x_start","x_end","push","get_feature_data","x","feature_dict","alpha_scaler","height_scaler","call","max_label_length","FeaturePainter","connector_color","get_required_height","rows_required","required_height","y_scale","get_top_padding","slots","textAlign","x_draw_coords","feature","feature_uid","feature_start","feature_end","draw_element","map_feature_data","tile_low","tile_high","LinkedFeaturePainter","draw_background_connector","draw_individual_connectors","get_row_height","DENSE_TRACK_HEIGHT","NO_DETAIL_TRACK_HEIGHT","SQUISH_TRACK_HEIGHT","PACK_TRACK_HEIGHT","thickness","feature_name","feature_strand","f_start","f_end","draw_start","draw_end","y_start","thick_start","thick_end","reverse_strand_color","label_color","gen_val","globalAlpha","NO_DETAIL_FEATURE_HEIGHT","feature_te","feature_blocks","full_height","feature_ts","min","thin_height","thick_height","SQUISH_FEATURE_HEIGHT","DENSE_FEATURE_HEIGHT","cur_y_start","cur_height","CONNECTOR_COLOR","manager","get_pattern","canvas","k","k_len","last_block_start","block","start_and_height","block_end","block_start","last_block_end","block_thick_start","block_thick_end","hscale_factor","new_height","ws_height","measureText","LABEL_SPACING","ReadPainter","ref_seq","base_color_fn","show_insertions","_parse_cigar","cigar_str","cigar_ops","blocks","cur_block","base_pos","parsed_cigar","match","op","op_len","op_char","indexOf","cigar","strand","read_seq","get_draw_coord","sequence_coord","cig_op","s_start","s_end","tile_region","base_offset","seq_offset","char_width_px","pack_mode","draw_height","PACK_FEATURE_HEIGHT","paint_utils","ReadPainterUtils","drawing_blocks","draw_last","t","rect_y","cig_id","cig","seq_start","cig_len","cur_seq","start_pos","c","fillText","c_start","insert_x_coord","gap","x_center","seq","str_len","type","update_base_offset","item","font","drawDownwardEquilateralTriangle","connector","b1_end","draw_read","b2_start","line_height","longest_feature_length","calculate_longest_feature_length","ArcLinkedFeaturePainter","draw_connector","block1_end","block2_start","block2_end","radius","PI","view_range","Color","rgb","a","Array","isArray","substring","split","alpha","eval","toCSS","join","toString","toHSL","h","s","g","b","r","l","toARGB","concat","mix","color2","weight","color1","p","w1","w","w2","argb","start_color","end_color","start_value","end_value","value_range","LinearRamp","value","SplitRamp","middle_color","positive_ramp","negative_ramp","map_value","DiagonalHeatmapPainter","Infinity","pos_color","neg_color","invsqrt2","rotate","scale","s1","e1","s2","ramp","e2","row_height","px_per_base","draw_deletion","draw_details","delete_details_thickness","VariantPainter","divider_height","num_samples","summary_height","show_sample_data","locus_data","ref","sample_gts","allele_counts","start","genotype","j","get_indel_info","alt","alt_len","ref_len","base_px","feature_height","draw_summary","alt_info","indel_info","draw_x_start","pos","draw_y_start","allele_frac","variant","snp"],"mappings":"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","file":"../../../scripts/viz/trackster/painters.js","sourcesContent":["define( [\"libs/underscore\"], function( _ ) {\n\n/**\n * Compute the type of overlap between two regions. They are assumed to be on the same chrom/contig.\n * The overlap is computed relative to the second region; hence, OVERLAP_START indicates that the first\n * region overlaps the start (but not the end) of the second region.\n * NOTE: Coordinates are assumed to be in BED format: half open (start is closed, end is open).\n */\nvar BEFORE = 1001, CONTAINS = 1002, OVERLAP_START = 1003, OVERLAP_END = 1004, CONTAINED_BY = 1005, AFTER = 1006;\nvar compute_overlap = function(first_region, second_region) {\n    var\n        first_start = first_region[0], first_end = first_region[1],\n        second_start = second_region[0], second_end = second_region[1],\n        overlap;\n    if (first_start < second_start) {\n        if (first_end <= second_start) {\n            overlap = BEFORE;\n        }\n        else if (first_end <= second_end) {\n            overlap = OVERLAP_START;\n        }\n        else { // first_end > second_end\n            overlap = CONTAINS;\n        }\n    }\n    else { // first_start >= second_start\n        if (first_start > second_end) {\n            overlap = AFTER;\n        }\n        else if (first_end <= second_end) {\n            overlap = CONTAINED_BY;\n        }\n        else {\n            overlap = OVERLAP_END;\n        }\n    }\n\n    return overlap;\n};\n\n/**\n * Returns true if regions overlap.\n */\nvar is_overlap = function(first_region, second_region) {\n    var overlap = compute_overlap(first_region, second_region);\n    return (overlap !== BEFORE && overlap !== AFTER);\n};\n\n/**\n * Draw a dashed line on a canvas using filled rectangles. This function is based on:\n * http://vetruvet.blogspot.com/2010/10/drawing-dashed-lines-on-html5-canvas.html\n * However, that approach uses lines, which don't seem to render as well, so use\n * rectangles instead.\n */\nvar dashedLine = function(ctx, x1, y1, x2, y2, dashLen) {\n    if (dashLen === undefined) { dashLen = 4; }\n    var dX = x2 - x1;\n    var dY = y2 - y1;\n    var dashes = Math.floor(Math.sqrt(dX * dX + dY * dY) / dashLen);\n    var dashX = dX / dashes;\n    var dashY = dY / dashes;\n    var q;\n\n    for (q = 0; q < dashes; q++, x1 += dashX, y1 += dashY) {\n        if (q % 2 !== 0) {\n            continue;\n        }\n        ctx.fillRect(x1, y1, dashLen, 1);\n    }\n};\n\n/**\n * Draw an isosceles triangle that points down.\n */\nvar drawDownwardEquilateralTriangle = function(ctx, down_vertex_x, down_vertex_y, side_len) {\n    // Compute other two points of triangle.\n    var\n        x1 = down_vertex_x - side_len/2,\n        x2 = down_vertex_x + side_len/2,\n        y = down_vertex_y - Math.sqrt( side_len*3/2 );\n\n    // Draw and fill.\n    ctx.beginPath();\n    ctx.moveTo(x1, y);\n    ctx.lineTo(x2, y);\n    ctx.lineTo(down_vertex_x, down_vertex_y);\n    ctx.lineTo(x1, y);\n\n    ctx.strokeStyle = this.fillStyle;\n    ctx.fill();\n    ctx.stroke();\n    ctx.closePath();\n};\n\n/**\n * Base class for all scalers. Scalers produce values that are used to change (scale) drawing attributes.\n */\nvar Scaler = function(default_val) {\n    this.default_val = (default_val ? default_val : 1);\n};\n\n/**\n * Produce a scaling value.\n */\nScaler.prototype.gen_val = function(input) {\n    return this.default_val;\n};\n\n/**\n * Results from painter.draw()\n */\nvar DrawResults = function(options) {\n    this.incomplete_features = options.incomplete_features;\n    this.feature_mapper = options.feature_mapper;\n};\n\n/**\n * Base class for painters\n *\n * -- Mode and prefs are both optional\n */\nvar Painter = function(data, view_start, view_end, prefs, mode) {\n    // Data and data properties\n    this.data = data;\n    // View\n    this.view_start = view_start;\n    this.view_end = view_end;\n    // Drawing prefs\n    this.prefs = _.extend({}, this.default_prefs, prefs);\n    this.mode = mode;\n};\n\nPainter.prototype.default_prefs = {};\n\n/**\n * Draw on the context using a rectangle of width x height using scale w_scale.\n */\nPainter.prototype.draw = function(ctx, width, height, w_scale) {};\n\n/**\n * Get starting drawing position, which is offset a half-base left of coordinate.\n */\nPainter.prototype.get_start_draw_pos = function(chrom_pos, w_scale) {\n    return this._chrom_pos_to_draw_pos(chrom_pos, w_scale, -0.5);\n};\n\n/**\n * Get end drawing position, which is offset a half-base right of coordinate.\n */\nPainter.prototype.get_end_draw_pos = function(chrom_pos, w_scale) {\n    return this._chrom_pos_to_draw_pos(chrom_pos, w_scale, 0.5);\n};\n\n/**\n * Get drawing position.\n */\nPainter.prototype.get_draw_pos = function(chrom_pos, w_scale) {\n    return this._chrom_pos_to_draw_pos(chrom_pos, w_scale, 0);\n};\n\n/**\n * Convert chromosome position to drawing position.\n */\nPainter.prototype._chrom_pos_to_draw_pos = function(chrom_pos, w_scale, offset) {\n    return Math.floor( w_scale * ( Math.max(0, chrom_pos - this.view_start) + offset) );\n};\n\n\nvar LinePainter = function(data, view_start, view_end, prefs, mode) {\n    Painter.call( this, data, view_start, view_end, prefs, mode );\n};\n\nLinePainter.prototype.default_prefs = { min_value: undefined, max_value: undefined, mode: \"Histogram\", color: \"#000\", overflow_color: \"#F66\" };\n\nLinePainter.prototype.draw = function(ctx, width, height, w_scale) {\n    var in_path = false,\n        min_value = this.prefs.min_value,\n        max_value = this.prefs.max_value,\n        vertical_range = max_value - min_value,\n        height_px = height,\n        view_start = this.view_start,\n        mode = this.mode,\n        data = this.data;\n\n    ctx.save();\n\n    // Pixel position of 0 on the y axis\n    var y_zero = Math.round( height + min_value / vertical_range * height );\n\n    // Horizontal line to denote x-axis\n    if ( mode !== \"Intensity\" ) {\n        ctx.fillStyle = \"#aaa\";\n        ctx.fillRect( 0, y_zero, width, 1 );\n    }\n\n    ctx.beginPath();\n    var x_scaled, y, delta_x_pxs;\n    if (data.length > 1) {\n        delta_x_pxs = _.map(data.slice(0,-1), function(d, i) {\n            return Math.ceil((data[i+1][0] - data[i][0]) * w_scale);\n        });\n    }\n    else {\n        delta_x_pxs = [10];\n    }\n\n    // Painter color can be in either block_color (FeatureTrack) or color pref (LineTrack).\n    var painter_color = this.prefs.block_color || this.prefs.color,\n        // Extract RGB from preference color.\n        pref_color = parseInt( painter_color.slice(1), 16 ),\n        pref_r = (pref_color & 0xff0000) >> 16,\n        pref_g = (pref_color & 0x00ff00) >> 8,\n        pref_b = pref_color & 0x0000ff,\n        top_overflow = false,\n        bot_overflow = false;\n\n\n    // Paint track.\n    var delta_x_px;\n    for (var i = 0, len = data.length; i < len; i++) {\n        // Reset attributes for next point.\n        ctx.fillStyle = ctx.strokeStyle = painter_color;\n        top_overflow = bot_overflow = false;\n        delta_x_px = delta_x_pxs[i];\n\n        x_scaled = Math.floor((data[i][0] - view_start - 0.5) * w_scale);\n        y = data[i][1];\n\n        // Process Y (scaler) value.\n        if (y === null) {\n            if (in_path && mode === \"Filled\") {\n                ctx.lineTo(x_scaled, height_px);\n            }\n            in_path = false;\n            continue;\n        }\n\n        // Bound Y value by min, max.\n        if (y < min_value) {\n            bot_overflow = true;\n            y = min_value;\n        }\n        else if (y > max_value) {\n            top_overflow = true;\n            y = max_value;\n        }\n\n        // Draw point.\n        if (mode === \"Histogram\") {\n            // y becomes the bar height in pixels, which is the negated for canvas coords\n            y = Math.round( y / vertical_range * height_px );\n            ctx.fillRect(x_scaled, y_zero, delta_x_px, - y );\n        }\n        else if (mode === \"Intensity\") {\n            var\n                saturation = (y - min_value) / vertical_range,\n                // Range is [pref_color, 255] where saturation = 0 --> 255 and saturation = 1 --> pref color\n                new_r = Math.round( pref_r + (255 - pref_r) * (1 - saturation) ),\n                new_g = Math.round( pref_g + (255 - pref_g) * (1 - saturation) ),\n                new_b = Math.round( pref_b + (255 - pref_b) * (1 - saturation) );\n            ctx.fillStyle = \"rgb(\" + new_r + \",\" + new_g + \",\" + new_b + \")\";\n            ctx.fillRect(x_scaled, 0, delta_x_px, height_px);\n        }\n        else { // mode is Coverage/Line or Filled.\n\n            // Scale Y value.\n            y = Math.round( height_px - (y - min_value) / vertical_range * height_px );\n            if (in_path) {\n                ctx.lineTo(x_scaled, y);\n            }\n            else {\n                in_path = true;\n                if (mode === \"Filled\") {\n                    ctx.moveTo(x_scaled, height_px);\n                    ctx.lineTo(x_scaled, y);\n                }\n                else {\n                    ctx.moveTo(x_scaled, y);\n                    // Use this approach (note: same as for filled) to draw line from 0 to\n                    // first data point.\n                    //ctx.moveTo(x_scaled, height_px);\n                    //ctx.lineTo(x_scaled, y);\n                }\n            }\n        }\n\n        // Draw lines at boundaries if overflowing min or max\n        ctx.fillStyle = this.prefs.overflow_color;\n        if (top_overflow || bot_overflow) {\n            var overflow_x;\n            if (mode === \"Histogram\" || mode === \"Intensity\") {\n                overflow_x = delta_x_px;\n            }\n            else { // Line and Filled, which are points\n                x_scaled -= 2; // Move it over to the left so it's centered on the point\n                overflow_x = 4;\n            }\n            if (top_overflow) {\n                ctx.fillRect(x_scaled, 0, overflow_x, 3);\n            }\n            if (bot_overflow) {\n                ctx.fillRect(x_scaled, height_px - 3, overflow_x, 3);\n            }\n        }\n        ctx.fillStyle = painter_color;\n    }\n    if (mode === \"Filled\") {\n        if (in_path) {\n            ctx.lineTo( x_scaled, y_zero );\n            ctx.lineTo( 0, y_zero );\n        }\n        ctx.fill();\n    }\n    else {\n        ctx.stroke();\n    }\n\n    ctx.restore();\n};\n\n/**\n * Mapper that contains information about feature locations and data.\n */\nvar FeaturePositionMapper = function(slot_height) {\n    this.feature_positions = {};\n    this.slot_height = slot_height;\n    this.translation = 0;\n    this.y_translation = 0;\n};\n\n/**\n * Map feature data to a position defined by <slot, x_start, x_end>.\n */\nFeaturePositionMapper.prototype.map_feature_data = function(feature_data, slot, x_start, x_end) {\n    if (!this.feature_positions[slot]) {\n        this.feature_positions[slot] = [];\n    }\n    this.feature_positions[slot].push({\n        data: feature_data,\n        x_start: x_start,\n        x_end: x_end\n    });\n};\n\n/**\n * Get feature data for position <x, y>\n */\nFeaturePositionMapper.prototype.get_feature_data = function(x, y) {\n    // Find slot using Y.\n    var slot = Math.floor( (y-this.y_translation)/this.slot_height ),\n        feature_dict;\n\n    // May not be over a slot due to padding, margin, etc.\n    if (!this.feature_positions[slot]) {\n        return null;\n    }\n\n    // Find feature using X.\n    x += this.translation;\n    for (var i = 0; i < this.feature_positions[slot].length; i++) {\n        feature_dict = this.feature_positions[slot][i];\n        if (x >= feature_dict.x_start && x <= feature_dict.x_end) {\n            return feature_dict.data;\n        }\n    }\n};\n\n/**\n * Abstract object for painting feature tracks. Subclasses must implement draw_element() for painting to work.\n * Painter uses a 0-based, half-open coordinate system; start coordinate is closed--included--and the end is open.\n * This coordinate system matches the BED format.\n */\nvar FeaturePainter = function(data, view_start, view_end, prefs, mode, alpha_scaler, height_scaler) {\n    Painter.call(this, data, view_start, view_end, prefs, mode);\n    this.alpha_scaler = (alpha_scaler ? alpha_scaler : new Scaler());\n    this.height_scaler = (height_scaler ? height_scaler : new Scaler());\n    this.max_label_length = 200;\n};\n\nFeaturePainter.prototype.default_prefs = { block_color: \"#FFF\", connector_color: \"#FFF\" };\n\n_.extend(FeaturePainter.prototype, {\n    get_required_height: function(rows_required, width) {\n        // y_scale is the height per row\n        var required_height = this.get_row_height(),\n            y_scale = required_height,\n            mode = this.mode;\n        // If using a packing mode, need to multiply by the number of slots used\n        if (mode === \"no_detail\" || mode === \"Squish\" || mode === \"Pack\") {\n            required_height = rows_required * y_scale;\n        }\n        return required_height + this.get_top_padding(width);\n    },\n\n    /** Extra padding before first row of features */\n    get_top_padding: function(width) {\n        return 0;\n    },\n\n    /**\n     * Draw data on ctx using slots and within the rectangle defined by width and height. Returns\n     * a FeaturePositionMapper object with information about where features were drawn.\n     */\n    draw: function(ctx, width, height, w_scale, slots) {\n        var data = this.data,\n            view_start = this.view_start,\n            view_end = this.view_end;\n\n        ctx.save();\n\n        ctx.fillStyle = this.prefs.block_color;\n        ctx.textAlign = \"right\";\n\n        var y_scale = this.get_row_height(),\n            feature_mapper = new FeaturePositionMapper(y_scale),\n            x_draw_coords,\n            incomplete_features = [];\n\n        for (var i = 0, len = data.length; i < len; i++) {\n            var feature = data[i],\n                feature_uid = feature[0],\n                feature_start = feature[1],\n                feature_end = feature[2],\n                // Slot valid only if features are slotted and this feature is slotted;\n                // feature may not be due to lack of space.\n                slot = (slots && slots[feature_uid] !== undefined ? slots[feature_uid].slot : null);\n\n            // Draw feature if (a) mode is dense or feature is slotted (as it must be for all non-dense modes) and\n            // (b) there's overlap between the feature and drawing region.\n            if ( (this.mode === \"Dense\" || slot !== null) && ( feature_start < view_end && feature_end > view_start ) ) {\n                x_draw_coords = this.draw_element(ctx, this.mode, feature, slot, view_start, view_end, w_scale, y_scale, width);\n                feature_mapper.map_feature_data(feature, slot, x_draw_coords[0], x_draw_coords[1]);\n\n                // Add to incomplete features if it's not drawn completely in region.\n                if (feature_start < view_start || feature_end > view_end) {\n                    incomplete_features.push(feature);\n                }\n            }\n        }\n\n        ctx.restore();\n\n        feature_mapper.y_translation = this.get_top_padding(width);\n        return new DrawResults({\n            incomplete_features: incomplete_features,\n            feature_mapper: feature_mapper\n        });\n    },\n\n    /**\n     * Abstract function for drawing an individual feature.\n     */\n    draw_element: function(ctx, mode, feature, slot, tile_low, tile_high, w_scale, y_scale, width ) {\n        return [0, 0];\n    }\n});\n\n// Constants specific to feature tracks moved here (HACKING, these should\n// basically all be configuration options)\nvar DENSE_TRACK_HEIGHT = 10,\n    NO_DETAIL_TRACK_HEIGHT = 3,\n    SQUISH_TRACK_HEIGHT = 5,\n    PACK_TRACK_HEIGHT = 10,\n    NO_DETAIL_FEATURE_HEIGHT = 1,\n    DENSE_FEATURE_HEIGHT = 9,\n    SQUISH_FEATURE_HEIGHT = 3,\n    PACK_FEATURE_HEIGHT = 9,\n    LABEL_SPACING = 2,\n    CONNECTOR_COLOR = \"#ccc\";\n\nvar LinkedFeaturePainter = function(data, view_start, view_end, prefs, mode, alpha_scaler, height_scaler) {\n    FeaturePainter.call(this, data, view_start, view_end, prefs, mode, alpha_scaler, height_scaler);\n    // Whether to draw a single connector in the background that spans the entire feature (the intron fishbone)\n    this.draw_background_connector = true;\n    // Whether to call draw_connector for every pair of blocks\n    this.draw_individual_connectors = false;\n};\n\n_.extend(LinkedFeaturePainter.prototype, FeaturePainter.prototype, {\n\n    /**\n     * Height of a single row, depends on mode\n     */\n    get_row_height: function() {\n        var mode = this.mode, height;\n        if (mode === \"Dense\") {\n            height = DENSE_TRACK_HEIGHT;\n        }\n        else if (mode === \"no_detail\") {\n            height = NO_DETAIL_TRACK_HEIGHT;\n        }\n        else if (mode === \"Squish\") {\n            height = SQUISH_TRACK_HEIGHT;\n        }\n        else { // mode === \"Pack\"\n            height = PACK_TRACK_HEIGHT;\n        }\n        return height;\n    },\n\n    /**\n     * Draw a feature. Returns an array with feature's start and end X coordinates.\n     */\n    draw_element: function(ctx, mode, feature, slot, tile_low, tile_high, w_scale, y_scale, width) {\n        var feature_uid = feature[0],\n            feature_start = feature[1],\n            feature_end = feature[2],\n            feature_name = feature[3],\n            feature_strand = feature[4],\n            // -0.5 to offset region between bases.\n            f_start = Math.floor( Math.max(0, (feature_start - tile_low - 0.5) * w_scale) ),\n            f_end   = Math.ceil( Math.min(width, Math.max(0, (feature_end - tile_low - 0.5) * w_scale)) ),\n            draw_start = f_start,\n            draw_end = f_end,\n            y_start = (mode === \"Dense\" ? 0 : (0 + slot)) * y_scale + this.get_top_padding(width),\n            thickness, y_start, thick_start = null, thick_end = null,\n            // TODO: is there any reason why block, label color cannot be set at the Painter level?\n            // For now, assume '.' === '+'\n            block_color = (!feature_strand || feature_strand === \"+\" || feature_strand === \".\" ? this.prefs.block_color : this.prefs.reverse_strand_color);\n            label_color = this.prefs.label_color;\n\n        // Set global alpha.\n        ctx.globalAlpha = this.alpha_scaler.gen_val(feature);\n\n        // In dense mode, put all data in top slot.\n        if (mode === \"Dense\") {\n            slot = 1;\n        }\n\n        if (mode === \"no_detail\") {\n            // No details for feature, so only one way to display.\n            ctx.fillStyle = block_color;\n            ctx.fillRect(f_start, y_start + 5, f_end - f_start, NO_DETAIL_FEATURE_HEIGHT);\n        }\n        else { // Mode is either Squish or Pack:\n            // Feature details.\n            var feature_ts = feature[5],\n                feature_te = feature[6],\n                feature_blocks = feature[7],\n                // Whether we are drawing full height or squished features\n                full_height = true;\n\n            if (feature_ts && feature_te) {\n                thick_start = Math.floor( Math.max(0, (feature_ts - tile_low) * w_scale) );\n                thick_end = Math.ceil( Math.min(width, Math.max(0, (feature_te - tile_low) * w_scale)) );\n            }\n\n            // Set vars that depend on mode.\n            var thin_height, thick_height;\n            if (mode === \"Squish\" ) {\n                thin_height = 1;\n                thick_height = SQUISH_FEATURE_HEIGHT;\n                full_height = false;\n            } else if ( mode === \"Dense\" ) {\n                thin_height = 5;\n                thick_height = DENSE_FEATURE_HEIGHT;\n            } else { // mode === \"Pack\"\n                thin_height = 5;\n                thick_height = PACK_FEATURE_HEIGHT;\n            }\n\n            // Draw feature/feature blocks + connectors.\n            if (!feature_blocks) {\n                // If there are no blocks, treat the feature as one big exon.\n                ctx.fillStyle = block_color;\n                ctx.fillRect(f_start, y_start + 1, f_end - f_start, thick_height);\n                // If strand is specified, draw arrows over feature\n                if ( feature_strand && full_height ) {\n                    if (feature_strand === \"+\") {\n                        ctx.fillStyle = ctx.canvas.manager.get_pattern( 'right_strand_inv' );\n                    } else if (feature_strand === \"-\") {\n                        ctx.fillStyle = ctx.canvas.manager.get_pattern( 'left_strand_inv' );\n                    }\n                    ctx.fillRect(f_start, y_start + 1, f_end - f_start, thick_height);\n                }\n            } else {\n                //\n                // There are feature blocks and mode is either Squish or Pack.\n                //\n                // Approach: (a) draw whole feature as connector/intron and (b) draw blocks as\n                // needed. This ensures that whole feature, regardless of whether it starts with\n                // a block, is visible.\n                //\n\n                // Compute y axis start position and height\n                var cur_y_start, cur_height;\n                if (mode === \"Squish\" || mode === \"Dense\") {\n                    cur_y_start = y_start + Math.floor(SQUISH_FEATURE_HEIGHT/2) + 1;\n                    cur_height = 1;\n                }\n                else { // mode === \"Pack\"\n                    if (feature_strand) {\n                        cur_y_start = y_start;\n                        cur_height = thick_height;\n                    }\n                    else {\n                        cur_y_start += (SQUISH_FEATURE_HEIGHT/2) + 1;\n                        cur_height = 1;\n                    }\n                }\n\n                // Draw whole feature as connector/intron.\n                if ( this.draw_background_connector ) {\n                    if (mode === \"Squish\" || mode === \"Dense\") {\n                        ctx.fillStyle = CONNECTOR_COLOR;\n                    }\n                    else { // mode === \"Pack\"\n                        if (feature_strand) {\n                            if (feature_strand === \"+\") {\n                                ctx.fillStyle = ctx.canvas.manager.get_pattern( 'right_strand' );\n                            } else if (feature_strand === \"-\") {\n                                ctx.fillStyle = ctx.canvas.manager.get_pattern( 'left_strand' );\n                            }\n                        }\n                        else {\n                            ctx.fillStyle = CONNECTOR_COLOR;\n                        }\n                    }\n                    ctx.fillRect(f_start, cur_y_start, f_end - f_start, cur_height);\n                }\n\n                // Draw blocks.\n                var start_and_height;\n                for (var k = 0, k_len = feature_blocks.length; k < k_len; k++) {\n                    var block = feature_blocks[k],\n                        // -0.5 to offset block between bases.\n                        block_start = Math.floor( Math.max(0, (block[0] - tile_low - 0.5) * w_scale) ),\n                        block_end = Math.ceil( Math.min(width, Math.max((block[1] - tile_low - 0.5) * w_scale)) ),\n                        last_block_start, last_block_end;\n\n                    // Skip drawing if block not on tile.\n                    if (block_start > block_end) { continue; }\n\n                    // Draw thin block.\n                    ctx.fillStyle = block_color;\n                    ctx.fillRect(block_start, y_start + (thick_height-thin_height)/2 + 1, block_end - block_start, thin_height);\n\n                    // If block intersects with thick region, draw block as thick.\n                    // - No thick is sometimes encoded as thick_start == thick_end, so don't draw in that case\n                    if (thick_start !== undefined && feature_te > feature_ts && !(block_start > thick_end || block_end < thick_start) ) {\n                        var block_thick_start = Math.max(block_start, thick_start),\n                            block_thick_end = Math.min(block_end, thick_end);\n                        ctx.fillRect(block_thick_start, y_start + 1, block_thick_end - block_thick_start, thick_height);\n                        if ( feature_blocks.length === 1 && mode === \"Pack\") {\n                            // Exactly one block means we have no introns, but do have a distinct \"thick\" region,\n                            // draw arrows over it if in pack mode.\n                            if (feature_strand === \"+\") {\n                                ctx.fillStyle = ctx.canvas.manager.get_pattern( 'right_strand_inv' );\n                            } else if (feature_strand === \"-\") {\n                                ctx.fillStyle = ctx.canvas.manager.get_pattern( 'left_strand_inv' );\n                            }\n                            // If region is wide enough in pixels, pad a bit\n                            if ( block_thick_start + 14 < block_thick_end ) {\n                                block_thick_start += 2;\n                                block_thick_end -= 2;\n                            }\n                            ctx.fillRect(block_thick_start, y_start + 1, block_thick_end - block_thick_start, thick_height);\n                        }\n                    }\n                    // Draw individual connectors if required\n                    if ( this.draw_individual_connectors && last_block_start ) {\n                        this.draw_connector( ctx, last_block_start, last_block_end, block_start, block_end, y_start );\n                    }\n                    last_block_start = block_start;\n                    last_block_end = block_end;\n                }\n\n                // FIXME: Height scaling only works in Pack mode right now.\n                if (mode === \"Pack\") {\n                    // Reset alpha so height scaling is not impacted by alpha scaling.\n                    ctx.globalAlpha = 1;\n\n                    // Height scaling: draw white lines to reduce height according to height scale factor.\n                    ctx.fillStyle = \"white\"; // TODO: set this to background color.\n                    var\n                        hscale_factor = this.height_scaler.gen_val(feature),\n                        // Ceil ensures that min height is >= 1.\n                        new_height = Math.ceil(thick_height * hscale_factor),\n                        ws_height = Math.round( (thick_height-new_height)/2 );\n                    if (hscale_factor !== 1) {\n                        ctx.fillRect(f_start, cur_y_start + 1, f_end - f_start, ws_height);\n                        ctx.fillRect(f_start, cur_y_start + thick_height - ws_height + 1, f_end - f_start, ws_height);\n                    }\n                }\n            }\n\n            // Reset alpha so that label is not transparent.\n            ctx.globalAlpha = 1;\n\n            // Draw label for Pack mode.\n            if (feature_name && mode === \"Pack\" && feature_start > tile_low) {\n                ctx.fillStyle = label_color;\n                // FIXME: assumption here that the entire view starts at 0\n                if (tile_low === 0 && f_start - ctx.measureText(feature_name).width < 0) {\n                    ctx.textAlign = \"left\";\n                    ctx.fillText(feature_name, f_end + LABEL_SPACING, y_start + 8, this.max_label_length);\n                    draw_end += ctx.measureText(feature_name).width + LABEL_SPACING;\n                } else {\n                    ctx.textAlign = \"right\";\n                    ctx.fillText(feature_name, f_start - LABEL_SPACING, y_start + 8, this.max_label_length);\n                    draw_start -= ctx.measureText(feature_name).width + LABEL_SPACING;\n                }\n                //ctx.fillStyle = block_color;\n            }\n        }\n\n        // Reset global alpha.\n        ctx.globalAlpha = 1;\n\n        return [draw_start, draw_end];\n    }\n});\n\nvar ReadPainter = function(data, view_start, view_end, prefs, mode, alpha_scaler, height_scaler, ref_seq, base_color_fn) {\n    FeaturePainter.call(this, data, view_start, view_end, prefs, mode, alpha_scaler, height_scaler);\n    this.ref_seq = (ref_seq ? ref_seq.data : null);\n    this.base_color_fn = base_color_fn;\n};\n\n_.extend(ReadPainter.prototype, FeaturePainter.prototype, {\n    /**\n     * Returns height based on mode.\n     */\n    get_row_height: function() {\n        var height, mode = this.mode;\n        if (mode === \"Dense\") {\n            height = DENSE_TRACK_HEIGHT;\n        }\n        else if (mode === \"Squish\") {\n            height = SQUISH_TRACK_HEIGHT;\n        }\n        else { // mode === \"Pack\"\n            height = PACK_TRACK_HEIGHT;\n            if (this.prefs.show_insertions) {\n                height *= 2;\n            }\n        }\n        return height;\n    },\n\n    /**\n     * Parse CIGAR string to get (a) a list of contiguous drawing blocks (MD=X) and\n     * (b) an array of [ op_index, op_len ] pairs where op_index is an index into the\n     * string 'MIDNSHP=X' Return value is a dictionary with two entries, blocks and cigar\n     */\n    _parse_cigar: function(cigar_str) {\n        var cigar_ops = 'MIDNSHP=X';\n\n        // Parse cigar.\n        var blocks = [ [0, 0] ],\n            cur_block = blocks[0],\n            base_pos = 0,\n\n            // Parse cigar operations out and update/create blocks as needed.\n            parsed_cigar = _.map(cigar_str.match(/[0-9]+[MIDNSHP=X]/g), function(op) {\n                // Get operation length, character.\n                var op_len = parseInt(op.slice(0, -1), 10),\n                    op_char = op.slice(-1);\n\n                // Update drawing block.\n                if (op_char === 'N') {\n                    // At skip, so need to start new block if current block represents\n                    // drawing area.\n                    if (cur_block[1] !== 0) {\n                        cur_block = [base_pos + op_len, base_pos + op_len];\n                        blocks.push(cur_block);\n                    }\n                }\n                else if ('ISHP'.indexOf(op_char) === -1) {\n                    // Operation is M,D,=,X.\n                    cur_block[1] += op_len;\n                    base_pos += op_len;\n                }\n\n                // Return parsed cigar.\n                return [ cigar_ops.indexOf(op_char), op_len ];\n            });\n\n        return {\n            blocks: blocks,\n            cigar: parsed_cigar\n        };\n    },\n\n    /**\n     * Draw a single read from reference-based read sequence and cigar.\n     */\n    draw_read: function(ctx, mode, w_scale, y_start, tile_low, tile_high, feature_start, cigar, strand, read_seq) {\n        // Helper function to update base and sequnence offsets.\n        var update_base_offset = function(offset, cig_op, cig_len) {\n                if ('M=NXD'.indexOf(cig_op) !== -1) {\n                    offset += cig_len;\n                }\n                return offset;\n            },\n            update_seq_offset = function(offset, cig_op, cig_len) {\n                if ('IX'.indexOf(cig_op) !== -1) {\n                    offset += cig_len;\n                }\n                return offset;\n            },\n            // Gets drawing coordinate for a sequence coordinate. Assumes closure variables w_scale and tile_low.\n            get_draw_coord = function(sequence_coord) {\n                // -0.5 to offset sequence between bases.\n                return Math.floor( Math.max(0, (sequence_coord - tile_low - 0.5) * w_scale) );\n            };\n\n        ctx.textAlign = \"center\";\n        var tile_region = [tile_low, tile_high],\n            base_offset = 0,\n            seq_offset = 0,\n            gap = Math.round(w_scale/2),\n            char_width_px = ctx.canvas.manager.char_width_px,\n            block_color = (strand === \"+\" ? this.prefs.detail_block_color : this.prefs.reverse_strand_color),\n            pack_mode = (mode === 'Pack'),\n            draw_height = (pack_mode ? PACK_FEATURE_HEIGHT : SQUISH_FEATURE_HEIGHT),\n            rect_y = y_start + 1,\n            paint_utils = new ReadPainterUtils(ctx, draw_height, w_scale, mode),\n            drawing_blocks = [],\n            s_start,\n            s_end;\n\n        // Keep list of items that need to be drawn on top of initial drawing layer.\n        var draw_last = [];\n\n        // Parse cigar and get drawing blocks.\n        var t = this._parse_cigar(cigar);\n        cigar = t.cigar;\n        drawing_blocks = t.blocks;\n\n        // Draw blocks.\n        for (var i = 0; i < drawing_blocks.length; i++) {\n            var block = drawing_blocks[i];\n\n            if (is_overlap([feature_start + block[0], feature_start + block[1]], tile_region)) {\n                s_start = get_draw_coord(feature_start + block[0]);\n                s_end = get_draw_coord(feature_start + block[1]);\n\n                // Make sure that block is drawn even if it too small to be rendered officially; in this case,\n                // read is drawn at 1px.\n                // TODO: need to ensure that s_start, s_end are calculated the same for both slotting\n                // and drawing.\n                if (s_start === s_end) {\n                    s_end += 1;\n                }\n\n                // Draw read base as rectangle.\n                ctx.fillStyle = block_color;\n                ctx.fillRect(s_start, rect_y, s_end - s_start, draw_height);\n            }\n        }\n\n        // Draw read features.\n        for (var cig_id = 0, len = cigar.length; cig_id < len; cig_id++) {\n            var cig = cigar[cig_id],\n                cig_op = \"MIDNSHP=X\"[ cig[0] ],\n                cig_len = cig[1];\n\n            var seq_start = feature_start + base_offset;\n            s_start = get_draw_coord(seq_start);\n            s_end = get_draw_coord(seq_start + cig_len);\n\n            // Skip feature if it's not in tile.\n            if (!is_overlap([seq_start, seq_start + cig_len], tile_region)) {\n                // Update offsets.\n                base_offset = update_base_offset(base_offset, cig_op, cig_len);\n                seq_offset = update_seq_offset(seq_offset, cig_op, cig_len);\n                continue;\n            }\n\n            // Make sure that read is drawn even if it too small to be rendered officially; in this case,\n            // read is drawn at 1px.\n            // TODO: need to ensure that s_start, s_end are calculated the same for both slotting\n            // and drawing.\n            if (s_start === s_end) {\n                s_end += 1;\n            }\n\n            // Draw read feature.\n            switch (cig_op) {\n                case \"H\": // Hard clipping.\n                case \"S\": // Soft clipping.\n                case \"P\": // Padding.\n                    // Sequence not present and not related to alignment; do nothing.\n                    break;\n                case \"M\": // \"Match\".\n                    // Because it's not known whether there is a match, ignore.\n                    base_offset += cig_len;\n                    break;\n                case \"=\": // Match with reference.\n                case \"X\": // Mismatch with reference.\n                    //\n                    // Draw sequence and/or variants.\n                    //\n\n                    // Get sequence to draw.\n                    var cur_seq = '';\n                    if (cig_op === 'X') {\n                        // Get sequence from read_seq.\n                        cur_seq = read_seq.slice(seq_offset, seq_offset + cig_len);\n                    }\n                    else if (this.ref_seq) { // && cig_op === '='\n                        // Use reference sequence.\n                        cur_seq = this.ref_seq.slice(\n                            // If read starts after tile start, slice at read start.\n                            Math.max(0, seq_start - tile_low),\n                            // If read ends before tile end, slice at read end.\n                            Math.min(seq_start - tile_low + cig_len, tile_high - tile_low)\n                        );\n                    }\n\n                    // Draw sequence. Because cur_seq starts and read/tile start, go to there to start writing.\n                    var start_pos = Math.max(seq_start, tile_low);\n                    for (var c = 0; c < cur_seq.length; c++) {\n                        // Draw base if showing all (i.e. not showing differences) or there is a mismatch.\n                        if (cur_seq && !this.prefs.show_differences || cig_op === 'X') {\n                            // Draw base.\n                            var c_start = Math.floor( Math.max(0, (start_pos + c - tile_low) * w_scale) );\n                            ctx.fillStyle = this.base_color_fn(cur_seq[c]);\n                            if (pack_mode && w_scale > char_width_px) {\n                                ctx.fillText(cur_seq[c], c_start, y_start + 9);\n                            }\n                            // Require a minimum w_scale so that variants are only drawn when somewhat zoomed in.\n                            else if (w_scale > 0.05) {\n                                ctx.fillRect(c_start - gap, rect_y, Math.max( 1, Math.round(w_scale) ), draw_height);\n                            }\n                        }\n                    }\n\n                    // Move forward in sequence only if sequence used to get mismatches.\n                    if (cig_op === 'X') { seq_offset += cig_len; }\n                    base_offset += cig_len;\n\n                    break;\n                case \"N\": // Skipped bases.\n                    ctx.fillStyle = CONNECTOR_COLOR;\n                    ctx.fillRect(s_start, rect_y + (draw_height - 1)/2, s_end - s_start, 1);\n                    // No change in seq_offset because sequence not used when skipping.\n                    base_offset += cig_len;\n                    break;\n                case \"D\": // Deletion.\n                    paint_utils.draw_deletion(s_start, rect_y, cig_len);\n                    base_offset += cig_len;\n                    break;\n                case \"I\": // Insertion.\n                    // Check to see if sequence should be drawn at all by looking at the overlap between\n                    // the sequence region and the tile region.\n                    var insert_x_coord = s_start - gap;\n\n                    if (is_overlap([seq_start, seq_start + cig_len], tile_region)) {\n                        var seq = read_seq.slice(seq_offset, seq_offset + cig_len);\n                        // Insertion point is between the sequence start and the previous base: (-gap) moves\n                        // back from sequence start to insertion point.\n                        if (this.prefs.show_insertions) {\n                            //\n                            // Show inserted sequence above, centered on insertion point.\n                            //\n\n                            // Draw sequence.\n                            // X center is offset + start - <half_sequence_length>\n                            var x_center = s_start - (s_end - s_start)/2;\n                            if ( (mode === \"Pack\" || this.mode === \"Auto\") && read_seq !== undefined && w_scale > char_width_px) {\n                                // Draw sequence container.\n                                ctx.fillStyle = \"yellow\";\n                                ctx.fillRect(x_center - gap, y_start - 9, s_end - s_start, 9);\n                                draw_last[draw_last.length] = {type: \"triangle\", data: [insert_x_coord, y_start + 4, 5]};\n                                ctx.fillStyle = CONNECTOR_COLOR;\n                                // Based on overlap b/t sequence and tile, get sequence to be drawn.\n                                switch( compute_overlap( [seq_start, seq_start + cig_len], tile_region ) ) {\n                                    case(OVERLAP_START):\n                                        seq = seq.slice(tile_low-seq_start);\n                                        break;\n                                    case(OVERLAP_END):\n                                        seq = seq.slice(0, seq_start-tile_high);\n                                        break;\n                                    case(CONTAINED_BY):\n                                        // All of sequence drawn.\n                                        break;\n                                    case(CONTAINS):\n                                        seq = seq.slice(tile_low-seq_start, seq_start-tile_high);\n                                        break;\n                                }\n                                // Draw sequence.\n                                for (var c = 0, str_len = seq.length; c < str_len; c++) {\n                                    var c_start = Math.floor( Math.max(0, (seq_start + c -  tile_low) * w_scale) );\n                                    ctx.fillText(seq[c], c_start - (s_end - s_start)/2, y_start);\n                                }\n                            }\n                            else {\n                                // Draw block.\n                                ctx.fillStyle = \"yellow\";\n                                // TODO: This is a pretty hack-ish way to fill rectangle based on mode.\n                                ctx.fillRect(x_center, y_start + (this.mode !== \"Dense\" ? 2 : 5),\n                                             s_end - s_start, (mode !== \"Dense\" ? SQUISH_FEATURE_HEIGHT : DENSE_FEATURE_HEIGHT));\n                            }\n                        }\n                        else {\n                            if ( (mode === \"Pack\" || this.mode === \"Auto\") && read_seq !== undefined && w_scale > char_width_px) {\n                                // Show insertions with a single number at the insertion point.\n                                draw_last.push( { type: \"text\", data: [seq.length, insert_x_coord, y_start + 9] } );\n                            }\n                            else {\n                                // TODO: probably can merge this case with code above.\n                            }\n                        }\n                    }\n                    seq_offset += cig_len;\n                    // No change to base offset because insertions are drawn above sequence/read.\n                    break;\n            }\n        }\n\n        //\n        // Draw last items.\n        //\n        ctx.fillStyle = \"yellow\";\n        var item, type, data;\n        for (var i = 0; i < draw_last.length; i++) {\n            item = draw_last[i];\n            type = item.type;\n            data = item.data;\n            if (type === \"text\") {\n                ctx.save();\n                ctx.font = \"bold \" + ctx.font;\n                ctx.fillText(data[0], data[1], data[2]);\n                ctx.restore();\n            }\n            else if (type === \"triangle\") {\n                drawDownwardEquilateralTriangle(ctx, data[0], data[1], data[2]);\n            }\n        }\n    },\n\n    /**\n     * Draw a complete read pair\n     */\n    draw_element: function(ctx, mode, feature, slot, tile_low, tile_high, w_scale, y_scale, width ) {\n        // All features need a start, end, and vertical center.\n        var feature_uid = feature[0],\n            feature_start = feature[1],\n            feature_end = feature[2],\n            feature_name = feature[3],\n            // -0.5 to put element between bases.\n            f_start = Math.floor( Math.max(-0.5 * w_scale, (feature_start - tile_low - 0.5) * w_scale) ),\n            f_end   = Math.ceil( Math.min(width, Math.max(0, (feature_end - tile_low - 0.5) * w_scale)) ),\n            y_start = (mode === \"Dense\" ? 0 : (0 + slot)) * y_scale,\n            draw_height = (mode === 'Pack' ? PACK_FEATURE_HEIGHT : SQUISH_FEATURE_HEIGHT),\n            label_color = this.prefs.label_color;\n\n        // Draw read.\n        if (feature[5] instanceof Array) {\n            // Read is paired.\n            var connector = true;\n\n            // Draw left/forward read.\n            if (feature[4][1] >= tile_low && feature[4][0] <= tile_high && feature[4][2]) {\n                this.draw_read(ctx, mode, w_scale, y_start, tile_low, tile_high, feature[4][0], feature[4][2], feature[4][3], feature[4][4]);\n            }\n            else {\n                connector = false;\n            }\n\n            // Draw right/reverse read.\n            if (feature[5][1] >= tile_low && feature[5][0] <= tile_high && feature[5][2]) {\n                this.draw_read(ctx, mode, w_scale, y_start, tile_low, tile_high, feature[5][0], feature[5][2], feature[5][3], feature[5][4]);\n            }\n            else {\n                connector = false;\n            }\n\n            // Draw connector if both reads were drawn.\n            // TODO: currently, there is no way to connect reads drawn on different tiles; to connect reads on different tiles, data manager\n            // code is needed to join mate pairs from different regions. Alternatively, requesting multiple regions of data at once would\n            // make it possible to put together more easily.\n            // -0.5 to position connector correctly between reads.\n            var b1_end   = Math.ceil( Math.min(width, Math.max(-0.5 * w_scale, (feature[4][1] - tile_low - 0.5) * w_scale)) ),\n                b2_start = Math.floor( Math.max(-0.5 * w_scale, (feature[5][0] - tile_low - 0.5) * w_scale) );\n            if (connector && b2_start > b1_end) {\n                ctx.fillStyle = CONNECTOR_COLOR;\n                var line_height = y_start + 1 + (draw_height - 1)/2;\n                dashedLine(ctx, b1_end, line_height, b2_start, line_height);\n            }\n        } else {\n            // Read is single.\n            this.draw_read(ctx, mode, w_scale, y_start, tile_low, tile_high, feature_start, feature[4], feature[5], feature[6]);\n        }\n        if (mode === \"Pack\" && feature_start >= tile_low && feature_name !== \".\") {\n            // Draw label.\n            ctx.fillStyle = this.prefs.label_color;\n            if (tile_low === 0 && f_start - ctx.measureText(feature_name).width < 0) {\n                ctx.textAlign = \"left\";\n                ctx.fillText(feature_name, f_end + LABEL_SPACING, y_start + 9, this.max_label_length);\n            } else {\n                ctx.textAlign = \"right\";\n                ctx.fillText(feature_name, f_start - LABEL_SPACING, y_start + 9, this.max_label_length);\n            }\n        }\n\n        // FIXME: provide actual coordinates for drawn read.\n        return [0,0];\n    }\n});\n\nvar ArcLinkedFeaturePainter = function(data, view_start, view_end, prefs, mode, alpha_scaler, height_scaler) {\n    LinkedFeaturePainter.call(this, data, view_start, view_end, prefs, mode, alpha_scaler, height_scaler);\n    // Need to know the longest feature length for adding spacing\n    this.longest_feature_length = this.calculate_longest_feature_length();\n    this.draw_background_connector = false;\n    this.draw_individual_connectors = true;\n};\n\n_.extend(ArcLinkedFeaturePainter.prototype, FeaturePainter.prototype, LinkedFeaturePainter.prototype, {\n\n    calculate_longest_feature_length: function () {\n        var longest_feature_length = 0;\n        for (var i = 0, len = this.data.length; i < len; i++) {\n            var feature = this.data[i], feature_start = feature[1], feature_end = feature[2];\n            longest_feature_length = Math.max( longest_feature_length, feature_end - feature_start );\n        }\n        return longest_feature_length;\n    },\n\n    get_top_padding: function( width ) {\n        var view_range = this.view_end - this.view_start,\n            w_scale = width / view_range;\n        return Math.min( 128, Math.ceil( ( this.longest_feature_length / 2 ) * w_scale ) );\n    },\n\n    draw_connector: function( ctx, block1_start, block1_end, block2_start, block2_end, y_start ) {\n        // Arc drawing -- from closest endpoints\n        var x_center = ( block1_end + block2_start ) / 2,\n            radius = block2_start - x_center;\n        // For full half circles\n        var angle1 = Math.PI, angle2 = 0;\n        if ( radius > 0 ) {\n            ctx.beginPath();\n            ctx.arc( x_center, y_start, block2_start - x_center, Math.PI, 0 );\n            ctx.stroke();\n        }\n    }\n});\n\n// Color stuff from less.js\n\nvar Color = function (rgb, a) {\n    /**\n     * The end goal here, is to parse the arguments\n     * into an integer triplet, such as `128, 255, 0`\n     *\n     * This facilitates operations and conversions.\n     */\n    if (Array.isArray(rgb)) {\n        this.rgb = rgb;\n    } else if (rgb.length == 6) {\n        this.rgb = rgb.match(/.{2}/g).map(function (c) {\n            return parseInt(c, 16);\n        });\n    } else if (rgb.length == 7) {\n        this.rgb = rgb.substring(1,7).match(/.{2}/g).map(function (c) {\n            return parseInt(c, 16);\n        });\n    } else {\n        this.rgb = rgb.split('').map(function (c) {\n            return parseInt(c + c, 16);\n        });\n    }\n    this.alpha = typeof(a) === 'number' ? a : 1;\n};\nColor.prototype = {\n    eval: function () { return this; },\n\n    //\n    // If we have some transparency, the only way to represent it\n    // is via `rgba`. Otherwise, we use the hex representation,\n    // which has better compatibility with older browsers.\n    // Values are capped between `0` and `255`, rounded and zero-padded.\n    //\n    toCSS: function () {\n        if (this.alpha < 1.0) {\n            return \"rgba(\" + this.rgb.map(function (c) {\n                return Math.round(c);\n            }).concat(this.alpha).join(', ') + \")\";\n        } else {\n            return '#' + this.rgb.map(function (i) {\n                i = Math.round(i);\n                i = (i > 255 ? 255 : (i < 0 ? 0 : i)).toString(16);\n                return i.length === 1 ? '0' + i : i;\n            }).join('');\n        }\n    },\n\n    toHSL: function () {\n        var r = this.rgb[0] / 255,\n            g = this.rgb[1] / 255,\n            b = this.rgb[2] / 255,\n            a = this.alpha;\n\n        var max = Math.max(r, g, b), min = Math.min(r, g, b);\n        var h, s, l = (max + min) / 2, d = max - min;\n\n        if (max === min) {\n            h = s = 0;\n        } else {\n            s = l > 0.5 ? d / (2 - max - min) : d / (max + min);\n\n            switch (max) {\n                case r: h = (g - b) / d + (g < b ? 6 : 0); break;\n                case g: h = (b - r) / d + 2;               break;\n                case b: h = (r - g) / d + 4;               break;\n            }\n            h /= 6;\n        }\n        return { h: h * 360, s: s, l: l, a: a };\n    },\n\n    toARGB: function () {\n        var argb = [Math.round(this.alpha * 255)].concat(this.rgb);\n        return '#' + argb.map(function (i) {\n            i = Math.round(i);\n            i = (i > 255 ? 255 : (i < 0 ? 0 : i)).toString(16);\n            return i.length === 1 ? '0' + i : i;\n        }).join('');\n    },\n\n    mix: function (color2, weight) {\n        color1 = this;\n\n        var p = weight; // .value / 100.0;\n        var w = p * 2 - 1;\n        var a = color1.toHSL().a - color2.toHSL().a;\n\n        var w1 = (((w * a == -1) ? w : (w + a) / (1 + w * a)) + 1) / 2.0;\n        var w2 = 1 - w1;\n\n        var rgb = [color1.rgb[0] * w1 + color2.rgb[0] * w2,\n                   color1.rgb[1] * w1 + color2.rgb[1] * w2,\n                   color1.rgb[2] * w1 + color2.rgb[2] * w2];\n\n        var alpha = color1.alpha * p + color2.alpha * (1 - p);\n\n        return new Color(rgb, alpha);\n    }\n};\n\n\n// End colors from less.js\n\nvar LinearRamp = function( start_color, end_color, start_value, end_value ) {\n    /**\n     * Simple linear gradient\n     */\n    this.start_color = new Color( start_color );\n    this.end_color = new Color( end_color );\n    this.start_value = start_value;\n    this.end_value = end_value;\n    this.value_range = end_value - start_value;\n};\n\nLinearRamp.prototype.map_value = function( value ) {\n    value = Math.max( value, this.start_value );\n    value = Math.min( value, this.end_value );\n    value = ( value - this.start_value ) / this.value_range;\n    // HACK: just red for now\n    // return \"hsl(0,100%,\" + (value * 100) + \"%)\"\n    return this.start_color.mix( this.end_color, 1 - value ).toCSS();\n};\n\nvar SplitRamp = function( start_color, middle_color, end_color, start_value, end_value ) {\n    /**\n     * Two gradients split away from 0\n     */\n    this.positive_ramp = new LinearRamp( middle_color, end_color, 0, end_value );\n    this.negative_ramp = new LinearRamp( middle_color, start_color, 0, -start_value );\n    this.start_value = start_value;\n    this.end_value = end_value;\n};\n\nSplitRamp.prototype.map_value = function( value ) {\n    value = Math.max( value, this.start_value );\n    value = Math.min( value, this.end_value );\n    if ( value >= 0 ) {\n        return this.positive_ramp.map_value( value );\n    } else {\n        return this.negative_ramp.map_value( -value );\n    }\n};\n\nvar DiagonalHeatmapPainter = function(data, view_start, view_end, prefs, mode) {\n    Painter.call( this, data, view_start, view_end, prefs, mode );\n    var i, len;\n\n    if ( this.prefs.min_value === undefined ) {\n        var min_value = Infinity;\n        for (i = 0, len = this.data.length; i < len; i++) {\n            min_value = Math.min( min_value, this.data[i][6] );\n        }\n        this.prefs.min_value = min_value;\n    }\n    if ( this.prefs.max_value === undefined ) {\n        var max_value = -Infinity;\n        for (i = 0, len = this.data.length; i < len; i++) {\n            max_value = Math.max( max_value, this.data[i][6] );\n        }\n        this.prefs.max_value = max_value;\n    }\n};\n\nDiagonalHeatmapPainter.prototype.default_prefs = {\n    min_value: undefined,\n    max_value: undefined,\n    mode: \"Heatmap\",\n    pos_color: \"#FF8C00\",\n    neg_color: \"#4169E1\"\n};\n\nDiagonalHeatmapPainter.prototype.draw = function(ctx, width, height, w_scale) {\n    var\n        min_value = this.prefs.min_value,\n        max_value = this.prefs.max_value,\n        value_range = max_value - min_value,\n        height_px = height,\n        view_start = this.view_start,\n        mode = this.mode,\n        data = this.data,\n        invsqrt2 = 1 / Math.sqrt(2);\n\n    var ramp = ( new SplitRamp( this.prefs.neg_color, \"#FFFFFF\", this.prefs.pos_color, min_value, max_value ) );\n\n    var d, s1, e1, s2, e2, value;\n\n    var scale = function( p ) { return ( p - view_start ) * w_scale; };\n\n    ctx.save();\n\n    // Draw into triangle, then rotate and scale\n    ctx.rotate(-45 * Math.PI / 180);\n    ctx.scale( invsqrt2, invsqrt2 );\n\n    // Paint track.\n    for (var i = 0, len = data.length; i < len; i++) {\n        d = data[i];\n\n        s1 = scale( d[1] );\n        e1 = scale( d[2] );\n        s2 = scale( d[4] );\n        e2 = scale( d[5] );\n        value = d[6];\n\n        ctx.fillStyle = ( ramp.map_value( value ) );\n        ctx.fillRect( s1, s2, ( e1 - s1 ), ( e2 - s2 ) );\n    }\n\n    ctx.restore();\n};\n\n/**\n * Utilities for painting reads.\n */\nvar ReadPainterUtils = function(ctx, row_height, px_per_base, mode) {\n    this.ctx = ctx;\n    this.row_height = row_height;\n    this.px_per_base = px_per_base;\n    this.draw_details = (mode === 'Pack' || mode === 'Auto') && (px_per_base >= ctx.canvas.manager.char_width_px);\n    this.delete_details_thickness = 0.2;\n};\n\n_.extend(ReadPainterUtils.prototype, {\n    /**\n     * Draw deletion of base(s).\n     * @param draw_detail if true, drawing in detail and deletion is drawn more subtly\n     */\n    draw_deletion: function(x, y, len) {\n        this.ctx.fillStyle = \"black\";\n        var thickness = (this.draw_details ? this.delete_details_thickness : 1) * this.row_height;\n        y += 0.5 * ( this.row_height - thickness );\n        this.ctx.fillRect(x, y, len * this.px_per_base, thickness);\n    }\n});\n\n/**\n * Paints variant data onto canvas.\n */\nvar VariantPainter = function(data, view_start, view_end, prefs, mode, base_color_fn) {\n    Painter.call(this, data, view_start, view_end, prefs, mode);\n    this.base_color_fn = base_color_fn;\n    this.divider_height = 1;\n};\n\n_.extend(VariantPainter.prototype, Painter.prototype, {\n    /**\n     * Height of a single row, depends on mode\n     */\n    get_row_height: function() {\n        var mode = this.mode, height;\n        if (mode === \"Dense\") {\n            height = DENSE_TRACK_HEIGHT;\n        }\n        else if (mode === \"Squish\") {\n            height = SQUISH_TRACK_HEIGHT;\n        }\n        else { // mode === \"Pack\"\n            height = PACK_TRACK_HEIGHT;\n        }\n        return height;\n    },\n\n    /**\n     * Returns required height to draw a particular number of samples in a given mode.\n     */\n    get_required_height: function(num_samples) {\n        // FIXME: for single-sample data, height should be summary_height when zoomed out and\n        // row_height when zoomed in.\n        var height = this.prefs.summary_height;\n\n        // If showing sample data, height is summary + divider + samples.\n        if (num_samples > 1 && this.prefs.show_sample_data) {\n            height += this.divider_height + num_samples * this.get_row_height();\n        }\n        return height;\n    },\n\n    /**\n     * Draw on the context using a rectangle of width x height with scale w_scale.\n     */\n    draw: function(ctx, width, height, w_scale) {\n        ctx.save();\n\n        var\n        /**\n         * Returns dictionary of information about an indel; returns empty if there no indel. Assumes indel is left-aligned.\n         * Dict attributes:\n         *    -type: 'insertion' or 'deletion'\n         *    -start: where the deletion starts relative to reference start\n         *    -len: how long the deletion is\n         */\n        get_indel_info = function(ref, alt) {\n            var ref_len = ref.length,\n                alt_len = alt.length,\n                start = 0,\n                len = 1,\n                type = null;\n            if (alt === '-') {\n                type = 'deletion';\n                len = ref.length;\n            }\n            else if (ref.indexOf(alt) === 0 && ref_len > alt_len) {\n                type = 'deletion';\n                len = ref_len - alt_len;\n                start = alt_len;\n            }\n            else if (alt.indexOf(ref) === 0 && ref_len < alt_len) {\n                // Insertion.\n                type = 'insertion';\n                len = alt_len - ref_len;\n                start = alt_len;\n            }\n\n            return ( type !== null ? { type: type, start: start, len: len } : {} );\n        };\n\n        // Draw.\n        var locus_data,\n            pos,\n            id,\n            ref,\n            alt,\n            qual,\n            filter,\n            sample_gts,\n            allele_counts,\n            variant,\n            draw_x_start,\n            draw_y_start,\n            genotype,\n            // Always draw variants at least 1 pixel wide.\n            base_px = Math.max(1, Math.floor(w_scale)),\n            // Determine number of samples.\n            num_samples = (this.data.length ? this.data[0][7].split(',').length : 0),\n            row_height = (this.mode === 'Squish' ? SQUISH_TRACK_HEIGHT : PACK_TRACK_HEIGHT),\n            // If zoomed out, fill the whole row with feature to make it easier to read;\n            // when zoomed in, use feature height so that there are gaps in sample rows.\n            feature_height = (w_scale < 0.1 ?\n                              row_height :\n                              (this.mode === 'Squish' ? SQUISH_FEATURE_HEIGHT : PACK_FEATURE_HEIGHT)\n                             ),\n            draw_summary = true,\n            paint_utils = new ReadPainterUtils(ctx, row_height, w_scale, this.mode),\n            j;\n\n        // If there's a single sample, update drawing variables.\n        if (num_samples === 1) {\n            row_height = feature_height =\n                (w_scale < ctx.canvas.manager.char_width_px ? this.prefs.summary_height : row_height);\n            paint_utils.row_height = row_height;\n            // No summary when there's a single sample.\n            draw_summary = false;\n        }\n\n        // Draw divider between summary and samples.\n        if (this.prefs.show_sample_data && draw_summary) {\n            ctx.fillStyle = '#F3F3F3';\n            ctx.globalAlpha = 1;\n            ctx.fillRect(0, this.prefs.summary_height - this.divider_height, width, this.divider_height);\n        }\n\n        // Draw variants.\n        ctx.textAlign = \"center\";\n        for (var i = 0; i < this.data.length; i++) {\n            // Get locus data.\n            locus_data = this.data[i];\n            pos = locus_data[1];\n            ref = locus_data[3];\n            alt = [ locus_data[4].split(',') ];\n            sample_gts = locus_data[7].split(',');\n            allele_counts = locus_data.slice(8);\n\n            // Process alterate values to derive information about each alt.\n            alt = _.map(_.flatten(alt), function(a) {\n                var alt_info = {\n                        type: 'snp',\n                        value: a,\n                        start: 0\n                    },\n                    indel_info = get_indel_info(ref, a);\n\n                return _.extend(alt_info, indel_info);\n            });\n\n            // Only draw locus data if it's in viewing region.\n            if (pos < this.view_start || pos > this.view_end) {\n                continue;\n            }\n\n            // Draw summary for alleles.\n            if (draw_summary) {\n                ctx.fillStyle = '#999999';\n                ctx.globalAlpha = 1;\n                for (j = 0; j < alt.length; j++) {\n                    // Draw background for summary.\n                    draw_x_start = this.get_start_draw_pos(pos + alt[j].start, w_scale);\n                    ctx.fillRect(draw_x_start, 0, base_px, this.prefs.summary_height);\n                    draw_y_start = this.prefs.summary_height;\n                    // Draw allele fractions onto summary.\n                    for (j = 0; j < alt.length; j++) {\n                        ctx.fillStyle = ( alt[j].type === 'deletion' ? 'black' : this.base_color_fn(alt[j].value) );\n                        allele_frac = allele_counts / sample_gts.length;\n                        draw_height = Math.ceil(this.prefs.summary_height * allele_frac);\n                        ctx.fillRect(draw_x_start, draw_y_start - draw_height, base_px, draw_height);\n                        draw_y_start -= draw_height;\n                    }\n                }\n            }\n\n            // Done drawing if not showing samples data.\n            if (!this.prefs.show_sample_data) { continue; }\n\n            // Draw sample genotype(s).\n            draw_y_start = (draw_summary ? this.prefs.summary_height + this.divider_height : 0);\n            for (j = 0; j < sample_gts.length; j++, draw_y_start += row_height) {\n                genotype = (sample_gts[j] ? sample_gts[j].split(/\\/|\\|/) : ['0', '0']);\n\n                // Get variant to draw and set drawing properties.\n                variant = null;\n                if (genotype[0] === genotype[1]) {\n                    if (genotype[0] === '.') {\n                        // TODO: draw uncalled variant.\n                    }\n                    else if (genotype[0] !== '0') {\n                        // Homozygous for variant.\n                        variant = alt[ parseInt(genotype[0], 10) - 1 ];\n                        ctx.globalAlpha = 1;\n                    }\n                    // else reference\n                }\n                else { // Heterozygous for variant.\n                    variant = (genotype[0] !== '0' ? genotype[0] : genotype[1]);\n                    variant = alt[ parseInt(variant, 10) - 1 ];\n                    ctx.globalAlpha = 0.5;\n                }\n\n                // If there's a variant, draw it.\n                if (variant) {\n                    draw_x_start = this.get_start_draw_pos(pos + variant.start, w_scale);\n                    if (variant.type === 'snp') {\n                        var snp = variant.value;\n                        ctx.fillStyle = this.base_color_fn(snp);\n                        if (paint_utils.draw_details) {\n                            ctx.fillText(snp, this.get_draw_pos(pos, w_scale), draw_y_start + row_height);\n                        }\n                        else {\n                            ctx.fillRect(draw_x_start, draw_y_start + 1, base_px, feature_height);\n                        }\n                    }\n                    else if (variant.type === 'deletion') {\n                        paint_utils.draw_deletion(draw_x_start, draw_y_start + 1, variant.len);\n                    }\n                    else {\n                        // TODO: handle insertions.\n                    }\n                }\n            }\n        }\n\n        ctx.restore();\n    }\n});\n\nreturn {\n    Scaler: Scaler,\n    LinePainter: LinePainter,\n    LinkedFeaturePainter: LinkedFeaturePainter,\n    ReadPainter: ReadPainter,\n    ArcLinkedFeaturePainter: ArcLinkedFeaturePainter,\n    DiagonalHeatmapPainter: DiagonalHeatmapPainter,\n    VariantPainter: VariantPainter\n};\n\n\n});\n"]}