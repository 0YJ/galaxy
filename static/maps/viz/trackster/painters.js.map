{"version":3,"sources":["viz/trackster/painters.js"],"names":["compute_overlap","first_region","second_region","first_start","first_end","second_start","second_end","overlap","AFTER","CONTAINED_BY","dashedLine","ctx","x1","y1","x2","y2","dashLen","undefined","q","dX","dY","dashes","Math","floor","sqrt","dashX","dashY","drawDownwardEquilateralTriangle","down_vertex_x","down_vertex_y","side_len","y","beginPath","moveTo","lineTo","strokeStyle","fill","stroke","default_val","Scaler","prototype","gen_val","input","this","DrawResults","options","incomplete_features","feature_mapper","Painter","data","view_start","view_end","prefs","_underscore2","default","extend","default_prefs","mode","draw","width","w_scale","get_start_draw_pos","chrom_pos","_chrom_pos_to_draw_pos","get_end_draw_pos","get_draw_pos","offset","max","LinePainter","call","min_value","max_value","overflow_color","height","in_path","vertical_range","height_px","save","round","y_zero","fillStyle","fillRect","x_scaled","delta_x_pxs","length","map","slice","d","i","ceil","delta_x_px","painter_color","block_color","color","pref_color","parseInt","pref_r","pref_g","pref_b","bot_overflow","len","top_overflow","saturation","new_g","new_b","new_r","overflow_x","FeaturePositionMapper","slot_height","feature_positions","y_translation","map_feature_data","feature_data","slot","x_end","x_start","push","x","feature_dict","FeaturePainter","alpha_scaler","connector_color","get_required_height","rows_required","max_label_length","required_height","get_row_height","get_top_padding","y_scale","slots","x_draw_coords","feature_uid","feature","textAlign","feature_start","feature_end","draw_element","DENSE_TRACK_HEIGHT","NO_DETAIL_TRACK_HEIGHT","DENSE_FEATURE_HEIGHT","SQUISH_FEATURE_HEIGHT","LinkedFeaturePainter","draw_background_connector","draw_individual_connectors","tile_low","height_scaler","f_start","y_start","f_end","feature_ts","feature_te","full_height","thin_height","thick_height","tile_high","feature_name","feature_strand","manager","get_pattern","min","draw_start","draw_end","thick_start","cur_y_start","cur_height","globalAlpha","feature_blocks","start_and_height","block","block_start","block_end","thick_end","last_block_end","new_height","canvas","ref_seq","base_color_fn","show_insertions","k","k_len","last_block_start","cigar_ops","blocks","cur_block","parsed_cigar","op_len","op_char","indexOf","block_thick_end","block_thick_start","update_base_offset","cig_op","update_seq_offset","draw_connector","tile_region","base_offset","seq_offset","char_width_px","rect_y","paint_utils","ReadPainterUtils","draw_last","_parse_cigar","t","cigar","hscale_factor","ws_height","drawing_blocks","is_overlap","s_start","get_draw_coord","label_color","cig","cig_len","measureText","s_end","seq_start","fillText","ReadPainter","cur_seq","cigar_str","match","op","insert_x_coord","gap","base_pos","x_center","draw_read","seq","strand","sequence_coord","item","type","draw_height","connector","cig_id","b2_start","ArcLinkedFeaturePainter","longest_feature_length","view_range","radius","block2_start","c","angle2","show_differences","c_start","start_pos","Color","rgb","pack_mode","alpha","draw_deletion","read_seq","g","r","w","str_len","start_color","end_color","start_value","LinearRamp","middle_color","end_value","map_value","line_height","DiagonalHeatmapPainter","pos_color","rotate","scale","invsqrt2","s1","Array","row_height","px_per_base","delete_details_thickness","thickness","VariantPainter","divider_height","SQUISH_TRACK_HEIGHT","b1_end","num_samples","get_indel_info","alt_len","start","ref","alt","ref_len","id","filter","sample_gts","feature_height","draw_summary","show_sample_data","locus_data","pos","split","allele_counts","value","indel_info","block1_start","block2_end","draw_y_start","summary_height","PI","a","variant","genotype","substring","eval","toCSS","concat","join","toString","toHSL","h","s","b","l","toARGB","mix","color2","weight","color1","p","w1","w2","value_range","SplitRamp","positive_ramp","negative_ramp","Infinity","neg_color","e1","s2","e2","ramp","restore","draw_details","draw_x_start","j","base_px","flatten","alt_info","allele_frac","snp"],"mappings":"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","file":"../../../scripts/viz/trackster/painters.js","sourcesContent":["import _ from \"libs/underscore\";\n/**\n * Compute the type of overlap between two regions. They are assumed to be on the same chrom/contig.\n * The overlap is computed relative to the second region; hence, OVERLAP_START indicates that the first\n * region overlaps the start (but not the end) of the second region.\n * NOTE: Coordinates are assumed to be in BED format: half open (start is closed, end is open).\n */\nvar BEFORE = 1001,\n    CONTAINS = 1002,\n    OVERLAP_START = 1003,\n    OVERLAP_END = 1004,\n    CONTAINED_BY = 1005,\n    AFTER = 1006;\nvar compute_overlap = function(first_region, second_region) {\n    var first_start = first_region[0],\n        first_end = first_region[1],\n        second_start = second_region[0],\n        second_end = second_region[1],\n        overlap;\n    if (first_start < second_start) {\n        if (first_end <= second_start) {\n            overlap = BEFORE;\n        } else if (first_end <= second_end) {\n            overlap = OVERLAP_START;\n        } else {\n            // first_end > second_end\n            overlap = CONTAINS;\n        }\n    } else {\n        // first_start >= second_start\n        if (first_start > second_end) {\n            overlap = AFTER;\n        } else if (first_end <= second_end) {\n            overlap = CONTAINED_BY;\n        } else {\n            overlap = OVERLAP_END;\n        }\n    }\n\n    return overlap;\n};\n\n/**\n * Returns true if regions overlap.\n */\nvar is_overlap = function(first_region, second_region) {\n    var overlap = compute_overlap(first_region, second_region);\n    return overlap !== BEFORE && overlap !== AFTER;\n};\n\n/**\n * Draw a dashed line on a canvas using filled rectangles. This function is based on:\n * http://vetruvet.blogspot.com/2010/10/drawing-dashed-lines-on-html5-canvas.html\n * However, that approach uses lines, which don't seem to render as well, so use\n * rectangles instead.\n */\nvar dashedLine = function(ctx, x1, y1, x2, y2, dashLen) {\n    if (dashLen === undefined) {\n        dashLen = 4;\n    }\n    var dX = x2 - x1;\n    var dY = y2 - y1;\n    var dashes = Math.floor(Math.sqrt(dX * dX + dY * dY) / dashLen);\n    var dashX = dX / dashes;\n    var dashY = dY / dashes;\n    var q;\n\n    for (q = 0; q < dashes; q++, x1 += dashX, y1 += dashY) {\n        if (q % 2 !== 0) {\n            continue;\n        }\n        ctx.fillRect(x1, y1, dashLen, 1);\n    }\n};\n\n/**\n * Draw an isosceles triangle that points down.\n */\nvar drawDownwardEquilateralTriangle = function(\n    ctx,\n    down_vertex_x,\n    down_vertex_y,\n    side_len\n) {\n    // Compute other two points of triangle.\n    var x1 = down_vertex_x - side_len / 2,\n        x2 = down_vertex_x + side_len / 2,\n        y = down_vertex_y - Math.sqrt(side_len * 3 / 2);\n\n    // Draw and fill.\n    ctx.beginPath();\n    ctx.moveTo(x1, y);\n    ctx.lineTo(x2, y);\n    ctx.lineTo(down_vertex_x, down_vertex_y);\n    ctx.lineTo(x1, y);\n\n    ctx.strokeStyle = this.fillStyle;\n    ctx.fill();\n    ctx.stroke();\n    ctx.closePath();\n};\n\n/**\n * Base class for all scalers. Scalers produce values that are used to change (scale) drawing attributes.\n */\nvar Scaler = function(default_val) {\n    this.default_val = default_val ? default_val : 1;\n};\n\n/**\n * Produce a scaling value.\n */\nScaler.prototype.gen_val = function(input) {\n    return this.default_val;\n};\n\n/**\n * Results from painter.draw()\n */\nvar DrawResults = function(options) {\n    this.incomplete_features = options.incomplete_features;\n    this.feature_mapper = options.feature_mapper;\n};\n\n/**\n * Base class for painters\n *\n * -- Mode and prefs are both optional\n */\nvar Painter = function(data, view_start, view_end, prefs, mode) {\n    // Data and data properties\n    this.data = data;\n    // View\n    this.view_start = view_start;\n    this.view_end = view_end;\n    // Drawing prefs\n    this.prefs = _.extend({}, this.default_prefs, prefs);\n    this.mode = mode;\n};\n\nPainter.prototype.default_prefs = {};\n\n/**\n * Draw on the context using a rectangle of width x height using scale w_scale.\n */\nPainter.prototype.draw = function(ctx, width, height, w_scale) {};\n\n/**\n * Get starting drawing position, which is offset a half-base left of coordinate.\n */\nPainter.prototype.get_start_draw_pos = function(chrom_pos, w_scale) {\n    return this._chrom_pos_to_draw_pos(chrom_pos, w_scale, -0.5);\n};\n\n/**\n * Get end drawing position, which is offset a half-base right of coordinate.\n */\nPainter.prototype.get_end_draw_pos = function(chrom_pos, w_scale) {\n    return this._chrom_pos_to_draw_pos(chrom_pos, w_scale, 0.5);\n};\n\n/**\n * Get drawing position.\n */\nPainter.prototype.get_draw_pos = function(chrom_pos, w_scale) {\n    return this._chrom_pos_to_draw_pos(chrom_pos, w_scale, 0);\n};\n\n/**\n * Convert chromosome position to drawing position.\n */\nPainter.prototype._chrom_pos_to_draw_pos = function(\n    chrom_pos,\n    w_scale,\n    offset\n) {\n    return Math.floor(\n        w_scale * (Math.max(0, chrom_pos - this.view_start) + offset)\n    );\n};\n\nvar LinePainter = function(data, view_start, view_end, prefs, mode) {\n    Painter.call(this, data, view_start, view_end, prefs, mode);\n};\n\nLinePainter.prototype.default_prefs = {\n    min_value: undefined,\n    max_value: undefined,\n    mode: \"Histogram\",\n    color: \"#000\",\n    overflow_color: \"#F66\"\n};\n\nLinePainter.prototype.draw = function(ctx, width, height, w_scale) {\n    var in_path = false,\n        min_value = this.prefs.min_value,\n        max_value = this.prefs.max_value,\n        vertical_range = max_value - min_value,\n        height_px = height,\n        view_start = this.view_start,\n        mode = this.mode,\n        data = this.data;\n\n    ctx.save();\n\n    // Pixel position of 0 on the y axis\n    var y_zero = Math.round(height + min_value / vertical_range * height);\n\n    // Horizontal line to denote x-axis\n    if (mode !== \"Intensity\") {\n        ctx.fillStyle = \"#aaa\";\n        ctx.fillRect(0, y_zero, width, 1);\n    }\n\n    ctx.beginPath();\n    var x_scaled, y, delta_x_pxs;\n    if (data.length > 1) {\n        delta_x_pxs = _.map(data.slice(0, -1), function(d, i) {\n            return Math.ceil((data[i + 1][0] - data[i][0]) * w_scale);\n        });\n    } else {\n        delta_x_pxs = [10];\n    }\n\n    // Painter color can be in either block_color (FeatureTrack) or color pref (LineTrack).\n    var painter_color = this.prefs.block_color || this.prefs.color,\n        // Extract RGB from preference color.\n        pref_color = parseInt(painter_color.slice(1), 16),\n        pref_r = (pref_color & 0xff0000) >> 16,\n        pref_g = (pref_color & 0x00ff00) >> 8,\n        pref_b = pref_color & 0x0000ff,\n        top_overflow = false,\n        bot_overflow = false;\n\n    // Paint track.\n    var delta_x_px;\n    for (var i = 0, len = data.length; i < len; i++) {\n        // Reset attributes for next point.\n        ctx.fillStyle = ctx.strokeStyle = painter_color;\n        top_overflow = bot_overflow = false;\n        delta_x_px = delta_x_pxs[i];\n\n        x_scaled = Math.floor((data[i][0] - view_start - 0.5) * w_scale);\n        y = data[i][1];\n\n        // Process Y (scaler) value.\n        if (y === null) {\n            if (in_path && mode === \"Filled\") {\n                ctx.lineTo(x_scaled, height_px);\n            }\n            in_path = false;\n            continue;\n        }\n\n        // Bound Y value by min, max.\n        if (y < min_value) {\n            bot_overflow = true;\n            y = min_value;\n        } else if (y > max_value) {\n            top_overflow = true;\n            y = max_value;\n        }\n\n        // Draw point.\n        if (mode === \"Histogram\") {\n            // y becomes the bar height in pixels, which is the negated for canvas coords\n            y = Math.round(y / vertical_range * height_px);\n            ctx.fillRect(x_scaled, y_zero, delta_x_px, -y);\n        } else if (mode === \"Intensity\") {\n            var saturation = (y - min_value) / vertical_range,\n                // Range is [pref_color, 255] where saturation = 0 --> 255 and saturation = 1 --> pref color\n                new_r = Math.round(pref_r + (255 - pref_r) * (1 - saturation)),\n                new_g = Math.round(pref_g + (255 - pref_g) * (1 - saturation)),\n                new_b = Math.round(pref_b + (255 - pref_b) * (1 - saturation));\n            ctx.fillStyle = \"rgb(\" + new_r + \",\" + new_g + \",\" + new_b + \")\";\n            ctx.fillRect(x_scaled, 0, delta_x_px, height_px);\n        } else {\n            // mode is Coverage/Line or Filled.\n\n            // Scale Y value.\n            y = Math.round(\n                height_px - (y - min_value) / vertical_range * height_px\n            );\n            if (in_path) {\n                ctx.lineTo(x_scaled, y);\n            } else {\n                in_path = true;\n                if (mode === \"Filled\") {\n                    ctx.moveTo(x_scaled, height_px);\n                    ctx.lineTo(x_scaled, y);\n                } else {\n                    ctx.moveTo(x_scaled, y);\n                    // Use this approach (note: same as for filled) to draw line from 0 to\n                    // first data point.\n                    //ctx.moveTo(x_scaled, height_px);\n                    //ctx.lineTo(x_scaled, y);\n                }\n            }\n        }\n\n        // Draw lines at boundaries if overflowing min or max\n        ctx.fillStyle = this.prefs.overflow_color;\n        if (top_overflow || bot_overflow) {\n            var overflow_x;\n            if (mode === \"Histogram\" || mode === \"Intensity\") {\n                overflow_x = delta_x_px;\n            } else {\n                // Line and Filled, which are points\n                x_scaled -= 2; // Move it over to the left so it's centered on the point\n                overflow_x = 4;\n            }\n            if (top_overflow) {\n                ctx.fillRect(x_scaled, 0, overflow_x, 3);\n            }\n            if (bot_overflow) {\n                ctx.fillRect(x_scaled, height_px - 3, overflow_x, 3);\n            }\n        }\n        ctx.fillStyle = painter_color;\n    }\n    if (mode === \"Filled\") {\n        if (in_path) {\n            ctx.lineTo(x_scaled, y_zero);\n            ctx.lineTo(0, y_zero);\n        }\n        ctx.fill();\n    } else {\n        ctx.stroke();\n    }\n\n    ctx.restore();\n};\n\n/**\n * Mapper that contains information about feature locations and data.\n */\nvar FeaturePositionMapper = function(slot_height) {\n    this.feature_positions = {};\n    this.slot_height = slot_height;\n    this.translation = 0;\n    this.y_translation = 0;\n};\n\n/**\n * Map feature data to a position defined by <slot, x_start, x_end>.\n */\nFeaturePositionMapper.prototype.map_feature_data = function(\n    feature_data,\n    slot,\n    x_start,\n    x_end\n) {\n    if (!this.feature_positions[slot]) {\n        this.feature_positions[slot] = [];\n    }\n    this.feature_positions[slot].push({\n        data: feature_data,\n        x_start: x_start,\n        x_end: x_end\n    });\n};\n\n/**\n * Get feature data for position <x, y>\n */\nFeaturePositionMapper.prototype.get_feature_data = function(x, y) {\n    // Find slot using Y.\n    var slot = Math.floor((y - this.y_translation) / this.slot_height),\n        feature_dict;\n\n    // May not be over a slot due to padding, margin, etc.\n    if (!this.feature_positions[slot]) {\n        return null;\n    }\n\n    // Find feature using X.\n    x += this.translation;\n    for (var i = 0; i < this.feature_positions[slot].length; i++) {\n        feature_dict = this.feature_positions[slot][i];\n        if (x >= feature_dict.x_start && x <= feature_dict.x_end) {\n            return feature_dict.data;\n        }\n    }\n};\n\n/**\n * Abstract object for painting feature tracks. Subclasses must implement draw_element() for painting to work.\n * Painter uses a 0-based, half-open coordinate system; start coordinate is closed--included--and the end is open.\n * This coordinate system matches the BED format.\n */\nvar FeaturePainter = function(\n    data,\n    view_start,\n    view_end,\n    prefs,\n    mode,\n    alpha_scaler,\n    height_scaler\n) {\n    Painter.call(this, data, view_start, view_end, prefs, mode);\n    this.alpha_scaler = alpha_scaler ? alpha_scaler : new Scaler();\n    this.height_scaler = height_scaler ? height_scaler : new Scaler();\n    this.max_label_length = 200;\n};\n\nFeaturePainter.prototype.default_prefs = {\n    block_color: \"#FFF\",\n    connector_color: \"#FFF\"\n};\n\n_.extend(FeaturePainter.prototype, {\n    get_required_height: function(rows_required, width) {\n        // y_scale is the height per row\n        var required_height = this.get_row_height(),\n            y_scale = required_height,\n            mode = this.mode;\n        // If using a packing mode, need to multiply by the number of slots used\n        if (mode === \"no_detail\" || mode === \"Squish\" || mode === \"Pack\") {\n            required_height = rows_required * y_scale;\n        }\n        return required_height + this.get_top_padding(width);\n    },\n\n    /** Extra padding before first row of features */\n    get_top_padding: function(width) {\n        return 0;\n    },\n\n    /**\n     * Draw data on ctx using slots and within the rectangle defined by width and height. Returns\n     * a FeaturePositionMapper object with information about where features were drawn.\n     */\n    draw: function(ctx, width, height, w_scale, slots) {\n        var data = this.data,\n            view_start = this.view_start,\n            view_end = this.view_end;\n\n        ctx.save();\n\n        ctx.fillStyle = this.prefs.block_color;\n        ctx.textAlign = \"right\";\n\n        var y_scale = this.get_row_height(),\n            feature_mapper = new FeaturePositionMapper(y_scale),\n            x_draw_coords,\n            incomplete_features = [];\n\n        for (var i = 0, len = data.length; i < len; i++) {\n            var feature = data[i],\n                feature_uid = feature[0],\n                feature_start = feature[1],\n                feature_end = feature[2],\n                // Slot valid only if features are slotted and this feature is slotted;\n                // feature may not be due to lack of space.\n                slot =\n                    slots && slots[feature_uid] !== undefined\n                        ? slots[feature_uid].slot\n                        : null;\n\n            // Draw feature if (a) mode is dense or feature is slotted (as it must be for all non-dense modes) and\n            // (b) there's overlap between the feature and drawing region.\n            if (\n                (this.mode === \"Dense\" || slot !== null) &&\n                (feature_start < view_end && feature_end > view_start)\n            ) {\n                x_draw_coords = this.draw_element(\n                    ctx,\n                    this.mode,\n                    feature,\n                    slot,\n                    view_start,\n                    view_end,\n                    w_scale,\n                    y_scale,\n                    width\n                );\n                feature_mapper.map_feature_data(\n                    feature,\n                    slot,\n                    x_draw_coords[0],\n                    x_draw_coords[1]\n                );\n\n                // Add to incomplete features if it's not drawn completely in region.\n                if (feature_start < view_start || feature_end > view_end) {\n                    incomplete_features.push(feature);\n                }\n            }\n        }\n\n        ctx.restore();\n\n        feature_mapper.y_translation = this.get_top_padding(width);\n        return new DrawResults({\n            incomplete_features: incomplete_features,\n            feature_mapper: feature_mapper\n        });\n    },\n\n    /**\n     * Abstract function for drawing an individual feature.\n     */\n    draw_element: function(\n        ctx,\n        mode,\n        feature,\n        slot,\n        tile_low,\n        tile_high,\n        w_scale,\n        y_scale,\n        width\n    ) {\n        return [0, 0];\n    }\n});\n\n// Constants specific to feature tracks moved here (HACKING, these should\n// basically all be configuration options)\nvar DENSE_TRACK_HEIGHT = 10,\n    NO_DETAIL_TRACK_HEIGHT = 3,\n    SQUISH_TRACK_HEIGHT = 5,\n    PACK_TRACK_HEIGHT = 10,\n    NO_DETAIL_FEATURE_HEIGHT = 1,\n    DENSE_FEATURE_HEIGHT = 9,\n    SQUISH_FEATURE_HEIGHT = 3,\n    PACK_FEATURE_HEIGHT = 9,\n    LABEL_SPACING = 2,\n    CONNECTOR_COLOR = \"#ccc\";\n\nvar LinkedFeaturePainter = function(\n    data,\n    view_start,\n    view_end,\n    prefs,\n    mode,\n    alpha_scaler,\n    height_scaler\n) {\n    FeaturePainter.call(\n        this,\n        data,\n        view_start,\n        view_end,\n        prefs,\n        mode,\n        alpha_scaler,\n        height_scaler\n    );\n    // Whether to draw a single connector in the background that spans the entire feature (the intron fishbone)\n    this.draw_background_connector = true;\n    // Whether to call draw_connector for every pair of blocks\n    this.draw_individual_connectors = false;\n};\n\n_.extend(LinkedFeaturePainter.prototype, FeaturePainter.prototype, {\n    /**\n     * Height of a single row, depends on mode\n     */\n    get_row_height: function() {\n        var mode = this.mode,\n            height;\n        if (mode === \"Dense\") {\n            height = DENSE_TRACK_HEIGHT;\n        } else if (mode === \"no_detail\") {\n            height = NO_DETAIL_TRACK_HEIGHT;\n        } else if (mode === \"Squish\") {\n            height = SQUISH_TRACK_HEIGHT;\n        } else {\n            // mode === \"Pack\"\n            height = PACK_TRACK_HEIGHT;\n        }\n        return height;\n    },\n\n    /**\n     * Draw a feature. Returns an array with feature's start and end X coordinates.\n     */\n    draw_element: function(\n        ctx,\n        mode,\n        feature,\n        slot,\n        tile_low,\n        tile_high,\n        w_scale,\n        y_scale,\n        width\n    ) {\n        var feature_uid = feature[0],\n            feature_start = feature[1],\n            feature_end = feature[2],\n            feature_name = feature[3],\n            feature_strand = feature[4],\n            // -0.5 to offset region between bases.\n            f_start = Math.floor(\n                Math.max(0, (feature_start - tile_low - 0.5) * w_scale)\n            ),\n            f_end = Math.ceil(\n                Math.min(\n                    width,\n                    Math.max(0, (feature_end - tile_low - 0.5) * w_scale)\n                )\n            ),\n            draw_start = f_start,\n            draw_end = f_end,\n            y_start =\n                (mode === \"Dense\" ? 0 : 0 + slot) * y_scale +\n                this.get_top_padding(width),\n            thickness,\n            y_start,\n            thick_start = null,\n            thick_end = null,\n            // TODO: is there any reason why block, label color cannot be set at the Painter level?\n            // For now, assume '.' === '+'\n            block_color =\n                !feature_strand ||\n                feature_strand === \"+\" ||\n                feature_strand === \".\"\n                    ? this.prefs.block_color\n                    : this.prefs.reverse_strand_color,\n            label_color = this.prefs.label_color;\n\n        // Set global alpha.\n        ctx.globalAlpha = this.alpha_scaler.gen_val(feature);\n\n        // In dense mode, put all data in top slot.\n        if (mode === \"Dense\") {\n            slot = 1;\n        }\n\n        if (mode === \"no_detail\") {\n            // No details for feature, so only one way to display.\n            ctx.fillStyle = block_color;\n            ctx.fillRect(\n                f_start,\n                y_start + 5,\n                f_end - f_start,\n                NO_DETAIL_FEATURE_HEIGHT\n            );\n        } else {\n            // Mode is either Squish or Pack:\n            // Feature details.\n            var feature_ts = feature[5],\n                feature_te = feature[6],\n                feature_blocks = feature[7],\n                // Whether we are drawing full height or squished features\n                full_height = true;\n\n            if (feature_ts && feature_te) {\n                thick_start = Math.floor(\n                    Math.max(0, (feature_ts - tile_low) * w_scale)\n                );\n                thick_end = Math.ceil(\n                    Math.min(\n                        width,\n                        Math.max(0, (feature_te - tile_low) * w_scale)\n                    )\n                );\n            }\n\n            // Set vars that depend on mode.\n            var thin_height, thick_height;\n            if (mode === \"Squish\") {\n                thin_height = 1;\n                thick_height = SQUISH_FEATURE_HEIGHT;\n                full_height = false;\n            } else if (mode === \"Dense\") {\n                thin_height = 5;\n                thick_height = DENSE_FEATURE_HEIGHT;\n            } else {\n                // mode === \"Pack\"\n                thin_height = 5;\n                thick_height = PACK_FEATURE_HEIGHT;\n            }\n\n            // Draw feature/feature blocks + connectors.\n            if (!feature_blocks) {\n                // If there are no blocks, treat the feature as one big exon.\n                ctx.fillStyle = block_color;\n                ctx.fillRect(\n                    f_start,\n                    y_start + 1,\n                    f_end - f_start,\n                    thick_height\n                );\n                // If strand is specified, draw arrows over feature\n                if (feature_strand && full_height) {\n                    if (feature_strand === \"+\") {\n                        ctx.fillStyle = ctx.canvas.manager.get_pattern(\n                            \"right_strand_inv\"\n                        );\n                    } else if (feature_strand === \"-\") {\n                        ctx.fillStyle = ctx.canvas.manager.get_pattern(\n                            \"left_strand_inv\"\n                        );\n                    }\n                    ctx.fillRect(\n                        f_start,\n                        y_start + 1,\n                        f_end - f_start,\n                        thick_height\n                    );\n                }\n            } else {\n                //\n                // There are feature blocks and mode is either Squish or Pack.\n                //\n                // Approach: (a) draw whole feature as connector/intron and (b) draw blocks as\n                // needed. This ensures that whole feature, regardless of whether it starts with\n                // a block, is visible.\n                //\n\n                // Compute y axis start position and height\n                var cur_y_start, cur_height;\n                if (mode === \"Squish\" || mode === \"Dense\") {\n                    cur_y_start =\n                        y_start + Math.floor(SQUISH_FEATURE_HEIGHT / 2) + 1;\n                    cur_height = 1;\n                } else {\n                    // mode === \"Pack\"\n                    if (feature_strand) {\n                        cur_y_start = y_start;\n                        cur_height = thick_height;\n                    } else {\n                        cur_y_start += SQUISH_FEATURE_HEIGHT / 2 + 1;\n                        cur_height = 1;\n                    }\n                }\n\n                // Draw whole feature as connector/intron.\n                if (this.draw_background_connector) {\n                    if (mode === \"Squish\" || mode === \"Dense\") {\n                        ctx.fillStyle = CONNECTOR_COLOR;\n                    } else {\n                        // mode === \"Pack\"\n                        if (feature_strand) {\n                            if (feature_strand === \"+\") {\n                                ctx.fillStyle = ctx.canvas.manager.get_pattern(\n                                    \"right_strand\"\n                                );\n                            } else if (feature_strand === \"-\") {\n                                ctx.fillStyle = ctx.canvas.manager.get_pattern(\n                                    \"left_strand\"\n                                );\n                            }\n                        } else {\n                            ctx.fillStyle = CONNECTOR_COLOR;\n                        }\n                    }\n                    ctx.fillRect(\n                        f_start,\n                        cur_y_start,\n                        f_end - f_start,\n                        cur_height\n                    );\n                }\n\n                // Draw blocks.\n                var start_and_height;\n                for (var k = 0, k_len = feature_blocks.length; k < k_len; k++) {\n                    var block = feature_blocks[k],\n                        // -0.5 to offset block between bases.\n                        block_start = Math.floor(\n                            Math.max(0, (block[0] - tile_low - 0.5) * w_scale)\n                        ),\n                        block_end = Math.ceil(\n                            Math.min(\n                                width,\n                                Math.max((block[1] - tile_low - 0.5) * w_scale)\n                            )\n                        ),\n                        last_block_start,\n                        last_block_end;\n\n                    // Skip drawing if block not on tile.\n                    if (block_start > block_end) {\n                        continue;\n                    }\n\n                    // Draw thin block.\n                    ctx.fillStyle = block_color;\n                    ctx.fillRect(\n                        block_start,\n                        y_start + (thick_height - thin_height) / 2 + 1,\n                        block_end - block_start,\n                        thin_height\n                    );\n\n                    // If block intersects with thick region, draw block as thick.\n                    // - No thick is sometimes encoded as thick_start == thick_end, so don't draw in that case\n                    if (\n                        thick_start !== undefined &&\n                        feature_te > feature_ts &&\n                        !(block_start > thick_end || block_end < thick_start)\n                    ) {\n                        var block_thick_start = Math.max(\n                                block_start,\n                                thick_start\n                            ),\n                            block_thick_end = Math.min(block_end, thick_end);\n                        ctx.fillRect(\n                            block_thick_start,\n                            y_start + 1,\n                            block_thick_end - block_thick_start,\n                            thick_height\n                        );\n                        if (feature_blocks.length === 1 && mode === \"Pack\") {\n                            // Exactly one block means we have no introns, but do have a distinct \"thick\" region,\n                            // draw arrows over it if in pack mode.\n                            if (feature_strand === \"+\") {\n                                ctx.fillStyle = ctx.canvas.manager.get_pattern(\n                                    \"right_strand_inv\"\n                                );\n                            } else if (feature_strand === \"-\") {\n                                ctx.fillStyle = ctx.canvas.manager.get_pattern(\n                                    \"left_strand_inv\"\n                                );\n                            }\n                            // If region is wide enough in pixels, pad a bit\n                            if (block_thick_start + 14 < block_thick_end) {\n                                block_thick_start += 2;\n                                block_thick_end -= 2;\n                            }\n                            ctx.fillRect(\n                                block_thick_start,\n                                y_start + 1,\n                                block_thick_end - block_thick_start,\n                                thick_height\n                            );\n                        }\n                    }\n                    // Draw individual connectors if required\n                    if (this.draw_individual_connectors && last_block_start) {\n                        this.draw_connector(\n                            ctx,\n                            last_block_start,\n                            last_block_end,\n                            block_start,\n                            block_end,\n                            y_start\n                        );\n                    }\n                    last_block_start = block_start;\n                    last_block_end = block_end;\n                }\n\n                // FIXME: Height scaling only works in Pack mode right now.\n                if (mode === \"Pack\") {\n                    // Reset alpha so height scaling is not impacted by alpha scaling.\n                    ctx.globalAlpha = 1;\n\n                    // Height scaling: draw white lines to reduce height according to height scale factor.\n                    ctx.fillStyle = \"white\"; // TODO: set this to background color.\n                    var hscale_factor = this.height_scaler.gen_val(feature),\n                        // Ceil ensures that min height is >= 1.\n                        new_height = Math.ceil(thick_height * hscale_factor),\n                        ws_height = Math.round((thick_height - new_height) / 2);\n                    if (hscale_factor !== 1) {\n                        ctx.fillRect(\n                            f_start,\n                            cur_y_start + 1,\n                            f_end - f_start,\n                            ws_height\n                        );\n                        ctx.fillRect(\n                            f_start,\n                            cur_y_start + thick_height - ws_height + 1,\n                            f_end - f_start,\n                            ws_height\n                        );\n                    }\n                }\n            }\n\n            // Reset alpha so that label is not transparent.\n            ctx.globalAlpha = 1;\n\n            // Draw label for Pack mode.\n            if (feature_name && mode === \"Pack\" && feature_start > tile_low) {\n                ctx.fillStyle = label_color;\n                // FIXME: assumption here that the entire view starts at 0\n                if (\n                    tile_low === 0 &&\n                    f_start - ctx.measureText(feature_name).width < 0\n                ) {\n                    ctx.textAlign = \"left\";\n                    ctx.fillText(\n                        feature_name,\n                        f_end + LABEL_SPACING,\n                        y_start + 8,\n                        this.max_label_length\n                    );\n                    draw_end +=\n                        ctx.measureText(feature_name).width + LABEL_SPACING;\n                } else {\n                    ctx.textAlign = \"right\";\n                    ctx.fillText(\n                        feature_name,\n                        f_start - LABEL_SPACING,\n                        y_start + 8,\n                        this.max_label_length\n                    );\n                    draw_start -=\n                        ctx.measureText(feature_name).width + LABEL_SPACING;\n                }\n                //ctx.fillStyle = block_color;\n            }\n        }\n\n        // Reset global alpha.\n        ctx.globalAlpha = 1;\n\n        return [draw_start, draw_end];\n    }\n});\n\nvar ReadPainter = function(\n    data,\n    view_start,\n    view_end,\n    prefs,\n    mode,\n    alpha_scaler,\n    height_scaler,\n    ref_seq,\n    base_color_fn\n) {\n    FeaturePainter.call(\n        this,\n        data,\n        view_start,\n        view_end,\n        prefs,\n        mode,\n        alpha_scaler,\n        height_scaler\n    );\n    this.ref_seq = ref_seq ? ref_seq.data : null;\n    this.base_color_fn = base_color_fn;\n};\n\n_.extend(ReadPainter.prototype, FeaturePainter.prototype, {\n    /**\n     * Returns height based on mode.\n     */\n    get_row_height: function() {\n        var height,\n            mode = this.mode;\n        if (mode === \"Dense\") {\n            height = DENSE_TRACK_HEIGHT;\n        } else if (mode === \"Squish\") {\n            height = SQUISH_TRACK_HEIGHT;\n        } else {\n            // mode === \"Pack\"\n            height = PACK_TRACK_HEIGHT;\n            if (this.prefs.show_insertions) {\n                height *= 2;\n            }\n        }\n        return height;\n    },\n\n    /**\n     * Parse CIGAR string to get (a) a list of contiguous drawing blocks (MD=X) and\n     * (b) an array of [ op_index, op_len ] pairs where op_index is an index into the\n     * string 'MIDNSHP=X' Return value is a dictionary with two entries, blocks and cigar\n     */\n    _parse_cigar: function(cigar_str) {\n        var cigar_ops = \"MIDNSHP=X\";\n\n        // Parse cigar.\n        var blocks = [[0, 0]],\n            cur_block = blocks[0],\n            base_pos = 0,\n            // Parse cigar operations out and update/create blocks as needed.\n            parsed_cigar = _.map(\n                cigar_str.match(/[0-9]+[MIDNSHP=X]/g),\n                function(op) {\n                    // Get operation length, character.\n                    var op_len = parseInt(op.slice(0, -1), 10),\n                        op_char = op.slice(-1);\n\n                    // Update drawing block.\n                    if (op_char === \"N\") {\n                        // At skip, so need to start new block if current block represents\n                        // drawing area.\n                        if (cur_block[1] !== 0) {\n                            cur_block = [base_pos + op_len, base_pos + op_len];\n                            blocks.push(cur_block);\n                        }\n                    } else if (\"ISHP\".indexOf(op_char) === -1) {\n                        // Operation is M,D,=,X.\n                        cur_block[1] += op_len;\n                        base_pos += op_len;\n                    }\n\n                    // Return parsed cigar.\n                    return [cigar_ops.indexOf(op_char), op_len];\n                }\n            );\n\n        return {\n            blocks: blocks,\n            cigar: parsed_cigar\n        };\n    },\n\n    /**\n     * Draw a single read from reference-based read sequence and cigar.\n     */\n    draw_read: function(\n        ctx,\n        mode,\n        w_scale,\n        y_start,\n        tile_low,\n        tile_high,\n        feature_start,\n        cigar,\n        strand,\n        read_seq\n    ) {\n        // Helper function to update base and sequnence offsets.\n        var update_base_offset = function(offset, cig_op, cig_len) {\n                if (\"M=NXD\".indexOf(cig_op) !== -1) {\n                    offset += cig_len;\n                }\n                return offset;\n            },\n            update_seq_offset = function(offset, cig_op, cig_len) {\n                if (\"IX\".indexOf(cig_op) !== -1) {\n                    offset += cig_len;\n                }\n                return offset;\n            },\n            // Gets drawing coordinate for a sequence coordinate. Assumes closure variables w_scale and tile_low.\n            get_draw_coord = function(sequence_coord) {\n                // -0.5 to offset sequence between bases.\n                return Math.floor(\n                    Math.max(0, (sequence_coord - tile_low - 0.5) * w_scale)\n                );\n            };\n\n        ctx.textAlign = \"center\";\n        var tile_region = [tile_low, tile_high],\n            base_offset = 0,\n            seq_offset = 0,\n            gap = Math.round(w_scale / 2),\n            char_width_px = ctx.canvas.manager.char_width_px,\n            block_color =\n                strand === \"+\"\n                    ? this.prefs.detail_block_color\n                    : this.prefs.reverse_strand_color,\n            pack_mode = mode === \"Pack\",\n            draw_height = pack_mode\n                ? PACK_FEATURE_HEIGHT\n                : SQUISH_FEATURE_HEIGHT,\n            rect_y = y_start + 1,\n            paint_utils = new ReadPainterUtils(ctx, draw_height, w_scale, mode),\n            drawing_blocks = [],\n            s_start,\n            s_end;\n\n        // Keep list of items that need to be drawn on top of initial drawing layer.\n        var draw_last = [];\n\n        // Parse cigar and get drawing blocks.\n        var t = this._parse_cigar(cigar);\n        cigar = t.cigar;\n        drawing_blocks = t.blocks;\n\n        // Draw blocks.\n        for (var i = 0; i < drawing_blocks.length; i++) {\n            var block = drawing_blocks[i];\n\n            if (\n                is_overlap(\n                    [feature_start + block[0], feature_start + block[1]],\n                    tile_region\n                )\n            ) {\n                s_start = get_draw_coord(feature_start + block[0]);\n                s_end = get_draw_coord(feature_start + block[1]);\n\n                // Make sure that block is drawn even if it too small to be rendered officially; in this case,\n                // read is drawn at 1px.\n                // TODO: need to ensure that s_start, s_end are calculated the same for both slotting\n                // and drawing.\n                if (s_start === s_end) {\n                    s_end += 1;\n                }\n\n                // Draw read base as rectangle.\n                ctx.fillStyle = block_color;\n                ctx.fillRect(s_start, rect_y, s_end - s_start, draw_height);\n            }\n        }\n\n        // Draw read features.\n        for (var cig_id = 0, len = cigar.length; cig_id < len; cig_id++) {\n            var cig = cigar[cig_id],\n                cig_op = \"MIDNSHP=X\"[cig[0]],\n                cig_len = cig[1];\n\n            var seq_start = feature_start + base_offset;\n            s_start = get_draw_coord(seq_start);\n            s_end = get_draw_coord(seq_start + cig_len);\n\n            // Skip feature if it's not in tile.\n            if (!is_overlap([seq_start, seq_start + cig_len], tile_region)) {\n                // Update offsets.\n                base_offset = update_base_offset(base_offset, cig_op, cig_len);\n                seq_offset = update_seq_offset(seq_offset, cig_op, cig_len);\n                continue;\n            }\n\n            // Make sure that read is drawn even if it too small to be rendered officially; in this case,\n            // read is drawn at 1px.\n            // TODO: need to ensure that s_start, s_end are calculated the same for both slotting\n            // and drawing.\n            if (s_start === s_end) {\n                s_end += 1;\n            }\n\n            // Draw read feature.\n            switch (cig_op) {\n                case \"H\": // Hard clipping.\n                case \"S\": // Soft clipping.\n                case \"P\": // Padding.\n                    // Sequence not present and not related to alignment; do nothing.\n                    break;\n                case \"M\": // \"Match\".\n                    // Because it's not known whether there is a match, ignore.\n                    base_offset += cig_len;\n                    break;\n                case \"=\": // Match with reference.\n                case \"X\": // Mismatch with reference.\n                    //\n                    // Draw sequence and/or variants.\n                    //\n\n                    // Get sequence to draw.\n                    var cur_seq = \"\";\n                    if (cig_op === \"X\") {\n                        // Get sequence from read_seq.\n                        cur_seq = read_seq.slice(\n                            seq_offset,\n                            seq_offset + cig_len\n                        );\n                    } else if (this.ref_seq) {\n                        // && cig_op === '='\n                        // Use reference sequence.\n                        cur_seq = this.ref_seq.slice(\n                            // If read starts after tile start, slice at read start.\n                            Math.max(0, seq_start - tile_low),\n                            // If read ends before tile end, slice at read end.\n                            Math.min(\n                                seq_start - tile_low + cig_len,\n                                tile_high - tile_low\n                            )\n                        );\n                    }\n\n                    // Draw sequence. Because cur_seq starts and read/tile start, go to there to start writing.\n                    var start_pos = Math.max(seq_start, tile_low);\n                    for (var c = 0; c < cur_seq.length; c++) {\n                        // Draw base if showing all (i.e. not showing differences) or there is a mismatch.\n                        if (\n                            (cur_seq && !this.prefs.show_differences) ||\n                            cig_op === \"X\"\n                        ) {\n                            // Draw base.\n                            var c_start = Math.floor(\n                                Math.max(\n                                    0,\n                                    (start_pos + c - tile_low) * w_scale\n                                )\n                            );\n                            ctx.fillStyle = this.base_color_fn(cur_seq[c]);\n                            if (pack_mode && w_scale > char_width_px) {\n                                ctx.fillText(cur_seq[c], c_start, y_start + 9);\n                            } else if (w_scale > 0.05) {\n                                // Require a minimum w_scale so that variants are only drawn when somewhat zoomed in.\n                                ctx.fillRect(\n                                    c_start - gap,\n                                    rect_y,\n                                    Math.max(1, Math.round(w_scale)),\n                                    draw_height\n                                );\n                            }\n                        }\n                    }\n\n                    // Move forward in sequence only if sequence used to get mismatches.\n                    if (cig_op === \"X\") {\n                        seq_offset += cig_len;\n                    }\n                    base_offset += cig_len;\n\n                    break;\n                case \"N\": // Skipped bases.\n                    ctx.fillStyle = CONNECTOR_COLOR;\n                    ctx.fillRect(\n                        s_start,\n                        rect_y + (draw_height - 1) / 2,\n                        s_end - s_start,\n                        1\n                    );\n                    // No change in seq_offset because sequence not used when skipping.\n                    base_offset += cig_len;\n                    break;\n                case \"D\": // Deletion.\n                    paint_utils.draw_deletion(s_start, rect_y, cig_len);\n                    base_offset += cig_len;\n                    break;\n                case \"I\": // Insertion.\n                    // Check to see if sequence should be drawn at all by looking at the overlap between\n                    // the sequence region and the tile region.\n                    var insert_x_coord = s_start - gap;\n\n                    if (\n                        is_overlap(\n                            [seq_start, seq_start + cig_len],\n                            tile_region\n                        )\n                    ) {\n                        var seq = read_seq.slice(\n                            seq_offset,\n                            seq_offset + cig_len\n                        );\n                        // Insertion point is between the sequence start and the previous base: (-gap) moves\n                        // back from sequence start to insertion point.\n                        if (this.prefs.show_insertions) {\n                            //\n                            // Show inserted sequence above, centered on insertion point.\n                            //\n\n                            // Draw sequence.\n                            // X center is offset + start - <half_sequence_length>\n                            var x_center = s_start - (s_end - s_start) / 2;\n                            if (\n                                (mode === \"Pack\" || this.mode === \"Auto\") &&\n                                read_seq !== undefined &&\n                                w_scale > char_width_px\n                            ) {\n                                // Draw sequence container.\n                                ctx.fillStyle = \"yellow\";\n                                ctx.fillRect(\n                                    x_center - gap,\n                                    y_start - 9,\n                                    s_end - s_start,\n                                    9\n                                );\n                                draw_last[draw_last.length] = {\n                                    type: \"triangle\",\n                                    data: [insert_x_coord, y_start + 4, 5]\n                                };\n                                ctx.fillStyle = CONNECTOR_COLOR;\n                                // Based on overlap b/t sequence and tile, get sequence to be drawn.\n                                switch (compute_overlap(\n                                    [seq_start, seq_start + cig_len],\n                                    tile_region\n                                )) {\n                                    case OVERLAP_START:\n                                        seq = seq.slice(tile_low - seq_start);\n                                        break;\n                                    case OVERLAP_END:\n                                        seq = seq.slice(\n                                            0,\n                                            seq_start - tile_high\n                                        );\n                                        break;\n                                    case CONTAINED_BY:\n                                        // All of sequence drawn.\n                                        break;\n                                    case CONTAINS:\n                                        seq = seq.slice(\n                                            tile_low - seq_start,\n                                            seq_start - tile_high\n                                        );\n                                        break;\n                                }\n                                // Draw sequence.\n                                for (\n                                    var c = 0, str_len = seq.length;\n                                    c < str_len;\n                                    c++\n                                ) {\n                                    var c_start = Math.floor(\n                                        Math.max(\n                                            0,\n                                            (seq_start + c - tile_low) * w_scale\n                                        )\n                                    );\n                                    ctx.fillText(\n                                        seq[c],\n                                        c_start - (s_end - s_start) / 2,\n                                        y_start\n                                    );\n                                }\n                            } else {\n                                // Draw block.\n                                ctx.fillStyle = \"yellow\";\n                                // TODO: This is a pretty hack-ish way to fill rectangle based on mode.\n                                ctx.fillRect(\n                                    x_center,\n                                    y_start + (this.mode !== \"Dense\" ? 2 : 5),\n                                    s_end - s_start,\n                                    mode !== \"Dense\"\n                                        ? SQUISH_FEATURE_HEIGHT\n                                        : DENSE_FEATURE_HEIGHT\n                                );\n                            }\n                        } else {\n                            if (\n                                (mode === \"Pack\" || this.mode === \"Auto\") &&\n                                read_seq !== undefined &&\n                                w_scale > char_width_px\n                            ) {\n                                // Show insertions with a single number at the insertion point.\n                                draw_last.push({\n                                    type: \"text\",\n                                    data: [\n                                        seq.length,\n                                        insert_x_coord,\n                                        y_start + 9\n                                    ]\n                                });\n                            } else {\n                                // TODO: probably can merge this case with code above.\n                            }\n                        }\n                    }\n                    seq_offset += cig_len;\n                    // No change to base offset because insertions are drawn above sequence/read.\n                    break;\n            }\n        }\n\n        //\n        // Draw last items.\n        //\n        ctx.fillStyle = \"yellow\";\n        var item, type, data;\n        for (var i = 0; i < draw_last.length; i++) {\n            item = draw_last[i];\n            type = item.type;\n            data = item.data;\n            if (type === \"text\") {\n                ctx.save();\n                ctx.font = \"bold \" + ctx.font;\n                ctx.fillText(data[0], data[1], data[2]);\n                ctx.restore();\n            } else if (type === \"triangle\") {\n                drawDownwardEquilateralTriangle(ctx, data[0], data[1], data[2]);\n            }\n        }\n    },\n\n    /**\n     * Draw a complete read pair\n     */\n    draw_element: function(\n        ctx,\n        mode,\n        feature,\n        slot,\n        tile_low,\n        tile_high,\n        w_scale,\n        y_scale,\n        width\n    ) {\n        // All features need a start, end, and vertical center.\n        var feature_uid = feature[0],\n            feature_start = feature[1],\n            feature_end = feature[2],\n            feature_name = feature[3],\n            // -0.5 to put element between bases.\n            f_start = Math.floor(\n                Math.max(\n                    -0.5 * w_scale,\n                    (feature_start - tile_low - 0.5) * w_scale\n                )\n            ),\n            f_end = Math.ceil(\n                Math.min(\n                    width,\n                    Math.max(0, (feature_end - tile_low - 0.5) * w_scale)\n                )\n            ),\n            y_start = (mode === \"Dense\" ? 0 : 0 + slot) * y_scale,\n            draw_height =\n                mode === \"Pack\" ? PACK_FEATURE_HEIGHT : SQUISH_FEATURE_HEIGHT,\n            label_color = this.prefs.label_color;\n\n        // Draw read.\n        if (feature[5] instanceof Array) {\n            // Read is paired.\n            var connector = true;\n\n            // Draw left/forward read.\n            if (\n                feature[4][1] >= tile_low &&\n                feature[4][0] <= tile_high &&\n                feature[4][2]\n            ) {\n                this.draw_read(\n                    ctx,\n                    mode,\n                    w_scale,\n                    y_start,\n                    tile_low,\n                    tile_high,\n                    feature[4][0],\n                    feature[4][2],\n                    feature[4][3],\n                    feature[4][4]\n                );\n            } else {\n                connector = false;\n            }\n\n            // Draw right/reverse read.\n            if (\n                feature[5][1] >= tile_low &&\n                feature[5][0] <= tile_high &&\n                feature[5][2]\n            ) {\n                this.draw_read(\n                    ctx,\n                    mode,\n                    w_scale,\n                    y_start,\n                    tile_low,\n                    tile_high,\n                    feature[5][0],\n                    feature[5][2],\n                    feature[5][3],\n                    feature[5][4]\n                );\n            } else {\n                connector = false;\n            }\n\n            // Draw connector if both reads were drawn.\n            // TODO: currently, there is no way to connect reads drawn on different tiles; to connect reads on different tiles, data manager\n            // code is needed to join mate pairs from different regions. Alternatively, requesting multiple regions of data at once would\n            // make it possible to put together more easily.\n            // -0.5 to position connector correctly between reads.\n            var b1_end = Math.ceil(\n                    Math.min(\n                        width,\n                        Math.max(\n                            -0.5 * w_scale,\n                            (feature[4][1] - tile_low - 0.5) * w_scale\n                        )\n                    )\n                ),\n                b2_start = Math.floor(\n                    Math.max(\n                        -0.5 * w_scale,\n                        (feature[5][0] - tile_low - 0.5) * w_scale\n                    )\n                );\n            if (connector && b2_start > b1_end) {\n                ctx.fillStyle = CONNECTOR_COLOR;\n                var line_height = y_start + 1 + (draw_height - 1) / 2;\n                dashedLine(ctx, b1_end, line_height, b2_start, line_height);\n            }\n        } else {\n            // Read is single.\n            this.draw_read(\n                ctx,\n                mode,\n                w_scale,\n                y_start,\n                tile_low,\n                tile_high,\n                feature_start,\n                feature[4],\n                feature[5],\n                feature[6]\n            );\n        }\n        if (\n            mode === \"Pack\" &&\n            feature_start >= tile_low &&\n            feature_name !== \".\"\n        ) {\n            // Draw label.\n            ctx.fillStyle = this.prefs.label_color;\n            if (\n                tile_low === 0 &&\n                f_start - ctx.measureText(feature_name).width < 0\n            ) {\n                ctx.textAlign = \"left\";\n                ctx.fillText(\n                    feature_name,\n                    f_end + LABEL_SPACING,\n                    y_start + 9,\n                    this.max_label_length\n                );\n            } else {\n                ctx.textAlign = \"right\";\n                ctx.fillText(\n                    feature_name,\n                    f_start - LABEL_SPACING,\n                    y_start + 9,\n                    this.max_label_length\n                );\n            }\n        }\n\n        // FIXME: provide actual coordinates for drawn read.\n        return [0, 0];\n    }\n});\n\nvar ArcLinkedFeaturePainter = function(\n    data,\n    view_start,\n    view_end,\n    prefs,\n    mode,\n    alpha_scaler,\n    height_scaler\n) {\n    LinkedFeaturePainter.call(\n        this,\n        data,\n        view_start,\n        view_end,\n        prefs,\n        mode,\n        alpha_scaler,\n        height_scaler\n    );\n    // Need to know the longest feature length for adding spacing\n    this.longest_feature_length = this.calculate_longest_feature_length();\n    this.draw_background_connector = false;\n    this.draw_individual_connectors = true;\n};\n\n_.extend(\n    ArcLinkedFeaturePainter.prototype,\n    FeaturePainter.prototype,\n    LinkedFeaturePainter.prototype,\n    {\n        calculate_longest_feature_length: function() {\n            var longest_feature_length = 0;\n            for (var i = 0, len = this.data.length; i < len; i++) {\n                var feature = this.data[i],\n                    feature_start = feature[1],\n                    feature_end = feature[2];\n                longest_feature_length = Math.max(\n                    longest_feature_length,\n                    feature_end - feature_start\n                );\n            }\n            return longest_feature_length;\n        },\n\n        get_top_padding: function(width) {\n            var view_range = this.view_end - this.view_start,\n                w_scale = width / view_range;\n            return Math.min(\n                128,\n                Math.ceil(this.longest_feature_length / 2 * w_scale)\n            );\n        },\n\n        draw_connector: function(\n            ctx,\n            block1_start,\n            block1_end,\n            block2_start,\n            block2_end,\n            y_start\n        ) {\n            // Arc drawing -- from closest endpoints\n            var x_center = (block1_end + block2_start) / 2,\n                radius = block2_start - x_center;\n            // For full half circles\n            var angle1 = Math.PI,\n                angle2 = 0;\n            if (radius > 0) {\n                ctx.beginPath();\n                ctx.arc(x_center, y_start, block2_start - x_center, Math.PI, 0);\n                ctx.stroke();\n            }\n        }\n    }\n);\n\n// Color stuff from less.js\n\nvar Color = function(rgb, a) {\n    /**\n     * The end goal here, is to parse the arguments\n     * into an integer triplet, such as `128, 255, 0`\n     *\n     * This facilitates operations and conversions.\n     */\n    if (Array.isArray(rgb)) {\n        this.rgb = rgb;\n    } else if (rgb.length == 6) {\n        this.rgb = rgb.match(/.{2}/g).map(function(c) {\n            return parseInt(c, 16);\n        });\n    } else if (rgb.length == 7) {\n        this.rgb = rgb\n            .substring(1, 7)\n            .match(/.{2}/g)\n            .map(function(c) {\n                return parseInt(c, 16);\n            });\n    } else {\n        this.rgb = rgb.split(\"\").map(function(c) {\n            return parseInt(c + c, 16);\n        });\n    }\n    this.alpha = typeof a === \"number\" ? a : 1;\n};\nColor.prototype = {\n    eval: function() {\n        return this;\n    },\n\n    //\n    // If we have some transparency, the only way to represent it\n    // is via `rgba`. Otherwise, we use the hex representation,\n    // which has better compatibility with older browsers.\n    // Values are capped between `0` and `255`, rounded and zero-padded.\n    //\n    toCSS: function() {\n        if (this.alpha < 1.0) {\n            return (\n                \"rgba(\" +\n                this.rgb\n                    .map(function(c) {\n                        return Math.round(c);\n                    })\n                    .concat(this.alpha)\n                    .join(\", \") +\n                \")\"\n            );\n        } else {\n            return (\n                \"#\" +\n                this.rgb\n                    .map(function(i) {\n                        i = Math.round(i);\n                        i = (i > 255 ? 255 : i < 0 ? 0 : i).toString(16);\n                        return i.length === 1 ? \"0\" + i : i;\n                    })\n                    .join(\"\")\n            );\n        }\n    },\n\n    toHSL: function() {\n        var r = this.rgb[0] / 255,\n            g = this.rgb[1] / 255,\n            b = this.rgb[2] / 255,\n            a = this.alpha;\n\n        var max = Math.max(r, g, b),\n            min = Math.min(r, g, b);\n        var h,\n            s,\n            l = (max + min) / 2,\n            d = max - min;\n\n        if (max === min) {\n            h = s = 0;\n        } else {\n            s = l > 0.5 ? d / (2 - max - min) : d / (max + min);\n\n            switch (max) {\n                case r:\n                    h = (g - b) / d + (g < b ? 6 : 0);\n                    break;\n                case g:\n                    h = (b - r) / d + 2;\n                    break;\n                case b:\n                    h = (r - g) / d + 4;\n                    break;\n            }\n            h /= 6;\n        }\n        return { h: h * 360, s: s, l: l, a: a };\n    },\n\n    toARGB: function() {\n        var argb = [Math.round(this.alpha * 255)].concat(this.rgb);\n        return (\n            \"#\" +\n            argb\n                .map(function(i) {\n                    i = Math.round(i);\n                    i = (i > 255 ? 255 : i < 0 ? 0 : i).toString(16);\n                    return i.length === 1 ? \"0\" + i : i;\n                })\n                .join(\"\")\n        );\n    },\n\n    mix: function(color2, weight) {\n        var color1 = this;\n\n        var p = weight; // .value / 100.0;\n        var w = p * 2 - 1;\n        var a = color1.toHSL().a - color2.toHSL().a;\n\n        var w1 = ((w * a == -1 ? w : (w + a) / (1 + w * a)) + 1) / 2.0;\n        var w2 = 1 - w1;\n\n        var rgb = [\n            color1.rgb[0] * w1 + color2.rgb[0] * w2,\n            color1.rgb[1] * w1 + color2.rgb[1] * w2,\n            color1.rgb[2] * w1 + color2.rgb[2] * w2\n        ];\n\n        var alpha = color1.alpha * p + color2.alpha * (1 - p);\n\n        return new Color(rgb, alpha);\n    }\n};\n\n// End colors from less.js\n\nvar LinearRamp = function(start_color, end_color, start_value, end_value) {\n    /**\n     * Simple linear gradient\n     */\n    this.start_color = new Color(start_color);\n    this.end_color = new Color(end_color);\n    this.start_value = start_value;\n    this.end_value = end_value;\n    this.value_range = end_value - start_value;\n};\n\nLinearRamp.prototype.map_value = function(value) {\n    value = Math.max(value, this.start_value);\n    value = Math.min(value, this.end_value);\n    value = (value - this.start_value) / this.value_range;\n    // HACK: just red for now\n    // return \"hsl(0,100%,\" + (value * 100) + \"%)\"\n    return this.start_color.mix(this.end_color, 1 - value).toCSS();\n};\n\nvar SplitRamp = function(\n    start_color,\n    middle_color,\n    end_color,\n    start_value,\n    end_value\n) {\n    /**\n     * Two gradients split away from 0\n     */\n    this.positive_ramp = new LinearRamp(middle_color, end_color, 0, end_value);\n    this.negative_ramp = new LinearRamp(\n        middle_color,\n        start_color,\n        0,\n        -start_value\n    );\n    this.start_value = start_value;\n    this.end_value = end_value;\n};\n\nSplitRamp.prototype.map_value = function(value) {\n    value = Math.max(value, this.start_value);\n    value = Math.min(value, this.end_value);\n    if (value >= 0) {\n        return this.positive_ramp.map_value(value);\n    } else {\n        return this.negative_ramp.map_value(-value);\n    }\n};\n\nvar DiagonalHeatmapPainter = function(data, view_start, view_end, prefs, mode) {\n    Painter.call(this, data, view_start, view_end, prefs, mode);\n    var i, len;\n\n    if (this.prefs.min_value === undefined) {\n        var min_value = Infinity;\n        for (i = 0, len = this.data.length; i < len; i++) {\n            min_value = Math.min(min_value, this.data[i][6]);\n        }\n        this.prefs.min_value = min_value;\n    }\n    if (this.prefs.max_value === undefined) {\n        var max_value = -Infinity;\n        for (i = 0, len = this.data.length; i < len; i++) {\n            max_value = Math.max(max_value, this.data[i][6]);\n        }\n        this.prefs.max_value = max_value;\n    }\n};\n\nDiagonalHeatmapPainter.prototype.default_prefs = {\n    min_value: undefined,\n    max_value: undefined,\n    mode: \"Heatmap\",\n    pos_color: \"#FF8C00\",\n    neg_color: \"#4169E1\"\n};\n\nDiagonalHeatmapPainter.prototype.draw = function(ctx, width, height, w_scale) {\n    var min_value = this.prefs.min_value,\n        max_value = this.prefs.max_value,\n        value_range = max_value - min_value,\n        height_px = height,\n        view_start = this.view_start,\n        mode = this.mode,\n        data = this.data,\n        invsqrt2 = 1 / Math.sqrt(2);\n\n    var ramp = new SplitRamp(\n        this.prefs.neg_color,\n        \"#FFFFFF\",\n        this.prefs.pos_color,\n        min_value,\n        max_value\n    );\n\n    var d, s1, e1, s2, e2, value;\n\n    var scale = function(p) {\n        return (p - view_start) * w_scale;\n    };\n\n    ctx.save();\n\n    // Draw into triangle, then rotate and scale\n    ctx.rotate(-45 * Math.PI / 180);\n    ctx.scale(invsqrt2, invsqrt2);\n\n    // Paint track.\n    for (var i = 0, len = data.length; i < len; i++) {\n        d = data[i];\n\n        s1 = scale(d[1]);\n        e1 = scale(d[2]);\n        s2 = scale(d[4]);\n        e2 = scale(d[5]);\n        value = d[6];\n\n        ctx.fillStyle = ramp.map_value(value);\n        ctx.fillRect(s1, s2, e1 - s1, e2 - s2);\n    }\n\n    ctx.restore();\n};\n\n/**\n * Utilities for painting reads.\n */\nvar ReadPainterUtils = function(ctx, row_height, px_per_base, mode) {\n    this.ctx = ctx;\n    this.row_height = row_height;\n    this.px_per_base = px_per_base;\n    this.draw_details =\n        (mode === \"Pack\" || mode === \"Auto\") &&\n        px_per_base >= ctx.canvas.manager.char_width_px;\n    this.delete_details_thickness = 0.2;\n};\n\n_.extend(ReadPainterUtils.prototype, {\n    /**\n     * Draw deletion of base(s).\n     * @param draw_detail if true, drawing in detail and deletion is drawn more subtly\n     */\n    draw_deletion: function(x, y, len) {\n        this.ctx.fillStyle = \"black\";\n        var thickness =\n            (this.draw_details ? this.delete_details_thickness : 1) *\n            this.row_height;\n        y += 0.5 * (this.row_height - thickness);\n        this.ctx.fillRect(x, y, len * this.px_per_base, thickness);\n    }\n});\n\n/**\n * Paints variant data onto canvas.\n */\nvar VariantPainter = function(\n    data,\n    view_start,\n    view_end,\n    prefs,\n    mode,\n    base_color_fn\n) {\n    Painter.call(this, data, view_start, view_end, prefs, mode);\n    this.base_color_fn = base_color_fn;\n    this.divider_height = 1;\n};\n\n_.extend(VariantPainter.prototype, Painter.prototype, {\n    /**\n     * Height of a single row, depends on mode\n     */\n    get_row_height: function() {\n        var mode = this.mode,\n            height;\n        if (mode === \"Dense\") {\n            height = DENSE_TRACK_HEIGHT;\n        } else if (mode === \"Squish\") {\n            height = SQUISH_TRACK_HEIGHT;\n        } else {\n            // mode === \"Pack\"\n            height = PACK_TRACK_HEIGHT;\n        }\n        return height;\n    },\n\n    /**\n     * Returns required height to draw a particular number of samples in a given mode.\n     */\n    get_required_height: function(num_samples) {\n        // FIXME: for single-sample data, height should be summary_height when zoomed out and\n        // row_height when zoomed in.\n        var height = this.prefs.summary_height;\n\n        // If showing sample data, height is summary + divider + samples.\n        if (num_samples > 1 && this.prefs.show_sample_data) {\n            height += this.divider_height + num_samples * this.get_row_height();\n        }\n        return height;\n    },\n\n    /**\n     * Draw on the context using a rectangle of width x height with scale w_scale.\n     */\n    draw: function(ctx, width, height, w_scale) {\n        ctx.save();\n\n        var /**\n         * Returns dictionary of information about an indel; returns empty if there no indel. Assumes indel is left-aligned.\n         * Dict attributes:\n         *    -type: 'insertion' or 'deletion'\n         *    -start: where the deletion starts relative to reference start\n         *    -len: how long the deletion is\n         */\n        get_indel_info = function(ref, alt) {\n            var ref_len = ref.length,\n                alt_len = alt.length,\n                start = 0,\n                len = 1,\n                type = null;\n            if (alt === \"-\") {\n                type = \"deletion\";\n                len = ref.length;\n            } else if (ref.indexOf(alt) === 0 && ref_len > alt_len) {\n                type = \"deletion\";\n                len = ref_len - alt_len;\n                start = alt_len;\n            } else if (alt.indexOf(ref) === 0 && ref_len < alt_len) {\n                // Insertion.\n                type = \"insertion\";\n                len = alt_len - ref_len;\n                start = alt_len;\n            }\n\n            return type !== null ? { type: type, start: start, len: len } : {};\n        };\n\n        // Draw.\n        var locus_data,\n            pos,\n            id,\n            ref,\n            alt,\n            qual,\n            filter,\n            sample_gts,\n            allele_counts,\n            variant,\n            draw_x_start,\n            draw_y_start,\n            genotype,\n            // Always draw variants at least 1 pixel wide.\n            base_px = Math.max(1, Math.floor(w_scale)),\n            // Determine number of samples.\n            num_samples = this.data.length\n                ? this.data[0][7].split(\",\").length\n                : 0,\n            row_height =\n                this.mode === \"Squish\"\n                    ? SQUISH_TRACK_HEIGHT\n                    : PACK_TRACK_HEIGHT,\n            // If zoomed out, fill the whole row with feature to make it easier to read;\n            // when zoomed in, use feature height so that there are gaps in sample rows.\n            feature_height =\n                w_scale < 0.1\n                    ? row_height\n                    : this.mode === \"Squish\"\n                      ? SQUISH_FEATURE_HEIGHT\n                      : PACK_FEATURE_HEIGHT,\n            draw_summary = true,\n            paint_utils = new ReadPainterUtils(\n                ctx,\n                row_height,\n                w_scale,\n                this.mode\n            ),\n            j;\n\n        // If there's a single sample, update drawing variables.\n        if (num_samples === 1) {\n            row_height = feature_height =\n                w_scale < ctx.canvas.manager.char_width_px\n                    ? this.prefs.summary_height\n                    : row_height;\n            paint_utils.row_height = row_height;\n            // No summary when there's a single sample.\n            draw_summary = false;\n        }\n\n        // Draw divider between summary and samples.\n        if (this.prefs.show_sample_data && draw_summary) {\n            ctx.fillStyle = \"#F3F3F3\";\n            ctx.globalAlpha = 1;\n            ctx.fillRect(\n                0,\n                this.prefs.summary_height - this.divider_height,\n                width,\n                this.divider_height\n            );\n        }\n\n        // Draw variants.\n        ctx.textAlign = \"center\";\n        for (var i = 0; i < this.data.length; i++) {\n            // Get locus data.\n            locus_data = this.data[i];\n            pos = locus_data[1];\n            ref = locus_data[3];\n            alt = [locus_data[4].split(\",\")];\n            sample_gts = locus_data[7].split(\",\");\n            allele_counts = locus_data.slice(8);\n\n            // Process alterate values to derive information about each alt.\n            alt = _.map(_.flatten(alt), function(a) {\n                var alt_info = {\n                        type: \"snp\",\n                        value: a,\n                        start: 0\n                    },\n                    indel_info = get_indel_info(ref, a);\n\n                return _.extend(alt_info, indel_info);\n            });\n\n            // Only draw locus data if it's in viewing region.\n            if (pos < this.view_start || pos > this.view_end) {\n                continue;\n            }\n\n            // Draw summary for alleles.\n            if (draw_summary) {\n                ctx.fillStyle = \"#999999\";\n                ctx.globalAlpha = 1;\n                for (j = 0; j < alt.length; j++) {\n                    // Draw background for summary.\n                    draw_x_start = this.get_start_draw_pos(\n                        pos + alt[j].start,\n                        w_scale\n                    );\n                    ctx.fillRect(\n                        draw_x_start,\n                        0,\n                        base_px,\n                        this.prefs.summary_height\n                    );\n                    draw_y_start = this.prefs.summary_height;\n                    // Draw allele fractions onto summary.\n                    for (j = 0; j < alt.length; j++) {\n                        ctx.fillStyle =\n                            alt[j].type === \"deletion\"\n                                ? \"black\"\n                                : this.base_color_fn(alt[j].value);\n                        var allele_frac = allele_counts / sample_gts.length;\n                        var draw_height = Math.ceil(\n                            this.prefs.summary_height * allele_frac\n                        );\n                        ctx.fillRect(\n                            draw_x_start,\n                            draw_y_start - draw_height,\n                            base_px,\n                            draw_height\n                        );\n                        draw_y_start -= draw_height;\n                    }\n                }\n            }\n\n            // Done drawing if not showing samples data.\n            if (!this.prefs.show_sample_data) {\n                continue;\n            }\n\n            // Draw sample genotype(s).\n            draw_y_start = draw_summary\n                ? this.prefs.summary_height + this.divider_height\n                : 0;\n            for (\n                j = 0;\n                j < sample_gts.length;\n                j++, draw_y_start += row_height\n            ) {\n                genotype = sample_gts[j]\n                    ? sample_gts[j].split(/\\/|\\|/)\n                    : [\"0\", \"0\"];\n\n                // Get variant to draw and set drawing properties.\n                variant = null;\n                if (genotype[0] === genotype[1]) {\n                    if (genotype[0] === \".\") {\n                        // TODO: draw uncalled variant.\n                    } else if (genotype[0] !== \"0\") {\n                        // Homozygous for variant.\n                        variant = alt[parseInt(genotype[0], 10) - 1];\n                        ctx.globalAlpha = 1;\n                    }\n                    // else reference\n                } else {\n                    // Heterozygous for variant.\n                    variant = genotype[0] !== \"0\" ? genotype[0] : genotype[1];\n                    variant = alt[parseInt(variant, 10) - 1];\n                    ctx.globalAlpha = 0.5;\n                }\n\n                // If there's a variant, draw it.\n                if (variant) {\n                    draw_x_start = this.get_start_draw_pos(\n                        pos + variant.start,\n                        w_scale\n                    );\n                    if (variant.type === \"snp\") {\n                        var snp = variant.value;\n                        ctx.fillStyle = this.base_color_fn(snp);\n                        if (paint_utils.draw_details) {\n                            ctx.fillText(\n                                snp,\n                                this.get_draw_pos(pos, w_scale),\n                                draw_y_start + row_height\n                            );\n                        } else {\n                            ctx.fillRect(\n                                draw_x_start,\n                                draw_y_start + 1,\n                                base_px,\n                                feature_height\n                            );\n                        }\n                    } else if (variant.type === \"deletion\") {\n                        paint_utils.draw_deletion(\n                            draw_x_start,\n                            draw_y_start + 1,\n                            variant.len\n                        );\n                    } else {\n                        // TODO: handle insertions.\n                    }\n                }\n            }\n        }\n\n        ctx.restore();\n    }\n});\n\nexport default {\n    Scaler: Scaler,\n    LinePainter: LinePainter,\n    LinkedFeaturePainter: LinkedFeaturePainter,\n    ReadPainter: ReadPainter,\n    ArcLinkedFeaturePainter: ArcLinkedFeaturePainter,\n    DiagonalHeatmapPainter: DiagonalHeatmapPainter,\n    VariantPainter: VariantPainter\n};\n"]}