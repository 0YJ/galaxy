{"version":3,"sources":["viz/trackster/painters.js"],"names":["define","_","compute_overlap","first_region","second_region","first_start","first_end","second_start","second_end","is_overlap","overlap","dashedLine","ctx","x1","y1","x2","y2","dashLen","undefined","q","dX","dY","dashes","Math","floor","sqrt","dashX","dashY","fillRect","drawDownwardEquilateralTriangle","down_vertex_x","down_vertex_y","side_len","y","beginPath","moveTo","lineTo","strokeStyle","this","fillStyle","fill","stroke","closePath","Scaler","default_val","prototype","gen_val","input","DrawResults","options","incomplete_features","feature_mapper","Painter","data","view_start","view_end","prefs","mode","extend","default_prefs","draw","width","height","w_scale","get_start_draw_pos","chrom_pos","_chrom_pos_to_draw_pos","get_end_draw_pos","get_draw_pos","offset","max","LinePainter","call","min_value","max_value","color","overflow_color","in_path","vertical_range","height_px","save","y_zero","round","x_scaled","delta_x_pxs","length","map","slice","d","i","ceil","delta_x_px","painter_color","block_color","pref_color","parseInt","pref_r","pref_g","pref_b","top_overflow","bot_overflow","len","saturation","new_r","new_g","new_b","overflow_x","restore","FeaturePositionMapper","slot_height","feature_positions","translation","y_translation","map_feature_data","feature_data","slot","x_start","x_end","push","get_feature_data","x","feature_dict","FeaturePainter","alpha_scaler","height_scaler","max_label_length","connector_color","get_required_height","rows_required","required_height","get_row_height","y_scale","get_top_padding","slots","textAlign","x_draw_coords","feature","feature_uid","feature_start","feature_end","draw_element","tile_low","tile_high","LinkedFeaturePainter","draw_background_connector","draw_individual_connectors","y_start","feature_name","feature_strand","f_start","f_end","min","draw_start","draw_end","thick_start","thick_end","reverse_strand_color","label_color","globalAlpha","feature_ts","feature_te","feature_blocks","full_height","thin_height","thick_height","cur_y_start","cur_height","SQUISH_FEATURE_HEIGHT","canvas","manager","get_pattern","k","k_len","last_block_start","last_block_end","block","block_start","block_end","block_thick_start","block_thick_end","draw_connector","hscale_factor","new_height","ws_height","measureText","fillText","ReadPainter","ref_seq","base_color_fn","show_insertions","_parse_cigar","cigar_str","cigar_ops","blocks","cur_block","base_pos","parsed_cigar","match","op","op_len","op_char","indexOf","cigar","draw_read","strand","read_seq","get_draw_coord","sequence_coord","s_start","s_end","tile_region","base_offset","seq_offset","gap","char_width_px","detail_block_color","pack_mode","draw_height","rect_y","paint_utils","ReadPainterUtils","drawing_blocks","draw_last","t","cig_id","cig","cig_op","cig_len","seq_start","cur_seq","start_pos","c","show_differences","c_start","draw_deletion","insert_x_coord","seq","x_center","type","str_len","item","font","Array","connector","b1_end","b2_start","line_height","ArcLinkedFeaturePainter","longest_feature_length","calculate_longest_feature_length","view_range","block1_start","block1_end","block2_start","block2_end","radius","PI","arc","Color","rgb","a","isArray","substring","split","alpha","eval","toCSS","concat","join","toString","toHSL","h","s","r","g","b","l","toARGB","mix","color2","weight","color1","p","w","w1","w2","LinearRamp","start_color","end_color","start_value","end_value","value_range","map_value","value","SplitRamp","middle_color","positive_ramp","negative_ramp","DiagonalHeatmapPainter","Infinity","pos_color","neg_color","s1","e1","s2","e2","invsqrt2","ramp","scale","rotate","row_height","px_per_base","draw_details","delete_details_thickness","thickness","VariantPainter","divider_height","num_samples","summary_height","show_sample_data","locus_data","pos","ref","alt","sample_gts","allele_counts","variant","draw_x_start","draw_y_start","genotype","j","get_indel_info","ref_len","alt_len","start","base_px","feature_height","draw_summary","flatten","alt_info","indel_info","allele_frac","snp"],"mappings":"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","file":"../../../scripts/viz/trackster/painters.js","sourcesContent":["define( [\"libs/underscore\"], function( _ ) {\n\n/**\n * Compute the type of overlap between two regions. They are assumed to be on the same chrom/contig.\n * The overlap is computed relative to the second region; hence, OVERLAP_START indicates that the first\n * region overlaps the start (but not the end) of the second region.\n * NOTE: Coordinates are assumed to be in BED format: half open (start is closed, end is open).\n */\nvar BEFORE = 1001, CONTAINS = 1002, OVERLAP_START = 1003, OVERLAP_END = 1004, CONTAINED_BY = 1005, AFTER = 1006;\nvar compute_overlap = function(first_region, second_region) {\n    var\n        first_start = first_region[0], first_end = first_region[1],\n        second_start = second_region[0], second_end = second_region[1],\n        overlap;\n    if (first_start < second_start) {\n        if (first_end <= second_start) {\n            overlap = BEFORE;\n        }\n        else if (first_end <= second_end) {\n            overlap = OVERLAP_START;\n        }\n        else { // first_end > second_end\n            overlap = CONTAINS;\n        }\n    }\n    else { // first_start >= second_start\n        if (first_start > second_end) {\n            overlap = AFTER;\n        }\n        else if (first_end <= second_end) {\n            overlap = CONTAINED_BY;\n        }\n        else {\n            overlap = OVERLAP_END;\n        }\n    }\n\n    return overlap;\n};\n\n/**\n * Returns true if regions overlap.\n */\nvar is_overlap = function(first_region, second_region) {\n    var overlap = compute_overlap(first_region, second_region);\n    return (overlap !== BEFORE && overlap !== AFTER);\n};\n\n/**\n * Draw a dashed line on a canvas using filled rectangles. This function is based on:\n * http://vetruvet.blogspot.com/2010/10/drawing-dashed-lines-on-html5-canvas.html\n * However, that approach uses lines, which don't seem to render as well, so use\n * rectangles instead.\n */\nvar dashedLine = function(ctx, x1, y1, x2, y2, dashLen) {\n    if (dashLen === undefined) { dashLen = 4; }\n    var dX = x2 - x1;\n    var dY = y2 - y1;\n    var dashes = Math.floor(Math.sqrt(dX * dX + dY * dY) / dashLen);\n    var dashX = dX / dashes;\n    var dashY = dY / dashes;\n    var q;\n\n    for (q = 0; q < dashes; q++, x1 += dashX, y1 += dashY) {\n        if (q % 2 !== 0) {\n            continue;\n        }\n        ctx.fillRect(x1, y1, dashLen, 1);\n    }\n};\n\n/**\n * Draw an isosceles triangle that points down.\n */\nvar drawDownwardEquilateralTriangle = function(ctx, down_vertex_x, down_vertex_y, side_len) {\n    // Compute other two points of triangle.\n    var\n        x1 = down_vertex_x - side_len/2,\n        x2 = down_vertex_x + side_len/2,\n        y = down_vertex_y - Math.sqrt( side_len*3/2 );\n\n    // Draw and fill.\n    ctx.beginPath();\n    ctx.moveTo(x1, y);\n    ctx.lineTo(x2, y);\n    ctx.lineTo(down_vertex_x, down_vertex_y);\n    ctx.lineTo(x1, y);\n\n    ctx.strokeStyle = this.fillStyle;\n    ctx.fill();\n    ctx.stroke();\n    ctx.closePath();\n};\n\n/**\n * Base class for all scalers. Scalers produce values that are used to change (scale) drawing attributes.\n */\nvar Scaler = function(default_val) {\n    this.default_val = (default_val ? default_val : 1);\n};\n\n/**\n * Produce a scaling value.\n */\nScaler.prototype.gen_val = function(input) {\n    return this.default_val;\n};\n\n/**\n * Results from painter.draw()\n */\nvar DrawResults = function(options) {\n    this.incomplete_features = options.incomplete_features;\n    this.feature_mapper = options.feature_mapper;\n};\n\n/**\n * Base class for painters\n *\n * -- Mode and prefs are both optional\n */\nvar Painter = function(data, view_start, view_end, prefs, mode) {\n    // Data and data properties\n    this.data = data;\n    // View\n    this.view_start = view_start;\n    this.view_end = view_end;\n    // Drawing prefs\n    this.prefs = _.extend({}, this.default_prefs, prefs);\n    this.mode = mode;\n};\n\nPainter.prototype.default_prefs = {};\n\n/**\n * Draw on the context using a rectangle of width x height using scale w_scale.\n */\nPainter.prototype.draw = function(ctx, width, height, w_scale) {};\n\n/**\n * Get starting drawing position, which is offset a half-base left of coordinate.\n */\nPainter.prototype.get_start_draw_pos = function(chrom_pos, w_scale) {\n    return this._chrom_pos_to_draw_pos(chrom_pos, w_scale, -0.5);\n};\n\n/**\n * Get end drawing position, which is offset a half-base right of coordinate.\n */\nPainter.prototype.get_end_draw_pos = function(chrom_pos, w_scale) {\n    return this._chrom_pos_to_draw_pos(chrom_pos, w_scale, 0.5);\n};\n\n/**\n * Get drawing position.\n */\nPainter.prototype.get_draw_pos = function(chrom_pos, w_scale) {\n    return this._chrom_pos_to_draw_pos(chrom_pos, w_scale, 0);\n};\n\n/**\n * Convert chromosome position to drawing position.\n */\nPainter.prototype._chrom_pos_to_draw_pos = function(chrom_pos, w_scale, offset) {\n    return Math.floor( w_scale * ( Math.max(0, chrom_pos - this.view_start) + offset) );\n};\n\n\nvar LinePainter = function(data, view_start, view_end, prefs, mode) {\n    Painter.call( this, data, view_start, view_end, prefs, mode );\n};\n\nLinePainter.prototype.default_prefs = { min_value: undefined, max_value: undefined, mode: \"Histogram\", color: \"#000\", overflow_color: \"#F66\" };\n\nLinePainter.prototype.draw = function(ctx, width, height, w_scale) {\n    var in_path = false,\n        min_value = this.prefs.min_value,\n        max_value = this.prefs.max_value,\n        vertical_range = max_value - min_value,\n        height_px = height,\n        view_start = this.view_start,\n        mode = this.mode,\n        data = this.data;\n\n    ctx.save();\n\n    // Pixel position of 0 on the y axis\n    var y_zero = Math.round( height + min_value / vertical_range * height );\n\n    // Horizontal line to denote x-axis\n    if ( mode !== \"Intensity\" ) {\n        ctx.fillStyle = \"#aaa\";\n        ctx.fillRect( 0, y_zero, width, 1 );\n    }\n\n    ctx.beginPath();\n    var x_scaled, y, delta_x_pxs;\n    if (data.length > 1) {\n        delta_x_pxs = _.map(data.slice(0,-1), function(d, i) {\n            return Math.ceil((data[i+1][0] - data[i][0]) * w_scale);\n        });\n    }\n    else {\n        delta_x_pxs = [10];\n    }\n\n    // Painter color can be in either block_color (FeatureTrack) or color pref (LineTrack).\n    var painter_color = this.prefs.block_color || this.prefs.color,\n        // Extract RGB from preference color.\n        pref_color = parseInt( painter_color.slice(1), 16 ),\n        pref_r = (pref_color & 0xff0000) >> 16,\n        pref_g = (pref_color & 0x00ff00) >> 8,\n        pref_b = pref_color & 0x0000ff,\n        top_overflow = false,\n        bot_overflow = false;\n\n\n    // Paint track.\n    var delta_x_px;\n    for (var i = 0, len = data.length; i < len; i++) {\n        // Reset attributes for next point.\n        ctx.fillStyle = ctx.strokeStyle = painter_color;\n        top_overflow = bot_overflow = false;\n        delta_x_px = delta_x_pxs[i];\n\n        x_scaled = Math.floor((data[i][0] - view_start - 0.5) * w_scale);\n        y = data[i][1];\n\n        // Process Y (scaler) value.\n        if (y === null) {\n            if (in_path && mode === \"Filled\") {\n                ctx.lineTo(x_scaled, height_px);\n            }\n            in_path = false;\n            continue;\n        }\n\n        // Bound Y value by min, max.\n        if (y < min_value) {\n            bot_overflow = true;\n            y = min_value;\n        }\n        else if (y > max_value) {\n            top_overflow = true;\n            y = max_value;\n        }\n\n        // Draw point.\n        if (mode === \"Histogram\") {\n            // y becomes the bar height in pixels, which is the negated for canvas coords\n            y = Math.round( y / vertical_range * height_px );\n            ctx.fillRect(x_scaled, y_zero, delta_x_px, - y );\n        }\n        else if (mode === \"Intensity\") {\n            var\n                saturation = (y - min_value) / vertical_range,\n                // Range is [pref_color, 255] where saturation = 0 --> 255 and saturation = 1 --> pref color\n                new_r = Math.round( pref_r + (255 - pref_r) * (1 - saturation) ),\n                new_g = Math.round( pref_g + (255 - pref_g) * (1 - saturation) ),\n                new_b = Math.round( pref_b + (255 - pref_b) * (1 - saturation) );\n            ctx.fillStyle = \"rgb(\" + new_r + \",\" + new_g + \",\" + new_b + \")\";\n            ctx.fillRect(x_scaled, 0, delta_x_px, height_px);\n        }\n        else { // mode is Coverage/Line or Filled.\n\n            // Scale Y value.\n            y = Math.round( height_px - (y - min_value) / vertical_range * height_px );\n            if (in_path) {\n                ctx.lineTo(x_scaled, y);\n            }\n            else {\n                in_path = true;\n                if (mode === \"Filled\") {\n                    ctx.moveTo(x_scaled, height_px);\n                    ctx.lineTo(x_scaled, y);\n                }\n                else {\n                    ctx.moveTo(x_scaled, y);\n                    // Use this approach (note: same as for filled) to draw line from 0 to\n                    // first data point.\n                    //ctx.moveTo(x_scaled, height_px);\n                    //ctx.lineTo(x_scaled, y);\n                }\n            }\n        }\n\n        // Draw lines at boundaries if overflowing min or max\n        ctx.fillStyle = this.prefs.overflow_color;\n        if (top_overflow || bot_overflow) {\n            var overflow_x;\n            if (mode === \"Histogram\" || mode === \"Intensity\") {\n                overflow_x = delta_x_px;\n            }\n            else { // Line and Filled, which are points\n                x_scaled -= 2; // Move it over to the left so it's centered on the point\n                overflow_x = 4;\n            }\n            if (top_overflow) {\n                ctx.fillRect(x_scaled, 0, overflow_x, 3);\n            }\n            if (bot_overflow) {\n                ctx.fillRect(x_scaled, height_px - 3, overflow_x, 3);\n            }\n        }\n        ctx.fillStyle = painter_color;\n    }\n    if (mode === \"Filled\") {\n        if (in_path) {\n            ctx.lineTo( x_scaled, y_zero );\n            ctx.lineTo( 0, y_zero );\n        }\n        ctx.fill();\n    }\n    else {\n        ctx.stroke();\n    }\n\n    ctx.restore();\n};\n\n/**\n * Mapper that contains information about feature locations and data.\n */\nvar FeaturePositionMapper = function(slot_height) {\n    this.feature_positions = {};\n    this.slot_height = slot_height;\n    this.translation = 0;\n    this.y_translation = 0;\n};\n\n/**\n * Map feature data to a position defined by <slot, x_start, x_end>.\n */\nFeaturePositionMapper.prototype.map_feature_data = function(feature_data, slot, x_start, x_end) {\n    if (!this.feature_positions[slot]) {\n        this.feature_positions[slot] = [];\n    }\n    this.feature_positions[slot].push({\n        data: feature_data,\n        x_start: x_start,\n        x_end: x_end\n    });\n};\n\n/**\n * Get feature data for position <x, y>\n */\nFeaturePositionMapper.prototype.get_feature_data = function(x, y) {\n    // Find slot using Y.\n    var slot = Math.floor( (y-this.y_translation)/this.slot_height ),\n        feature_dict;\n\n    // May not be over a slot due to padding, margin, etc.\n    if (!this.feature_positions[slot]) {\n        return null;\n    }\n\n    // Find feature using X.\n    x += this.translation;\n    for (var i = 0; i < this.feature_positions[slot].length; i++) {\n        feature_dict = this.feature_positions[slot][i];\n        if (x >= feature_dict.x_start && x <= feature_dict.x_end) {\n            return feature_dict.data;\n        }\n    }\n};\n\n/**\n * Abstract object for painting feature tracks. Subclasses must implement draw_element() for painting to work.\n * Painter uses a 0-based, half-open coordinate system; start coordinate is closed--included--and the end is open.\n * This coordinate system matches the BED format.\n */\nvar FeaturePainter = function(data, view_start, view_end, prefs, mode, alpha_scaler, height_scaler) {\n    Painter.call(this, data, view_start, view_end, prefs, mode);\n    this.alpha_scaler = (alpha_scaler ? alpha_scaler : new Scaler());\n    this.height_scaler = (height_scaler ? height_scaler : new Scaler());\n    this.max_label_length = 200;\n};\n\nFeaturePainter.prototype.default_prefs = { block_color: \"#FFF\", connector_color: \"#FFF\" };\n\n_.extend(FeaturePainter.prototype, {\n    get_required_height: function(rows_required, width) {\n        // y_scale is the height per row\n        var required_height = this.get_row_height(),\n            y_scale = required_height,\n            mode = this.mode;\n        // If using a packing mode, need to multiply by the number of slots used\n        if (mode === \"no_detail\" || mode === \"Squish\" || mode === \"Pack\") {\n            required_height = rows_required * y_scale;\n        }\n        return required_height + this.get_top_padding(width);\n    },\n\n    /** Extra padding before first row of features */\n    get_top_padding: function(width) {\n        return 0;\n    },\n\n    /**\n     * Draw data on ctx using slots and within the rectangle defined by width and height. Returns\n     * a FeaturePositionMapper object with information about where features were drawn.\n     */\n    draw: function(ctx, width, height, w_scale, slots) {\n        var data = this.data,\n            view_start = this.view_start,\n            view_end = this.view_end;\n\n        ctx.save();\n\n        ctx.fillStyle = this.prefs.block_color;\n        ctx.textAlign = \"right\";\n\n        var y_scale = this.get_row_height(),\n            feature_mapper = new FeaturePositionMapper(y_scale),\n            x_draw_coords,\n            incomplete_features = [];\n\n        for (var i = 0, len = data.length; i < len; i++) {\n            var feature = data[i],\n                feature_uid = feature[0],\n                feature_start = feature[1],\n                feature_end = feature[2],\n                // Slot valid only if features are slotted and this feature is slotted;\n                // feature may not be due to lack of space.\n                slot = (slots && slots[feature_uid] !== undefined ? slots[feature_uid].slot : null);\n\n            // Draw feature if (a) mode is dense or feature is slotted (as it must be for all non-dense modes) and\n            // (b) there's overlap between the feature and drawing region.\n            if ( (this.mode === \"Dense\" || slot !== null) && ( feature_start < view_end && feature_end > view_start ) ) {\n                x_draw_coords = this.draw_element(ctx, this.mode, feature, slot, view_start, view_end, w_scale, y_scale, width);\n                feature_mapper.map_feature_data(feature, slot, x_draw_coords[0], x_draw_coords[1]);\n\n                // Add to incomplete features if it's not drawn completely in region.\n                if (feature_start < view_start || feature_end > view_end) {\n                    incomplete_features.push(feature);\n                }\n            }\n        }\n\n        ctx.restore();\n\n        feature_mapper.y_translation = this.get_top_padding(width);\n        return new DrawResults({\n            incomplete_features: incomplete_features,\n            feature_mapper: feature_mapper\n        });\n    },\n\n    /**\n     * Abstract function for drawing an individual feature.\n     */\n    draw_element: function(ctx, mode, feature, slot, tile_low, tile_high, w_scale, y_scale, width ) {\n        return [0, 0];\n    }\n});\n\n// Constants specific to feature tracks moved here (HACKING, these should\n// basically all be configuration options)\nvar DENSE_TRACK_HEIGHT = 10,\n    NO_DETAIL_TRACK_HEIGHT = 3,\n    SQUISH_TRACK_HEIGHT = 5,\n    PACK_TRACK_HEIGHT = 10,\n    NO_DETAIL_FEATURE_HEIGHT = 1,\n    DENSE_FEATURE_HEIGHT = 9,\n    SQUISH_FEATURE_HEIGHT = 3,\n    PACK_FEATURE_HEIGHT = 9,\n    LABEL_SPACING = 2,\n    CONNECTOR_COLOR = \"#ccc\";\n\nvar LinkedFeaturePainter = function(data, view_start, view_end, prefs, mode, alpha_scaler, height_scaler) {\n    FeaturePainter.call(this, data, view_start, view_end, prefs, mode, alpha_scaler, height_scaler);\n    // Whether to draw a single connector in the background that spans the entire feature (the intron fishbone)\n    this.draw_background_connector = true;\n    // Whether to call draw_connector for every pair of blocks\n    this.draw_individual_connectors = false;\n};\n\n_.extend(LinkedFeaturePainter.prototype, FeaturePainter.prototype, {\n\n    /**\n     * Height of a single row, depends on mode\n     */\n    get_row_height: function() {\n        var mode = this.mode, height;\n        if (mode === \"Dense\") {\n            height = DENSE_TRACK_HEIGHT;\n        }\n        else if (mode === \"no_detail\") {\n            height = NO_DETAIL_TRACK_HEIGHT;\n        }\n        else if (mode === \"Squish\") {\n            height = SQUISH_TRACK_HEIGHT;\n        }\n        else { // mode === \"Pack\"\n            height = PACK_TRACK_HEIGHT;\n        }\n        return height;\n    },\n\n    /**\n     * Draw a feature. Returns an array with feature's start and end X coordinates.\n     */\n    draw_element: function(ctx, mode, feature, slot, tile_low, tile_high, w_scale, y_scale, width) {\n        var feature_uid = feature[0],\n            feature_start = feature[1],\n            feature_end = feature[2],\n            feature_name = feature[3],\n            feature_strand = feature[4],\n            // -0.5 to offset region between bases.\n            f_start = Math.floor( Math.max(0, (feature_start - tile_low - 0.5) * w_scale) ),\n            f_end   = Math.ceil( Math.min(width, Math.max(0, (feature_end - tile_low - 0.5) * w_scale)) ),\n            draw_start = f_start,\n            draw_end = f_end,\n            y_start = (mode === \"Dense\" ? 0 : (0 + slot)) * y_scale + this.get_top_padding(width),\n            thickness, y_start, thick_start = null, thick_end = null,\n            // TODO: is there any reason why block, label color cannot be set at the Painter level?\n            // For now, assume '.' === '+'\n            block_color = (!feature_strand || feature_strand === \"+\" || feature_strand === \".\" ? this.prefs.block_color : this.prefs.reverse_strand_color);\n            label_color = this.prefs.label_color;\n\n        // Set global alpha.\n        ctx.globalAlpha = this.alpha_scaler.gen_val(feature);\n\n        // In dense mode, put all data in top slot.\n        if (mode === \"Dense\") {\n            slot = 1;\n        }\n\n        if (mode === \"no_detail\") {\n            // No details for feature, so only one way to display.\n            ctx.fillStyle = block_color;\n            ctx.fillRect(f_start, y_start + 5, f_end - f_start, NO_DETAIL_FEATURE_HEIGHT);\n        }\n        else { // Mode is either Squish or Pack:\n            // Feature details.\n            var feature_ts = feature[5],\n                feature_te = feature[6],\n                feature_blocks = feature[7],\n                // Whether we are drawing full height or squished features\n                full_height = true;\n\n            if (feature_ts && feature_te) {\n                thick_start = Math.floor( Math.max(0, (feature_ts - tile_low) * w_scale) );\n                thick_end = Math.ceil( Math.min(width, Math.max(0, (feature_te - tile_low) * w_scale)) );\n            }\n\n            // Set vars that depend on mode.\n            var thin_height, thick_height;\n            if (mode === \"Squish\" ) {\n                thin_height = 1;\n                thick_height = SQUISH_FEATURE_HEIGHT;\n                full_height = false;\n            } else if ( mode === \"Dense\" ) {\n                thin_height = 5;\n                thick_height = DENSE_FEATURE_HEIGHT;\n            } else { // mode === \"Pack\"\n                thin_height = 5;\n                thick_height = PACK_FEATURE_HEIGHT;\n            }\n\n            // Draw feature/feature blocks + connectors.\n            if (!feature_blocks) {\n                // If there are no blocks, treat the feature as one big exon.\n                ctx.fillStyle = block_color;\n                ctx.fillRect(f_start, y_start + 1, f_end - f_start, thick_height);\n                // If strand is specified, draw arrows over feature\n                if ( feature_strand && full_height ) {\n                    if (feature_strand === \"+\") {\n                        ctx.fillStyle = ctx.canvas.manager.get_pattern( 'right_strand_inv' );\n                    } else if (feature_strand === \"-\") {\n                        ctx.fillStyle = ctx.canvas.manager.get_pattern( 'left_strand_inv' );\n                    }\n                    ctx.fillRect(f_start, y_start + 1, f_end - f_start, thick_height);\n                }\n            } else {\n                //\n                // There are feature blocks and mode is either Squish or Pack.\n                //\n                // Approach: (a) draw whole feature as connector/intron and (b) draw blocks as\n                // needed. This ensures that whole feature, regardless of whether it starts with\n                // a block, is visible.\n                //\n\n                // Compute y axis start position and height\n                var cur_y_start, cur_height;\n                if (mode === \"Squish\" || mode === \"Dense\") {\n                    cur_y_start = y_start + Math.floor(SQUISH_FEATURE_HEIGHT/2) + 1;\n                    cur_height = 1;\n                }\n                else { // mode === \"Pack\"\n                    if (feature_strand) {\n                        cur_y_start = y_start;\n                        cur_height = thick_height;\n                    }\n                    else {\n                        cur_y_start += (SQUISH_FEATURE_HEIGHT/2) + 1;\n                        cur_height = 1;\n                    }\n                }\n\n                // Draw whole feature as connector/intron.\n                if ( this.draw_background_connector ) {\n                    if (mode === \"Squish\" || mode === \"Dense\") {\n                        ctx.fillStyle = CONNECTOR_COLOR;\n                    }\n                    else { // mode === \"Pack\"\n                        if (feature_strand) {\n                            if (feature_strand === \"+\") {\n                                ctx.fillStyle = ctx.canvas.manager.get_pattern( 'right_strand' );\n                            } else if (feature_strand === \"-\") {\n                                ctx.fillStyle = ctx.canvas.manager.get_pattern( 'left_strand' );\n                            }\n                        }\n                        else {\n                            ctx.fillStyle = CONNECTOR_COLOR;\n                        }\n                    }\n                    ctx.fillRect(f_start, cur_y_start, f_end - f_start, cur_height);\n                }\n\n                // Draw blocks.\n                var start_and_height;\n                for (var k = 0, k_len = feature_blocks.length; k < k_len; k++) {\n                    var block = feature_blocks[k],\n                        // -0.5 to offset block between bases.\n                        block_start = Math.floor( Math.max(0, (block[0] - tile_low - 0.5) * w_scale) ),\n                        block_end = Math.ceil( Math.min(width, Math.max((block[1] - tile_low - 0.5) * w_scale)) ),\n                        last_block_start, last_block_end;\n\n                    // Skip drawing if block not on tile.\n                    if (block_start > block_end) { continue; }\n\n                    // Draw thin block.\n                    ctx.fillStyle = block_color;\n                    ctx.fillRect(block_start, y_start + (thick_height-thin_height)/2 + 1, block_end - block_start, thin_height);\n\n                    // If block intersects with thick region, draw block as thick.\n                    // - No thick is sometimes encoded as thick_start == thick_end, so don't draw in that case\n                    if (thick_start !== undefined && feature_te > feature_ts && !(block_start > thick_end || block_end < thick_start) ) {\n                        var block_thick_start = Math.max(block_start, thick_start),\n                            block_thick_end = Math.min(block_end, thick_end);\n                        ctx.fillRect(block_thick_start, y_start + 1, block_thick_end - block_thick_start, thick_height);\n                        if ( feature_blocks.length === 1 && mode === \"Pack\") {\n                            // Exactly one block means we have no introns, but do have a distinct \"thick\" region,\n                            // draw arrows over it if in pack mode.\n                            if (feature_strand === \"+\") {\n                                ctx.fillStyle = ctx.canvas.manager.get_pattern( 'right_strand_inv' );\n                            } else if (feature_strand === \"-\") {\n                                ctx.fillStyle = ctx.canvas.manager.get_pattern( 'left_strand_inv' );\n                            }\n                            // If region is wide enough in pixels, pad a bit\n                            if ( block_thick_start + 14 < block_thick_end ) {\n                                block_thick_start += 2;\n                                block_thick_end -= 2;\n                            }\n                            ctx.fillRect(block_thick_start, y_start + 1, block_thick_end - block_thick_start, thick_height);\n                        }\n                    }\n                    // Draw individual connectors if required\n                    if ( this.draw_individual_connectors && last_block_start ) {\n                        this.draw_connector( ctx, last_block_start, last_block_end, block_start, block_end, y_start );\n                    }\n                    last_block_start = block_start;\n                    last_block_end = block_end;\n                }\n\n                // FIXME: Height scaling only works in Pack mode right now.\n                if (mode === \"Pack\") {\n                    // Reset alpha so height scaling is not impacted by alpha scaling.\n                    ctx.globalAlpha = 1;\n\n                    // Height scaling: draw white lines to reduce height according to height scale factor.\n                    ctx.fillStyle = \"white\"; // TODO: set this to background color.\n                    var\n                        hscale_factor = this.height_scaler.gen_val(feature),\n                        // Ceil ensures that min height is >= 1.\n                        new_height = Math.ceil(thick_height * hscale_factor),\n                        ws_height = Math.round( (thick_height-new_height)/2 );\n                    if (hscale_factor !== 1) {\n                        ctx.fillRect(f_start, cur_y_start + 1, f_end - f_start, ws_height);\n                        ctx.fillRect(f_start, cur_y_start + thick_height - ws_height + 1, f_end - f_start, ws_height);\n                    }\n                }\n            }\n\n            // Reset alpha so that label is not transparent.\n            ctx.globalAlpha = 1;\n\n            // Draw label for Pack mode.\n            if (feature_name && mode === \"Pack\" && feature_start > tile_low) {\n                ctx.fillStyle = label_color;\n                // FIXME: assumption here that the entire view starts at 0\n                if (tile_low === 0 && f_start - ctx.measureText(feature_name).width < 0) {\n                    ctx.textAlign = \"left\";\n                    ctx.fillText(feature_name, f_end + LABEL_SPACING, y_start + 8, this.max_label_length);\n                    draw_end += ctx.measureText(feature_name).width + LABEL_SPACING;\n                } else {\n                    ctx.textAlign = \"right\";\n                    ctx.fillText(feature_name, f_start - LABEL_SPACING, y_start + 8, this.max_label_length);\n                    draw_start -= ctx.measureText(feature_name).width + LABEL_SPACING;\n                }\n                //ctx.fillStyle = block_color;\n            }\n        }\n\n        // Reset global alpha.\n        ctx.globalAlpha = 1;\n\n        return [draw_start, draw_end];\n    }\n});\n\nvar ReadPainter = function(data, view_start, view_end, prefs, mode, alpha_scaler, height_scaler, ref_seq, base_color_fn) {\n    FeaturePainter.call(this, data, view_start, view_end, prefs, mode, alpha_scaler, height_scaler);\n    this.ref_seq = (ref_seq ? ref_seq.data : null);\n    this.base_color_fn = base_color_fn;\n};\n\n_.extend(ReadPainter.prototype, FeaturePainter.prototype, {\n    /**\n     * Returns height based on mode.\n     */\n    get_row_height: function() {\n        var height, mode = this.mode;\n        if (mode === \"Dense\") {\n            height = DENSE_TRACK_HEIGHT;\n        }\n        else if (mode === \"Squish\") {\n            height = SQUISH_TRACK_HEIGHT;\n        }\n        else { // mode === \"Pack\"\n            height = PACK_TRACK_HEIGHT;\n            if (this.prefs.show_insertions) {\n                height *= 2;\n            }\n        }\n        return height;\n    },\n\n    /**\n     * Parse CIGAR string to get (a) a list of contiguous drawing blocks (MD=X) and\n     * (b) an array of [ op_index, op_len ] pairs where op_index is an index into the\n     * string 'MIDNSHP=X' Return value is a dictionary with two entries, blocks and cigar\n     */\n    _parse_cigar: function(cigar_str) {\n        var cigar_ops = 'MIDNSHP=X';\n\n        // Parse cigar.\n        var blocks = [ [0, 0] ],\n            cur_block = blocks[0],\n            base_pos = 0,\n\n            // Parse cigar operations out and update/create blocks as needed.\n            parsed_cigar = _.map(cigar_str.match(/[0-9]+[MIDNSHP=X]/g), function(op) {\n                // Get operation length, character.\n                var op_len = parseInt(op.slice(0, -1), 10),\n                    op_char = op.slice(-1);\n\n                // Update drawing block.\n                if (op_char === 'N') {\n                    // At skip, so need to start new block if current block represents\n                    // drawing area.\n                    if (cur_block[1] !== 0) {\n                        cur_block = [base_pos + op_len, base_pos + op_len];\n                        blocks.push(cur_block);\n                    }\n                }\n                else if ('ISHP'.indexOf(op_char) === -1) {\n                    // Operation is M,D,=,X.\n                    cur_block[1] += op_len;\n                    base_pos += op_len;\n                }\n\n                // Return parsed cigar.\n                return [ cigar_ops.indexOf(op_char), op_len ];\n            });\n\n        return {\n            blocks: blocks,\n            cigar: parsed_cigar\n        };\n    },\n\n    /**\n     * Draw a single read from reference-based read sequence and cigar.\n     */\n    draw_read: function(ctx, mode, w_scale, y_start, tile_low, tile_high, feature_start, cigar, strand, read_seq) {\n        // Helper function to update base and sequnence offsets.\n        var update_base_offset = function(offset, cig_op, cig_len) {\n                if ('M=NXD'.indexOf(cig_op) !== -1) {\n                    offset += cig_len;\n                }\n                return offset;\n            },\n            update_seq_offset = function(offset, cig_op, cig_len) {\n                if ('IX'.indexOf(cig_op) !== -1) {\n                    offset += cig_len;\n                }\n                return offset;\n            },\n            // Gets drawing coordinate for a sequence coordinate. Assumes closure variables w_scale and tile_low.\n            get_draw_coord = function(sequence_coord) {\n                // -0.5 to offset sequence between bases.\n                return Math.floor( Math.max(0, (sequence_coord - tile_low - 0.5) * w_scale) );\n            };\n\n        ctx.textAlign = \"center\";\n        var tile_region = [tile_low, tile_high],\n            base_offset = 0,\n            seq_offset = 0,\n            gap = Math.round(w_scale/2),\n            char_width_px = ctx.canvas.manager.char_width_px,\n            block_color = (strand === \"+\" ? this.prefs.detail_block_color : this.prefs.reverse_strand_color),\n            pack_mode = (mode === 'Pack'),\n            draw_height = (pack_mode ? PACK_FEATURE_HEIGHT : SQUISH_FEATURE_HEIGHT),\n            rect_y = y_start + 1,\n            paint_utils = new ReadPainterUtils(ctx, draw_height, w_scale, mode),\n            drawing_blocks = [],\n            s_start,\n            s_end;\n\n        // Keep list of items that need to be drawn on top of initial drawing layer.\n        var draw_last = [];\n\n        // Parse cigar and get drawing blocks.\n        var t = this._parse_cigar(cigar);\n        cigar = t.cigar;\n        drawing_blocks = t.blocks;\n\n        // Draw blocks.\n        for (var i = 0; i < drawing_blocks.length; i++) {\n            var block = drawing_blocks[i];\n\n            if (is_overlap([feature_start + block[0], feature_start + block[1]], tile_region)) {\n                s_start = get_draw_coord(feature_start + block[0]);\n                s_end = get_draw_coord(feature_start + block[1]);\n\n                // Make sure that block is drawn even if it too small to be rendered officially; in this case,\n                // read is drawn at 1px.\n                // TODO: need to ensure that s_start, s_end are calculated the same for both slotting\n                // and drawing.\n                if (s_start === s_end) {\n                    s_end += 1;\n                }\n\n                // Draw read base as rectangle.\n                ctx.fillStyle = block_color;\n                ctx.fillRect(s_start, rect_y, s_end - s_start, draw_height);\n            }\n        }\n\n        // Draw read features.\n        for (var cig_id = 0, len = cigar.length; cig_id < len; cig_id++) {\n            var cig = cigar[cig_id],\n                cig_op = \"MIDNSHP=X\"[ cig[0] ],\n                cig_len = cig[1];\n\n            var seq_start = feature_start + base_offset;\n            s_start = get_draw_coord(seq_start);\n            s_end = get_draw_coord(seq_start + cig_len);\n\n            // Skip feature if it's not in tile.\n            if (!is_overlap([seq_start, seq_start + cig_len], tile_region)) {\n                // Update offsets.\n                base_offset = update_base_offset(base_offset, cig_op, cig_len);\n                seq_offset = update_seq_offset(seq_offset, cig_op, cig_len);\n                continue;\n            }\n\n            // Make sure that read is drawn even if it too small to be rendered officially; in this case,\n            // read is drawn at 1px.\n            // TODO: need to ensure that s_start, s_end are calculated the same for both slotting\n            // and drawing.\n            if (s_start === s_end) {\n                s_end += 1;\n            }\n\n            // Draw read feature.\n            switch (cig_op) {\n                case \"H\": // Hard clipping.\n                case \"S\": // Soft clipping.\n                case \"P\": // Padding.\n                    // Sequence not present and not related to alignment; do nothing.\n                    break;\n                case \"M\": // \"Match\".\n                    // Because it's not known whether there is a match, ignore.\n                    base_offset += cig_len;\n                    break;\n                case \"=\": // Match with reference.\n                case \"X\": // Mismatch with reference.\n                    //\n                    // Draw sequence and/or variants.\n                    //\n\n                    // Get sequence to draw.\n                    var cur_seq = '';\n                    if (cig_op === 'X') {\n                        // Get sequence from read_seq.\n                        cur_seq = read_seq.slice(seq_offset, seq_offset + cig_len);\n                    }\n                    else if (this.ref_seq) { // && cig_op === '='\n                        // Use reference sequence.\n                        cur_seq = this.ref_seq.slice(\n                            // If read starts after tile start, slice at read start.\n                            Math.max(0, seq_start - tile_low),\n                            // If read ends before tile end, slice at read end.\n                            Math.min(seq_start - tile_low + cig_len, tile_high - tile_low)\n                        );\n                    }\n\n                    // Draw sequence. Because cur_seq starts and read/tile start, go to there to start writing.\n                    var start_pos = Math.max(seq_start, tile_low);\n                    for (var c = 0; c < cur_seq.length; c++) {\n                        // Draw base if showing all (i.e. not showing differences) or there is a mismatch.\n                        if (cur_seq && !this.prefs.show_differences || cig_op === 'X') {\n                            // Draw base.\n                            var c_start = Math.floor( Math.max(0, (start_pos + c - tile_low) * w_scale) );\n                            ctx.fillStyle = this.base_color_fn(cur_seq[c]);\n                            if (pack_mode && w_scale > char_width_px) {\n                                ctx.fillText(cur_seq[c], c_start, y_start + 9);\n                            }\n                            // Require a minimum w_scale so that variants are only drawn when somewhat zoomed in.\n                            else if (w_scale > 0.05) {\n                                ctx.fillRect(c_start - gap, rect_y, Math.max( 1, Math.round(w_scale) ), draw_height);\n                            }\n                        }\n                    }\n\n                    // Move forward in sequence only if sequence used to get mismatches.\n                    if (cig_op === 'X') { seq_offset += cig_len; }\n                    base_offset += cig_len;\n\n                    break;\n                case \"N\": // Skipped bases.\n                    ctx.fillStyle = CONNECTOR_COLOR;\n                    ctx.fillRect(s_start, rect_y + (draw_height - 1)/2, s_end - s_start, 1);\n                    // No change in seq_offset because sequence not used when skipping.\n                    base_offset += cig_len;\n                    break;\n                case \"D\": // Deletion.\n                    paint_utils.draw_deletion(s_start, rect_y, cig_len);\n                    base_offset += cig_len;\n                    break;\n                case \"I\": // Insertion.\n                    // Check to see if sequence should be drawn at all by looking at the overlap between\n                    // the sequence region and the tile region.\n                    var insert_x_coord = s_start - gap;\n\n                    if (is_overlap([seq_start, seq_start + cig_len], tile_region)) {\n                        var seq = read_seq.slice(seq_offset, seq_offset + cig_len);\n                        // Insertion point is between the sequence start and the previous base: (-gap) moves\n                        // back from sequence start to insertion point.\n                        if (this.prefs.show_insertions) {\n                            //\n                            // Show inserted sequence above, centered on insertion point.\n                            //\n\n                            // Draw sequence.\n                            // X center is offset + start - <half_sequence_length>\n                            var x_center = s_start - (s_end - s_start)/2;\n                            if ( (mode === \"Pack\" || this.mode === \"Auto\") && read_seq !== undefined && w_scale > char_width_px) {\n                                // Draw sequence container.\n                                ctx.fillStyle = \"yellow\";\n                                ctx.fillRect(x_center - gap, y_start - 9, s_end - s_start, 9);\n                                draw_last[draw_last.length] = {type: \"triangle\", data: [insert_x_coord, y_start + 4, 5]};\n                                ctx.fillStyle = CONNECTOR_COLOR;\n                                // Based on overlap b/t sequence and tile, get sequence to be drawn.\n                                switch( compute_overlap( [seq_start, seq_start + cig_len], tile_region ) ) {\n                                    case(OVERLAP_START):\n                                        seq = seq.slice(tile_low-seq_start);\n                                        break;\n                                    case(OVERLAP_END):\n                                        seq = seq.slice(0, seq_start-tile_high);\n                                        break;\n                                    case(CONTAINED_BY):\n                                        // All of sequence drawn.\n                                        break;\n                                    case(CONTAINS):\n                                        seq = seq.slice(tile_low-seq_start, seq_start-tile_high);\n                                        break;\n                                }\n                                // Draw sequence.\n                                for (var c = 0, str_len = seq.length; c < str_len; c++) {\n                                    var c_start = Math.floor( Math.max(0, (seq_start + c -  tile_low) * w_scale) );\n                                    ctx.fillText(seq[c], c_start - (s_end - s_start)/2, y_start);\n                                }\n                            }\n                            else {\n                                // Draw block.\n                                ctx.fillStyle = \"yellow\";\n                                // TODO: This is a pretty hack-ish way to fill rectangle based on mode.\n                                ctx.fillRect(x_center, y_start + (this.mode !== \"Dense\" ? 2 : 5),\n                                             s_end - s_start, (mode !== \"Dense\" ? SQUISH_FEATURE_HEIGHT : DENSE_FEATURE_HEIGHT));\n                            }\n                        }\n                        else {\n                            if ( (mode === \"Pack\" || this.mode === \"Auto\") && read_seq !== undefined && w_scale > char_width_px) {\n                                // Show insertions with a single number at the insertion point.\n                                draw_last.push( { type: \"text\", data: [seq.length, insert_x_coord, y_start + 9] } );\n                            }\n                            else {\n                                // TODO: probably can merge this case with code above.\n                            }\n                        }\n                    }\n                    seq_offset += cig_len;\n                    // No change to base offset because insertions are drawn above sequence/read.\n                    break;\n            }\n        }\n\n        //\n        // Draw last items.\n        //\n        ctx.fillStyle = \"yellow\";\n        var item, type, data;\n        for (var i = 0; i < draw_last.length; i++) {\n            item = draw_last[i];\n            type = item.type;\n            data = item.data;\n            if (type === \"text\") {\n                ctx.save();\n                ctx.font = \"bold \" + ctx.font;\n                ctx.fillText(data[0], data[1], data[2]);\n                ctx.restore();\n            }\n            else if (type === \"triangle\") {\n                drawDownwardEquilateralTriangle(ctx, data[0], data[1], data[2]);\n            }\n        }\n    },\n\n    /**\n     * Draw a complete read pair\n     */\n    draw_element: function(ctx, mode, feature, slot, tile_low, tile_high, w_scale, y_scale, width ) {\n        // All features need a start, end, and vertical center.\n        var feature_uid = feature[0],\n            feature_start = feature[1],\n            feature_end = feature[2],\n            feature_name = feature[3],\n            // -0.5 to put element between bases.\n            f_start = Math.floor( Math.max(-0.5 * w_scale, (feature_start - tile_low - 0.5) * w_scale) ),\n            f_end   = Math.ceil( Math.min(width, Math.max(0, (feature_end - tile_low - 0.5) * w_scale)) ),\n            y_start = (mode === \"Dense\" ? 0 : (0 + slot)) * y_scale,\n            draw_height = (mode === 'Pack' ? PACK_FEATURE_HEIGHT : SQUISH_FEATURE_HEIGHT),\n            label_color = this.prefs.label_color;\n\n        // Draw read.\n        if (feature[5] instanceof Array) {\n            // Read is paired.\n            var connector = true;\n\n            // Draw left/forward read.\n            if (feature[4][1] >= tile_low && feature[4][0] <= tile_high && feature[4][2]) {\n                this.draw_read(ctx, mode, w_scale, y_start, tile_low, tile_high, feature[4][0], feature[4][2], feature[4][3], feature[4][4]);\n            }\n            else {\n                connector = false;\n            }\n\n            // Draw right/reverse read.\n            if (feature[5][1] >= tile_low && feature[5][0] <= tile_high && feature[5][2]) {\n                this.draw_read(ctx, mode, w_scale, y_start, tile_low, tile_high, feature[5][0], feature[5][2], feature[5][3], feature[5][4]);\n            }\n            else {\n                connector = false;\n            }\n\n            // Draw connector if both reads were drawn.\n            // TODO: currently, there is no way to connect reads drawn on different tiles; to connect reads on different tiles, data manager\n            // code is needed to join mate pairs from different regions. Alternatively, requesting multiple regions of data at once would\n            // make it possible to put together more easily.\n            // -0.5 to position connector correctly between reads.\n            var b1_end   = Math.ceil( Math.min(width, Math.max(-0.5 * w_scale, (feature[4][1] - tile_low - 0.5) * w_scale)) ),\n                b2_start = Math.floor( Math.max(-0.5 * w_scale, (feature[5][0] - tile_low - 0.5) * w_scale) );\n            if (connector && b2_start > b1_end) {\n                ctx.fillStyle = CONNECTOR_COLOR;\n                var line_height = y_start + 1 + (draw_height - 1)/2;\n                dashedLine(ctx, b1_end, line_height, b2_start, line_height);\n            }\n        } else {\n            // Read is single.\n            this.draw_read(ctx, mode, w_scale, y_start, tile_low, tile_high, feature_start, feature[4], feature[5], feature[6]);\n        }\n        if (mode === \"Pack\" && feature_start >= tile_low && feature_name !== \".\") {\n            // Draw label.\n            ctx.fillStyle = this.prefs.label_color;\n            if (tile_low === 0 && f_start - ctx.measureText(feature_name).width < 0) {\n                ctx.textAlign = \"left\";\n                ctx.fillText(feature_name, f_end + LABEL_SPACING, y_start + 9, this.max_label_length);\n            } else {\n                ctx.textAlign = \"right\";\n                ctx.fillText(feature_name, f_start - LABEL_SPACING, y_start + 9, this.max_label_length);\n            }\n        }\n\n        // FIXME: provide actual coordinates for drawn read.\n        return [0,0];\n    }\n});\n\nvar ArcLinkedFeaturePainter = function(data, view_start, view_end, prefs, mode, alpha_scaler, height_scaler) {\n    LinkedFeaturePainter.call(this, data, view_start, view_end, prefs, mode, alpha_scaler, height_scaler);\n    // Need to know the longest feature length for adding spacing\n    this.longest_feature_length = this.calculate_longest_feature_length();\n    this.draw_background_connector = false;\n    this.draw_individual_connectors = true;\n};\n\n_.extend(ArcLinkedFeaturePainter.prototype, FeaturePainter.prototype, LinkedFeaturePainter.prototype, {\n\n    calculate_longest_feature_length: function () {\n        var longest_feature_length = 0;\n        for (var i = 0, len = this.data.length; i < len; i++) {\n            var feature = this.data[i], feature_start = feature[1], feature_end = feature[2];\n            longest_feature_length = Math.max( longest_feature_length, feature_end - feature_start );\n        }\n        return longest_feature_length;\n    },\n\n    get_top_padding: function( width ) {\n        var view_range = this.view_end - this.view_start,\n            w_scale = width / view_range;\n        return Math.min( 128, Math.ceil( ( this.longest_feature_length / 2 ) * w_scale ) );\n    },\n\n    draw_connector: function( ctx, block1_start, block1_end, block2_start, block2_end, y_start ) {\n        // Arc drawing -- from closest endpoints\n        var x_center = ( block1_end + block2_start ) / 2,\n            radius = block2_start - x_center;\n        // For full half circles\n        var angle1 = Math.PI, angle2 = 0;\n        if ( radius > 0 ) {\n            ctx.beginPath();\n            ctx.arc( x_center, y_start, block2_start - x_center, Math.PI, 0 );\n            ctx.stroke();\n        }\n    }\n});\n\n// Color stuff from less.js\n\nvar Color = function (rgb, a) {\n    /**\n     * The end goal here, is to parse the arguments\n     * into an integer triplet, such as `128, 255, 0`\n     *\n     * This facilitates operations and conversions.\n     */\n    if (Array.isArray(rgb)) {\n        this.rgb = rgb;\n    } else if (rgb.length == 6) {\n        this.rgb = rgb.match(/.{2}/g).map(function (c) {\n            return parseInt(c, 16);\n        });\n    } else if (rgb.length == 7) {\n        this.rgb = rgb.substring(1,7).match(/.{2}/g).map(function (c) {\n            return parseInt(c, 16);\n        });\n    } else {\n        this.rgb = rgb.split('').map(function (c) {\n            return parseInt(c + c, 16);\n        });\n    }\n    this.alpha = typeof(a) === 'number' ? a : 1;\n};\nColor.prototype = {\n    eval: function () { return this; },\n\n    //\n    // If we have some transparency, the only way to represent it\n    // is via `rgba`. Otherwise, we use the hex representation,\n    // which has better compatibility with older browsers.\n    // Values are capped between `0` and `255`, rounded and zero-padded.\n    //\n    toCSS: function () {\n        if (this.alpha < 1.0) {\n            return \"rgba(\" + this.rgb.map(function (c) {\n                return Math.round(c);\n            }).concat(this.alpha).join(', ') + \")\";\n        } else {\n            return '#' + this.rgb.map(function (i) {\n                i = Math.round(i);\n                i = (i > 255 ? 255 : (i < 0 ? 0 : i)).toString(16);\n                return i.length === 1 ? '0' + i : i;\n            }).join('');\n        }\n    },\n\n    toHSL: function () {\n        var r = this.rgb[0] / 255,\n            g = this.rgb[1] / 255,\n            b = this.rgb[2] / 255,\n            a = this.alpha;\n\n        var max = Math.max(r, g, b), min = Math.min(r, g, b);\n        var h, s, l = (max + min) / 2, d = max - min;\n\n        if (max === min) {\n            h = s = 0;\n        } else {\n            s = l > 0.5 ? d / (2 - max - min) : d / (max + min);\n\n            switch (max) {\n                case r: h = (g - b) / d + (g < b ? 6 : 0); break;\n                case g: h = (b - r) / d + 2;               break;\n                case b: h = (r - g) / d + 4;               break;\n            }\n            h /= 6;\n        }\n        return { h: h * 360, s: s, l: l, a: a };\n    },\n\n    toARGB: function () {\n        var argb = [Math.round(this.alpha * 255)].concat(this.rgb);\n        return '#' + argb.map(function (i) {\n            i = Math.round(i);\n            i = (i > 255 ? 255 : (i < 0 ? 0 : i)).toString(16);\n            return i.length === 1 ? '0' + i : i;\n        }).join('');\n    },\n\n    mix: function (color2, weight) {\n        color1 = this;\n\n        var p = weight; // .value / 100.0;\n        var w = p * 2 - 1;\n        var a = color1.toHSL().a - color2.toHSL().a;\n\n        var w1 = (((w * a == -1) ? w : (w + a) / (1 + w * a)) + 1) / 2.0;\n        var w2 = 1 - w1;\n\n        var rgb = [color1.rgb[0] * w1 + color2.rgb[0] * w2,\n                   color1.rgb[1] * w1 + color2.rgb[1] * w2,\n                   color1.rgb[2] * w1 + color2.rgb[2] * w2];\n\n        var alpha = color1.alpha * p + color2.alpha * (1 - p);\n\n        return new Color(rgb, alpha);\n    }\n};\n\n\n// End colors from less.js\n\nvar LinearRamp = function( start_color, end_color, start_value, end_value ) {\n    /**\n     * Simple linear gradient\n     */\n    this.start_color = new Color( start_color );\n    this.end_color = new Color( end_color );\n    this.start_value = start_value;\n    this.end_value = end_value;\n    this.value_range = end_value - start_value;\n};\n\nLinearRamp.prototype.map_value = function( value ) {\n    value = Math.max( value, this.start_value );\n    value = Math.min( value, this.end_value );\n    value = ( value - this.start_value ) / this.value_range;\n    // HACK: just red for now\n    // return \"hsl(0,100%,\" + (value * 100) + \"%)\"\n    return this.start_color.mix( this.end_color, 1 - value ).toCSS();\n};\n\nvar SplitRamp = function( start_color, middle_color, end_color, start_value, end_value ) {\n    /**\n     * Two gradients split away from 0\n     */\n    this.positive_ramp = new LinearRamp( middle_color, end_color, 0, end_value );\n    this.negative_ramp = new LinearRamp( middle_color, start_color, 0, -start_value );\n    this.start_value = start_value;\n    this.end_value = end_value;\n};\n\nSplitRamp.prototype.map_value = function( value ) {\n    value = Math.max( value, this.start_value );\n    value = Math.min( value, this.end_value );\n    if ( value >= 0 ) {\n        return this.positive_ramp.map_value( value );\n    } else {\n        return this.negative_ramp.map_value( -value );\n    }\n};\n\nvar DiagonalHeatmapPainter = function(data, view_start, view_end, prefs, mode) {\n    Painter.call( this, data, view_start, view_end, prefs, mode );\n    var i, len;\n\n    if ( this.prefs.min_value === undefined ) {\n        var min_value = Infinity;\n        for (i = 0, len = this.data.length; i < len; i++) {\n            min_value = Math.min( min_value, this.data[i][6] );\n        }\n        this.prefs.min_value = min_value;\n    }\n    if ( this.prefs.max_value === undefined ) {\n        var max_value = -Infinity;\n        for (i = 0, len = this.data.length; i < len; i++) {\n            max_value = Math.max( max_value, this.data[i][6] );\n        }\n        this.prefs.max_value = max_value;\n    }\n};\n\nDiagonalHeatmapPainter.prototype.default_prefs = {\n    min_value: undefined,\n    max_value: undefined,\n    mode: \"Heatmap\",\n    pos_color: \"#FF8C00\",\n    neg_color: \"#4169E1\"\n};\n\nDiagonalHeatmapPainter.prototype.draw = function(ctx, width, height, w_scale) {\n    var\n        min_value = this.prefs.min_value,\n        max_value = this.prefs.max_value,\n        value_range = max_value - min_value,\n        height_px = height,\n        view_start = this.view_start,\n        mode = this.mode,\n        data = this.data,\n        invsqrt2 = 1 / Math.sqrt(2);\n\n    var ramp = ( new SplitRamp( this.prefs.neg_color, \"#FFFFFF\", this.prefs.pos_color, min_value, max_value ) );\n\n    var d, s1, e1, s2, e2, value;\n\n    var scale = function( p ) { return ( p - view_start ) * w_scale; };\n\n    ctx.save();\n\n    // Draw into triangle, then rotate and scale\n    ctx.rotate(-45 * Math.PI / 180);\n    ctx.scale( invsqrt2, invsqrt2 );\n\n    // Paint track.\n    for (var i = 0, len = data.length; i < len; i++) {\n        d = data[i];\n\n        s1 = scale( d[1] );\n        e1 = scale( d[2] );\n        s2 = scale( d[4] );\n        e2 = scale( d[5] );\n        value = d[6];\n\n        ctx.fillStyle = ( ramp.map_value( value ) );\n        ctx.fillRect( s1, s2, ( e1 - s1 ), ( e2 - s2 ) );\n    }\n\n    ctx.restore();\n};\n\n/**\n * Utilities for painting reads.\n */\nvar ReadPainterUtils = function(ctx, row_height, px_per_base, mode) {\n    this.ctx = ctx;\n    this.row_height = row_height;\n    this.px_per_base = px_per_base;\n    this.draw_details = (mode === 'Pack' || mode === 'Auto') && (px_per_base >= ctx.canvas.manager.char_width_px);\n    this.delete_details_thickness = 0.2;\n};\n\n_.extend(ReadPainterUtils.prototype, {\n    /**\n     * Draw deletion of base(s).\n     * @param draw_detail if true, drawing in detail and deletion is drawn more subtly\n     */\n    draw_deletion: function(x, y, len) {\n        this.ctx.fillStyle = \"black\";\n        var thickness = (this.draw_details ? this.delete_details_thickness : 1) * this.row_height;\n        y += 0.5 * ( this.row_height - thickness );\n        this.ctx.fillRect(x, y, len * this.px_per_base, thickness);\n    }\n});\n\n/**\n * Paints variant data onto canvas.\n */\nvar VariantPainter = function(data, view_start, view_end, prefs, mode, base_color_fn) {\n    Painter.call(this, data, view_start, view_end, prefs, mode);\n    this.base_color_fn = base_color_fn;\n    this.divider_height = 1;\n};\n\n_.extend(VariantPainter.prototype, Painter.prototype, {\n    /**\n     * Height of a single row, depends on mode\n     */\n    get_row_height: function() {\n        var mode = this.mode, height;\n        if (mode === \"Dense\") {\n            height = DENSE_TRACK_HEIGHT;\n        }\n        else if (mode === \"Squish\") {\n            height = SQUISH_TRACK_HEIGHT;\n        }\n        else { // mode === \"Pack\"\n            height = PACK_TRACK_HEIGHT;\n        }\n        return height;\n    },\n\n    /**\n     * Returns required height to draw a particular number of samples in a given mode.\n     */\n    get_required_height: function(num_samples) {\n        // FIXME: for single-sample data, height should be summary_height when zoomed out and\n        // row_height when zoomed in.\n        var height = this.prefs.summary_height;\n\n        // If showing sample data, height is summary + divider + samples.\n        if (num_samples > 1 && this.prefs.show_sample_data) {\n            height += this.divider_height + num_samples * this.get_row_height();\n        }\n        return height;\n    },\n\n    /**\n     * Draw on the context using a rectangle of width x height with scale w_scale.\n     */\n    draw: function(ctx, width, height, w_scale) {\n        ctx.save();\n\n        var\n        /**\n         * Returns dictionary of information about an indel; returns empty if there no indel. Assumes indel is left-aligned.\n         * Dict attributes:\n         *    -type: 'insertion' or 'deletion'\n         *    -start: where the deletion starts relative to reference start\n         *    -len: how long the deletion is\n         */\n        get_indel_info = function(ref, alt) {\n            var ref_len = ref.length,\n                alt_len = alt.length,\n                start = 0,\n                len = 1,\n                type = null;\n            if (alt === '-') {\n                type = 'deletion';\n                len = ref.length;\n            }\n            else if (ref.indexOf(alt) === 0 && ref_len > alt_len) {\n                type = 'deletion';\n                len = ref_len - alt_len;\n                start = alt_len;\n            }\n            else if (alt.indexOf(ref) === 0 && ref_len < alt_len) {\n                // Insertion.\n                type = 'insertion';\n                len = alt_len - ref_len;\n                start = alt_len;\n            }\n\n            return ( type !== null ? { type: type, start: start, len: len } : {} );\n        };\n\n        // Draw.\n        var locus_data,\n            pos,\n            id,\n            ref,\n            alt,\n            qual,\n            filter,\n            sample_gts,\n            allele_counts,\n            variant,\n            draw_x_start,\n            draw_y_start,\n            genotype,\n            // Always draw variants at least 1 pixel wide.\n            base_px = Math.max(1, Math.floor(w_scale)),\n            // Determine number of samples.\n            num_samples = (this.data.length ? this.data[0][7].split(',').length : 0),\n            row_height = (this.mode === 'Squish' ? SQUISH_TRACK_HEIGHT : PACK_TRACK_HEIGHT),\n            // If zoomed out, fill the whole row with feature to make it easier to read;\n            // when zoomed in, use feature height so that there are gaps in sample rows.\n            feature_height = (w_scale < 0.1 ?\n                              row_height :\n                              (this.mode === 'Squish' ? SQUISH_FEATURE_HEIGHT : PACK_FEATURE_HEIGHT)\n                             ),\n            draw_summary = true,\n            paint_utils = new ReadPainterUtils(ctx, row_height, w_scale, this.mode),\n            j;\n\n        // If there's a single sample, update drawing variables.\n        if (num_samples === 1) {\n            row_height = feature_height =\n                (w_scale < ctx.canvas.manager.char_width_px ? this.prefs.summary_height : row_height);\n            paint_utils.row_height = row_height;\n            // No summary when there's a single sample.\n            draw_summary = false;\n        }\n\n        // Draw divider between summary and samples.\n        if (this.prefs.show_sample_data && draw_summary) {\n            ctx.fillStyle = '#F3F3F3';\n            ctx.globalAlpha = 1;\n            ctx.fillRect(0, this.prefs.summary_height - this.divider_height, width, this.divider_height);\n        }\n\n        // Draw variants.\n        ctx.textAlign = \"center\";\n        for (var i = 0; i < this.data.length; i++) {\n            // Get locus data.\n            locus_data = this.data[i];\n            pos = locus_data[1];\n            ref = locus_data[3];\n            alt = [ locus_data[4].split(',') ];\n            sample_gts = locus_data[7].split(',');\n            allele_counts = locus_data.slice(8);\n\n            // Process alterate values to derive information about each alt.\n            alt = _.map(_.flatten(alt), function(a) {\n                var alt_info = {\n                        type: 'snp',\n                        value: a,\n                        start: 0\n                    },\n                    indel_info = get_indel_info(ref, a);\n\n                return _.extend(alt_info, indel_info);\n            });\n\n            // Only draw locus data if it's in viewing region.\n            if (pos < this.view_start || pos > this.view_end) {\n                continue;\n            }\n\n            // Draw summary for alleles.\n            if (draw_summary) {\n                ctx.fillStyle = '#999999';\n                ctx.globalAlpha = 1;\n                for (j = 0; j < alt.length; j++) {\n                    // Draw background for summary.\n                    draw_x_start = this.get_start_draw_pos(pos + alt[j].start, w_scale);\n                    ctx.fillRect(draw_x_start, 0, base_px, this.prefs.summary_height);\n                    draw_y_start = this.prefs.summary_height;\n                    // Draw allele fractions onto summary.\n                    for (j = 0; j < alt.length; j++) {\n                        ctx.fillStyle = ( alt[j].type === 'deletion' ? 'black' : this.base_color_fn(alt[j].value) );\n                        allele_frac = allele_counts / sample_gts.length;\n                        draw_height = Math.ceil(this.prefs.summary_height * allele_frac);\n                        ctx.fillRect(draw_x_start, draw_y_start - draw_height, base_px, draw_height);\n                        draw_y_start -= draw_height;\n                    }\n                }\n            }\n\n            // Done drawing if not showing samples data.\n            if (!this.prefs.show_sample_data) { continue; }\n\n            // Draw sample genotype(s).\n            draw_y_start = (draw_summary ? this.prefs.summary_height + this.divider_height : 0);\n            for (j = 0; j < sample_gts.length; j++, draw_y_start += row_height) {\n                genotype = (sample_gts[j] ? sample_gts[j].split(/\\/|\\|/) : ['0', '0']);\n\n                // Get variant to draw and set drawing properties.\n                variant = null;\n                if (genotype[0] === genotype[1]) {\n                    if (genotype[0] === '.') {\n                        // TODO: draw uncalled variant.\n                    }\n                    else if (genotype[0] !== '0') {\n                        // Homozygous for variant.\n                        variant = alt[ parseInt(genotype[0], 10) - 1 ];\n                        ctx.globalAlpha = 1;\n                    }\n                    // else reference\n                }\n                else { // Heterozygous for variant.\n                    variant = (genotype[0] !== '0' ? genotype[0] : genotype[1]);\n                    variant = alt[ parseInt(variant, 10) - 1 ];\n                    ctx.globalAlpha = 0.5;\n                }\n\n                // If there's a variant, draw it.\n                if (variant) {\n                    draw_x_start = this.get_start_draw_pos(pos + variant.start, w_scale);\n                    if (variant.type === 'snp') {\n                        var snp = variant.value;\n                        ctx.fillStyle = this.base_color_fn(snp);\n                        if (paint_utils.draw_details) {\n                            ctx.fillText(snp, this.get_draw_pos(pos, w_scale), draw_y_start + row_height);\n                        }\n                        else {\n                            ctx.fillRect(draw_x_start, draw_y_start + 1, base_px, feature_height);\n                        }\n                    }\n                    else if (variant.type === 'deletion') {\n                        paint_utils.draw_deletion(draw_x_start, draw_y_start + 1, variant.len);\n                    }\n                    else {\n                        // TODO: handle insertions.\n                    }\n                }\n            }\n        }\n\n        ctx.restore();\n    }\n});\n\nreturn {\n    Scaler: Scaler,\n    LinePainter: LinePainter,\n    LinkedFeaturePainter: LinkedFeaturePainter,\n    ReadPainter: ReadPainter,\n    ArcLinkedFeaturePainter: ArcLinkedFeaturePainter,\n    DiagonalHeatmapPainter: DiagonalHeatmapPainter,\n    VariantPainter: VariantPainter\n};\n\n\n});\n"]}