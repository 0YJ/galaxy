{"version":3,"sources":["viz/trackster/painters.js"],"names":["_","compute_overlap","first_region","second_region","first_start","first_end","second_start","second_end","BEFORE","overlap","OVERLAP_START","dashedLine","ctx","dashLen","q","dX","x2","x1","dY","y2","y1","dashes","Math","floor","sqrt","dashX","dashY","fillRect","drawDownwardEquilateralTriangle","down_vertex_x","down_vertex_y","side_len","y","beginPath","moveTo","lineTo","strokeStyle","this","fillStyle","fill","stroke","closePath","Scaler","default_val","DrawResults","options","incomplete_features","feature_mapper","Painter","data","view_start","view_end","prefs","mode","prototype","extend","default_prefs","draw","width","height","w_scale","get_start_draw_pos","chrom_pos","_chrom_pos_to_draw_pos","get_end_draw_pos","offset","LinePainter","call","min_value","undefined","max_value","color","vertical_range","overflow_color","height_px","x_scaled","delta_x_pxs","length","round","ceil","i","delta_x_px","block_color","pref_color","painter_color","slice","pref_g","pref_b","top_overflow","parseInt","y_zero","bot_overflow","pref_r","saturation","new_g","new_b","new_r","in_path","overflow_x","restore","slot_height","feature_positions","translation","y_translation","FeaturePositionMapper","map_feature_data","feature_data","slot","x_start","x_end","push","get_feature_data","x","feature_dict","FeaturePainter","alpha_scaler","height_scaler","max_label_length","connector_color","get_required_height","required_height","rows_required","get_row_height","y_scale","get_top_padding","slots","textAlign","x_draw_coords","feature_uid","feature","len","feature_start","feature_end","draw_element","SQUISH_FEATURE_HEIGHT","PACK_TRACK_HEIGHT","DENSE_FEATURE_HEIGHT","PACK_FEATURE_HEIGHT","LABEL_SPACING","tile_low","tile_high","LinkedFeaturePainter","f_start","draw_background_connector","feature_strand","thick_start","thick_end","thin_height","thick_height","full_height","feature_name","f_end","min","max","draw_start","draw_end","y_start","canvas","reverse_strand_color","label_color","cur_y_start","cur_height","feature_ts","feature_blocks","feature_te","start_and_height","k","k_len","block_start","ws_height","fillText","measureText","manager","get_pattern","ReadPainter","ref_seq","base_color_fn","last_block_start","last_block_end","block","DENSE_TRACK_HEIGHT","block_end","op_len","blocks","cur_block","base_pos","op_char","block_thick_start","block_thick_end","update_base_offset","cig_len","draw_individual_connectors","draw_connector","get_draw_coord","tile_region","base_offset","globalAlpha","draw_height","pack_mode","hscale_factor","gen_val","drawing_blocks","new_height","_parse_cigar","s_start","s_end","cig_id","cig","cigar","is_overlap","seq_start","seq_offset","cur_seq","start_pos","show_insertions","cigar_str","parsed_cigar","map","match","op","indexOf","seq","read_seq","sequence_coord","draw_last","type","gap","char_width_px","strand","detail_block_color","rect_y","paint_utils","item","t","cig_op","draw_read","connector","b2_start","ArcLinkedFeaturePainter","longest_feature_length","calculate_longest_feature_length","c","show_differences","view_range","c_start","block1_start","block2_start","x_center","isArray","rgb","substring","draw_deletion","insert_x_coord","d","l","alpha","concat","str_len","weight","color2","w1","color1","LinearRamp","end_color","start_color","start_value","map_value","end_value","CONTAINS","update_seq_offset","negative_ramp","DiagonalHeatmapPainter","font","pos_color","neg_color","value_range","invsqrt2","s1","scale","e1","s2","value","ReadPainterUtils","thickness","b1_end","line_height","num_samples","get_indel_info","ref_len","ref","start","alt","draw_x_start","base_px","row_height","feature_height","draw_summary","locus_data","sample_gts","allele_counts","block1_end","radius","pos","arc","PI","Array","draw_y_start","show_sample_data","split","a","Color","genotype","variant","draw_details","toString","get_draw_pos","toHSL","h","s","r","g","b","VariantPainter","toARGB","join","mix","p","w","w2","toCSS","SplitRamp","middle_color","positive_ramp","Infinity","e2","ramp","save","rotate","px_per_base","delete_details_thickness","divider_height","summary_height","j","alt_len","flatten","alt_info","indel_info","allele_frac","snp"],"mappings":"8IAAYA,6JAeRC,EAAkB,SAACC,EAAcC,GACjC,IAAIC,EAAcF,EAAa,GAC3BG,EAAYH,EAAa,GACzBI,EAAeH,EAAc,GAC7BI,EAAaJ,EAAc,GAF/B,OAIIC,EAAcE,EACVD,GAAaC,EAdZ,KAgBMD,GAAaE,EAbZ,KADL,KAFXC,EAAJD,EAMY,KAJGF,GAAfE,EAGmB,KADD,MAWNE,EAAAA,SAAAA,EAAAN,GACH,IAAAM,EAFDR,EAEWI,EAAyBF,GAChCM,OAjBC,OAiBDA,GAXA,OAWUC,GASbC,EAFD,SAAAC,EAEWP,EAAAA,EAAAA,EAAAA,EAAaE,QACpBE,IAAAA,IACHI,EAFM,GAIN,IA6BDC,EA7BCC,EAAAC,EAAAC,EACJC,EAAAC,EAAAC,EAyBGC,EAASC,KAAKC,MAAMD,KAAKE,KAAKT,EAAKA,EAAKG,EAAKA,GAAML,GAvBvDY,EAAOhB,EAAAA,EA1BXiB,EAAAR,EAAAG,EAsDI,IAAKP,EAAI,EAAGA,EAAIO,EAAQP,IAAKG,GAAMQ,EAAOL,GAAMM,EACxCZ,EAAI,GAAM,GArBlBF,EAAAe,SAAOlB,EAAAA,EAAYD,EAAUC,IA+B7BmB,EAAkC,SAClChB,EAvBJiB,EACIC,EACIjB,GAGJ,IAAAI,EAAIC,EAAJa,EAAA,EAEAf,EAAIS,EAAaJ,EAAjB,EACAW,EAAIN,EAAaL,KAAjBG,KAAA,EAAAO,EAAA,GAGAnB,EAAAqB,YACIrB,EAAAsB,OAAAjB,EAAIH,GACAF,EAAAuB,OAAAnB,EAAAgB,GACHpB,EAAAuB,OAAAN,EAAAC,GACDlB,EAAAA,OAAAA,EAAIe,GAEXf,EAjBDwB,YAAAC,KAAAC,UA0CI1B,EAAI2B,OAvBR3B,EAAA4B,SAyBI5B,EAAI6B,aAbJC,EAAI1B,SAAKa,GACTQ,KAAAM,YAAQb,GAA0BC,GAMlCnB,EAAAA,UAAIuB,QAAON,SAAeC,GAC1BlB,OAAAA,KAAIuB,aAMP,IAAAS,EAvBD,SAAAC,GA2CIR,KAAKS,oBAAsBD,EAAQC,oBAlBvCT,KAAAU,eAAAF,EAAAE,gBA2BIC,EAAU,SAASC,EAAMC,EAAYC,EAAUC,EAAOC,GAjB1DX,KAAAA,KAAOY,EAENjB,KAFDa,WAAAA,EAsBIb,KAAKc,SAAWA,EAEhBd,KAAKe,MAAQpD,EAAEuD,UAAWlB,KAAKmB,cAAeJ,GAC9Cf,KAAKgB,KAAOA,GAhBZL,EAAAM,UAAKP,iBAwBTC,EAAQM,UAAUG,KAAO,SAAC7C,EAAK8C,EAAOC,EAAQC,KAd1CZ,EAAAM,UAAAO,mBAAA,SAAAC,EAAAF,GACA,OAAAvB,KAAA0B,uBAAAD,EAAAF,GAAA,KAMHZ,EATDM,UAAAU,iBAAA,SAAAF,EAAAF,GA6BI,OAAOvB,KAAK0B,uBAAuBD,EAAWF,EAAS,KAb3DZ,EAAAA,UAAQM,aAAiB,SAAAQ,EAAaH,GAoBlC,OAAOtB,KAAK0B,uBAAuBD,EAAWF,EAAS,IAb1DZ,EAFDM,UAAAS,uBAAA,SAsBID,EAlBJF,EAoBIK,GAjBJjB,OAAAA,KAAQM,MACJM,GAAOtC,KAAKyC,IAAAA,EAAAA,EAAuBD,KAAAA,YAA5BG,KAuBX,IAAIC,EAAc,SAASjB,EAAMC,EAAYC,EAAUC,EAAOC,GAC1DL,EAAQmB,KAAK9B,KAAMY,EAAMC,EAAYC,EAAUC,EAAOC,IAhBzDa,EAFDZ,UAAAE,eAsBIY,eAAWC,EAlBfC,eAAAD,EAoBIhB,KAAM,YACNkB,MAAO,OAlBXvB,eAAQM,QAsBRY,EAAYZ,UAAUG,KAAO,SAAS7C,EAAK8C,EAAOC,EAAQC,GAZ1D,IAAIM,GAAAA,EACAlB,EAAAX,KAAAe,MAAAgB,UADJE,EAAAjC,KAAAe,MAAAkB,UAgBQE,EAAiBF,EAAYF,EAZrCF,EAAYZ,EACRc,EAAWC,KAAAA,WACXC,EAAAA,KAAWD,KACXhB,EAAMhB,KAAAY,KAENwB,EAAAA,OAGJP,IAAAA,EAAYZ,KAAAA,MAAUG,EAAOW,EAAcV,EAAeE,GAGlDU,cAAJjB,IACAzC,EAAI4D,UAAAA,OACJ5D,EAAI8D,SAAAA,EAAYf,EAAhBD,EAAA,IAGA9C,EAAAqB,YAcA,IAAI0C,EAZJ/D,EAcIgE,EAXJA,EADA3B,EAAA4B,OAAA,EACavD,EAAAA,IAAKwD,EAAMnB,MAAAA,GAASS,GAAAA,SAAAA,EAAAA,GAAAA,OAczB9C,KAAKyD,MAAM9B,EAAK+B,EAAI,GAAG,GAAK/B,EAAK+B,GAAG,IAAMpB,MAV1CtB,IAiBR,IAAA,IADA2C,EAZArE,EAAAyB,KAAAe,MAAA8B,aAAA7C,KAAAe,MAAAmB,MAGAY,EAAIP,SAAJQ,EAAAC,MAAA,GAAA,IAEIT,GAAc,SAAdA,IAAoB,GAAmBU,GAC9BP,MAD8BI,IACxB,EADwBI,EAAvC,IAAAJ,EAGHK,GAAM,EACHZ,GAAAA,EAIAQ,EAAAA,EAAAA,EAAAA,EAAgBP,OAAWK,EAAAA,EAAAA,IAuB3B,GArBJtE,EAAI0B,UAAA1B,EAAAwB,YAAAgD,EACJD,EAAaM,GAASL,EAclBH,EAAaL,EAAYI,GAX7BL,EAAIW,KAAUH,OAAAA,EAAaH,GAAA,GAAd9B,EAAb,IAAAU,GAiBc,QAhBd5B,EAAIuD,EAAAA,GAAAA,IAgBA,CAKI,GATJZ,EAAAA,GACA3C,GAAA,EAcIA,EAAIoC,GAZRpC,EAAAsC,IACAkB,GAAA,EACIxD,EAAAsC,GAIA,cAAAjB,EAeArB,EAAIV,KAAKwD,MAAM9C,EAAIwC,EAAiBE,GAZxC9D,EAAAe,SAAAgD,EAAAe,EAAAT,GAAAjD,QACA,GAAQoC,cAAJpC,EAAe,CACf2D,IAAAA,GAAAA,EAAevB,GAAfI,EAGAgB,EAAAA,KAAAA,MAAeI,GAAf,IAAAA,IAAA,EAAAC,IAEHC,EAAAxE,KAAAwD,MAAAQ,GAAA,IAAAA,IAAA,EAAAO,IAcOE,EAAQzE,KAAKwD,MAAMS,GAAU,IAAMA,IAAW,EAAIM,IAZ1DjF,EAAA0B,UAAA,OAAA0D,EAAA,IAAAF,EAAA,IAAAC,EAAA,IACAnF,EAAIyC,SAASsB,EAAA,EAAaM,EAAAP,QAKtB1C,EAAAV,KAAIuE,MAcAnB,GAAa1C,EAAIoC,GAAaI,EAAiBE,GAXnDsB,EAcIpF,EAAIuB,OAAOwC,EAAU3C,IAXzBiE,GAAIF,EACJ,WAAIzD,GACAX,EAAAA,OAASgD,EAAbD,GACG9D,EAAAuB,OAAAwC,EAAA3C,IAeKpB,EAAIsB,OAAOyC,EAAU3C,IAArBpB,GADHA,EAAA0B,UAHDD,KAGOe,MAAAqB,eACH7D,GAAIsB,EAAOyC,CACX,IAAAuB,EACA,cAAA7C,GAAA,cAAAA,EACA6C,EAAAjB,GAGPN,GAAA,EACJuB,EAAA,GAEDV,GACIlD,EAAAA,SAAYqC,EAAWF,EAAAA,EAA3B,GAEIkB,GACA/E,EAAIyC,SAASsB,EAAAD,EAAerB,EAAS6C,EAAa,GAG9CtF,EAAA0B,UAAA8C,OA3EZa,GAAA,WAAA5C,GACI4B,EAAAA,OAAJN,EAAAD,GAEIuB,GAAA,EA0EQC,WAAAA,GACHD,IACDrF,EAAAuB,OAAIqD,EAAJE,GACI9E,EAAAA,OAAAA,EAAIe,IAERf,EAAA2B,QAEC3B,EAAA4B,SAGR5B,EAAAuF,WAMGvF,IAAAA,EAAA,SAAAwF,GACH/D,KANDgE,qBAOIzF,KAAAA,YAAAwF,EACH/D,KAAAiE,YAAA,EAYDjE,KAAKkE,cAAgB,GAMzBC,EAAsBlD,UAAUmD,iBAAmB,SAVnDC,EACIC,EACAC,EACAC,GAHJxE,KAAAgE,kBAAAM,KAiBQtE,KAAKgE,kBAAkBM,OAE3BtE,KAAKgE,kBAAkBM,GAAMG,MACzB7D,KAAMyD,EAVdF,QAAAA,EAMIK,MAAKA,KAG6BL,EAAlClD,UAAAyD,iBAAA,SAAAC,EAAAhF,GAYA,IAEIiF,EAFAN,EAAOrF,KAAKC,OAAOS,EAAIK,KAAKkE,eAAiBlE,KAAK+D,aADtD,IAAA/D,KAAAgE,kBAAAM,GACA,OAAIA,KAIJK,GAAA3E,KAAAiE,YACA,IAAA,IAAKtB,EAAA,EAAKqB,EAAAA,KAAAA,kBAAyBM,GAAA9B,OAAAG,IAElC,GADGiC,EAAA5E,KAAAgE,kBAAAM,GAAA3B,GACHgC,GAAAC,EAAAL,SAAAI,GAAAC,EAAAJ,MAOO,OAAOI,EAAahE,MAUhC,IAAIiE,EAAiB,SALrBjE,EAOIC,EACAC,EACAC,EACAC,EALJ8D,EASInE,GAEAA,EAAAmB,KAAKiD,KAAAA,EAAgBA,EAAAA,EAAgBA,EAAhB/D,GACrBhB,KAAA8E,aAAKE,GAAL,IAAA3E,EACHL,KAbD+E,cAAAA,GAAA,IAAA1E,EAYIL,KAAKgF,iBAAmB,KAKxBC,EAAAA,UAAiB9D,eAFoB0B,YAAzC,OAEIoC,gBAAiB,QAKbtH,EAAAuD,OAAA2D,EAAA5D,WACAiE,oBAAIC,SAAkBC,EAAKC,GAE3B,IAAAF,EAAcA,KAAAA,iBAEdG,EAAAH,EACAnE,EAAIA,KAAAA,KAGJ,MADC,cAAAA,GAAA,WAAAA,GAAA,SAAAA,IACDmE,EAAOA,EAAuBI,GAAvBJ,EAAkBnF,KAAKuF,gBAAgBlE,IAMjDkE,gBAjB8B,SAAAlE,GAgB3B,OAAO,GASPD,KAAA,SAAIP,EAAAA,EAAaS,EAAKT,EAAtB2E,GACA,IAAA5E,EAAIE,KAAAA,KADAD,EAAab,KAAKa,WAGtBtC,EAAAyB,KAAAc,SAEAvC,EAAAA,OAAAA,EAAI0B,UAAYD,KAAKe,MAAM8B,YAG3BtE,EAAAkH,UAAIH,QAOA,IAAA,IALAI,EAAJJ,EAAII,KAAAA,iBACJhF,EAAID,IAAAA,EAAJ6E,GAEA7E,KAEIkC,EAAIgD,EAAAA,EAAAA,EAAcC,OAAAjD,EAAlBkD,EAAAlD,IAAA,CACA,IAAAiD,EAAIE,EAAAA,GACJH,EAAII,EAAcH,GADdE,EAAgBF,EAAQ,GAG5BG,EAAIH,EAAA,GAOJtB,EACAkB,QAAAxD,IAAAwD,EAAAG,GAEKH,EAAKxE,GAASsD,KAGfoB,MAoBIjF,UAAAA,KAAAA,MAAyBmF,OAAzBnF,IACHqF,EAAAhF,GAAAiF,EAAAlF,IAER6E,EAAA1F,KAAAgG,aAtBWzH,EAwBRuF,KAAJ9C,KAtBY4E,EAwBZlF,EACOG,EACHJ,EACAC,EAFJ4E,EArF2BjE,GA2F/BX,EAAA0D,iBAtBgBwB,EACAtB,EAwBhB0B,EAAc,GAWFN,EAAR,KAIRI,EAAAjF,GAAAkF,EAAAjF,IACAL,EAAAgE,KAAAmB,IAQIK,OAHAC,EAAAA,UAEAC,EAAAA,cAAJnG,KAAAuF,gBAAAlE,GACI4E,IAAAA,GACAG,oBAAJ3F,EACI4F,eAAJ3F,KAwBIsF,aAAA,SACAzH,EAtBJyC,EA1BQ4E,EAmDN1E,EACEoF,EAjDIC,EACAhF,EAmDJ8D,EACIhE,GAEA,OAAIL,EAAAA,MAMH,IAsBDwF,EAAIV,SACJlF,EACAC,EACAC,EA3DJC,EA6DIC,EACAyF,EA3DJ1B,GAEAF,EAAe/C,KAoEX9B,KACAY,EAlEAC,EAoEAC,EAlEAC,EAsEAC,EACA8D,EACAC,GAGA/E,KAAA0G,2BAAI,EAEJ7D,KAAAA,4BACK8D,GAnEbhJ,EAAEuD,OAAOsF,EAAqBvF,UAAW4D,EAAe5D,WA4EhDoE,eAAA,WACA,IAAArE,EAAIA,KAAAA,KA5DJ,MA8DC,UAAAA,EAlEM,GAoEM,cAATA,EAlESkF,EAoELjG,WAAJ1B,EAnEH,EACM+C,IAMX0E,aAAc,SA8ENzH,EACIqI,EAGAC,EAMHvC,EAnFLgC,EAqFIC,EACAhF,EAnFJ+D,EAqFIjE,GAEIyF,EAAc,GAAdA,IACAC,EAAAA,EAAed,GACfe,EAAAA,EAAc,GACjBC,EAAUjG,EAAAA,GACP8F,EAAAA,EAAA,GAGAL,EAAAxH,KAAAC,MACA4H,KAAAA,IAAAA,GAAAA,EAAAR,EAAA,IAAA/E,IAjFJ2F,EAAQjI,KAAKyD,KAqFbzD,KAAAkI,IACA9F,EACIpC,KAAAmI,IAAA,GAAArB,EAAAO,EAAA,IAAA/E,KASA8F,EAAIV,EACAW,EAAAJ,EAICK,GACGhJ,UAAAA,EAAI0B,EAAAA,EAAAA,GAAgBuH,EAGvBxH,KAAAuF,gBAAAlE,GASLuF,EAAA,KACAC,EAAA,KAIAhE,EACA8D,GAAA,MAAAA,GAAA,MAAAA,EAEA3G,KAAAe,MAAA0G,qBAnGEzH,KAAKe,MAAM8B,YAGjB6E,EAAc1H,KAAKe,MAAM2G,YA6GhB,GARDC,EAAAA,YAAAA,KAAAA,aACIJ,QAAUtI,GAGd,UAAA+B,IACAsD,EAAA,GAGC,cAAAtD,EAEG4G,EAAAA,UAAAA,EACHrJ,EAAAe,SACJmH,EAlGDc,EAAU,EAoGVL,EAAAT,EA1LmD,OA6L3ClI,CAGA,IAAAsJ,EAAAjC,EAAIe,GAEIpI,EAAAA,EAAAA,GAGHuJ,EAJDlC,EAIO,GAKVoB,GAAA,EAEAa,GAAAE,IACJnB,EAAA3H,KAAAC,MACDX,KAAAA,IAAIe,GAAAA,EAEAqI,GAFJpG,IArGJsF,EAAY5H,KAAKyD,KA6GjBzD,KAAAkI,IACIa,EACJ/I,KAASgJ,IAAI,GAAGC,EAAQJ,GAAetF,MAQnC,IAAAsE,EAOAC,EAwBI,GAvBJ,WAAA/F,GAlHJ8F,EAAc,EAoHVC,EAtNhB,EAuNgBC,GAAImB,IAEHrB,EAAA,EAlHLC,EA1JW,GA8RHe,EAjGL,CA8JC,IAAAH,EAlJAC,EAqJIQ,WAAJpH,GAAgB,UAAA/B,GAChB0I,EACIpJ,EAAIe,KAAAA,MACAmH,KAEAS,EAGJ3I,EAAIe,GAQfqH,GA7JWgB,EAAcJ,EA+J1BK,EAAAb,IA5JYY,GAAe1B,IA+J3B2B,EAAA,GAQQrJ,KAAAA,4BACI8J,WAAJ9J,GAEI2I,UADAD,EAKJK,EAAAA,UA5UF,OAgVMe,EAOIC,MADRjB,EAEH9I,EAAA0B,UAAA1B,EAAAiJ,OAAAe,QAAAC,YACD,gBAEP,MAAA7B,IA5KuBpI,EAAI0B,UAAY1B,EAAIiJ,OAAOe,QAAQC,YA8K3D,gBAIHjK,EAAA0B,UAjWa,OAoWdwI,EAAcnJ,SAWCwC,EAUA4G,EACVC,EAAgBA,EAtBzBf,IA6BIvC,IAAAA,IAAgB4C,EAAA,EAAAC,EAAAJ,EAAWtF,OAAAyF,EAAAC,EAAAD,IAAA,CACnB3G,IAL8CsH,EA5KlCC,EAiLhBC,EAAAhB,EAAAG,GAGI3G,EAASyH,KAAAA,MACF/H,KAAAA,IAAS,GAAA8H,EAAU,GAAAxC,EAAA,IAAA/E,IAG1ByH,EAAA/J,KAAAyD,KACApB,KAAS4E,IACAnF,EACLO,KAAA8F,KAAA0B,EAAA,GAAAxC,EAAA,IAAA/E,KAxLI,KAAI4G,EAAca,GAAlB,CA+MJC,GA1MI1K,EAAI0B,UAAY4C,EAiM5BtE,EAAAe,SACI4J,EA/LY3B,GAAWR,EAAeD,GAAe,EAAI,EAiMzDqC,EAAYhB,EACZiB,QAMwBpH,IAApBqH,GA/LQtB,EAAaF,KAiMzBM,EAAAtB,GAAAmC,EAAApC,GACIyC,CACA,IAAAC,EAAArK,KAAAmI,IACAe,EACIgB,GAGHI,EAAAtK,KAAAkI,IAAA6B,EAAAnC,GACEtI,EAAIe,SACPgK,EACAH,EAAgBF,EAChBG,EAAAE,EACHvC,GAED,IAAAe,EAAAtF,QAAA,SAAAxB,IA7LuC,MAAnB2F,EAiMjBpI,EAAA0B,UAAA1B,EAAAiJ,OAAAe,QAAAC,YAAA,oBAAP,MAAA7B,IA3DkDpI,EAAA0B,UAAA1B,EAAAiJ,OAAAe,QAAAC,YAhItB,oBAoMrBc,EAGP/H,GAHOgI,IAYPD,GAAA,EACIE,GAAAA,GAEI5H,EAAU6H,SACbH,EACD/B,EAAA,EAJJgC,EAAAD,EArMwBvC,IAgNbnF,KAAP8H,4BAAAd,GAJJ5I,KAAA2J,eArMoBpL,EA4MhBqK,EACJgB,EAAiBzB,EAGRjJ,EAJTqI,GASIsC,EAAc1B,EACd2B,EAAJd,GAzMQ,GAAa,SAAThI,EAAiB,CAEjBzC,EAAIwL,YAAc,EAmN1BC,EAAAA,UAAcC,QA/MN,IAAIC,EAAgBlK,KAAK+E,cAAcoF,QAAQvE,GAqNvDwE,EAAiBnL,KAArByD,KAAAqE,EAAAmD,GAEA9B,EAAAnJ,KAAAwD,OAAAsE,EAAAsD,GAAA,GAjNkC,IAAlBH,IAmNhB3L,EAAAe,SACgBmH,EAjNIkB,EAAc,EAmNlCT,EAAAT,EACa6D,GAEbF,EAAAA,SAjNoB3D,EAmNpBkB,EAAAZ,EAAAqB,EAAA,EACgBzF,EAAIyH,EACJA,UAzRA7L,EAAA0B,UAAIsJ,EACJhL,EAAAA,SAMAkI,EACIc,EAAA,EACAL,EAAAT,EACAM,GAKIxI,GAAAA,IAGH,MAAAoI,EACDpI,EAAA0B,UAAA1B,EAAAiJ,OAAAe,QAAAC,YACA,oBAEIe,MAAAA,IACHhL,EAAA0B,UAAA1B,EAAAiJ,OAAAe,QAAAC,YACDjK,oBAQRA,EAAAe,SACAmH,EACIc,EAAKoC,EAQRzC,EAAAT,EACDmC,IA0PJrK,EAAAwL,YAAA,EAGA9C,GAAA,SAAIsD,GAAmBzE,EAAAQ,IACnBkE,EAAAA,UAAAA,EAGJ,IAAAlE,GACA/H,EAAI0B,EAAJqI,YAAgBzF,GAAhBxB,MAAA,GAEH9C,EAAAkH,UAAA,OACJlH,EAAA8J,SAtNepB,EAwNhBC,EAllBY,EAmlBHuD,EAAY5E,EACb6E,KAAMC,kBAENlB,GAtNQlL,EAAI+J,YAAYrB,GAAc5F,MAhYlC,IAylBRkJ,EAAAA,UAAUX,QACVY,EAAQZ,SAtNI3C,EAwNZR,EA5lBQ,EA6lBHmE,EAAYC,EACb7K,KAAAgF,kBAEA8F,GACAvM,EAAA+J,YAAArB,GAAA5F,MAjmBI,IA0mBP,OAFD9C,EAAAwL,YAAIQ,GAEHlD,EAAAC,MAIG,IAAAmB,EAAA,SACA7H,EACAC,EAAUC,EACNC,EACAC,EACJ8D,EAAUC,EACN2D,EACAoB,GAEJjF,EAAA/C,KACA9B,KAAUY,EACNC,EACAC,EACAC,EAnNZC,EAqNY8D,EACAC,GAEI/E,KAAA0I,QAAAA,EAAAA,EAAA9H,KAAA,KACAmK,KAAAA,cAAAA,GAMApN,EAAAuD,OAAAuH,EAAAxH,UAAA4D,EAAA5D,WAIIoE,eAAA,WACApG,IAAAA,EAKP+B,EAAAhB,KAAAgB,KAoBQ,MA9OR,UAATA,EA4NQM,EA1mBL,GA2mBS0J,WAAJhK,EACAM,EAzmBX,GA+mBmBA,EA9mBbA,GA+mBatB,KAAAe,MAAAkK,kBAMA1M,GAAAA,IAGC+C,GAaTgJ,aAAA,SAAAY,GACIJ,IArOZ5B,IAAW,EAAG,IA0OVC,EAAAD,EAAA,GAAUE,EAAA,EAQN+B,EAAAxN,EAAAyN,IAAAF,EAAAG,MAAA,sBAAA,SAAAC,GAEA,IAAArC,EAAA7F,SAAAkI,EAAAtI,MAAA,GAAA,GAAA,IACJqG,EAAKiC,EAALtI,OAAA,GAuBY,MArBR8G,MAAAA,EAEM,IAAAX,EAAA,KACNA,GAAAC,EAAAH,EAAAG,EAAAH,GACAC,EAAAzE,KAAA0E,KAxOgC,IAA7B,OAAOoC,QAAQlC,KAiPdF,EAAA,IAAIqC,EAIJpC,GAAAH,IAnCA6B,YAuCIS,QAAAlC,GAAAJ,KAGA,OACAC,OAAAA,EACAyB,MAAAQ,IAgBQvK,UAAAA,SAF0BrC,EAI9BA,EACAgD,EACAgG,EAIIjB,EACIkF,EACA1F,EACJ6E,EACIa,EAIAC,GAGA,IAsCX7B,EAAA,SACJ8B,GADI,OAOGzM,KAAAC,MACAyM,KAAAA,IAAAA,GAAAA,EAAUlH,EAAK,IAAAlD,KAAAhD,EAAAkH,UAAA,SAQlB,IAoBjBmG,EACAhL,EArBiBiJ,GAAAvD,EAdDC,GAeIuD,EAAA,EACHgB,EAAA,EACJe,EAAA5M,KAAAwD,MAAAlB,EAAA,GACJuK,EAAAvN,EAAAiJ,OAAAe,QAAAuD,cAEDjJ,EACA,MAAAkJ,EAlNR/L,KAAAe,MAAAiL,mBAoNHhM,KAAAe,MAAA0G,qBAEDwC,EAAA,SAAAjJ,EAEAgJ,EAAAC,EAt0BkB,EAiDtB,EAyxBIgC,EAAA1E,EAAA,EACA2E,EAAA,IAAgBvJ,EAAcH,EAAQG,EAAKpB,EAAAP,GACvCmL,KAKI5N,KAGH6N,EAAApM,KALDsK,aAKWsB,GACPrM,EAAAA,EAAAA,MACH6K,EAAAgC,EAAAlD,OA7RL,IAASvG,EAAI,EAAGA,EAAIyH,EAAe5H,OAAQG,IAAK,CAiSpD,IAAAmG,EAAAsB,EAAAzH,GAGAqD,GAWIF,EAAAgD,EAAA,GAAAhD,EAAAgD,EAAA,IACInD,MAGAI,EAAAA,EAAJD,EAAAgD,EAAA,QACI7B,EAAAA,EAAuBnB,EAA3BgD,EAAA,OAcIvB,GAAWvG,GAKX0G,EAAAA,UAAc7E,EAjTVtE,EAAIe,SAASiL,EAAS0B,EAAQzB,EAAQD,EAASP,IAKvD,IAAK,IAAIS,EAAS,EAAG5E,EAAM8E,EAAMnI,OAAQiI,EAAS5E,EAAK4E,IAAU,CAmT7D,IAAAC,EAAAC,EAAAF,GACA4B,EACIzG,YAAiBU,EAAAA,IAIjBmD,EAAK6C,EAAAA,GAaLC,EAAAA,EAAAzC,EASA,GARHS,EAAAX,EAAAiB,GAhUDL,EAAQZ,EAAeiB,EAAYpB,GAwU/BmB,GAAK0B,EAEDtL,EACAO,GAHJsI,GAwCA,OAlWAU,IAAYC,IAyVhBA,GAAIgC,GASAH,GACA/N,IAAAA,IACH,IAAA,IA1EL,IA2EO,IAEH,MAYH,IAAA,IAMGwL,GAAAL,EACIxJ,MACJ,IACIqG,IAGA/H,IAAAA,IAgBP,IAAAwM,EAAA,GAxX0B,MAAXsB,EA2XTtB,EAAPU,EAAAzI,MACH8H,EA3kBLA,EAAArB,GA8kBIgD,KAA0B/D,UAoBrBgE,EAAAA,KAAyBhE,QAAKiE,MAE9BjD,KAAAA,IAAAA,EAALmB,EAAAvE,GAxYwBrH,KAAKkI,IA4Y7BsF,EAAwBxL,EACxB4D,EAGI8H,EAAkCrG,KAU7B,IAAA,IAJGoG,EAAAA,KAAyBzN,IAAAA,EACrByN,GAGPE,EAAA,EAAAA,EAAA7B,EAAAvI,OAAAoK,IAXT,GAnYyB7B,IAAY/K,KAAKe,MAAM8L,kBAkZ3B,MAAAR,EACTS,CAEGC,EAEH9N,KAAUC,MApBtBD,KAAAmI,IA7XgC,GAqZZ4D,EACZzM,EACAyO,GAFYzL,IAjZIhD,EAAI0B,UAAYD,KAAK2I,cAAcoC,EAAQ6B,IA4Z9CK,GAAeC,EAA5BpB,EA1ZoBvN,EAAI8J,SAAS0C,EAAQ6B,GAAIG,EAASxF,EAAU,GA4ZhEhG,EAAA,KAzZoBhD,EAAIe,SA4ZxByN,EAAAlB,EACgBI,EACZhN,KAAAmI,IAAA,EAAAnI,KAAAwD,MAAAlB,IACkBgG,GApZC,MAAX8E,IA6ZZvB,GAAArB,GA1ZQK,GAAeL,EAEf,MACJ,IAAK,IACDlL,EAAI0B,UAtoBN,OAmiCJkN,EAAAA,SACKC,EACA5K,GAARwH,EAAqB,GAAA,EACboD,EAAA7C,EAA4BnH,GAEvC0G,GACKuD,EAEI,MAHT,IAAA,IAIGnB,EAAAoB,cAAA/C,EAAA0B,EAAAxC,GACHK,GAAWL,EAAkB,MAA7B,IAAA,IAjBR,IAAA8D,EAAAhD,EAAAsB,EAsBU,GACFjB,GAFUC,EAAAA,EAAApB,GArZUI,GA2ZxB,CACA,IAAA2B,EAAAC,EAAAzI,MACA8H,EACAA,EAAArB,GAKY,GAAAzJ,KACAe,MAAKqM,gBACI,CAYMzK,IAAEH,EAAF+H,GAA2B5H,EAAlC4H,GAAA,EANZ,IAUH,SAAAvJ,GAAA,SAAAhB,KAAAgB,YAhCSgB,IAAAyJ,GAjYclK,EAAUuK,EAoa/B,CAee0B,OAbVjP,EAAc0B,UAAtB,SACQ1B,EAAce,SACtB4N,EAAArB,EACUtE,EAAV,EACUiD,EAAVD,EACA,GAEQoB,EAARA,EAAAnJ,SACAoJ,KAAA,WAla4BhL,MAAO2M,EAAgBhG,EAAU,EAAG,IAqa5DhJ,EAAA0B,UAjmCM,OAmmCiBmH,GAlaEyD,EAAWA,EAAYpB,GAoahDI,IAEY,KA3qDJ,KA4qDA2B,EAAAA,EAAAxI,MAAAsD,EAAAuE,GACJ,MACQ,KA7qDN,KA8qDEW,EAAAA,EAAAxI,MACJ,EACI6H,EAAAtE,GARR,MAWA,KAlrDO,KAorDgBkH,MAjEjB,KAtnDH,KAsxCyBjC,EAAMA,EAAIxI,MAoa3BsD,EAAAuE,EACa6C,EAAcC,GAC1C,IAtEU,IAAAf,EAAA,EAAAgB,EAAApC,EAAAhJ,OAvVkBoK,EAAIgB,EAyadC,IAClB,CAva4B,IAAId,EAAU9N,KAAKC,MAya/BD,KAAAmI,IAChB,GAC2B0G,EAA3BlB,EAAAtG,GAAA/E,IAGAhD,EAAA8J,SAvagCmD,EAAIoB,GA0ahBmB,GAAYX,EAAP7C,GACrByD,EAza4BzG,SA2UxChJ,EAAA0B,UAAA,SAwGA1B,EAAAe,SA3aoC4N,EA6ahCe,GAAmCC,UAAbC,KAATnN,KAAiCoN,EAAAA,GAC9C5D,EAAAD,EA3ayC,UAATvJ,EApvBhC,EAnDuB,QAitC3B,SAAAA,GAAA,SAAAhB,KAAAgB,YAla6CgB,IAAbyJ,GA6aX4C,EAAYvC,GAGPsC,EAAd3J,MACRmH,KAAA,OACAhL,MAC4B4K,EAAK0C,OANrCX,EApawChG,EAAU,KA+bzC+G,GAAL7E,OArUY8C,EA7KwB,SAAA3K,EAAAyK,EAAA5C,GAfR,OAgBS8E,IAAL,QAAAhD,QAAAc,KACIb,GAAAA,GAjBR5J,EA4LhB2K,CAAAzC,EAAAuC,EAAA5C,GACHqB,EAhKuB,SAAAlJ,EAAAyK,EAAIU,GAaR,OAPIxO,IAAAA,KAAAA,QAAAA,KAKHqD,GAAA6H,GAED7H,EAmJnB4M,CAAA1D,EAAAuB,EAAA5C,GA6ULlL,EAAA0B,UAAYwO,SAIhBC,IAAAA,IAHCvC,EAPLP,EA9aYhL,EAwbR8N,EAAAA,EAAAA,EAAAA,EAAyBlM,OAAzBkM,IAEI/L,GADJhC,EAAQmB,EAAWlB,IACnBgL,KACI/F,EAAJsG,EAAAvL,KAtbqB,SAATgL,GAwbRrN,EAAKwC,OACDgB,EAAAA,KAAAA,QAAJxD,EAAAoQ,KACApQ,EAAKoE,SAAOkD,EAAM,GAAKjF,EAAK4B,GAA5B5B,EAAwCiF,IACpC9D,EAAAA,WACH,aAAA6J,GACDrM,EAAAhB,EAAAqC,EAAA,GAAAA,EAAA,GAAAA,EAAA,KAQHoF,aAAA,SAlBLzH,EAnaQyC,EAwbR0N,EACI3M,EACAE,EACAjB,EACA4N,EACAC,EALJxN,GASoBuE,EAAA,GAAhB,IAEIkJ,EAAc7M,EAAAA,GACdI,EAAYf,EAAhB,GACIT,EAAa+E,EAAK/E,GAGtB4F,EAAIsI,KAAW7P,MAtbPD,KAAKmI,KAAK,GAAM7F,GAAUuE,EAAgBQ,EAAW,IAAO/E,IAgchEiM,EAAJvO,KAAAyD,KACIsM,KAAJ7H,IACA9F,EACApC,KAAAmI,IAAA,GAAArB,EAAAO,EAAA,IAAA/E,KAII0N,GAAAA,UAAQjO,EAAA,EAAA,EAAAsD,GAAAgB,EAAZ0E,EA1biB,SAAThJ,EA93Bc,EAiDtB,EA+0BsBhB,KAAKe,MAAM2G,YA8bjCnJ,GAAI0Q,EAAMF,aAAUA,MAApB,CAEA,IAAAxC,GAAA,EAIIyC,EAAWxB,GAAN,IAALlH,GACA4I,EAAW1B,GAAN,IAALjH,GACA4I,EAAW3B,GAAN,GAEL4B,KAAQ5B,UA1bIjP,EA4bR0B,EACAX,EACPiI,EA1bejB,EA4bhBC,EA/CJX,EAAA,GAAA,GA1YoBA,EAAQ,GAAG,GA4b/BA,EAAA,GAAA,GA1boBA,EAAQ,GAAG,IA8b3B2G,GAAA,EADJ3G,EAAA,GAAA,IAAAU,GApbgBV,EAAQ,GAAG,IAAMW,GA8bxB8I,EAAAA,GAAAA,GA3bOrP,KAAKsM,UACD/N,EACAyC,EA8bhBsM,EACI/F,EACI+H,EAGC/I,EACLX,EAAStG,GAAT,GACHsG,EAAA,GAAA,GAZLA,EAAA,GAAA,GAjboBA,EAAQ,GAAG,IAGf2G,GAAY,EA8cxB,IAAAgD,EAAAtQ,KAAAyD,KArcYzD,KAAKkI,IACD9F,EAuchBgE,KAAgB+B,KACD,GAAKpG,GAChB4E,EAAA,GAAA,GAAAU,EAAA,IAAA/E,KAGOiL,EAEAvN,KAAAC,MACHD,KAAAmI,KACA9F,GAAS4E,GACZN,EAAA,GAAA,GAAAU,EAAA,IAAA/E,IAIL,GAAAgL,GAAAC,EAAA+C,EAAA,CArcYhR,EAAI0B,UAt5BF,OAu5BF,IAAIuP,EAAcjI,EAAU,GAAKyC,EAAc,GAAK,EAuchE9E,EAAAA,EAAqBqK,EAAAC,EAAAhD,EAASiD,SAlctBzP,KAAKsM,UAucT/N,EACIkR,EACAnO,EACHiG,EACDjB,EA9B8CC,EAtatCT,EAucZF,EAAA,GArcYA,EAAQ,GACRA,EAAQ,IAiChB,MAyaI,SAAJ5E,GArcI8E,GAAiBQ,GACA,MAAjBW,IAGA1I,EAAI0B,UAAYD,KAAKe,MAAM2G,YAwcd,IAAjBgI,GACIjJ,EAAIkJ,EAAUC,YAAd3I,GAAA5F,MAAA,GAEA9C,EAAIsR,UAAJ,OACAtR,EAAIsH,SACA+F,EACAkE,EAh7CI,EAi7CJlE,EAAO,EACP/F,KAAAA,oBAGAA,EAAAA,UAAM8J,QACNE,EAAAA,SAHG5I,EAKHR,EAx7CI,EAy7CJmF,EAAO,EACP/F,KAAAA,qBAhcA,EAAG,MA0cX,IAAA4G,EAAA,SACA7L,EACAC,EACAC,EACAC,EACAC,EACA8D,EACAC,GAEAyB,EAAIuJ,KACJ/P,KACAY,EArcAC,EAucAC,EACAkP,EArcAhP,EAucA8D,EACA2K,GAncJzP,KAAK0M,uBAAyB1M,KAAK2M,mCAwc/B3M,KAAA0G,2BAAI,EACJ1G,KAAA0J,4BAAA,GAQA/L,EAAAuD,OA3cJuL,EAAwBxL,UA6cpB4D,EAAIqH,UA3cR1F,EAAqBvF,WAEjB0L,iCAAkC,WAmdlC,IAAI8C,IADJ/C,EAAA,EACI+C,EAAAA,EAAAA,EAAJzP,KAAuBY,KAAA4B,OAAAG,EAAAkD,EAAAlD,IAAA,CACnBsN,IAAAA,EAAaC,KAAAA,KAAAA,GAIbhE,EAAY+D,EAAaA,GACzBlK,EAAAH,EAAA,GACAuK,EAAAlR,KAAAmI,IACHsF,EAndW3G,EAAcD,GAudtBvH,OAAAA,GAQHgH,gBAAA,SAAAlE,GAxdG,IA0dJE,EAAAF,GA1dqBrB,KAAKc,SAAWd,KAAKa,YA2d1CtC,OAAIkH,KAAAA,IACJ,IACIxG,KAAAyD,KAAA1C,KAAA0M,uBAAA,EAAAnL,KAIAuO,eAAOM,SACPC,EACAC,EAxdAC,EA0dAtD,EACA6C,EACIvI,GAGIsI,IAAAA,GAAAA,EAAO5C,GAAA,EAvdXuD,EAASvD,EAAeC,EA4dxBjO,KAASiC,GAGbsP,EAAA,IACAjS,EAAIkS,YACAlS,EAAAmS,IAAAxD,EAAA3F,EAAA0F,EAAAC,EAAAjO,KAAA0R,GAAA,GACHpS,EAAA4B,aAQO4P,IAAAA,EAAAA,SAAAA,EAAAA,GAkBIa,MAAAzD,QAAAC,GAGA7O,KAAAA,IAAAA,EAMAsS,GAAAA,EAAAA,OACH7Q,KAAAoN,IAAAA,EAAA/B,MAAA,SAAAD,IAAA,SAAAwB,GAAA,OAAAxJ,SAAAwJ,EAAA,MACJ,GAAAQ,EAAA5K,OACJxC,KAAAoN,IAAAA,EA1eAC,UAAU,EAAG,GA4edhC,MAAA,SACAD,IAAA,SAAAwB,GAAA,OAAKxJ,SAAAwJ,EAAWkE,MAEf9Q,KAAAoN,IAAAA,EAAA2D,MAAA,IAAA3F,IAAA,SAAAwB,GAAA,OAAAxJ,SAAAwJ,EAAAA,EAAA,MAED5M,KAAA0N,MAAA,iBAAAsD,EAAAA,EAAA,GAIAC,EAAAhQ,WAKIiQ,KAAAA,WAhfR,OAAOlR,MA4fSzB,MAAAA,WACH,OAAAyB,KAAA0N,MAAA,EAEJ,QACG1N,KAAAoN,IACA+D,IAAAA,SAAAA,GAAAA,OAAAA,KAAUD,MAAAA,KACVC,OAAAA,KAAAA,OACA5S,KAAAA,MACH,IAIGwR,IAIA/P,KAAAoN,IACIhC,IAAA,SAAAzI,GAGIpE,OAFJA,EAAAA,KAAI0B,MAAAA,GAEA,KADJ0C,GAAAA,EAAIuJ,IAAAA,IAAYkF,EAAAA,EAAAA,EAAhBzO,GAA8B0O,SAAA,KAC1B9S,OAAA,IAEIoE,EAAK2O,IAIT/S,KAAAA,KAcJgT,MAAA,WACH,IAMhBC,EArRLC,EA+QqBC,EAAA1R,KAAAoN,IAAA,GAAA,IACJuE,EAAA3R,KAAAoN,IAAA,GAAA,IACJwE,EAAA5R,KAAAoN,IAAA,GAAA,IACJ4D,EAAAhR,KAAA0N,MAlgBGtG,EAAMnI,KAAKmI,IAAIsK,EAAGC,EAAGC,GAogBzBrT,EAAIuF,KAAJqD,IAAAuK,EAAAC,EAAAC,GAhgBInE,GAAKrG,EAAMD,GAAO,EAClBqG,EAAIpG,EAmgBDD,EAEXtF,GAAAA,IAAAA,EACA2E,EAAAA,EAAAA,MACAiC,CAGAoJ,OAFApF,EAAAA,EAAAA,GAAAA,GAAAA,EAAyBA,EAAAA,GAAAA,GAAAA,EALdtF,GAOX0K,GAlgBY,KAAKH,EACDF,GAAKG,EAAIC,GAAKpE,GAAKmE,EAAIC,EAAI,EAAI,GAC/B,MACJ,KAAKD,EACDH,GAAKI,EAAIF,GAAKlE,EAAI,EAClB,MACJ,KAAKoE,EACDJ,GAAKE,EAAIC,GAAKnE,EAAI,EAG1BgE,GAAK,EAET,OAASA,EAAO,IAAJA,EAASC,EAAGA,EAAGhE,EAAGA,EAAGuD,EAAGA,IAGxCc,OAAQ,WAEJ,MACI,KAFQ7S,KAAKwD,MAAmB,IAAbzC,KAAK0N,QAAcC,OAAO3N,KAAKoN,KAI7ChC,IAAI,SAAAzI,GAGD,OAFAA,EAAI1D,KAAKwD,MAAME,GAEK,KADpBA,GAAKA,EAAI,IAAM,IAAMA,EAAI,EAAI,EAAIA,GAAG0O,SAAS,KACpC7O,OAAe,IAAMG,EAAIA,IAErCoP,KAAK,KAIlBC,IAAK,SAASlE,EAAQD,GAClB,IAAIG,EAAShO,KAETiS,EAAIpE,EACJqE,EAAQ,EAAJD,EAAQ,EACZjB,EAAIhD,EAAOuD,QAAQP,EAAIlD,EAAOyD,QAAQP,EAEtCjD,IAAOmE,EAAIlB,IAAM,EAAIkB,GAAKA,EAAIlB,IAAM,EAAIkB,EAAIlB,IAAM,GAAK,EACvDmB,EAAK,EAAIpE,EAETX,GACAY,EAAOZ,IAAI,GAAKW,EAAKD,EAAOV,IAAI,GAAK+E,EACrCnE,EAAOZ,IAAI,GAAKW,EAAKD,EAAOV,IAAI,GAAK+E,EACrCnE,EAAOZ,IAAI,GAAKW,EAAKD,EAAOV,IAAI,GAAK+E,GAGrCzE,EAAQM,EAAON,MAAQuE,EAAInE,EAAOJ,OAAS,EAAIuE,GAEnD,OAAO,IAAIhB,EAAM7D,EAAKM,KAM9B,IAAIO,EAAa,SAASE,EAAaD,EAAWE,EAAaE,GAI3DtO,KAAKmO,YAAc,IAAI8C,EAAM9C,GAC7BnO,KAAKkO,UAAY,IAAI+C,EAAM/C,GAC3BlO,KAAKoO,YAAcA,EACnBpO,KAAKsO,UAAYA,EACjBtO,KAAK8O,YAAcR,EAAYF,GAGnCH,EAAWhN,UAAUoN,UAAY,SAASe,GAMtC,OALAA,EAAQnQ,KAAKmI,IAAIgI,EAAOpP,KAAKoO,aAC7BgB,EAAQnQ,KAAKkI,IAAIiI,EAAOpP,KAAKsO,WAC7Bc,GAASA,EAAQpP,KAAKoO,aAAepO,KAAK8O,YAGnC9O,KAAKmO,YAAY6D,IAAIhS,KAAKkO,UAAW,EAAIkB,GAAOgD,SAG3D,IAAIC,EAAY,SACZlE,EACAmE,EACApE,EACAE,EACAE,GAKAtO,KAAKuS,cAAgB,IAAItE,EAAWqE,EAAcpE,EAAW,EAAGI,GAChEtO,KAAKyO,cAAgB,IAAIR,EACrBqE,EACAnE,EACA,GACCC,GAELpO,KAAKoO,YAAcA,EACnBpO,KAAKsO,UAAYA,GAGrB+D,EAAUpR,UAAUoN,UAAY,SAASe,GAGrC,OAFAA,EAAQnQ,KAAKmI,IAAIgI,EAAOpP,KAAKoO,cAC7BgB,EAAQnQ,KAAKkI,IAAIiI,EAAOpP,KAAKsO,aAChB,EACFtO,KAAKuS,cAAclE,UAAUe,GAE7BpP,KAAKyO,cAAcJ,WAAWe,IAI7C,IAAIV,EAAyB,SAAS9N,EAAMC,EAAYC,EAAUC,EAAOC,GACrEL,EAAQmB,KAAK9B,KAAMY,EAAMC,EAAYC,EAAUC,EAAOC,GACtD,IAAI2B,EACAkD,EAEJ,QAA6B7D,IAAzBhC,KAAKe,MAAMgB,UAAyB,CACpC,IAAIA,EAAYyQ,EAAAA,EAChB,IAAK7P,EAAI,EAAGkD,EAAM7F,KAAKY,KAAK4B,OAAQG,EAAIkD,EAAKlD,IACzCZ,EAAY9C,KAAKkI,IAAIpF,EAAW/B,KAAKY,KAAK+B,GAAG,IAEjD3C,KAAKe,MAAMgB,UAAYA,EAE3B,QAA6BC,IAAzBhC,KAAKe,MAAMkB,UAAyB,CACpC,IAAIA,GAAauQ,EAAAA,EACjB,IAAK7P,EAAI,EAAGkD,EAAM7F,KAAKY,KAAK4B,OAAQG,EAAIkD,EAAKlD,IACzCV,EAAYhD,KAAKmI,IAAInF,EAAWjC,KAAKY,KAAK+B,GAAG,IAEjD3C,KAAKe,MAAMkB,UAAYA,IAI/ByM,EAAuBzN,UAAUE,eAC7BY,eAAWC,EACXC,eAAWD,EACXhB,KAAM,UACN4N,UAAW,UACXC,UAAW,WAGfH,EAAuBzN,UAAUG,KAAO,SAAS7C,EAAK8C,EAAOC,EAAQC,GACjE,IAiBIiM,EACAwB,EACAE,EACAC,EACAsD,EACArD,EAtBArN,EAAY/B,KAAKe,MAAMgB,UACvBE,EAAYjC,KAAKe,MAAMkB,UAGvBpB,EAAab,KAAKa,WAElBD,GADOZ,KAAKgB,KACLhB,KAAKY,MACZmO,EAAW,EAAI9P,KAAKE,KAAK,GAEzBuT,EAAO,IAAIL,EACXrS,KAAKe,MAAM8N,UACX,UACA7O,KAAKe,MAAM6N,UACX7M,EACAE,GAUAgN,EAAQ,SAAAgD,GAAA,OAAMA,EAAIpR,GAAcU,GAEpChD,EAAIoU,OAGJpU,EAAIqU,QAAQ,GAAK3T,KAAK0R,GAAK,KAC3BpS,EAAI0Q,MAAMF,EAAUA,GAGpB,IAAK,IAAIpM,EAAI,EAAGkD,EAAMjF,EAAK4B,OAAQG,EAAIkD,EAAKlD,IAGxCqM,EAAKC,GAFLzB,EAAI5M,EAAK+B,IAEI,IACbuM,EAAKD,EAAMzB,EAAE,IACb2B,EAAKF,EAAMzB,EAAE,IACbiF,EAAKxD,EAAMzB,EAAE,IACb4B,EAAQ5B,EAAE,GAEVjP,EAAI0B,UAAYyS,EAAKrE,UAAUe,GAC/B7Q,EAAIe,SAAS0P,EAAIG,EAAID,EAAKF,EAAIyD,EAAKtD,GAGvC5Q,EAAIuF,WAMR,IAAIuL,EAAmB,SAAS9Q,EAAK0R,EAAY4C,EAAa7R,GAC1DhB,KAAKzB,IAAMA,EACXyB,KAAKiQ,WAAaA,EAClBjQ,KAAK6S,YAAcA,EACnB7S,KAAKoR,cACS,SAATpQ,GAA4B,SAATA,IACpB6R,GAAetU,EAAIiJ,OAAOe,QAAQuD,cACtC9L,KAAK8S,yBAA2B,IAGpCnV,EAAEuD,OAAOmO,EAAiBpO,WAKtBqM,cAAe,SAAS3I,EAAGhF,EAAGkG,GAC1B7F,KAAKzB,IAAI0B,UAAY,QACrB,IAAIqP,GACCtP,KAAKoR,aAAepR,KAAK8S,yBAA2B,GACrD9S,KAAKiQ,WACTtQ,GAAK,IAAOK,KAAKiQ,WAAaX,GAC9BtP,KAAKzB,IAAIe,SAASqF,EAAGhF,EAAGkG,EAAM7F,KAAK6S,YAAavD,MAOxD,IAAIuC,EAAiB,SACjBjR,EACAC,EACAC,EACAC,EACAC,EACA2H,GAEAhI,EAAQmB,KAAK9B,KAAMY,EAAMC,EAAYC,EAAUC,EAAOC,GACtDhB,KAAK2I,cAAgBA,EACrB3I,KAAK+S,eAAiB,GAG1BpV,EAAEuD,OAAO2Q,EAAe5Q,UAAWN,EAAQM,WAIvCoE,eAAgB,WACZ,IAAIrE,EAAOhB,KAAKgB,KAUhB,MARa,UAATA,EA11CG,GA41Ca,WAATA,EAz1CV,EACMM,IAo2CX4D,oBAAqB,SAASuK,GAG1B,IAAInO,EAAStB,KAAKe,MAAMiS,eAMxB,OAHIvD,EAAc,GAAKzP,KAAKe,MAAM+P,mBAC9BxP,GAAUtB,KAAK+S,eAAiBtD,EAAczP,KAAKqF,kBAEhD/D,GAMXF,KAAM,SAAS7C,EAAK8C,EAAOC,EAAQC,GAC/BhD,EAAIoU,OAEJ,IA+BIvC,EAEAK,EAEAb,EACAE,EAGAO,EACAC,EACAa,EACApB,EACAc,EACAK,EA6BA+B,EAlEJvD,EAAiB,SAACE,EAAKE,GACnB,IAAIH,EAAUC,EAAIpN,OACd0Q,EAAUpD,EAAItN,OACdqN,EAAQ,EACRhK,EAAM,EACN+F,EAAO,KAeX,MAdY,MAARkE,GACAlE,EAAO,WACP/F,EAAM+J,EAAIpN,QACkB,IAArBoN,EAAIrE,QAAQuE,IAAcH,EAAUuD,GAC3CtH,EAAO,WACP/F,EAAM8J,EAAUuD,EAChBrD,EAAQqD,GACoB,IAArBpD,EAAIvE,QAAQqE,IAAcD,EAAUuD,IAE3CtH,EAAO,YACP/F,EAAMqN,EAAUvD,EAChBE,EAAQqD,GAGI,OAATtH,GAAkBA,KAAMA,EAAMiE,MAAOA,EAAOhK,IAAKA,OAoB5DmK,EAAU/Q,KAAKmI,IAAI,EAAGnI,KAAKC,MAAMqC,IAGjCkO,EAAczP,KAAKY,KAAK4B,OAASxC,KAAKY,KAAK,GAAG,GAAGmQ,MAAM,KAAKvO,OAAS,EAEjEyN,EACc,WAAdjQ,KAAKgB,KA56CR,EACMM,GA+6CP4O,EACI3O,EAAU,GACJ0O,EACc,WAAdjQ,KAAKgB,KA/6CnB,EAjDsB,EAo+CdmP,GAAe,EAEfjE,EAAc,IAAImD,EAClB9Q,EACA0R,EACA1O,EACAvB,KAAKgB,MAMW,IAAhByO,IACAQ,EAAaC,EACT3O,EAAUhD,EAAIiJ,OAAOe,QAAQuD,cACvB9L,KAAKe,MAAMiS,eACX/C,EACV/D,EAAY+D,WAAaA,EAEzBE,GAAe,GAIfnQ,KAAKe,MAAM+P,kBAAoBX,IAC/B5R,EAAI0B,UAAY,UAChB1B,EAAIwL,YAAc,EAClBxL,EAAIe,SACA,EACAU,KAAKe,MAAMiS,eAAiBhT,KAAK+S,eACjC1R,EACArB,KAAK+S,iBAKbxU,EAAIkH,UAAY,SAChB,IAAK,IAAI9C,EAAI,EAAGA,EAAI3C,KAAKY,KAAK4B,OAAQG,IAuBlC,GArBAyN,EAAapQ,KAAKY,KAAK+B,GACvB8N,EAAML,EAAW,GACjBR,EAAMQ,EAAW,GACjBN,GAAOM,EAAW,GAAGW,MAAM,MAC3BV,EAAaD,EAAW,GAAGW,MAAM,KACjCT,EAAgBF,EAAWpN,MAAM,GAGjC8M,EAAMnS,EAAEyN,IAAIzN,EAAEwV,QAAQrD,GAAM,SAAAkB,GACxB,IAAIoC,GACAxH,KAAM,MACNwD,MAAO4B,EACPnB,MAAO,GAGPwD,EAAa3D,EAAeE,EAAKoB,GAErC,OAAOrT,EAAEuD,OAAOkS,EAAUC,OAI1B5C,EAAMzQ,KAAKa,YAAc4P,EAAMzQ,KAAKc,UAAxC,CAKA,GAAIqP,EAGA,IAFA5R,EAAI0B,UAAY,UAChB1B,EAAIwL,YAAc,EACbkJ,EAAI,EAAGA,EAAInD,EAAItN,OAAQyQ,IAcxB,IAZAlD,EAAe/P,KAAKwB,mBAChBiP,EAAMX,EAAImD,GAAGpD,MACbtO,GAEJhD,EAAIe,SACAyQ,EACA,EACAC,EACAhQ,KAAKe,MAAMiS,gBAEfnC,EAAe7Q,KAAKe,MAAMiS,eAErBC,EAAI,EAAGA,EAAInD,EAAItN,OAAQyQ,IAAK,CAC7B1U,EAAI0B,UACgB,aAAhB6P,EAAImD,GAAGrH,KACD,QACA5L,KAAK2I,cAAcmH,EAAImD,GAAG7D,OACpC,IAAIkE,EAAchD,EAAgBD,EAAW7N,OACzCwH,EAAc/K,KAAKyD,KACnB1C,KAAKe,MAAMiS,eAAiBM,GAEhC/U,EAAIe,SACAyQ,EACAc,EAAe7G,EACfgG,EACAhG,GAEJ6G,GAAgB7G,EAM5B,GAAKhK,KAAKe,MAAM+P,iBAQhB,IAHAD,EAAeV,EACTnQ,KAAKe,MAAMiS,eAAiBhT,KAAK+S,eACjC,EAEFE,EAAI,EACJA,EAAI5C,EAAW7N,OACfyQ,IAAKpC,GAAgBZ,EAyBrB,GAvBAiB,EAAWb,EAAW4C,GAChB5C,EAAW4C,GAAGlC,MAAM,UACnB,IAAK,KAGZI,EAAU,KACND,EAAS,KAAOA,EAAS,GACL,MAAhBA,EAAS,IAEc,MAAhBA,EAAS,KAEhBC,EAAUrB,EAAI1M,SAAS8N,EAAS,GAAI,IAAM,GAC1C3S,EAAIwL,YAAc,IAKtBoH,EAA0B,MAAhBD,EAAS,GAAaA,EAAS,GAAKA,EAAS,GACvDC,EAAUrB,EAAI1M,SAAS+N,EAAS,IAAM,GACtC5S,EAAIwL,YAAc,IAIlBoH,EAKA,GAJApB,EAAe/P,KAAKwB,mBAChBiP,EAAMU,EAAQtB,MACdtO,GAEiB,QAAjB4P,EAAQvF,KAAgB,CACxB,IAAI2H,EAAMpC,EAAQ/B,MAClB7Q,EAAI0B,UAAYD,KAAK2I,cAAc4K,GAC/BrH,EAAYkF,aACZ7S,EAAI8J,SACAkL,EACAvT,KAAKsR,aAAab,EAAKlP,GACvBsP,EAAeZ,GAGnB1R,EAAIe,SACAyQ,EACAc,EAAe,EACfb,EACAE,OAGgB,aAAjBiB,EAAQvF,MACfM,EAAYoB,cACRyC,EACAc,EAAe,EACfM,EAAQtL,KAS5BtH,EAAIuF,wBAKRzD,OAAQA,EACRwB,YAAaA,EACb2E,qBAAsBA,EACtBiC,YAAaA,EACbgE,wBAAyBA,EACzBiC,uBAAwBA,EACxBmD,eAAgBA","file":"../../../scripts/viz/trackster/painters.js","sourcesContent":["import * as _ from \"libs/underscore\";\n\n/**\n * Compute the type of overlap between two regions. They are assumed to be on the same chrom/contig.\n * The overlap is computed relative to the second region; hence, OVERLAP_START indicates that the first\n * region overlaps the start (but not the end) of the second region.\n * NOTE: Coordinates are assumed to be in BED format: half open (start is closed, end is open).\n */\nvar BEFORE = 1001;\n\nvar CONTAINS = 1002;\nvar OVERLAP_START = 1003;\nvar OVERLAP_END = 1004;\nvar CONTAINED_BY = 1005;\nvar AFTER = 1006;\nvar compute_overlap = (first_region, second_region) => {\n    var first_start = first_region[0];\n    var first_end = first_region[1];\n    var second_start = second_region[0];\n    var second_end = second_region[1];\n    var overlap;\n    if (first_start < second_start) {\n        if (first_end <= second_start) {\n            overlap = BEFORE;\n        } else if (first_end <= second_end) {\n            overlap = OVERLAP_START;\n        } else {\n            // first_end > second_end\n            overlap = CONTAINS;\n        }\n    } else {\n        // first_start >= second_start\n        if (first_start > second_end) {\n            overlap = AFTER;\n        } else if (first_end <= second_end) {\n            overlap = CONTAINED_BY;\n        } else {\n            overlap = OVERLAP_END;\n        }\n    }\n\n    return overlap;\n};\n\n/**\n * Returns true if regions overlap.\n */\nvar is_overlap = (first_region, second_region) => {\n    var overlap = compute_overlap(first_region, second_region);\n    return overlap !== BEFORE && overlap !== AFTER;\n};\n\n/**\n * Draw a dashed line on a canvas using filled rectangles. This function is based on:\n * http://vetruvet.blogspot.com/2010/10/drawing-dashed-lines-on-html5-canvas.html\n * However, that approach uses lines, which don't seem to render as well, so use\n * rectangles instead.\n */\nvar dashedLine = (ctx, x1, y1, x2, y2, dashLen) => {\n    if (dashLen === undefined) {\n        dashLen = 4;\n    }\n    var dX = x2 - x1;\n    var dY = y2 - y1;\n    var dashes = Math.floor(Math.sqrt(dX * dX + dY * dY) / dashLen);\n    var dashX = dX / dashes;\n    var dashY = dY / dashes;\n    var q;\n\n    for (q = 0; q < dashes; q++, x1 += dashX, y1 += dashY) {\n        if (q % 2 !== 0) {\n            continue;\n        }\n        ctx.fillRect(x1, y1, dashLen, 1);\n    }\n};\n\n/**\n * Draw an isosceles triangle that points down.\n */\nvar drawDownwardEquilateralTriangle = function(\n    ctx,\n    down_vertex_x,\n    down_vertex_y,\n    side_len\n) {\n    // Compute other two points of triangle.\n    var x1 = down_vertex_x - side_len / 2;\n\n    var x2 = down_vertex_x + side_len / 2;\n    var y = down_vertex_y - Math.sqrt(side_len * 3 / 2);\n\n    // Draw and fill.\n    ctx.beginPath();\n    ctx.moveTo(x1, y);\n    ctx.lineTo(x2, y);\n    ctx.lineTo(down_vertex_x, down_vertex_y);\n    ctx.lineTo(x1, y);\n\n    ctx.strokeStyle = this.fillStyle;\n    ctx.fill();\n    ctx.stroke();\n    ctx.closePath();\n};\n\n/**\n * Base class for all scalers. Scalers produce values that are used to change (scale) drawing attributes.\n */\nvar Scaler = function(default_val) {\n    this.default_val = default_val ? default_val : 1;\n};\n\n/**\n * Produce a scaling value.\n */\nScaler.prototype.gen_val = function(input) {\n    return this.default_val;\n};\n\n/**\n * Results from painter.draw()\n */\nvar DrawResults = function(options) {\n    this.incomplete_features = options.incomplete_features;\n    this.feature_mapper = options.feature_mapper;\n};\n\n/**\n * Base class for painters\n *\n * -- Mode and prefs are both optional\n */\nvar Painter = function(data, view_start, view_end, prefs, mode) {\n    // Data and data properties\n    this.data = data;\n    // View\n    this.view_start = view_start;\n    this.view_end = view_end;\n    // Drawing prefs\n    this.prefs = _.extend({}, this.default_prefs, prefs);\n    this.mode = mode;\n};\n\nPainter.prototype.default_prefs = {};\n\n/**\n * Draw on the context using a rectangle of width x height using scale w_scale.\n */\nPainter.prototype.draw = (ctx, width, height, w_scale) => {};\n\n/**\n * Get starting drawing position, which is offset a half-base left of coordinate.\n */\nPainter.prototype.get_start_draw_pos = function(chrom_pos, w_scale) {\n    return this._chrom_pos_to_draw_pos(chrom_pos, w_scale, -0.5);\n};\n\n/**\n * Get end drawing position, which is offset a half-base right of coordinate.\n */\nPainter.prototype.get_end_draw_pos = function(chrom_pos, w_scale) {\n    return this._chrom_pos_to_draw_pos(chrom_pos, w_scale, 0.5);\n};\n\n/**\n * Get drawing position.\n */\nPainter.prototype.get_draw_pos = function(chrom_pos, w_scale) {\n    return this._chrom_pos_to_draw_pos(chrom_pos, w_scale, 0);\n};\n\n/**\n * Convert chromosome position to drawing position.\n */\nPainter.prototype._chrom_pos_to_draw_pos = function(\n    chrom_pos,\n    w_scale,\n    offset\n) {\n    return Math.floor(\n        w_scale * (Math.max(0, chrom_pos - this.view_start) + offset)\n    );\n};\n\nvar LinePainter = function(data, view_start, view_end, prefs, mode) {\n    Painter.call(this, data, view_start, view_end, prefs, mode);\n};\n\nLinePainter.prototype.default_prefs = {\n    min_value: undefined,\n    max_value: undefined,\n    mode: \"Histogram\",\n    color: \"#000\",\n    overflow_color: \"#F66\"\n};\n\nLinePainter.prototype.draw = function(ctx, width, height, w_scale) {\n    var in_path = false;\n    var min_value = this.prefs.min_value;\n    var max_value = this.prefs.max_value;\n    var vertical_range = max_value - min_value;\n    var height_px = height;\n    var view_start = this.view_start;\n    var mode = this.mode;\n    var data = this.data;\n\n    ctx.save();\n\n    // Pixel position of 0 on the y axis\n    var y_zero = Math.round(height + min_value / vertical_range * height);\n\n    // Horizontal line to denote x-axis\n    if (mode !== \"Intensity\") {\n        ctx.fillStyle = \"#aaa\";\n        ctx.fillRect(0, y_zero, width, 1);\n    }\n\n    ctx.beginPath();\n    var x_scaled;\n    var y;\n    var delta_x_pxs;\n    if (data.length > 1) {\n        delta_x_pxs = _.map(data.slice(0, -1), (d, i) =>\n            Math.ceil((data[i + 1][0] - data[i][0]) * w_scale)\n        );\n    } else {\n        delta_x_pxs = [10];\n    }\n\n    // Painter color can be in either block_color (FeatureTrack) or color pref (LineTrack).\n    var painter_color = this.prefs.block_color || this.prefs.color;\n\n    var // Extract RGB from preference color.\n    pref_color = parseInt(painter_color.slice(1), 16);\n\n    var pref_r = (pref_color & 0xff0000) >> 16;\n    var pref_g = (pref_color & 0x00ff00) >> 8;\n    var pref_b = pref_color & 0x0000ff;\n    var top_overflow = false;\n    var bot_overflow = false;\n\n    // Paint track.\n    var delta_x_px;\n    for (var i = 0, len = data.length; i < len; i++) {\n        // Reset attributes for next point.\n        ctx.fillStyle = ctx.strokeStyle = painter_color;\n        top_overflow = bot_overflow = false;\n        delta_x_px = delta_x_pxs[i];\n\n        x_scaled = Math.floor((data[i][0] - view_start - 0.5) * w_scale);\n        y = data[i][1];\n\n        // Process Y (scaler) value.\n        if (y === null) {\n            if (in_path && mode === \"Filled\") {\n                ctx.lineTo(x_scaled, height_px);\n            }\n            in_path = false;\n            continue;\n        }\n\n        // Bound Y value by min, max.\n        if (y < min_value) {\n            bot_overflow = true;\n            y = min_value;\n        } else if (y > max_value) {\n            top_overflow = true;\n            y = max_value;\n        }\n\n        // Draw point.\n        if (mode === \"Histogram\") {\n            // y becomes the bar height in pixels, which is the negated for canvas coords\n            y = Math.round(y / vertical_range * height_px);\n            ctx.fillRect(x_scaled, y_zero, delta_x_px, -y);\n        } else if (mode === \"Intensity\") {\n            var saturation = (y - min_value) / vertical_range;\n\n            var // Range is [pref_color, 255] where saturation = 0 --> 255 and saturation = 1 --> pref color\n            new_r = Math.round(pref_r + (255 - pref_r) * (1 - saturation));\n\n            var new_g = Math.round(pref_g + (255 - pref_g) * (1 - saturation));\n            var new_b = Math.round(pref_b + (255 - pref_b) * (1 - saturation));\n            ctx.fillStyle = \"rgb(\" + new_r + \",\" + new_g + \",\" + new_b + \")\";\n            ctx.fillRect(x_scaled, 0, delta_x_px, height_px);\n        } else {\n            // mode is Coverage/Line or Filled.\n\n            // Scale Y value.\n            y = Math.round(\n                height_px - (y - min_value) / vertical_range * height_px\n            );\n            if (in_path) {\n                ctx.lineTo(x_scaled, y);\n            } else {\n                in_path = true;\n                if (mode === \"Filled\") {\n                    ctx.moveTo(x_scaled, height_px);\n                    ctx.lineTo(x_scaled, y);\n                } else {\n                    ctx.moveTo(x_scaled, y);\n                    // Use this approach (note: same as for filled) to draw line from 0 to\n                    // first data point.\n                    //ctx.moveTo(x_scaled, height_px);\n                    //ctx.lineTo(x_scaled, y);\n                }\n            }\n        }\n\n        // Draw lines at boundaries if overflowing min or max\n        ctx.fillStyle = this.prefs.overflow_color;\n        if (top_overflow || bot_overflow) {\n            var overflow_x;\n            if (mode === \"Histogram\" || mode === \"Intensity\") {\n                overflow_x = delta_x_px;\n            } else {\n                // Line and Filled, which are points\n                x_scaled -= 2; // Move it over to the left so it's centered on the point\n                overflow_x = 4;\n            }\n            if (top_overflow) {\n                ctx.fillRect(x_scaled, 0, overflow_x, 3);\n            }\n            if (bot_overflow) {\n                ctx.fillRect(x_scaled, height_px - 3, overflow_x, 3);\n            }\n        }\n        ctx.fillStyle = painter_color;\n    }\n    if (mode === \"Filled\") {\n        if (in_path) {\n            ctx.lineTo(x_scaled, y_zero);\n            ctx.lineTo(0, y_zero);\n        }\n        ctx.fill();\n    } else {\n        ctx.stroke();\n    }\n\n    ctx.restore();\n};\n\n/**\n * Mapper that contains information about feature locations and data.\n */\nvar FeaturePositionMapper = function(slot_height) {\n    this.feature_positions = {};\n    this.slot_height = slot_height;\n    this.translation = 0;\n    this.y_translation = 0;\n};\n\n/**\n * Map feature data to a position defined by <slot, x_start, x_end>.\n */\nFeaturePositionMapper.prototype.map_feature_data = function(\n    feature_data,\n    slot,\n    x_start,\n    x_end\n) {\n    if (!this.feature_positions[slot]) {\n        this.feature_positions[slot] = [];\n    }\n    this.feature_positions[slot].push({\n        data: feature_data,\n        x_start: x_start,\n        x_end: x_end\n    });\n};\n\n/**\n * Get feature data for position <x, y>\n */\nFeaturePositionMapper.prototype.get_feature_data = function(x, y) {\n    // Find slot using Y.\n    var slot = Math.floor((y - this.y_translation) / this.slot_height);\n\n    var feature_dict;\n\n    // May not be over a slot due to padding, margin, etc.\n    if (!this.feature_positions[slot]) {\n        return null;\n    }\n\n    // Find feature using X.\n    x += this.translation;\n    for (var i = 0; i < this.feature_positions[slot].length; i++) {\n        feature_dict = this.feature_positions[slot][i];\n        if (x >= feature_dict.x_start && x <= feature_dict.x_end) {\n            return feature_dict.data;\n        }\n    }\n};\n\n/**\n * Abstract object for painting feature tracks. Subclasses must implement draw_element() for painting to work.\n * Painter uses a 0-based, half-open coordinate system; start coordinate is closed--included--and the end is open.\n * This coordinate system matches the BED format.\n */\nvar FeaturePainter = function(\n    data,\n    view_start,\n    view_end,\n    prefs,\n    mode,\n    alpha_scaler,\n    height_scaler\n) {\n    Painter.call(this, data, view_start, view_end, prefs, mode);\n    this.alpha_scaler = alpha_scaler ? alpha_scaler : new Scaler();\n    this.height_scaler = height_scaler ? height_scaler : new Scaler();\n    this.max_label_length = 200;\n};\n\nFeaturePainter.prototype.default_prefs = {\n    block_color: \"#FFF\",\n    connector_color: \"#FFF\"\n};\n\n_.extend(FeaturePainter.prototype, {\n    get_required_height: function(rows_required, width) {\n        // y_scale is the height per row\n        var required_height = this.get_row_height();\n\n        var y_scale = required_height;\n        var mode = this.mode;\n        // If using a packing mode, need to multiply by the number of slots used\n        if (mode === \"no_detail\" || mode === \"Squish\" || mode === \"Pack\") {\n            required_height = rows_required * y_scale;\n        }\n        return required_height + this.get_top_padding(width);\n    },\n\n    /** Extra padding before first row of features */\n    get_top_padding: function(width) {\n        return 0;\n    },\n\n    /**\n     * Draw data on ctx using slots and within the rectangle defined by width and height. Returns\n     * a FeaturePositionMapper object with information about where features were drawn.\n     */\n    draw: function(ctx, width, height, w_scale, slots) {\n        var data = this.data;\n        var view_start = this.view_start;\n        var view_end = this.view_end;\n\n        ctx.save();\n\n        ctx.fillStyle = this.prefs.block_color;\n        ctx.textAlign = \"right\";\n\n        var y_scale = this.get_row_height();\n        var feature_mapper = new FeaturePositionMapper(y_scale);\n        var x_draw_coords;\n        var incomplete_features = [];\n\n        for (var i = 0, len = data.length; i < len; i++) {\n            var feature = data[i];\n            var feature_uid = feature[0];\n            var feature_start = feature[1];\n            var feature_end = feature[2];\n\n            var // Slot valid only if features are slotted and this feature is slotted;\n            // feature may not be due to lack of space.\n            slot =\n                slots && slots[feature_uid] !== undefined\n                    ? slots[feature_uid].slot\n                    : null;\n\n            // Draw feature if (a) mode is dense or feature is slotted (as it must be for all non-dense modes) and\n            // (b) there's overlap between the feature and drawing region.\n            if (\n                (this.mode === \"Dense\" || slot !== null) &&\n                (feature_start < view_end && feature_end > view_start)\n            ) {\n                x_draw_coords = this.draw_element(\n                    ctx,\n                    this.mode,\n                    feature,\n                    slot,\n                    view_start,\n                    view_end,\n                    w_scale,\n                    y_scale,\n                    width\n                );\n                feature_mapper.map_feature_data(\n                    feature,\n                    slot,\n                    x_draw_coords[0],\n                    x_draw_coords[1]\n                );\n\n                // Add to incomplete features if it's not drawn completely in region.\n                if (feature_start < view_start || feature_end > view_end) {\n                    incomplete_features.push(feature);\n                }\n            }\n        }\n\n        ctx.restore();\n\n        feature_mapper.y_translation = this.get_top_padding(width);\n        return new DrawResults({\n            incomplete_features: incomplete_features,\n            feature_mapper: feature_mapper\n        });\n    },\n\n    /**\n     * Abstract function for drawing an individual feature.\n     */\n    draw_element: function(\n        ctx,\n        mode,\n        feature,\n        slot,\n        tile_low,\n        tile_high,\n        w_scale,\n        y_scale,\n        width\n    ) {\n        return [0, 0];\n    }\n});\n\n// Constants specific to feature tracks moved here (HACKING, these should\n// basically all be configuration options)\nvar DENSE_TRACK_HEIGHT = 10;\n\nvar NO_DETAIL_TRACK_HEIGHT = 3;\nvar SQUISH_TRACK_HEIGHT = 5;\nvar PACK_TRACK_HEIGHT = 10;\nvar NO_DETAIL_FEATURE_HEIGHT = 1;\nvar DENSE_FEATURE_HEIGHT = 9;\nvar SQUISH_FEATURE_HEIGHT = 3;\nvar PACK_FEATURE_HEIGHT = 9;\nvar LABEL_SPACING = 2;\nvar CONNECTOR_COLOR = \"#ccc\";\n\nvar LinkedFeaturePainter = function(\n    data,\n    view_start,\n    view_end,\n    prefs,\n    mode,\n    alpha_scaler,\n    height_scaler\n) {\n    FeaturePainter.call(\n        this,\n        data,\n        view_start,\n        view_end,\n        prefs,\n        mode,\n        alpha_scaler,\n        height_scaler\n    );\n    // Whether to draw a single connector in the background that spans the entire feature (the intron fishbone)\n    this.draw_background_connector = true;\n    // Whether to call draw_connector for every pair of blocks\n    this.draw_individual_connectors = false;\n};\n\n_.extend(LinkedFeaturePainter.prototype, FeaturePainter.prototype, {\n    /**\n     * Height of a single row, depends on mode\n     */\n    get_row_height: function() {\n        var mode = this.mode;\n        var height;\n        if (mode === \"Dense\") {\n            height = DENSE_TRACK_HEIGHT;\n        } else if (mode === \"no_detail\") {\n            height = NO_DETAIL_TRACK_HEIGHT;\n        } else if (mode === \"Squish\") {\n            height = SQUISH_TRACK_HEIGHT;\n        } else {\n            // mode === \"Pack\"\n            height = PACK_TRACK_HEIGHT;\n        }\n        return height;\n    },\n\n    /**\n     * Draw a feature. Returns an array with feature's start and end X coordinates.\n     */\n    draw_element: function(\n        ctx,\n        mode,\n        feature,\n        slot,\n        tile_low,\n        tile_high,\n        w_scale,\n        y_scale,\n        width\n    ) {\n        var feature_uid = feature[0];\n        var feature_start = feature[1];\n        var feature_end = feature[2];\n        var feature_name = feature[3];\n        var feature_strand = feature[4];\n\n        var // -0.5 to offset region between bases.\n        f_start = Math.floor(\n            Math.max(0, (feature_start - tile_low - 0.5) * w_scale)\n        );\n\n        var f_end = Math.ceil(\n            Math.min(\n                width,\n                Math.max(0, (feature_end - tile_low - 0.5) * w_scale)\n            )\n        );\n\n        var draw_start = f_start;\n        var draw_end = f_end;\n\n        var y_start =\n            (mode === \"Dense\" ? 0 : 0 + slot) * y_scale +\n            this.get_top_padding(width);\n\n        var thickness;\n        var y_start;\n        var thick_start = null;\n        var thick_end = null;\n\n        var // TODO: is there any reason why block, label color cannot be set at the Painter level?\n        // For now, assume '.' === '+'\n        block_color =\n            !feature_strand || feature_strand === \"+\" || feature_strand === \".\"\n                ? this.prefs.block_color\n                : this.prefs.reverse_strand_color;\n\n        var label_color = this.prefs.label_color;\n\n        // Set global alpha.\n        ctx.globalAlpha = this.alpha_scaler.gen_val(feature);\n\n        // In dense mode, put all data in top slot.\n        if (mode === \"Dense\") {\n            slot = 1;\n        }\n\n        if (mode === \"no_detail\") {\n            // No details for feature, so only one way to display.\n            ctx.fillStyle = block_color;\n            ctx.fillRect(\n                f_start,\n                y_start + 5,\n                f_end - f_start,\n                NO_DETAIL_FEATURE_HEIGHT\n            );\n        } else {\n            // Mode is either Squish or Pack:\n            // Feature details.\n            var feature_ts = feature[5];\n\n            var feature_te = feature[6];\n            var feature_blocks = feature[7];\n\n            var // Whether we are drawing full height or squished features\n            full_height = true;\n\n            if (feature_ts && feature_te) {\n                thick_start = Math.floor(\n                    Math.max(0, (feature_ts - tile_low) * w_scale)\n                );\n                thick_end = Math.ceil(\n                    Math.min(\n                        width,\n                        Math.max(0, (feature_te - tile_low) * w_scale)\n                    )\n                );\n            }\n\n            // Set vars that depend on mode.\n            var thin_height;\n\n            var thick_height;\n            if (mode === \"Squish\") {\n                thin_height = 1;\n                thick_height = SQUISH_FEATURE_HEIGHT;\n                full_height = false;\n            } else if (mode === \"Dense\") {\n                thin_height = 5;\n                thick_height = DENSE_FEATURE_HEIGHT;\n            } else {\n                // mode === \"Pack\"\n                thin_height = 5;\n                thick_height = PACK_FEATURE_HEIGHT;\n            }\n\n            // Draw feature/feature blocks + connectors.\n            if (!feature_blocks) {\n                // If there are no blocks, treat the feature as one big exon.\n                ctx.fillStyle = block_color;\n                ctx.fillRect(\n                    f_start,\n                    y_start + 1,\n                    f_end - f_start,\n                    thick_height\n                );\n                // If strand is specified, draw arrows over feature\n                if (feature_strand && full_height) {\n                    if (feature_strand === \"+\") {\n                        ctx.fillStyle = ctx.canvas.manager.get_pattern(\n                            \"right_strand_inv\"\n                        );\n                    } else if (feature_strand === \"-\") {\n                        ctx.fillStyle = ctx.canvas.manager.get_pattern(\n                            \"left_strand_inv\"\n                        );\n                    }\n                    ctx.fillRect(\n                        f_start,\n                        y_start + 1,\n                        f_end - f_start,\n                        thick_height\n                    );\n                }\n            } else {\n                //\n                // There are feature blocks and mode is either Squish or Pack.\n                //\n                // Approach: (a) draw whole feature as connector/intron and (b) draw blocks as\n                // needed. This ensures that whole feature, regardless of whether it starts with\n                // a block, is visible.\n                //\n\n                // Compute y axis start position and height\n                var cur_y_start;\n\n                var cur_height;\n                if (mode === \"Squish\" || mode === \"Dense\") {\n                    cur_y_start =\n                        y_start + Math.floor(SQUISH_FEATURE_HEIGHT / 2) + 1;\n                    cur_height = 1;\n                } else {\n                    // mode === \"Pack\"\n                    if (feature_strand) {\n                        cur_y_start = y_start;\n                        cur_height = thick_height;\n                    } else {\n                        cur_y_start += SQUISH_FEATURE_HEIGHT / 2 + 1;\n                        cur_height = 1;\n                    }\n                }\n\n                // Draw whole feature as connector/intron.\n                if (this.draw_background_connector) {\n                    if (mode === \"Squish\" || mode === \"Dense\") {\n                        ctx.fillStyle = CONNECTOR_COLOR;\n                    } else {\n                        // mode === \"Pack\"\n                        if (feature_strand) {\n                            if (feature_strand === \"+\") {\n                                ctx.fillStyle = ctx.canvas.manager.get_pattern(\n                                    \"right_strand\"\n                                );\n                            } else if (feature_strand === \"-\") {\n                                ctx.fillStyle = ctx.canvas.manager.get_pattern(\n                                    \"left_strand\"\n                                );\n                            }\n                        } else {\n                            ctx.fillStyle = CONNECTOR_COLOR;\n                        }\n                    }\n                    ctx.fillRect(\n                        f_start,\n                        cur_y_start,\n                        f_end - f_start,\n                        cur_height\n                    );\n                }\n\n                // Draw blocks.\n                var start_and_height;\n                for (var k = 0, k_len = feature_blocks.length; k < k_len; k++) {\n                    var block = feature_blocks[k];\n\n                    var // -0.5 to offset block between bases.\n                    block_start = Math.floor(\n                        Math.max(0, (block[0] - tile_low - 0.5) * w_scale)\n                    );\n\n                    var block_end = Math.ceil(\n                        Math.min(\n                            width,\n                            Math.max((block[1] - tile_low - 0.5) * w_scale)\n                        )\n                    );\n\n                    var last_block_start;\n                    var last_block_end;\n\n                    // Skip drawing if block not on tile.\n                    if (block_start > block_end) {\n                        continue;\n                    }\n\n                    // Draw thin block.\n                    ctx.fillStyle = block_color;\n                    ctx.fillRect(\n                        block_start,\n                        y_start + (thick_height - thin_height) / 2 + 1,\n                        block_end - block_start,\n                        thin_height\n                    );\n\n                    // If block intersects with thick region, draw block as thick.\n                    // - No thick is sometimes encoded as thick_start == thick_end, so don't draw in that case\n                    if (\n                        thick_start !== undefined &&\n                        feature_te > feature_ts &&\n                        !(block_start > thick_end || block_end < thick_start)\n                    ) {\n                        var block_thick_start = Math.max(\n                            block_start,\n                            thick_start\n                        );\n\n                        var block_thick_end = Math.min(block_end, thick_end);\n                        ctx.fillRect(\n                            block_thick_start,\n                            y_start + 1,\n                            block_thick_end - block_thick_start,\n                            thick_height\n                        );\n                        if (feature_blocks.length === 1 && mode === \"Pack\") {\n                            // Exactly one block means we have no introns, but do have a distinct \"thick\" region,\n                            // draw arrows over it if in pack mode.\n                            if (feature_strand === \"+\") {\n                                ctx.fillStyle = ctx.canvas.manager.get_pattern(\n                                    \"right_strand_inv\"\n                                );\n                            } else if (feature_strand === \"-\") {\n                                ctx.fillStyle = ctx.canvas.manager.get_pattern(\n                                    \"left_strand_inv\"\n                                );\n                            }\n                            // If region is wide enough in pixels, pad a bit\n                            if (block_thick_start + 14 < block_thick_end) {\n                                block_thick_start += 2;\n                                block_thick_end -= 2;\n                            }\n                            ctx.fillRect(\n                                block_thick_start,\n                                y_start + 1,\n                                block_thick_end - block_thick_start,\n                                thick_height\n                            );\n                        }\n                    }\n                    // Draw individual connectors if required\n                    if (this.draw_individual_connectors && last_block_start) {\n                        this.draw_connector(\n                            ctx,\n                            last_block_start,\n                            last_block_end,\n                            block_start,\n                            block_end,\n                            y_start\n                        );\n                    }\n                    last_block_start = block_start;\n                    last_block_end = block_end;\n                }\n\n                // FIXME: Height scaling only works in Pack mode right now.\n                if (mode === \"Pack\") {\n                    // Reset alpha so height scaling is not impacted by alpha scaling.\n                    ctx.globalAlpha = 1;\n\n                    // Height scaling: draw white lines to reduce height according to height scale factor.\n                    ctx.fillStyle = \"white\"; // TODO: set this to background color.\n                    var hscale_factor = this.height_scaler.gen_val(feature);\n\n                    var // Ceil ensures that min height is >= 1.\n                    new_height = Math.ceil(thick_height * hscale_factor);\n\n                    var ws_height = Math.round((thick_height - new_height) / 2);\n                    if (hscale_factor !== 1) {\n                        ctx.fillRect(\n                            f_start,\n                            cur_y_start + 1,\n                            f_end - f_start,\n                            ws_height\n                        );\n                        ctx.fillRect(\n                            f_start,\n                            cur_y_start + thick_height - ws_height + 1,\n                            f_end - f_start,\n                            ws_height\n                        );\n                    }\n                }\n            }\n\n            // Reset alpha so that label is not transparent.\n            ctx.globalAlpha = 1;\n\n            // Draw label for Pack mode.\n            if (feature_name && mode === \"Pack\" && feature_start > tile_low) {\n                ctx.fillStyle = label_color;\n                // FIXME: assumption here that the entire view starts at 0\n                if (\n                    tile_low === 0 &&\n                    f_start - ctx.measureText(feature_name).width < 0\n                ) {\n                    ctx.textAlign = \"left\";\n                    ctx.fillText(\n                        feature_name,\n                        f_end + LABEL_SPACING,\n                        y_start + 8,\n                        this.max_label_length\n                    );\n                    draw_end +=\n                        ctx.measureText(feature_name).width + LABEL_SPACING;\n                } else {\n                    ctx.textAlign = \"right\";\n                    ctx.fillText(\n                        feature_name,\n                        f_start - LABEL_SPACING,\n                        y_start + 8,\n                        this.max_label_length\n                    );\n                    draw_start -=\n                        ctx.measureText(feature_name).width + LABEL_SPACING;\n                }\n                //ctx.fillStyle = block_color;\n            }\n        }\n\n        // Reset global alpha.\n        ctx.globalAlpha = 1;\n\n        return [draw_start, draw_end];\n    }\n});\n\nvar ReadPainter = function(\n    data,\n    view_start,\n    view_end,\n    prefs,\n    mode,\n    alpha_scaler,\n    height_scaler,\n    ref_seq,\n    base_color_fn\n) {\n    FeaturePainter.call(\n        this,\n        data,\n        view_start,\n        view_end,\n        prefs,\n        mode,\n        alpha_scaler,\n        height_scaler\n    );\n    this.ref_seq = ref_seq ? ref_seq.data : null;\n    this.base_color_fn = base_color_fn;\n};\n\n_.extend(ReadPainter.prototype, FeaturePainter.prototype, {\n    /**\n     * Returns height based on mode.\n     */\n    get_row_height: function() {\n        var height;\n        var mode = this.mode;\n        if (mode === \"Dense\") {\n            height = DENSE_TRACK_HEIGHT;\n        } else if (mode === \"Squish\") {\n            height = SQUISH_TRACK_HEIGHT;\n        } else {\n            // mode === \"Pack\"\n            height = PACK_TRACK_HEIGHT;\n            if (this.prefs.show_insertions) {\n                height *= 2;\n            }\n        }\n        return height;\n    },\n\n    /**\n     * Parse CIGAR string to get (a) a list of contiguous drawing blocks (MD=X) and\n     * (b) an array of [ op_index, op_len ] pairs where op_index is an index into the\n     * string 'MIDNSHP=X' Return value is a dictionary with two entries, blocks and cigar\n     */\n    _parse_cigar: function(cigar_str) {\n        var cigar_ops = \"MIDNSHP=X\";\n\n        // Parse cigar.\n        var blocks = [[0, 0]];\n\n        var cur_block = blocks[0];\n        var base_pos = 0;\n\n        var // Parse cigar operations out and update/create blocks as needed.\n        parsed_cigar = _.map(cigar_str.match(/[0-9]+[MIDNSHP=X]/g), op => {\n            // Get operation length, character.\n            var op_len = parseInt(op.slice(0, -1), 10),\n                op_char = op.slice(-1);\n\n            // Update drawing block.\n            if (op_char === \"N\") {\n                // At skip, so need to start new block if current block represents\n                // drawing area.\n                if (cur_block[1] !== 0) {\n                    cur_block = [base_pos + op_len, base_pos + op_len];\n                    blocks.push(cur_block);\n                }\n            } else if (\"ISHP\".indexOf(op_char) === -1) {\n                // Operation is M,D,=,X.\n                cur_block[1] += op_len;\n                base_pos += op_len;\n            }\n\n            // Return parsed cigar.\n            return [cigar_ops.indexOf(op_char), op_len];\n        });\n\n        return {\n            blocks: blocks,\n            cigar: parsed_cigar\n        };\n    },\n\n    /**\n     * Draw a single read from reference-based read sequence and cigar.\n     */\n    draw_read: function(\n        ctx,\n        mode,\n        w_scale,\n        y_start,\n        tile_low,\n        tile_high,\n        feature_start,\n        cigar,\n        strand,\n        read_seq\n    ) {\n        // Helper function to update base and sequnence offsets.\n        var update_base_offset = (offset, cig_op, cig_len) => {\n            if (\"M=NXD\".indexOf(cig_op) !== -1) {\n                offset += cig_len;\n            }\n            return offset;\n        };\n\n        var update_seq_offset = (offset, cig_op, cig_len) => {\n            if (\"IX\".indexOf(cig_op) !== -1) {\n                offset += cig_len;\n            }\n            return offset;\n        };\n\n        var // Gets drawing coordinate for a sequence coordinate. Assumes closure variables w_scale and tile_low.\n        get_draw_coord = (\n            sequence_coord // -0.5 to offset sequence between bases.\n        ) =>\n            Math.floor(\n                Math.max(0, (sequence_coord - tile_low - 0.5) * w_scale)\n            );\n\n        ctx.textAlign = \"center\";\n        var tile_region = [tile_low, tile_high];\n        var base_offset = 0;\n        var seq_offset = 0;\n        var gap = Math.round(w_scale / 2);\n        var char_width_px = ctx.canvas.manager.char_width_px;\n\n        var block_color =\n            strand === \"+\"\n                ? this.prefs.detail_block_color\n                : this.prefs.reverse_strand_color;\n\n        var pack_mode = mode === \"Pack\";\n\n        var draw_height = pack_mode\n            ? PACK_FEATURE_HEIGHT\n            : SQUISH_FEATURE_HEIGHT;\n\n        var rect_y = y_start + 1;\n        var paint_utils = new ReadPainterUtils(ctx, draw_height, w_scale, mode);\n        var drawing_blocks = [];\n        var s_start;\n        var s_end;\n\n        // Keep list of items that need to be drawn on top of initial drawing layer.\n        var draw_last = [];\n\n        // Parse cigar and get drawing blocks.\n        var t = this._parse_cigar(cigar);\n        cigar = t.cigar;\n        drawing_blocks = t.blocks;\n\n        // Draw blocks.\n        for (var i = 0; i < drawing_blocks.length; i++) {\n            var block = drawing_blocks[i];\n\n            if (\n                is_overlap(\n                    [feature_start + block[0], feature_start + block[1]],\n                    tile_region\n                )\n            ) {\n                s_start = get_draw_coord(feature_start + block[0]);\n                s_end = get_draw_coord(feature_start + block[1]);\n\n                // Make sure that block is drawn even if it too small to be rendered officially; in this case,\n                // read is drawn at 1px.\n                // TODO: need to ensure that s_start, s_end are calculated the same for both slotting\n                // and drawing.\n                if (s_start === s_end) {\n                    s_end += 1;\n                }\n\n                // Draw read base as rectangle.\n                ctx.fillStyle = block_color;\n                ctx.fillRect(s_start, rect_y, s_end - s_start, draw_height);\n            }\n        }\n\n        // Draw read features.\n        for (var cig_id = 0, len = cigar.length; cig_id < len; cig_id++) {\n            var cig = cigar[cig_id];\n            var cig_op = \"MIDNSHP=X\"[cig[0]];\n            var cig_len = cig[1];\n\n            var seq_start = feature_start + base_offset;\n            s_start = get_draw_coord(seq_start);\n            s_end = get_draw_coord(seq_start + cig_len);\n\n            // Skip feature if it's not in tile.\n            if (!is_overlap([seq_start, seq_start + cig_len], tile_region)) {\n                // Update offsets.\n                base_offset = update_base_offset(base_offset, cig_op, cig_len);\n                seq_offset = update_seq_offset(seq_offset, cig_op, cig_len);\n                continue;\n            }\n\n            // Make sure that read is drawn even if it too small to be rendered officially; in this case,\n            // read is drawn at 1px.\n            // TODO: need to ensure that s_start, s_end are calculated the same for both slotting\n            // and drawing.\n            if (s_start === s_end) {\n                s_end += 1;\n            }\n\n            // Draw read feature.\n            switch (cig_op) {\n                case \"H\": // Hard clipping.\n                case \"S\": // Soft clipping.\n                case \"P\": // Padding.\n                    // Sequence not present and not related to alignment; do nothing.\n                    break;\n                case \"M\": // \"Match\".\n                    // Because it's not known whether there is a match, ignore.\n                    base_offset += cig_len;\n                    break;\n                case \"=\": // Match with reference.\n                case \"X\": // Mismatch with reference.\n                    //\n                    // Draw sequence and/or variants.\n                    //\n\n                    // Get sequence to draw.\n                    var cur_seq = \"\";\n                    if (cig_op === \"X\") {\n                        // Get sequence from read_seq.\n                        cur_seq = read_seq.slice(\n                            seq_offset,\n                            seq_offset + cig_len\n                        );\n                    } else if (this.ref_seq) {\n                        // && cig_op === '='\n                        // Use reference sequence.\n                        cur_seq = this.ref_seq.slice(\n                            // If read starts after tile start, slice at read start.\n                            Math.max(0, seq_start - tile_low),\n                            // If read ends before tile end, slice at read end.\n                            Math.min(\n                                seq_start - tile_low + cig_len,\n                                tile_high - tile_low\n                            )\n                        );\n                    }\n\n                    // Draw sequence. Because cur_seq starts and read/tile start, go to there to start writing.\n                    var start_pos = Math.max(seq_start, tile_low);\n                    for (var c = 0; c < cur_seq.length; c++) {\n                        // Draw base if showing all (i.e. not showing differences) or there is a mismatch.\n                        if (\n                            (cur_seq && !this.prefs.show_differences) ||\n                            cig_op === \"X\"\n                        ) {\n                            // Draw base.\n                            var c_start = Math.floor(\n                                Math.max(\n                                    0,\n                                    (start_pos + c - tile_low) * w_scale\n                                )\n                            );\n                            ctx.fillStyle = this.base_color_fn(cur_seq[c]);\n                            if (pack_mode && w_scale > char_width_px) {\n                                ctx.fillText(cur_seq[c], c_start, y_start + 9);\n                            } else if (w_scale > 0.05) {\n                                // Require a minimum w_scale so that variants are only drawn when somewhat zoomed in.\n                                ctx.fillRect(\n                                    c_start - gap,\n                                    rect_y,\n                                    Math.max(1, Math.round(w_scale)),\n                                    draw_height\n                                );\n                            }\n                        }\n                    }\n\n                    // Move forward in sequence only if sequence used to get mismatches.\n                    if (cig_op === \"X\") {\n                        seq_offset += cig_len;\n                    }\n                    base_offset += cig_len;\n\n                    break;\n                case \"N\": // Skipped bases.\n                    ctx.fillStyle = CONNECTOR_COLOR;\n                    ctx.fillRect(\n                        s_start,\n                        rect_y + (draw_height - 1) / 2,\n                        s_end - s_start,\n                        1\n                    );\n                    // No change in seq_offset because sequence not used when skipping.\n                    base_offset += cig_len;\n                    break;\n                case \"D\": // Deletion.\n                    paint_utils.draw_deletion(s_start, rect_y, cig_len);\n                    base_offset += cig_len;\n                    break;\n                case \"I\": // Insertion.\n                    // Check to see if sequence should be drawn at all by looking at the overlap between\n                    // the sequence region and the tile region.\n                    var insert_x_coord = s_start - gap;\n\n                    if (\n                        is_overlap(\n                            [seq_start, seq_start + cig_len],\n                            tile_region\n                        )\n                    ) {\n                        var seq = read_seq.slice(\n                            seq_offset,\n                            seq_offset + cig_len\n                        );\n                        // Insertion point is between the sequence start and the previous base: (-gap) moves\n                        // back from sequence start to insertion point.\n                        if (this.prefs.show_insertions) {\n                            //\n                            // Show inserted sequence above, centered on insertion point.\n                            //\n\n                            // Draw sequence.\n                            // X center is offset + start - <half_sequence_length>\n                            var x_center = s_start - (s_end - s_start) / 2;\n                            if (\n                                (mode === \"Pack\" || this.mode === \"Auto\") &&\n                                read_seq !== undefined &&\n                                w_scale > char_width_px\n                            ) {\n                                // Draw sequence container.\n                                ctx.fillStyle = \"yellow\";\n                                ctx.fillRect(\n                                    x_center - gap,\n                                    y_start - 9,\n                                    s_end - s_start,\n                                    9\n                                );\n                                draw_last[draw_last.length] = {\n                                    type: \"triangle\",\n                                    data: [insert_x_coord, y_start + 4, 5]\n                                };\n                                ctx.fillStyle = CONNECTOR_COLOR;\n                                // Based on overlap b/t sequence and tile, get sequence to be drawn.\n                                switch (compute_overlap(\n                                    [seq_start, seq_start + cig_len],\n                                    tile_region\n                                )) {\n                                    case OVERLAP_START:\n                                        seq = seq.slice(tile_low - seq_start);\n                                        break;\n                                    case OVERLAP_END:\n                                        seq = seq.slice(\n                                            0,\n                                            seq_start - tile_high\n                                        );\n                                        break;\n                                    case CONTAINED_BY:\n                                        // All of sequence drawn.\n                                        break;\n                                    case CONTAINS:\n                                        seq = seq.slice(\n                                            tile_low - seq_start,\n                                            seq_start - tile_high\n                                        );\n                                        break;\n                                }\n                                // Draw sequence.\n                                for (\n                                    var c = 0, str_len = seq.length;\n                                    c < str_len;\n                                    c++\n                                ) {\n                                    var c_start = Math.floor(\n                                        Math.max(\n                                            0,\n                                            (seq_start + c - tile_low) * w_scale\n                                        )\n                                    );\n                                    ctx.fillText(\n                                        seq[c],\n                                        c_start - (s_end - s_start) / 2,\n                                        y_start\n                                    );\n                                }\n                            } else {\n                                // Draw block.\n                                ctx.fillStyle = \"yellow\";\n                                // TODO: This is a pretty hack-ish way to fill rectangle based on mode.\n                                ctx.fillRect(\n                                    x_center,\n                                    y_start + (this.mode !== \"Dense\" ? 2 : 5),\n                                    s_end - s_start,\n                                    mode !== \"Dense\"\n                                        ? SQUISH_FEATURE_HEIGHT\n                                        : DENSE_FEATURE_HEIGHT\n                                );\n                            }\n                        } else {\n                            if (\n                                (mode === \"Pack\" || this.mode === \"Auto\") &&\n                                read_seq !== undefined &&\n                                w_scale > char_width_px\n                            ) {\n                                // Show insertions with a single number at the insertion point.\n                                draw_last.push({\n                                    type: \"text\",\n                                    data: [\n                                        seq.length,\n                                        insert_x_coord,\n                                        y_start + 9\n                                    ]\n                                });\n                            } else {\n                                // TODO: probably can merge this case with code above.\n                            }\n                        }\n                    }\n                    seq_offset += cig_len;\n                    // No change to base offset because insertions are drawn above sequence/read.\n                    break;\n            }\n        }\n\n        //\n        // Draw last items.\n        //\n        ctx.fillStyle = \"yellow\";\n        var item;\n        var type;\n        var data;\n        for (var i = 0; i < draw_last.length; i++) {\n            item = draw_last[i];\n            type = item.type;\n            data = item.data;\n            if (type === \"text\") {\n                ctx.save();\n                ctx.font = \"bold \" + ctx.font;\n                ctx.fillText(data[0], data[1], data[2]);\n                ctx.restore();\n            } else if (type === \"triangle\") {\n                drawDownwardEquilateralTriangle(ctx, data[0], data[1], data[2]);\n            }\n        }\n    },\n\n    /**\n     * Draw a complete read pair\n     */\n    draw_element: function(\n        ctx,\n        mode,\n        feature,\n        slot,\n        tile_low,\n        tile_high,\n        w_scale,\n        y_scale,\n        width\n    ) {\n        // All features need a start, end, and vertical center.\n        var feature_uid = feature[0];\n\n        var feature_start = feature[1];\n        var feature_end = feature[2];\n        var feature_name = feature[3];\n\n        var // -0.5 to put element between bases.\n        f_start = Math.floor(\n            Math.max(-0.5 * w_scale, (feature_start - tile_low - 0.5) * w_scale)\n        );\n\n        var f_end = Math.ceil(\n            Math.min(\n                width,\n                Math.max(0, (feature_end - tile_low - 0.5) * w_scale)\n            )\n        );\n\n        var y_start = (mode === \"Dense\" ? 0 : 0 + slot) * y_scale;\n\n        var draw_height =\n            mode === \"Pack\" ? PACK_FEATURE_HEIGHT : SQUISH_FEATURE_HEIGHT;\n\n        var label_color = this.prefs.label_color;\n\n        // Draw read.\n        if (feature[5] instanceof Array) {\n            // Read is paired.\n            var connector = true;\n\n            // Draw left/forward read.\n            if (\n                feature[4][1] >= tile_low &&\n                feature[4][0] <= tile_high &&\n                feature[4][2]\n            ) {\n                this.draw_read(\n                    ctx,\n                    mode,\n                    w_scale,\n                    y_start,\n                    tile_low,\n                    tile_high,\n                    feature[4][0],\n                    feature[4][2],\n                    feature[4][3],\n                    feature[4][4]\n                );\n            } else {\n                connector = false;\n            }\n\n            // Draw right/reverse read.\n            if (\n                feature[5][1] >= tile_low &&\n                feature[5][0] <= tile_high &&\n                feature[5][2]\n            ) {\n                this.draw_read(\n                    ctx,\n                    mode,\n                    w_scale,\n                    y_start,\n                    tile_low,\n                    tile_high,\n                    feature[5][0],\n                    feature[5][2],\n                    feature[5][3],\n                    feature[5][4]\n                );\n            } else {\n                connector = false;\n            }\n\n            // Draw connector if both reads were drawn.\n            // TODO: currently, there is no way to connect reads drawn on different tiles; to connect reads on different tiles, data manager\n            // code is needed to join mate pairs from different regions. Alternatively, requesting multiple regions of data at once would\n            // make it possible to put together more easily.\n            // -0.5 to position connector correctly between reads.\n            var b1_end = Math.ceil(\n                Math.min(\n                    width,\n                    Math.max(\n                        -0.5 * w_scale,\n                        (feature[4][1] - tile_low - 0.5) * w_scale\n                    )\n                )\n            );\n\n            var b2_start = Math.floor(\n                Math.max(\n                    -0.5 * w_scale,\n                    (feature[5][0] - tile_low - 0.5) * w_scale\n                )\n            );\n\n            if (connector && b2_start > b1_end) {\n                ctx.fillStyle = CONNECTOR_COLOR;\n                var line_height = y_start + 1 + (draw_height - 1) / 2;\n                dashedLine(ctx, b1_end, line_height, b2_start, line_height);\n            }\n        } else {\n            // Read is single.\n            this.draw_read(\n                ctx,\n                mode,\n                w_scale,\n                y_start,\n                tile_low,\n                tile_high,\n                feature_start,\n                feature[4],\n                feature[5],\n                feature[6]\n            );\n        }\n        if (\n            mode === \"Pack\" &&\n            feature_start >= tile_low &&\n            feature_name !== \".\"\n        ) {\n            // Draw label.\n            ctx.fillStyle = this.prefs.label_color;\n            if (\n                tile_low === 0 &&\n                f_start - ctx.measureText(feature_name).width < 0\n            ) {\n                ctx.textAlign = \"left\";\n                ctx.fillText(\n                    feature_name,\n                    f_end + LABEL_SPACING,\n                    y_start + 9,\n                    this.max_label_length\n                );\n            } else {\n                ctx.textAlign = \"right\";\n                ctx.fillText(\n                    feature_name,\n                    f_start - LABEL_SPACING,\n                    y_start + 9,\n                    this.max_label_length\n                );\n            }\n        }\n\n        // FIXME: provide actual coordinates for drawn read.\n        return [0, 0];\n    }\n});\n\nvar ArcLinkedFeaturePainter = function(\n    data,\n    view_start,\n    view_end,\n    prefs,\n    mode,\n    alpha_scaler,\n    height_scaler\n) {\n    LinkedFeaturePainter.call(\n        this,\n        data,\n        view_start,\n        view_end,\n        prefs,\n        mode,\n        alpha_scaler,\n        height_scaler\n    );\n    // Need to know the longest feature length for adding spacing\n    this.longest_feature_length = this.calculate_longest_feature_length();\n    this.draw_background_connector = false;\n    this.draw_individual_connectors = true;\n};\n\n_.extend(\n    ArcLinkedFeaturePainter.prototype,\n    FeaturePainter.prototype,\n    LinkedFeaturePainter.prototype,\n    {\n        calculate_longest_feature_length: function() {\n            var longest_feature_length = 0;\n            for (var i = 0, len = this.data.length; i < len; i++) {\n                var feature = this.data[i];\n                var feature_start = feature[1];\n                var feature_end = feature[2];\n                longest_feature_length = Math.max(\n                    longest_feature_length,\n                    feature_end - feature_start\n                );\n            }\n            return longest_feature_length;\n        },\n\n        get_top_padding: function(width) {\n            var view_range = this.view_end - this.view_start;\n            var w_scale = width / view_range;\n            return Math.min(\n                128,\n                Math.ceil(this.longest_feature_length / 2 * w_scale)\n            );\n        },\n\n        draw_connector: function(\n            ctx,\n            block1_start,\n            block1_end,\n            block2_start,\n            block2_end,\n            y_start\n        ) {\n            // Arc drawing -- from closest endpoints\n            var x_center = (block1_end + block2_start) / 2;\n\n            var radius = block2_start - x_center;\n\n            // For full half circles\n            var angle1 = Math.PI;\n\n            var angle2 = 0;\n            if (radius > 0) {\n                ctx.beginPath();\n                ctx.arc(x_center, y_start, block2_start - x_center, Math.PI, 0);\n                ctx.stroke();\n            }\n        }\n    }\n);\n\n// Color stuff from less.js\n\nvar Color = function(rgb, a) {\n    /**\n     * The end goal here, is to parse the arguments\n     * into an integer triplet, such as `128, 255, 0`\n     *\n     * This facilitates operations and conversions.\n     */\n    if (Array.isArray(rgb)) {\n        this.rgb = rgb;\n    } else if (rgb.length == 6) {\n        this.rgb = rgb.match(/.{2}/g).map(c => parseInt(c, 16));\n    } else if (rgb.length == 7) {\n        this.rgb = rgb\n            .substring(1, 7)\n            .match(/.{2}/g)\n            .map(c => parseInt(c, 16));\n    } else {\n        this.rgb = rgb.split(\"\").map(c => parseInt(c + c, 16));\n    }\n    this.alpha = typeof a === \"number\" ? a : 1;\n};\nColor.prototype = {\n    eval: function() {\n        return this;\n    },\n\n    //\n    // If we have some transparency, the only way to represent it\n    // is via `rgba`. Otherwise, we use the hex representation,\n    // which has better compatibility with older browsers.\n    // Values are capped between `0` and `255`, rounded and zero-padded.\n    //\n    toCSS: function() {\n        if (this.alpha < 1.0) {\n            return (\n                \"rgba(\" +\n                this.rgb\n                    .map(c => Math.round(c))\n                    .concat(this.alpha)\n                    .join(\", \") +\n                \")\"\n            );\n        } else {\n            return (\n                \"#\" +\n                this.rgb\n                    .map(i => {\n                        i = Math.round(i);\n                        i = (i > 255 ? 255 : i < 0 ? 0 : i).toString(16);\n                        return i.length === 1 ? \"0\" + i : i;\n                    })\n                    .join(\"\")\n            );\n        }\n    },\n\n    toHSL: function() {\n        var r = this.rgb[0] / 255;\n        var g = this.rgb[1] / 255;\n        var b = this.rgb[2] / 255;\n        var a = this.alpha;\n        var max = Math.max(r, g, b);\n        var min = Math.min(r, g, b);\n        var h;\n        var s;\n        var l = (max + min) / 2;\n        var d = max - min;\n\n        if (max === min) {\n            h = s = 0;\n        } else {\n            s = l > 0.5 ? d / (2 - max - min) : d / (max + min);\n\n            switch (max) {\n                case r:\n                    h = (g - b) / d + (g < b ? 6 : 0);\n                    break;\n                case g:\n                    h = (b - r) / d + 2;\n                    break;\n                case b:\n                    h = (r - g) / d + 4;\n                    break;\n            }\n            h /= 6;\n        }\n        return { h: h * 360, s: s, l: l, a: a };\n    },\n\n    toARGB: function() {\n        var argb = [Math.round(this.alpha * 255)].concat(this.rgb);\n        return (\n            \"#\" +\n            argb\n                .map(i => {\n                    i = Math.round(i);\n                    i = (i > 255 ? 255 : i < 0 ? 0 : i).toString(16);\n                    return i.length === 1 ? \"0\" + i : i;\n                })\n                .join(\"\")\n        );\n    },\n\n    mix: function(color2, weight) {\n        var color1 = this;\n\n        var p = weight; // .value / 100.0;\n        var w = p * 2 - 1;\n        var a = color1.toHSL().a - color2.toHSL().a;\n\n        var w1 = ((w * a == -1 ? w : (w + a) / (1 + w * a)) + 1) / 2.0;\n        var w2 = 1 - w1;\n\n        var rgb = [\n            color1.rgb[0] * w1 + color2.rgb[0] * w2,\n            color1.rgb[1] * w1 + color2.rgb[1] * w2,\n            color1.rgb[2] * w1 + color2.rgb[2] * w2\n        ];\n\n        var alpha = color1.alpha * p + color2.alpha * (1 - p);\n\n        return new Color(rgb, alpha);\n    }\n};\n\n// End colors from less.js\n\nvar LinearRamp = function(start_color, end_color, start_value, end_value) {\n    /**\n     * Simple linear gradient\n     */\n    this.start_color = new Color(start_color);\n    this.end_color = new Color(end_color);\n    this.start_value = start_value;\n    this.end_value = end_value;\n    this.value_range = end_value - start_value;\n};\n\nLinearRamp.prototype.map_value = function(value) {\n    value = Math.max(value, this.start_value);\n    value = Math.min(value, this.end_value);\n    value = (value - this.start_value) / this.value_range;\n    // HACK: just red for now\n    // return \"hsl(0,100%,\" + (value * 100) + \"%)\"\n    return this.start_color.mix(this.end_color, 1 - value).toCSS();\n};\n\nvar SplitRamp = function(\n    start_color,\n    middle_color,\n    end_color,\n    start_value,\n    end_value\n) {\n    /**\n     * Two gradients split away from 0\n     */\n    this.positive_ramp = new LinearRamp(middle_color, end_color, 0, end_value);\n    this.negative_ramp = new LinearRamp(\n        middle_color,\n        start_color,\n        0,\n        -start_value\n    );\n    this.start_value = start_value;\n    this.end_value = end_value;\n};\n\nSplitRamp.prototype.map_value = function(value) {\n    value = Math.max(value, this.start_value);\n    value = Math.min(value, this.end_value);\n    if (value >= 0) {\n        return this.positive_ramp.map_value(value);\n    } else {\n        return this.negative_ramp.map_value(-value);\n    }\n};\n\nvar DiagonalHeatmapPainter = function(data, view_start, view_end, prefs, mode) {\n    Painter.call(this, data, view_start, view_end, prefs, mode);\n    var i;\n    var len;\n\n    if (this.prefs.min_value === undefined) {\n        var min_value = Infinity;\n        for (i = 0, len = this.data.length; i < len; i++) {\n            min_value = Math.min(min_value, this.data[i][6]);\n        }\n        this.prefs.min_value = min_value;\n    }\n    if (this.prefs.max_value === undefined) {\n        var max_value = -Infinity;\n        for (i = 0, len = this.data.length; i < len; i++) {\n            max_value = Math.max(max_value, this.data[i][6]);\n        }\n        this.prefs.max_value = max_value;\n    }\n};\n\nDiagonalHeatmapPainter.prototype.default_prefs = {\n    min_value: undefined,\n    max_value: undefined,\n    mode: \"Heatmap\",\n    pos_color: \"#FF8C00\",\n    neg_color: \"#4169E1\"\n};\n\nDiagonalHeatmapPainter.prototype.draw = function(ctx, width, height, w_scale) {\n    var min_value = this.prefs.min_value;\n    var max_value = this.prefs.max_value;\n    var value_range = max_value - min_value;\n    var height_px = height;\n    var view_start = this.view_start;\n    var mode = this.mode;\n    var data = this.data;\n    var invsqrt2 = 1 / Math.sqrt(2);\n\n    var ramp = new SplitRamp(\n        this.prefs.neg_color,\n        \"#FFFFFF\",\n        this.prefs.pos_color,\n        min_value,\n        max_value\n    );\n\n    var d;\n    var s1;\n    var e1;\n    var s2;\n    var e2;\n    var value;\n\n    var scale = p => (p - view_start) * w_scale;\n\n    ctx.save();\n\n    // Draw into triangle, then rotate and scale\n    ctx.rotate(-45 * Math.PI / 180);\n    ctx.scale(invsqrt2, invsqrt2);\n\n    // Paint track.\n    for (var i = 0, len = data.length; i < len; i++) {\n        d = data[i];\n\n        s1 = scale(d[1]);\n        e1 = scale(d[2]);\n        s2 = scale(d[4]);\n        e2 = scale(d[5]);\n        value = d[6];\n\n        ctx.fillStyle = ramp.map_value(value);\n        ctx.fillRect(s1, s2, e1 - s1, e2 - s2);\n    }\n\n    ctx.restore();\n};\n\n/**\n * Utilities for painting reads.\n */\nvar ReadPainterUtils = function(ctx, row_height, px_per_base, mode) {\n    this.ctx = ctx;\n    this.row_height = row_height;\n    this.px_per_base = px_per_base;\n    this.draw_details =\n        (mode === \"Pack\" || mode === \"Auto\") &&\n        px_per_base >= ctx.canvas.manager.char_width_px;\n    this.delete_details_thickness = 0.2;\n};\n\n_.extend(ReadPainterUtils.prototype, {\n    /**\n     * Draw deletion of base(s).\n     * @param draw_detail if true, drawing in detail and deletion is drawn more subtly\n     */\n    draw_deletion: function(x, y, len) {\n        this.ctx.fillStyle = \"black\";\n        var thickness =\n            (this.draw_details ? this.delete_details_thickness : 1) *\n            this.row_height;\n        y += 0.5 * (this.row_height - thickness);\n        this.ctx.fillRect(x, y, len * this.px_per_base, thickness);\n    }\n});\n\n/**\n * Paints variant data onto canvas.\n */\nvar VariantPainter = function(\n    data,\n    view_start,\n    view_end,\n    prefs,\n    mode,\n    base_color_fn\n) {\n    Painter.call(this, data, view_start, view_end, prefs, mode);\n    this.base_color_fn = base_color_fn;\n    this.divider_height = 1;\n};\n\n_.extend(VariantPainter.prototype, Painter.prototype, {\n    /**\n     * Height of a single row, depends on mode\n     */\n    get_row_height: function() {\n        var mode = this.mode;\n        var height;\n        if (mode === \"Dense\") {\n            height = DENSE_TRACK_HEIGHT;\n        } else if (mode === \"Squish\") {\n            height = SQUISH_TRACK_HEIGHT;\n        } else {\n            // mode === \"Pack\"\n            height = PACK_TRACK_HEIGHT;\n        }\n        return height;\n    },\n\n    /**\n     * Returns required height to draw a particular number of samples in a given mode.\n     */\n    get_required_height: function(num_samples) {\n        // FIXME: for single-sample data, height should be summary_height when zoomed out and\n        // row_height when zoomed in.\n        var height = this.prefs.summary_height;\n\n        // If showing sample data, height is summary + divider + samples.\n        if (num_samples > 1 && this.prefs.show_sample_data) {\n            height += this.divider_height + num_samples * this.get_row_height();\n        }\n        return height;\n    },\n\n    /**\n     * Draw on the context using a rectangle of width x height with scale w_scale.\n     */\n    draw: function(ctx, width, height, w_scale) {\n        ctx.save();\n\n        var /**\n         * Returns dictionary of information about an indel; returns empty if there no indel. Assumes indel is left-aligned.\n         * Dict attributes:\n         *    -type: 'insertion' or 'deletion'\n         *    -start: where the deletion starts relative to reference start\n         *    -len: how long the deletion is\n         */\n        get_indel_info = (ref, alt) => {\n            var ref_len = ref.length;\n            var alt_len = alt.length;\n            var start = 0;\n            var len = 1;\n            var type = null;\n            if (alt === \"-\") {\n                type = \"deletion\";\n                len = ref.length;\n            } else if (ref.indexOf(alt) === 0 && ref_len > alt_len) {\n                type = \"deletion\";\n                len = ref_len - alt_len;\n                start = alt_len;\n            } else if (alt.indexOf(ref) === 0 && ref_len < alt_len) {\n                // Insertion.\n                type = \"insertion\";\n                len = alt_len - ref_len;\n                start = alt_len;\n            }\n\n            return type !== null ? { type: type, start: start, len: len } : {};\n        };\n\n        // Draw.\n        var locus_data;\n\n        var pos;\n        var id;\n        var ref;\n        var alt;\n        var qual;\n        var filter;\n        var sample_gts;\n        var allele_counts;\n        var variant;\n        var draw_x_start;\n        var draw_y_start;\n        var genotype;\n\n        var // Always draw variants at least 1 pixel wide.\n        base_px = Math.max(1, Math.floor(w_scale));\n\n        var // Determine number of samples.\n        num_samples = this.data.length ? this.data[0][7].split(\",\").length : 0;\n\n        var row_height =\n            this.mode === \"Squish\" ? SQUISH_TRACK_HEIGHT : PACK_TRACK_HEIGHT;\n\n        var // If zoomed out, fill the whole row with feature to make it easier to read;\n        // when zoomed in, use feature height so that there are gaps in sample rows.\n        feature_height =\n            w_scale < 0.1\n                ? row_height\n                : this.mode === \"Squish\"\n                  ? SQUISH_FEATURE_HEIGHT\n                  : PACK_FEATURE_HEIGHT;\n\n        var draw_summary = true;\n\n        var paint_utils = new ReadPainterUtils(\n            ctx,\n            row_height,\n            w_scale,\n            this.mode\n        );\n\n        var j;\n\n        // If there's a single sample, update drawing variables.\n        if (num_samples === 1) {\n            row_height = feature_height =\n                w_scale < ctx.canvas.manager.char_width_px\n                    ? this.prefs.summary_height\n                    : row_height;\n            paint_utils.row_height = row_height;\n            // No summary when there's a single sample.\n            draw_summary = false;\n        }\n\n        // Draw divider between summary and samples.\n        if (this.prefs.show_sample_data && draw_summary) {\n            ctx.fillStyle = \"#F3F3F3\";\n            ctx.globalAlpha = 1;\n            ctx.fillRect(\n                0,\n                this.prefs.summary_height - this.divider_height,\n                width,\n                this.divider_height\n            );\n        }\n\n        // Draw variants.\n        ctx.textAlign = \"center\";\n        for (var i = 0; i < this.data.length; i++) {\n            // Get locus data.\n            locus_data = this.data[i];\n            pos = locus_data[1];\n            ref = locus_data[3];\n            alt = [locus_data[4].split(\",\")];\n            sample_gts = locus_data[7].split(\",\");\n            allele_counts = locus_data.slice(8);\n\n            // Process alterate values to derive information about each alt.\n            alt = _.map(_.flatten(alt), a => {\n                var alt_info = {\n                    type: \"snp\",\n                    value: a,\n                    start: 0\n                };\n\n                var indel_info = get_indel_info(ref, a);\n\n                return _.extend(alt_info, indel_info);\n            });\n\n            // Only draw locus data if it's in viewing region.\n            if (pos < this.view_start || pos > this.view_end) {\n                continue;\n            }\n\n            // Draw summary for alleles.\n            if (draw_summary) {\n                ctx.fillStyle = \"#999999\";\n                ctx.globalAlpha = 1;\n                for (j = 0; j < alt.length; j++) {\n                    // Draw background for summary.\n                    draw_x_start = this.get_start_draw_pos(\n                        pos + alt[j].start,\n                        w_scale\n                    );\n                    ctx.fillRect(\n                        draw_x_start,\n                        0,\n                        base_px,\n                        this.prefs.summary_height\n                    );\n                    draw_y_start = this.prefs.summary_height;\n                    // Draw allele fractions onto summary.\n                    for (j = 0; j < alt.length; j++) {\n                        ctx.fillStyle =\n                            alt[j].type === \"deletion\"\n                                ? \"black\"\n                                : this.base_color_fn(alt[j].value);\n                        var allele_frac = allele_counts / sample_gts.length;\n                        var draw_height = Math.ceil(\n                            this.prefs.summary_height * allele_frac\n                        );\n                        ctx.fillRect(\n                            draw_x_start,\n                            draw_y_start - draw_height,\n                            base_px,\n                            draw_height\n                        );\n                        draw_y_start -= draw_height;\n                    }\n                }\n            }\n\n            // Done drawing if not showing samples data.\n            if (!this.prefs.show_sample_data) {\n                continue;\n            }\n\n            // Draw sample genotype(s).\n            draw_y_start = draw_summary\n                ? this.prefs.summary_height + this.divider_height\n                : 0;\n            for (\n                j = 0;\n                j < sample_gts.length;\n                j++, draw_y_start += row_height\n            ) {\n                genotype = sample_gts[j]\n                    ? sample_gts[j].split(/\\/|\\|/)\n                    : [\"0\", \"0\"];\n\n                // Get variant to draw and set drawing properties.\n                variant = null;\n                if (genotype[0] === genotype[1]) {\n                    if (genotype[0] === \".\") {\n                        // TODO: draw uncalled variant.\n                    } else if (genotype[0] !== \"0\") {\n                        // Homozygous for variant.\n                        variant = alt[parseInt(genotype[0], 10) - 1];\n                        ctx.globalAlpha = 1;\n                    }\n                    // else reference\n                } else {\n                    // Heterozygous for variant.\n                    variant = genotype[0] !== \"0\" ? genotype[0] : genotype[1];\n                    variant = alt[parseInt(variant, 10) - 1];\n                    ctx.globalAlpha = 0.5;\n                }\n\n                // If there's a variant, draw it.\n                if (variant) {\n                    draw_x_start = this.get_start_draw_pos(\n                        pos + variant.start,\n                        w_scale\n                    );\n                    if (variant.type === \"snp\") {\n                        var snp = variant.value;\n                        ctx.fillStyle = this.base_color_fn(snp);\n                        if (paint_utils.draw_details) {\n                            ctx.fillText(\n                                snp,\n                                this.get_draw_pos(pos, w_scale),\n                                draw_y_start + row_height\n                            );\n                        } else {\n                            ctx.fillRect(\n                                draw_x_start,\n                                draw_y_start + 1,\n                                base_px,\n                                feature_height\n                            );\n                        }\n                    } else if (variant.type === \"deletion\") {\n                        paint_utils.draw_deletion(\n                            draw_x_start,\n                            draw_y_start + 1,\n                            variant.len\n                        );\n                    } else {\n                        // TODO: handle insertions.\n                    }\n                }\n            }\n        }\n\n        ctx.restore();\n    }\n});\n\nexport default {\n    Scaler: Scaler,\n    LinePainter: LinePainter,\n    LinkedFeaturePainter: LinkedFeaturePainter,\n    ReadPainter: ReadPainter,\n    ArcLinkedFeaturePainter: ArcLinkedFeaturePainter,\n    DiagonalHeatmapPainter: DiagonalHeatmapPainter,\n    VariantPainter: VariantPainter\n};\n"]}