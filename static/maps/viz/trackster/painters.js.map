{"version":3,"sources":["viz/trackster/painters.js"],"names":["define","_","compute_overlap","first_region","second_region","CONTAINED_BY","AFTER","second_end","first_start","second_start","OVERLAP_START","first_end","is_overlap","overlap","dashedLine","ctx","x1","y1","x2","y2","dashLen","undefined","q","dX","dashes","Math","floor","sqrt","dY","dashX","dashY","fillRect","drawDownwardEquilateralTriangle","down_vertex_x","down_vertex_y","side_len","y","lineTo","strokeStyle","this","fillStyle","stroke","closePath","Scaler","default_val","prototype","gen_val","input","DrawResults","feature_mapper","options","incomplete_features","Painter","data","view_start","view_end","prefs","mode","extend","default_prefs","draw","width","height","w_scale","get_start_draw_pos","chrom_pos","_chrom_pos_to_draw_pos","get_end_draw_pos","get_draw_pos","LinePainter","offset","color","overflow_color","min_value","in_path","max_value","height_px","vertical_range","y_zero","beginPath","round","delta_x_pxs","x_scaled","length","painter_color","block_color","d","ceil","i","pref_color","bot_overflow","parseInt","slice","pref_r","delta_x_px","pref_g","pref_b","top_overflow","len","new_g","new_b","new_r","saturation","overflow_x","moveTo","restore","FeaturePositionMapper","feature_positions","slot_height","fill","feature_data","x_start","x_end","translation","y_translation","map_feature_data","slot","push","x","feature_dict","get_feature_data","alpha_scaler","FeaturePainter","connector_color","required_height","get_top_padding","height_scaler","call","max_label_length","get_row_height","y_scale","rows_required","x_draw_coords","draw_element","textAlign","feature","feature_uid","feature_start","feature_end","slots","NO_DETAIL_TRACK_HEIGHT","SQUISH_TRACK_HEIGHT","NO_DETAIL_FEATURE_HEIGHT","DENSE_FEATURE_HEIGHT","SQUISH_FEATURE_HEIGHT","PACK_FEATURE_HEIGHT","LABEL_SPACING","CONNECTOR_COLOR","LinkedFeaturePainter","draw_individual_connectors","PACK_TRACK_HEIGHT","tile_low","tile_high","f_start","draw_start","full_height","thick_end","thin_height","feature_name","cur_y_start","feature_strand","cur_height","max","f_end","draw_end","y_start","draw_background_connector","thick_start","label_color","globalAlpha","block_end","block_start","feature_blocks","feature_ts","feature_te","block_thick_end","block_thick_start","min","thick_height","ReadPainter","base_color_fn","DENSE_TRACK_HEIGHT","canvas","manager","get_pattern","show_insertions","base_pos","k","k_len","parsed_cigar","op_len","last_block_start","last_block_end","block","cur_block","blocks","indexOf","tile_region","base_offset","seq_offset","pack_mode","draw_height","drawing_blocks","get_draw_coord","s_end","draw_connector","cig_op","cig_len","update_base_offset","update_seq_offset","new_height","hscale_factor","ws_height","s_start","measureText","cur_seq","fillText","start_pos","seq_start","ref_seq","paint_utils","draw_last","type","seq","map","cigar_str","match","x_center","op_char","op","item","draw_read","cigar","read_seq","connector","sequence_coord","gap","char_width_px","strand","detail_block_color","reverse_strand_color","rect_y","b1_end","b2_start","t","calculate_longest_feature_length","cig_id","view_range","rgb","alpha","c","show_differences","c_start","b","argb","color1","p","w1","draw_deletion","a","w2","insert_x_coord","end_value","start_value","value_range","end_color","mix","positive_ramp","LinearRamp","middle_color","map_value","negative_ramp","DiagonalHeatmapPainter","Infinity","str_len","value","scale","ReadPainterUtils","radius","arc","thickness","save","font","VariantPainter","get_required_height","summary_height","num_samples","Array","ref_len","ref","alt_len","alt","start","locus_data","pos","filter","sample_gts","allele_counts","variant","draw_x_start","draw_y_start","genotype","draw_summary","line_height","alt_info","indel_info","j","ArcLinkedFeaturePainter","longest_feature_length","draw_details","block2_end","block1_end","block2_start","PI","Color","isArray","substring","split","eval","toCSS","concat","join","toString","toHSL","h","s","r","g","l","toARGB","color2","weight","w","start_color","SplitRamp","pos_color","neg_color","s1","e1","s2","e2","invsqrt2","ramp","rotate","row_height","px_per_base","delete_details_thickness","divider_height","show_sample_data","get_indel_info","base_px","feature_height","flatten","allele_frac","snp"],"mappings":"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","file":"../../../scripts/viz/trackster/painters.js","sourcesContent":["define([\"libs/underscore\"], function(_) {\n    /**\n * Compute the type of overlap between two regions. They are assumed to be on the same chrom/contig.\n * The overlap is computed relative to the second region; hence, OVERLAP_START indicates that the first\n * region overlaps the start (but not the end) of the second region.\n * NOTE: Coordinates are assumed to be in BED format: half open (start is closed, end is open).\n */\n    var BEFORE = 1001,\n        CONTAINS = 1002,\n        OVERLAP_START = 1003,\n        OVERLAP_END = 1004,\n        CONTAINED_BY = 1005,\n        AFTER = 1006;\n    var compute_overlap = function(first_region, second_region) {\n        var first_start = first_region[0],\n            first_end = first_region[1],\n            second_start = second_region[0],\n            second_end = second_region[1],\n            overlap;\n        if (first_start < second_start) {\n            if (first_end <= second_start) {\n                overlap = BEFORE;\n            } else if (first_end <= second_end) {\n                overlap = OVERLAP_START;\n            } else {\n                // first_end > second_end\n                overlap = CONTAINS;\n            }\n        } else {\n            // first_start >= second_start\n            if (first_start > second_end) {\n                overlap = AFTER;\n            } else if (first_end <= second_end) {\n                overlap = CONTAINED_BY;\n            } else {\n                overlap = OVERLAP_END;\n            }\n        }\n\n        return overlap;\n    };\n\n    /**\n * Returns true if regions overlap.\n */\n    var is_overlap = function(first_region, second_region) {\n        var overlap = compute_overlap(first_region, second_region);\n        return overlap !== BEFORE && overlap !== AFTER;\n    };\n\n    /**\n * Draw a dashed line on a canvas using filled rectangles. This function is based on:\n * http://vetruvet.blogspot.com/2010/10/drawing-dashed-lines-on-html5-canvas.html\n * However, that approach uses lines, which don't seem to render as well, so use\n * rectangles instead.\n */\n    var dashedLine = function(ctx, x1, y1, x2, y2, dashLen) {\n        if (dashLen === undefined) {\n            dashLen = 4;\n        }\n        var dX = x2 - x1;\n        var dY = y2 - y1;\n        var dashes = Math.floor(Math.sqrt(dX * dX + dY * dY) / dashLen);\n        var dashX = dX / dashes;\n        var dashY = dY / dashes;\n        var q;\n\n        for (q = 0; q < dashes; q++, x1 += dashX, y1 += dashY) {\n            if (q % 2 !== 0) {\n                continue;\n            }\n            ctx.fillRect(x1, y1, dashLen, 1);\n        }\n    };\n\n    /**\n * Draw an isosceles triangle that points down.\n */\n    var drawDownwardEquilateralTriangle = function(\n        ctx,\n        down_vertex_x,\n        down_vertex_y,\n        side_len\n    ) {\n        // Compute other two points of triangle.\n        var x1 = down_vertex_x - side_len / 2,\n            x2 = down_vertex_x + side_len / 2,\n            y = down_vertex_y - Math.sqrt(side_len * 3 / 2);\n\n        // Draw and fill.\n        ctx.beginPath();\n        ctx.moveTo(x1, y);\n        ctx.lineTo(x2, y);\n        ctx.lineTo(down_vertex_x, down_vertex_y);\n        ctx.lineTo(x1, y);\n\n        ctx.strokeStyle = this.fillStyle;\n        ctx.fill();\n        ctx.stroke();\n        ctx.closePath();\n    };\n\n    /**\n * Base class for all scalers. Scalers produce values that are used to change (scale) drawing attributes.\n */\n    var Scaler = function(default_val) {\n        this.default_val = default_val ? default_val : 1;\n    };\n\n    /**\n * Produce a scaling value.\n */\n    Scaler.prototype.gen_val = function(input) {\n        return this.default_val;\n    };\n\n    /**\n * Results from painter.draw()\n */\n    var DrawResults = function(options) {\n        this.incomplete_features = options.incomplete_features;\n        this.feature_mapper = options.feature_mapper;\n    };\n\n    /**\n * Base class for painters\n *\n * -- Mode and prefs are both optional\n */\n    var Painter = function(data, view_start, view_end, prefs, mode) {\n        // Data and data properties\n        this.data = data;\n        // View\n        this.view_start = view_start;\n        this.view_end = view_end;\n        // Drawing prefs\n        this.prefs = _.extend({}, this.default_prefs, prefs);\n        this.mode = mode;\n    };\n\n    Painter.prototype.default_prefs = {};\n\n    /**\n * Draw on the context using a rectangle of width x height using scale w_scale.\n */\n    Painter.prototype.draw = function(ctx, width, height, w_scale) {};\n\n    /**\n * Get starting drawing position, which is offset a half-base left of coordinate.\n */\n    Painter.prototype.get_start_draw_pos = function(chrom_pos, w_scale) {\n        return this._chrom_pos_to_draw_pos(chrom_pos, w_scale, -0.5);\n    };\n\n    /**\n * Get end drawing position, which is offset a half-base right of coordinate.\n */\n    Painter.prototype.get_end_draw_pos = function(chrom_pos, w_scale) {\n        return this._chrom_pos_to_draw_pos(chrom_pos, w_scale, 0.5);\n    };\n\n    /**\n * Get drawing position.\n */\n    Painter.prototype.get_draw_pos = function(chrom_pos, w_scale) {\n        return this._chrom_pos_to_draw_pos(chrom_pos, w_scale, 0);\n    };\n\n    /**\n * Convert chromosome position to drawing position.\n */\n    Painter.prototype._chrom_pos_to_draw_pos = function(\n        chrom_pos,\n        w_scale,\n        offset\n    ) {\n        return Math.floor(\n            w_scale * (Math.max(0, chrom_pos - this.view_start) + offset)\n        );\n    };\n\n    var LinePainter = function(data, view_start, view_end, prefs, mode) {\n        Painter.call(this, data, view_start, view_end, prefs, mode);\n    };\n\n    LinePainter.prototype.default_prefs = {\n        min_value: undefined,\n        max_value: undefined,\n        mode: \"Histogram\",\n        color: \"#000\",\n        overflow_color: \"#F66\"\n    };\n\n    LinePainter.prototype.draw = function(ctx, width, height, w_scale) {\n        var in_path = false,\n            min_value = this.prefs.min_value,\n            max_value = this.prefs.max_value,\n            vertical_range = max_value - min_value,\n            height_px = height,\n            view_start = this.view_start,\n            mode = this.mode,\n            data = this.data;\n\n        ctx.save();\n\n        // Pixel position of 0 on the y axis\n        var y_zero = Math.round(height + min_value / vertical_range * height);\n\n        // Horizontal line to denote x-axis\n        if (mode !== \"Intensity\") {\n            ctx.fillStyle = \"#aaa\";\n            ctx.fillRect(0, y_zero, width, 1);\n        }\n\n        ctx.beginPath();\n        var x_scaled, y, delta_x_pxs;\n        if (data.length > 1) {\n            delta_x_pxs = _.map(data.slice(0, -1), function(d, i) {\n                return Math.ceil((data[i + 1][0] - data[i][0]) * w_scale);\n            });\n        } else {\n            delta_x_pxs = [10];\n        }\n\n        // Painter color can be in either block_color (FeatureTrack) or color pref (LineTrack).\n        var painter_color = this.prefs.block_color || this.prefs.color,\n            // Extract RGB from preference color.\n            pref_color = parseInt(painter_color.slice(1), 16),\n            pref_r = (pref_color & 0xff0000) >> 16,\n            pref_g = (pref_color & 0x00ff00) >> 8,\n            pref_b = pref_color & 0x0000ff,\n            top_overflow = false,\n            bot_overflow = false;\n\n        // Paint track.\n        var delta_x_px;\n        for (var i = 0, len = data.length; i < len; i++) {\n            // Reset attributes for next point.\n            ctx.fillStyle = ctx.strokeStyle = painter_color;\n            top_overflow = bot_overflow = false;\n            delta_x_px = delta_x_pxs[i];\n\n            x_scaled = Math.floor((data[i][0] - view_start - 0.5) * w_scale);\n            y = data[i][1];\n\n            // Process Y (scaler) value.\n            if (y === null) {\n                if (in_path && mode === \"Filled\") {\n                    ctx.lineTo(x_scaled, height_px);\n                }\n                in_path = false;\n                continue;\n            }\n\n            // Bound Y value by min, max.\n            if (y < min_value) {\n                bot_overflow = true;\n                y = min_value;\n            } else if (y > max_value) {\n                top_overflow = true;\n                y = max_value;\n            }\n\n            // Draw point.\n            if (mode === \"Histogram\") {\n                // y becomes the bar height in pixels, which is the negated for canvas coords\n                y = Math.round(y / vertical_range * height_px);\n                ctx.fillRect(x_scaled, y_zero, delta_x_px, -y);\n            } else if (mode === \"Intensity\") {\n                var saturation = (y - min_value) / vertical_range,\n                    // Range is [pref_color, 255] where saturation = 0 --> 255 and saturation = 1 --> pref color\n                    new_r = Math.round(\n                        pref_r + (255 - pref_r) * (1 - saturation)\n                    ),\n                    new_g = Math.round(\n                        pref_g + (255 - pref_g) * (1 - saturation)\n                    ),\n                    new_b = Math.round(\n                        pref_b + (255 - pref_b) * (1 - saturation)\n                    );\n                ctx.fillStyle =\n                    \"rgb(\" + new_r + \",\" + new_g + \",\" + new_b + \")\";\n                ctx.fillRect(x_scaled, 0, delta_x_px, height_px);\n            } else {\n                // mode is Coverage/Line or Filled.\n\n                // Scale Y value.\n                y = Math.round(\n                    height_px - (y - min_value) / vertical_range * height_px\n                );\n                if (in_path) {\n                    ctx.lineTo(x_scaled, y);\n                } else {\n                    in_path = true;\n                    if (mode === \"Filled\") {\n                        ctx.moveTo(x_scaled, height_px);\n                        ctx.lineTo(x_scaled, y);\n                    } else {\n                        ctx.moveTo(x_scaled, y);\n                        // Use this approach (note: same as for filled) to draw line from 0 to\n                        // first data point.\n                        //ctx.moveTo(x_scaled, height_px);\n                        //ctx.lineTo(x_scaled, y);\n                    }\n                }\n            }\n\n            // Draw lines at boundaries if overflowing min or max\n            ctx.fillStyle = this.prefs.overflow_color;\n            if (top_overflow || bot_overflow) {\n                var overflow_x;\n                if (mode === \"Histogram\" || mode === \"Intensity\") {\n                    overflow_x = delta_x_px;\n                } else {\n                    // Line and Filled, which are points\n                    x_scaled -= 2; // Move it over to the left so it's centered on the point\n                    overflow_x = 4;\n                }\n                if (top_overflow) {\n                    ctx.fillRect(x_scaled, 0, overflow_x, 3);\n                }\n                if (bot_overflow) {\n                    ctx.fillRect(x_scaled, height_px - 3, overflow_x, 3);\n                }\n            }\n            ctx.fillStyle = painter_color;\n        }\n        if (mode === \"Filled\") {\n            if (in_path) {\n                ctx.lineTo(x_scaled, y_zero);\n                ctx.lineTo(0, y_zero);\n            }\n            ctx.fill();\n        } else {\n            ctx.stroke();\n        }\n\n        ctx.restore();\n    };\n\n    /**\n * Mapper that contains information about feature locations and data.\n */\n    var FeaturePositionMapper = function(slot_height) {\n        this.feature_positions = {};\n        this.slot_height = slot_height;\n        this.translation = 0;\n        this.y_translation = 0;\n    };\n\n    /**\n * Map feature data to a position defined by <slot, x_start, x_end>.\n */\n    FeaturePositionMapper.prototype.map_feature_data = function(\n        feature_data,\n        slot,\n        x_start,\n        x_end\n    ) {\n        if (!this.feature_positions[slot]) {\n            this.feature_positions[slot] = [];\n        }\n        this.feature_positions[slot].push({\n            data: feature_data,\n            x_start: x_start,\n            x_end: x_end\n        });\n    };\n\n    /**\n * Get feature data for position <x, y>\n */\n    FeaturePositionMapper.prototype.get_feature_data = function(x, y) {\n        // Find slot using Y.\n        var slot = Math.floor((y - this.y_translation) / this.slot_height),\n            feature_dict;\n\n        // May not be over a slot due to padding, margin, etc.\n        if (!this.feature_positions[slot]) {\n            return null;\n        }\n\n        // Find feature using X.\n        x += this.translation;\n        for (var i = 0; i < this.feature_positions[slot].length; i++) {\n            feature_dict = this.feature_positions[slot][i];\n            if (x >= feature_dict.x_start && x <= feature_dict.x_end) {\n                return feature_dict.data;\n            }\n        }\n    };\n\n    /**\n * Abstract object for painting feature tracks. Subclasses must implement draw_element() for painting to work.\n * Painter uses a 0-based, half-open coordinate system; start coordinate is closed--included--and the end is open.\n * This coordinate system matches the BED format.\n */\n    var FeaturePainter = function(\n        data,\n        view_start,\n        view_end,\n        prefs,\n        mode,\n        alpha_scaler,\n        height_scaler\n    ) {\n        Painter.call(this, data, view_start, view_end, prefs, mode);\n        this.alpha_scaler = alpha_scaler ? alpha_scaler : new Scaler();\n        this.height_scaler = height_scaler ? height_scaler : new Scaler();\n        this.max_label_length = 200;\n    };\n\n    FeaturePainter.prototype.default_prefs = {\n        block_color: \"#FFF\",\n        connector_color: \"#FFF\"\n    };\n\n    _.extend(FeaturePainter.prototype, {\n        get_required_height: function(rows_required, width) {\n            // y_scale is the height per row\n            var required_height = this.get_row_height(),\n                y_scale = required_height,\n                mode = this.mode;\n            // If using a packing mode, need to multiply by the number of slots used\n            if (mode === \"no_detail\" || mode === \"Squish\" || mode === \"Pack\") {\n                required_height = rows_required * y_scale;\n            }\n            return required_height + this.get_top_padding(width);\n        },\n\n        /** Extra padding before first row of features */\n        get_top_padding: function(width) {\n            return 0;\n        },\n\n        /**\n     * Draw data on ctx using slots and within the rectangle defined by width and height. Returns\n     * a FeaturePositionMapper object with information about where features were drawn.\n     */\n        draw: function(ctx, width, height, w_scale, slots) {\n            var data = this.data,\n                view_start = this.view_start,\n                view_end = this.view_end;\n\n            ctx.save();\n\n            ctx.fillStyle = this.prefs.block_color;\n            ctx.textAlign = \"right\";\n\n            var y_scale = this.get_row_height(),\n                feature_mapper = new FeaturePositionMapper(y_scale),\n                x_draw_coords,\n                incomplete_features = [];\n\n            for (var i = 0, len = data.length; i < len; i++) {\n                var feature = data[i],\n                    feature_uid = feature[0],\n                    feature_start = feature[1],\n                    feature_end = feature[2],\n                    // Slot valid only if features are slotted and this feature is slotted;\n                    // feature may not be due to lack of space.\n                    slot =\n                        slots && slots[feature_uid] !== undefined\n                            ? slots[feature_uid].slot\n                            : null;\n\n                // Draw feature if (a) mode is dense or feature is slotted (as it must be for all non-dense modes) and\n                // (b) there's overlap between the feature and drawing region.\n                if (\n                    (this.mode === \"Dense\" || slot !== null) &&\n                    (feature_start < view_end && feature_end > view_start)\n                ) {\n                    x_draw_coords = this.draw_element(\n                        ctx,\n                        this.mode,\n                        feature,\n                        slot,\n                        view_start,\n                        view_end,\n                        w_scale,\n                        y_scale,\n                        width\n                    );\n                    feature_mapper.map_feature_data(\n                        feature,\n                        slot,\n                        x_draw_coords[0],\n                        x_draw_coords[1]\n                    );\n\n                    // Add to incomplete features if it's not drawn completely in region.\n                    if (feature_start < view_start || feature_end > view_end) {\n                        incomplete_features.push(feature);\n                    }\n                }\n            }\n\n            ctx.restore();\n\n            feature_mapper.y_translation = this.get_top_padding(width);\n            return new DrawResults({\n                incomplete_features: incomplete_features,\n                feature_mapper: feature_mapper\n            });\n        },\n\n        /**\n     * Abstract function for drawing an individual feature.\n     */\n        draw_element: function(\n            ctx,\n            mode,\n            feature,\n            slot,\n            tile_low,\n            tile_high,\n            w_scale,\n            y_scale,\n            width\n        ) {\n            return [0, 0];\n        }\n    });\n\n    // Constants specific to feature tracks moved here (HACKING, these should\n    // basically all be configuration options)\n    var DENSE_TRACK_HEIGHT = 10,\n        NO_DETAIL_TRACK_HEIGHT = 3,\n        SQUISH_TRACK_HEIGHT = 5,\n        PACK_TRACK_HEIGHT = 10,\n        NO_DETAIL_FEATURE_HEIGHT = 1,\n        DENSE_FEATURE_HEIGHT = 9,\n        SQUISH_FEATURE_HEIGHT = 3,\n        PACK_FEATURE_HEIGHT = 9,\n        LABEL_SPACING = 2,\n        CONNECTOR_COLOR = \"#ccc\";\n\n    var LinkedFeaturePainter = function(\n        data,\n        view_start,\n        view_end,\n        prefs,\n        mode,\n        alpha_scaler,\n        height_scaler\n    ) {\n        FeaturePainter.call(\n            this,\n            data,\n            view_start,\n            view_end,\n            prefs,\n            mode,\n            alpha_scaler,\n            height_scaler\n        );\n        // Whether to draw a single connector in the background that spans the entire feature (the intron fishbone)\n        this.draw_background_connector = true;\n        // Whether to call draw_connector for every pair of blocks\n        this.draw_individual_connectors = false;\n    };\n\n    _.extend(LinkedFeaturePainter.prototype, FeaturePainter.prototype, {\n        /**\n     * Height of a single row, depends on mode\n     */\n        get_row_height: function() {\n            var mode = this.mode,\n                height;\n            if (mode === \"Dense\") {\n                height = DENSE_TRACK_HEIGHT;\n            } else if (mode === \"no_detail\") {\n                height = NO_DETAIL_TRACK_HEIGHT;\n            } else if (mode === \"Squish\") {\n                height = SQUISH_TRACK_HEIGHT;\n            } else {\n                // mode === \"Pack\"\n                height = PACK_TRACK_HEIGHT;\n            }\n            return height;\n        },\n\n        /**\n     * Draw a feature. Returns an array with feature's start and end X coordinates.\n     */\n        draw_element: function(\n            ctx,\n            mode,\n            feature,\n            slot,\n            tile_low,\n            tile_high,\n            w_scale,\n            y_scale,\n            width\n        ) {\n            var feature_uid = feature[0],\n                feature_start = feature[1],\n                feature_end = feature[2],\n                feature_name = feature[3],\n                feature_strand = feature[4],\n                // -0.5 to offset region between bases.\n                f_start = Math.floor(\n                    Math.max(0, (feature_start - tile_low - 0.5) * w_scale)\n                ),\n                f_end = Math.ceil(\n                    Math.min(\n                        width,\n                        Math.max(0, (feature_end - tile_low - 0.5) * w_scale)\n                    )\n                ),\n                draw_start = f_start,\n                draw_end = f_end,\n                y_start =\n                    (mode === \"Dense\" ? 0 : 0 + slot) * y_scale +\n                    this.get_top_padding(width),\n                thickness,\n                y_start,\n                thick_start = null,\n                thick_end = null,\n                // TODO: is there any reason why block, label color cannot be set at the Painter level?\n                // For now, assume '.' === '+'\n                block_color =\n                    !feature_strand ||\n                    feature_strand === \"+\" ||\n                    feature_strand === \".\"\n                        ? this.prefs.block_color\n                        : this.prefs.reverse_strand_color,\n                label_color = this.prefs.label_color;\n\n            // Set global alpha.\n            ctx.globalAlpha = this.alpha_scaler.gen_val(feature);\n\n            // In dense mode, put all data in top slot.\n            if (mode === \"Dense\") {\n                slot = 1;\n            }\n\n            if (mode === \"no_detail\") {\n                // No details for feature, so only one way to display.\n                ctx.fillStyle = block_color;\n                ctx.fillRect(\n                    f_start,\n                    y_start + 5,\n                    f_end - f_start,\n                    NO_DETAIL_FEATURE_HEIGHT\n                );\n            } else {\n                // Mode is either Squish or Pack:\n                // Feature details.\n                var feature_ts = feature[5],\n                    feature_te = feature[6],\n                    feature_blocks = feature[7],\n                    // Whether we are drawing full height or squished features\n                    full_height = true;\n\n                if (feature_ts && feature_te) {\n                    thick_start = Math.floor(\n                        Math.max(0, (feature_ts - tile_low) * w_scale)\n                    );\n                    thick_end = Math.ceil(\n                        Math.min(\n                            width,\n                            Math.max(0, (feature_te - tile_low) * w_scale)\n                        )\n                    );\n                }\n\n                // Set vars that depend on mode.\n                var thin_height, thick_height;\n                if (mode === \"Squish\") {\n                    thin_height = 1;\n                    thick_height = SQUISH_FEATURE_HEIGHT;\n                    full_height = false;\n                } else if (mode === \"Dense\") {\n                    thin_height = 5;\n                    thick_height = DENSE_FEATURE_HEIGHT;\n                } else {\n                    // mode === \"Pack\"\n                    thin_height = 5;\n                    thick_height = PACK_FEATURE_HEIGHT;\n                }\n\n                // Draw feature/feature blocks + connectors.\n                if (!feature_blocks) {\n                    // If there are no blocks, treat the feature as one big exon.\n                    ctx.fillStyle = block_color;\n                    ctx.fillRect(\n                        f_start,\n                        y_start + 1,\n                        f_end - f_start,\n                        thick_height\n                    );\n                    // If strand is specified, draw arrows over feature\n                    if (feature_strand && full_height) {\n                        if (feature_strand === \"+\") {\n                            ctx.fillStyle = ctx.canvas.manager.get_pattern(\n                                \"right_strand_inv\"\n                            );\n                        } else if (feature_strand === \"-\") {\n                            ctx.fillStyle = ctx.canvas.manager.get_pattern(\n                                \"left_strand_inv\"\n                            );\n                        }\n                        ctx.fillRect(\n                            f_start,\n                            y_start + 1,\n                            f_end - f_start,\n                            thick_height\n                        );\n                    }\n                } else {\n                    //\n                    // There are feature blocks and mode is either Squish or Pack.\n                    //\n                    // Approach: (a) draw whole feature as connector/intron and (b) draw blocks as\n                    // needed. This ensures that whole feature, regardless of whether it starts with\n                    // a block, is visible.\n                    //\n\n                    // Compute y axis start position and height\n                    var cur_y_start, cur_height;\n                    if (mode === \"Squish\" || mode === \"Dense\") {\n                        cur_y_start =\n                            y_start + Math.floor(SQUISH_FEATURE_HEIGHT / 2) + 1;\n                        cur_height = 1;\n                    } else {\n                        // mode === \"Pack\"\n                        if (feature_strand) {\n                            cur_y_start = y_start;\n                            cur_height = thick_height;\n                        } else {\n                            cur_y_start += SQUISH_FEATURE_HEIGHT / 2 + 1;\n                            cur_height = 1;\n                        }\n                    }\n\n                    // Draw whole feature as connector/intron.\n                    if (this.draw_background_connector) {\n                        if (mode === \"Squish\" || mode === \"Dense\") {\n                            ctx.fillStyle = CONNECTOR_COLOR;\n                        } else {\n                            // mode === \"Pack\"\n                            if (feature_strand) {\n                                if (feature_strand === \"+\") {\n                                    ctx.fillStyle = ctx.canvas.manager.get_pattern(\n                                        \"right_strand\"\n                                    );\n                                } else if (feature_strand === \"-\") {\n                                    ctx.fillStyle = ctx.canvas.manager.get_pattern(\n                                        \"left_strand\"\n                                    );\n                                }\n                            } else {\n                                ctx.fillStyle = CONNECTOR_COLOR;\n                            }\n                        }\n                        ctx.fillRect(\n                            f_start,\n                            cur_y_start,\n                            f_end - f_start,\n                            cur_height\n                        );\n                    }\n\n                    // Draw blocks.\n                    var start_and_height;\n                    for (\n                        var k = 0, k_len = feature_blocks.length;\n                        k < k_len;\n                        k++\n                    ) {\n                        var block = feature_blocks[k],\n                            // -0.5 to offset block between bases.\n                            block_start = Math.floor(\n                                Math.max(\n                                    0,\n                                    (block[0] - tile_low - 0.5) * w_scale\n                                )\n                            ),\n                            block_end = Math.ceil(\n                                Math.min(\n                                    width,\n                                    Math.max(\n                                        (block[1] - tile_low - 0.5) * w_scale\n                                    )\n                                )\n                            ),\n                            last_block_start,\n                            last_block_end;\n\n                        // Skip drawing if block not on tile.\n                        if (block_start > block_end) {\n                            continue;\n                        }\n\n                        // Draw thin block.\n                        ctx.fillStyle = block_color;\n                        ctx.fillRect(\n                            block_start,\n                            y_start + (thick_height - thin_height) / 2 + 1,\n                            block_end - block_start,\n                            thin_height\n                        );\n\n                        // If block intersects with thick region, draw block as thick.\n                        // - No thick is sometimes encoded as thick_start == thick_end, so don't draw in that case\n                        if (\n                            thick_start !== undefined &&\n                            feature_te > feature_ts &&\n                            !(\n                                block_start > thick_end ||\n                                block_end < thick_start\n                            )\n                        ) {\n                            var block_thick_start = Math.max(\n                                    block_start,\n                                    thick_start\n                                ),\n                                block_thick_end = Math.min(\n                                    block_end,\n                                    thick_end\n                                );\n                            ctx.fillRect(\n                                block_thick_start,\n                                y_start + 1,\n                                block_thick_end - block_thick_start,\n                                thick_height\n                            );\n                            if (\n                                feature_blocks.length === 1 &&\n                                mode === \"Pack\"\n                            ) {\n                                // Exactly one block means we have no introns, but do have a distinct \"thick\" region,\n                                // draw arrows over it if in pack mode.\n                                if (feature_strand === \"+\") {\n                                    ctx.fillStyle = ctx.canvas.manager.get_pattern(\n                                        \"right_strand_inv\"\n                                    );\n                                } else if (feature_strand === \"-\") {\n                                    ctx.fillStyle = ctx.canvas.manager.get_pattern(\n                                        \"left_strand_inv\"\n                                    );\n                                }\n                                // If region is wide enough in pixels, pad a bit\n                                if (block_thick_start + 14 < block_thick_end) {\n                                    block_thick_start += 2;\n                                    block_thick_end -= 2;\n                                }\n                                ctx.fillRect(\n                                    block_thick_start,\n                                    y_start + 1,\n                                    block_thick_end - block_thick_start,\n                                    thick_height\n                                );\n                            }\n                        }\n                        // Draw individual connectors if required\n                        if (\n                            this.draw_individual_connectors &&\n                            last_block_start\n                        ) {\n                            this.draw_connector(\n                                ctx,\n                                last_block_start,\n                                last_block_end,\n                                block_start,\n                                block_end,\n                                y_start\n                            );\n                        }\n                        last_block_start = block_start;\n                        last_block_end = block_end;\n                    }\n\n                    // FIXME: Height scaling only works in Pack mode right now.\n                    if (mode === \"Pack\") {\n                        // Reset alpha so height scaling is not impacted by alpha scaling.\n                        ctx.globalAlpha = 1;\n\n                        // Height scaling: draw white lines to reduce height according to height scale factor.\n                        ctx.fillStyle = \"white\"; // TODO: set this to background color.\n                        var hscale_factor = this.height_scaler.gen_val(feature),\n                            // Ceil ensures that min height is >= 1.\n                            new_height = Math.ceil(\n                                thick_height * hscale_factor\n                            ),\n                            ws_height = Math.round(\n                                (thick_height - new_height) / 2\n                            );\n                        if (hscale_factor !== 1) {\n                            ctx.fillRect(\n                                f_start,\n                                cur_y_start + 1,\n                                f_end - f_start,\n                                ws_height\n                            );\n                            ctx.fillRect(\n                                f_start,\n                                cur_y_start + thick_height - ws_height + 1,\n                                f_end - f_start,\n                                ws_height\n                            );\n                        }\n                    }\n                }\n\n                // Reset alpha so that label is not transparent.\n                ctx.globalAlpha = 1;\n\n                // Draw label for Pack mode.\n                if (\n                    feature_name &&\n                    mode === \"Pack\" &&\n                    feature_start > tile_low\n                ) {\n                    ctx.fillStyle = label_color;\n                    // FIXME: assumption here that the entire view starts at 0\n                    if (\n                        tile_low === 0 &&\n                        f_start - ctx.measureText(feature_name).width < 0\n                    ) {\n                        ctx.textAlign = \"left\";\n                        ctx.fillText(\n                            feature_name,\n                            f_end + LABEL_SPACING,\n                            y_start + 8,\n                            this.max_label_length\n                        );\n                        draw_end +=\n                            ctx.measureText(feature_name).width + LABEL_SPACING;\n                    } else {\n                        ctx.textAlign = \"right\";\n                        ctx.fillText(\n                            feature_name,\n                            f_start - LABEL_SPACING,\n                            y_start + 8,\n                            this.max_label_length\n                        );\n                        draw_start -=\n                            ctx.measureText(feature_name).width + LABEL_SPACING;\n                    }\n                    //ctx.fillStyle = block_color;\n                }\n            }\n\n            // Reset global alpha.\n            ctx.globalAlpha = 1;\n\n            return [draw_start, draw_end];\n        }\n    });\n\n    var ReadPainter = function(\n        data,\n        view_start,\n        view_end,\n        prefs,\n        mode,\n        alpha_scaler,\n        height_scaler,\n        ref_seq,\n        base_color_fn\n    ) {\n        FeaturePainter.call(\n            this,\n            data,\n            view_start,\n            view_end,\n            prefs,\n            mode,\n            alpha_scaler,\n            height_scaler\n        );\n        this.ref_seq = ref_seq ? ref_seq.data : null;\n        this.base_color_fn = base_color_fn;\n    };\n\n    _.extend(ReadPainter.prototype, FeaturePainter.prototype, {\n        /**\n     * Returns height based on mode.\n     */\n        get_row_height: function() {\n            var height,\n                mode = this.mode;\n            if (mode === \"Dense\") {\n                height = DENSE_TRACK_HEIGHT;\n            } else if (mode === \"Squish\") {\n                height = SQUISH_TRACK_HEIGHT;\n            } else {\n                // mode === \"Pack\"\n                height = PACK_TRACK_HEIGHT;\n                if (this.prefs.show_insertions) {\n                    height *= 2;\n                }\n            }\n            return height;\n        },\n\n        /**\n     * Parse CIGAR string to get (a) a list of contiguous drawing blocks (MD=X) and\n     * (b) an array of [ op_index, op_len ] pairs where op_index is an index into the\n     * string 'MIDNSHP=X' Return value is a dictionary with two entries, blocks and cigar\n     */\n        _parse_cigar: function(cigar_str) {\n            var cigar_ops = \"MIDNSHP=X\";\n\n            // Parse cigar.\n            var blocks = [[0, 0]],\n                cur_block = blocks[0],\n                base_pos = 0,\n                // Parse cigar operations out and update/create blocks as needed.\n                parsed_cigar = _.map(\n                    cigar_str.match(/[0-9]+[MIDNSHP=X]/g),\n                    function(op) {\n                        // Get operation length, character.\n                        var op_len = parseInt(op.slice(0, -1), 10),\n                            op_char = op.slice(-1);\n\n                        // Update drawing block.\n                        if (op_char === \"N\") {\n                            // At skip, so need to start new block if current block represents\n                            // drawing area.\n                            if (cur_block[1] !== 0) {\n                                cur_block = [\n                                    base_pos + op_len,\n                                    base_pos + op_len\n                                ];\n                                blocks.push(cur_block);\n                            }\n                        } else if (\"ISHP\".indexOf(op_char) === -1) {\n                            // Operation is M,D,=,X.\n                            cur_block[1] += op_len;\n                            base_pos += op_len;\n                        }\n\n                        // Return parsed cigar.\n                        return [cigar_ops.indexOf(op_char), op_len];\n                    }\n                );\n\n            return {\n                blocks: blocks,\n                cigar: parsed_cigar\n            };\n        },\n\n        /**\n     * Draw a single read from reference-based read sequence and cigar.\n     */\n        draw_read: function(\n            ctx,\n            mode,\n            w_scale,\n            y_start,\n            tile_low,\n            tile_high,\n            feature_start,\n            cigar,\n            strand,\n            read_seq\n        ) {\n            // Helper function to update base and sequnence offsets.\n            var update_base_offset = function(offset, cig_op, cig_len) {\n                    if (\"M=NXD\".indexOf(cig_op) !== -1) {\n                        offset += cig_len;\n                    }\n                    return offset;\n                },\n                update_seq_offset = function(offset, cig_op, cig_len) {\n                    if (\"IX\".indexOf(cig_op) !== -1) {\n                        offset += cig_len;\n                    }\n                    return offset;\n                },\n                // Gets drawing coordinate for a sequence coordinate. Assumes closure variables w_scale and tile_low.\n                get_draw_coord = function(sequence_coord) {\n                    // -0.5 to offset sequence between bases.\n                    return Math.floor(\n                        Math.max(0, (sequence_coord - tile_low - 0.5) * w_scale)\n                    );\n                };\n\n            ctx.textAlign = \"center\";\n            var tile_region = [tile_low, tile_high],\n                base_offset = 0,\n                seq_offset = 0,\n                gap = Math.round(w_scale / 2),\n                char_width_px = ctx.canvas.manager.char_width_px,\n                block_color =\n                    strand === \"+\"\n                        ? this.prefs.detail_block_color\n                        : this.prefs.reverse_strand_color,\n                pack_mode = mode === \"Pack\",\n                draw_height = pack_mode\n                    ? PACK_FEATURE_HEIGHT\n                    : SQUISH_FEATURE_HEIGHT,\n                rect_y = y_start + 1,\n                paint_utils = new ReadPainterUtils(\n                    ctx,\n                    draw_height,\n                    w_scale,\n                    mode\n                ),\n                drawing_blocks = [],\n                s_start,\n                s_end;\n\n            // Keep list of items that need to be drawn on top of initial drawing layer.\n            var draw_last = [];\n\n            // Parse cigar and get drawing blocks.\n            var t = this._parse_cigar(cigar);\n            cigar = t.cigar;\n            drawing_blocks = t.blocks;\n\n            // Draw blocks.\n            for (var i = 0; i < drawing_blocks.length; i++) {\n                var block = drawing_blocks[i];\n\n                if (\n                    is_overlap(\n                        [feature_start + block[0], feature_start + block[1]],\n                        tile_region\n                    )\n                ) {\n                    s_start = get_draw_coord(feature_start + block[0]);\n                    s_end = get_draw_coord(feature_start + block[1]);\n\n                    // Make sure that block is drawn even if it too small to be rendered officially; in this case,\n                    // read is drawn at 1px.\n                    // TODO: need to ensure that s_start, s_end are calculated the same for both slotting\n                    // and drawing.\n                    if (s_start === s_end) {\n                        s_end += 1;\n                    }\n\n                    // Draw read base as rectangle.\n                    ctx.fillStyle = block_color;\n                    ctx.fillRect(s_start, rect_y, s_end - s_start, draw_height);\n                }\n            }\n\n            // Draw read features.\n            for (var cig_id = 0, len = cigar.length; cig_id < len; cig_id++) {\n                var cig = cigar[cig_id],\n                    cig_op = \"MIDNSHP=X\"[cig[0]],\n                    cig_len = cig[1];\n\n                var seq_start = feature_start + base_offset;\n                s_start = get_draw_coord(seq_start);\n                s_end = get_draw_coord(seq_start + cig_len);\n\n                // Skip feature if it's not in tile.\n                if (\n                    !is_overlap([seq_start, seq_start + cig_len], tile_region)\n                ) {\n                    // Update offsets.\n                    base_offset = update_base_offset(\n                        base_offset,\n                        cig_op,\n                        cig_len\n                    );\n                    seq_offset = update_seq_offset(seq_offset, cig_op, cig_len);\n                    continue;\n                }\n\n                // Make sure that read is drawn even if it too small to be rendered officially; in this case,\n                // read is drawn at 1px.\n                // TODO: need to ensure that s_start, s_end are calculated the same for both slotting\n                // and drawing.\n                if (s_start === s_end) {\n                    s_end += 1;\n                }\n\n                // Draw read feature.\n                switch (cig_op) {\n                    case \"H\": // Hard clipping.\n                    case \"S\": // Soft clipping.\n                    case \"P\": // Padding.\n                        // Sequence not present and not related to alignment; do nothing.\n                        break;\n                    case \"M\": // \"Match\".\n                        // Because it's not known whether there is a match, ignore.\n                        base_offset += cig_len;\n                        break;\n                    case \"=\": // Match with reference.\n                    case \"X\": // Mismatch with reference.\n                        //\n                        // Draw sequence and/or variants.\n                        //\n\n                        // Get sequence to draw.\n                        var cur_seq = \"\";\n                        if (cig_op === \"X\") {\n                            // Get sequence from read_seq.\n                            cur_seq = read_seq.slice(\n                                seq_offset,\n                                seq_offset + cig_len\n                            );\n                        } else if (this.ref_seq) {\n                            // && cig_op === '='\n                            // Use reference sequence.\n                            cur_seq = this.ref_seq.slice(\n                                // If read starts after tile start, slice at read start.\n                                Math.max(0, seq_start - tile_low),\n                                // If read ends before tile end, slice at read end.\n                                Math.min(\n                                    seq_start - tile_low + cig_len,\n                                    tile_high - tile_low\n                                )\n                            );\n                        }\n\n                        // Draw sequence. Because cur_seq starts and read/tile start, go to there to start writing.\n                        var start_pos = Math.max(seq_start, tile_low);\n                        for (var c = 0; c < cur_seq.length; c++) {\n                            // Draw base if showing all (i.e. not showing differences) or there is a mismatch.\n                            if (\n                                (cur_seq && !this.prefs.show_differences) ||\n                                cig_op === \"X\"\n                            ) {\n                                // Draw base.\n                                var c_start = Math.floor(\n                                    Math.max(\n                                        0,\n                                        (start_pos + c - tile_low) * w_scale\n                                    )\n                                );\n                                ctx.fillStyle = this.base_color_fn(cur_seq[c]);\n                                if (pack_mode && w_scale > char_width_px) {\n                                    ctx.fillText(\n                                        cur_seq[c],\n                                        c_start,\n                                        y_start + 9\n                                    );\n                                } else if (w_scale > 0.05) {\n                                    // Require a minimum w_scale so that variants are only drawn when somewhat zoomed in.\n                                    ctx.fillRect(\n                                        c_start - gap,\n                                        rect_y,\n                                        Math.max(1, Math.round(w_scale)),\n                                        draw_height\n                                    );\n                                }\n                            }\n                        }\n\n                        // Move forward in sequence only if sequence used to get mismatches.\n                        if (cig_op === \"X\") {\n                            seq_offset += cig_len;\n                        }\n                        base_offset += cig_len;\n\n                        break;\n                    case \"N\": // Skipped bases.\n                        ctx.fillStyle = CONNECTOR_COLOR;\n                        ctx.fillRect(\n                            s_start,\n                            rect_y + (draw_height - 1) / 2,\n                            s_end - s_start,\n                            1\n                        );\n                        // No change in seq_offset because sequence not used when skipping.\n                        base_offset += cig_len;\n                        break;\n                    case \"D\": // Deletion.\n                        paint_utils.draw_deletion(s_start, rect_y, cig_len);\n                        base_offset += cig_len;\n                        break;\n                    case \"I\": // Insertion.\n                        // Check to see if sequence should be drawn at all by looking at the overlap between\n                        // the sequence region and the tile region.\n                        var insert_x_coord = s_start - gap;\n\n                        if (\n                            is_overlap(\n                                [seq_start, seq_start + cig_len],\n                                tile_region\n                            )\n                        ) {\n                            var seq = read_seq.slice(\n                                seq_offset,\n                                seq_offset + cig_len\n                            );\n                            // Insertion point is between the sequence start and the previous base: (-gap) moves\n                            // back from sequence start to insertion point.\n                            if (this.prefs.show_insertions) {\n                                //\n                                // Show inserted sequence above, centered on insertion point.\n                                //\n\n                                // Draw sequence.\n                                // X center is offset + start - <half_sequence_length>\n                                var x_center = s_start - (s_end - s_start) / 2;\n                                if (\n                                    (mode === \"Pack\" || this.mode === \"Auto\") &&\n                                    read_seq !== undefined &&\n                                    w_scale > char_width_px\n                                ) {\n                                    // Draw sequence container.\n                                    ctx.fillStyle = \"yellow\";\n                                    ctx.fillRect(\n                                        x_center - gap,\n                                        y_start - 9,\n                                        s_end - s_start,\n                                        9\n                                    );\n                                    draw_last[draw_last.length] = {\n                                        type: \"triangle\",\n                                        data: [insert_x_coord, y_start + 4, 5]\n                                    };\n                                    ctx.fillStyle = CONNECTOR_COLOR;\n                                    // Based on overlap b/t sequence and tile, get sequence to be drawn.\n                                    switch (compute_overlap(\n                                        [seq_start, seq_start + cig_len],\n                                        tile_region\n                                    )) {\n                                        case OVERLAP_START:\n                                            seq = seq.slice(\n                                                tile_low - seq_start\n                                            );\n                                            break;\n                                        case OVERLAP_END:\n                                            seq = seq.slice(\n                                                0,\n                                                seq_start - tile_high\n                                            );\n                                            break;\n                                        case CONTAINED_BY:\n                                            // All of sequence drawn.\n                                            break;\n                                        case CONTAINS:\n                                            seq = seq.slice(\n                                                tile_low - seq_start,\n                                                seq_start - tile_high\n                                            );\n                                            break;\n                                    }\n                                    // Draw sequence.\n                                    for (\n                                        var c = 0, str_len = seq.length;\n                                        c < str_len;\n                                        c++\n                                    ) {\n                                        var c_start = Math.floor(\n                                            Math.max(\n                                                0,\n                                                (seq_start + c - tile_low) *\n                                                    w_scale\n                                            )\n                                        );\n                                        ctx.fillText(\n                                            seq[c],\n                                            c_start - (s_end - s_start) / 2,\n                                            y_start\n                                        );\n                                    }\n                                } else {\n                                    // Draw block.\n                                    ctx.fillStyle = \"yellow\";\n                                    // TODO: This is a pretty hack-ish way to fill rectangle based on mode.\n                                    ctx.fillRect(\n                                        x_center,\n                                        y_start +\n                                            (this.mode !== \"Dense\" ? 2 : 5),\n                                        s_end - s_start,\n                                        mode !== \"Dense\"\n                                            ? SQUISH_FEATURE_HEIGHT\n                                            : DENSE_FEATURE_HEIGHT\n                                    );\n                                }\n                            } else {\n                                if (\n                                    (mode === \"Pack\" || this.mode === \"Auto\") &&\n                                    read_seq !== undefined &&\n                                    w_scale > char_width_px\n                                ) {\n                                    // Show insertions with a single number at the insertion point.\n                                    draw_last.push({\n                                        type: \"text\",\n                                        data: [\n                                            seq.length,\n                                            insert_x_coord,\n                                            y_start + 9\n                                        ]\n                                    });\n                                } else {\n                                    // TODO: probably can merge this case with code above.\n                                }\n                            }\n                        }\n                        seq_offset += cig_len;\n                        // No change to base offset because insertions are drawn above sequence/read.\n                        break;\n                }\n            }\n\n            //\n            // Draw last items.\n            //\n            ctx.fillStyle = \"yellow\";\n            var item, type, data;\n            for (var i = 0; i < draw_last.length; i++) {\n                item = draw_last[i];\n                type = item.type;\n                data = item.data;\n                if (type === \"text\") {\n                    ctx.save();\n                    ctx.font = \"bold \" + ctx.font;\n                    ctx.fillText(data[0], data[1], data[2]);\n                    ctx.restore();\n                } else if (type === \"triangle\") {\n                    drawDownwardEquilateralTriangle(\n                        ctx,\n                        data[0],\n                        data[1],\n                        data[2]\n                    );\n                }\n            }\n        },\n\n        /**\n     * Draw a complete read pair\n     */\n        draw_element: function(\n            ctx,\n            mode,\n            feature,\n            slot,\n            tile_low,\n            tile_high,\n            w_scale,\n            y_scale,\n            width\n        ) {\n            // All features need a start, end, and vertical center.\n            var feature_uid = feature[0],\n                feature_start = feature[1],\n                feature_end = feature[2],\n                feature_name = feature[3],\n                // -0.5 to put element between bases.\n                f_start = Math.floor(\n                    Math.max(\n                        -0.5 * w_scale,\n                        (feature_start - tile_low - 0.5) * w_scale\n                    )\n                ),\n                f_end = Math.ceil(\n                    Math.min(\n                        width,\n                        Math.max(0, (feature_end - tile_low - 0.5) * w_scale)\n                    )\n                ),\n                y_start = (mode === \"Dense\" ? 0 : 0 + slot) * y_scale,\n                draw_height =\n                    mode === \"Pack\"\n                        ? PACK_FEATURE_HEIGHT\n                        : SQUISH_FEATURE_HEIGHT,\n                label_color = this.prefs.label_color;\n\n            // Draw read.\n            if (feature[5] instanceof Array) {\n                // Read is paired.\n                var connector = true;\n\n                // Draw left/forward read.\n                if (\n                    feature[4][1] >= tile_low &&\n                    feature[4][0] <= tile_high &&\n                    feature[4][2]\n                ) {\n                    this.draw_read(\n                        ctx,\n                        mode,\n                        w_scale,\n                        y_start,\n                        tile_low,\n                        tile_high,\n                        feature[4][0],\n                        feature[4][2],\n                        feature[4][3],\n                        feature[4][4]\n                    );\n                } else {\n                    connector = false;\n                }\n\n                // Draw right/reverse read.\n                if (\n                    feature[5][1] >= tile_low &&\n                    feature[5][0] <= tile_high &&\n                    feature[5][2]\n                ) {\n                    this.draw_read(\n                        ctx,\n                        mode,\n                        w_scale,\n                        y_start,\n                        tile_low,\n                        tile_high,\n                        feature[5][0],\n                        feature[5][2],\n                        feature[5][3],\n                        feature[5][4]\n                    );\n                } else {\n                    connector = false;\n                }\n\n                // Draw connector if both reads were drawn.\n                // TODO: currently, there is no way to connect reads drawn on different tiles; to connect reads on different tiles, data manager\n                // code is needed to join mate pairs from different regions. Alternatively, requesting multiple regions of data at once would\n                // make it possible to put together more easily.\n                // -0.5 to position connector correctly between reads.\n                var b1_end = Math.ceil(\n                        Math.min(\n                            width,\n                            Math.max(\n                                -0.5 * w_scale,\n                                (feature[4][1] - tile_low - 0.5) * w_scale\n                            )\n                        )\n                    ),\n                    b2_start = Math.floor(\n                        Math.max(\n                            -0.5 * w_scale,\n                            (feature[5][0] - tile_low - 0.5) * w_scale\n                        )\n                    );\n                if (connector && b2_start > b1_end) {\n                    ctx.fillStyle = CONNECTOR_COLOR;\n                    var line_height = y_start + 1 + (draw_height - 1) / 2;\n                    dashedLine(ctx, b1_end, line_height, b2_start, line_height);\n                }\n            } else {\n                // Read is single.\n                this.draw_read(\n                    ctx,\n                    mode,\n                    w_scale,\n                    y_start,\n                    tile_low,\n                    tile_high,\n                    feature_start,\n                    feature[4],\n                    feature[5],\n                    feature[6]\n                );\n            }\n            if (\n                mode === \"Pack\" &&\n                feature_start >= tile_low &&\n                feature_name !== \".\"\n            ) {\n                // Draw label.\n                ctx.fillStyle = this.prefs.label_color;\n                if (\n                    tile_low === 0 &&\n                    f_start - ctx.measureText(feature_name).width < 0\n                ) {\n                    ctx.textAlign = \"left\";\n                    ctx.fillText(\n                        feature_name,\n                        f_end + LABEL_SPACING,\n                        y_start + 9,\n                        this.max_label_length\n                    );\n                } else {\n                    ctx.textAlign = \"right\";\n                    ctx.fillText(\n                        feature_name,\n                        f_start - LABEL_SPACING,\n                        y_start + 9,\n                        this.max_label_length\n                    );\n                }\n            }\n\n            // FIXME: provide actual coordinates for drawn read.\n            return [0, 0];\n        }\n    });\n\n    var ArcLinkedFeaturePainter = function(\n        data,\n        view_start,\n        view_end,\n        prefs,\n        mode,\n        alpha_scaler,\n        height_scaler\n    ) {\n        LinkedFeaturePainter.call(\n            this,\n            data,\n            view_start,\n            view_end,\n            prefs,\n            mode,\n            alpha_scaler,\n            height_scaler\n        );\n        // Need to know the longest feature length for adding spacing\n        this.longest_feature_length = this.calculate_longest_feature_length();\n        this.draw_background_connector = false;\n        this.draw_individual_connectors = true;\n    };\n\n    _.extend(\n        ArcLinkedFeaturePainter.prototype,\n        FeaturePainter.prototype,\n        LinkedFeaturePainter.prototype,\n        {\n            calculate_longest_feature_length: function() {\n                var longest_feature_length = 0;\n                for (var i = 0, len = this.data.length; i < len; i++) {\n                    var feature = this.data[i],\n                        feature_start = feature[1],\n                        feature_end = feature[2];\n                    longest_feature_length = Math.max(\n                        longest_feature_length,\n                        feature_end - feature_start\n                    );\n                }\n                return longest_feature_length;\n            },\n\n            get_top_padding: function(width) {\n                var view_range = this.view_end - this.view_start,\n                    w_scale = width / view_range;\n                return Math.min(\n                    128,\n                    Math.ceil(this.longest_feature_length / 2 * w_scale)\n                );\n            },\n\n            draw_connector: function(\n                ctx,\n                block1_start,\n                block1_end,\n                block2_start,\n                block2_end,\n                y_start\n            ) {\n                // Arc drawing -- from closest endpoints\n                var x_center = (block1_end + block2_start) / 2,\n                    radius = block2_start - x_center;\n                // For full half circles\n                var angle1 = Math.PI,\n                    angle2 = 0;\n                if (radius > 0) {\n                    ctx.beginPath();\n                    ctx.arc(\n                        x_center,\n                        y_start,\n                        block2_start - x_center,\n                        Math.PI,\n                        0\n                    );\n                    ctx.stroke();\n                }\n            }\n        }\n    );\n\n    // Color stuff from less.js\n\n    var Color = function(rgb, a) {\n        /**\n     * The end goal here, is to parse the arguments\n     * into an integer triplet, such as `128, 255, 0`\n     *\n     * This facilitates operations and conversions.\n     */\n        if (Array.isArray(rgb)) {\n            this.rgb = rgb;\n        } else if (rgb.length == 6) {\n            this.rgb = rgb.match(/.{2}/g).map(function(c) {\n                return parseInt(c, 16);\n            });\n        } else if (rgb.length == 7) {\n            this.rgb = rgb\n                .substring(1, 7)\n                .match(/.{2}/g)\n                .map(function(c) {\n                    return parseInt(c, 16);\n                });\n        } else {\n            this.rgb = rgb.split(\"\").map(function(c) {\n                return parseInt(c + c, 16);\n            });\n        }\n        this.alpha = typeof a === \"number\" ? a : 1;\n    };\n    Color.prototype = {\n        eval: function() {\n            return this;\n        },\n\n        //\n        // If we have some transparency, the only way to represent it\n        // is via `rgba`. Otherwise, we use the hex representation,\n        // which has better compatibility with older browsers.\n        // Values are capped between `0` and `255`, rounded and zero-padded.\n        //\n        toCSS: function() {\n            if (this.alpha < 1.0) {\n                return (\n                    \"rgba(\" +\n                    this.rgb\n                        .map(function(c) {\n                            return Math.round(c);\n                        })\n                        .concat(this.alpha)\n                        .join(\", \") +\n                    \")\"\n                );\n            } else {\n                return (\n                    \"#\" +\n                    this.rgb\n                        .map(function(i) {\n                            i = Math.round(i);\n                            i = (i > 255 ? 255 : i < 0 ? 0 : i).toString(16);\n                            return i.length === 1 ? \"0\" + i : i;\n                        })\n                        .join(\"\")\n                );\n            }\n        },\n\n        toHSL: function() {\n            var r = this.rgb[0] / 255,\n                g = this.rgb[1] / 255,\n                b = this.rgb[2] / 255,\n                a = this.alpha;\n\n            var max = Math.max(r, g, b),\n                min = Math.min(r, g, b);\n            var h,\n                s,\n                l = (max + min) / 2,\n                d = max - min;\n\n            if (max === min) {\n                h = s = 0;\n            } else {\n                s = l > 0.5 ? d / (2 - max - min) : d / (max + min);\n\n                switch (max) {\n                    case r:\n                        h = (g - b) / d + (g < b ? 6 : 0);\n                        break;\n                    case g:\n                        h = (b - r) / d + 2;\n                        break;\n                    case b:\n                        h = (r - g) / d + 4;\n                        break;\n                }\n                h /= 6;\n            }\n            return { h: h * 360, s: s, l: l, a: a };\n        },\n\n        toARGB: function() {\n            var argb = [Math.round(this.alpha * 255)].concat(this.rgb);\n            return (\n                \"#\" +\n                argb\n                    .map(function(i) {\n                        i = Math.round(i);\n                        i = (i > 255 ? 255 : i < 0 ? 0 : i).toString(16);\n                        return i.length === 1 ? \"0\" + i : i;\n                    })\n                    .join(\"\")\n            );\n        },\n\n        mix: function(color2, weight) {\n            var color1 = this;\n\n            var p = weight; // .value / 100.0;\n            var w = p * 2 - 1;\n            var a = color1.toHSL().a - color2.toHSL().a;\n\n            var w1 = ((w * a == -1 ? w : (w + a) / (1 + w * a)) + 1) / 2.0;\n            var w2 = 1 - w1;\n\n            var rgb = [\n                color1.rgb[0] * w1 + color2.rgb[0] * w2,\n                color1.rgb[1] * w1 + color2.rgb[1] * w2,\n                color1.rgb[2] * w1 + color2.rgb[2] * w2\n            ];\n\n            var alpha = color1.alpha * p + color2.alpha * (1 - p);\n\n            return new Color(rgb, alpha);\n        }\n    };\n\n    // End colors from less.js\n\n    var LinearRamp = function(start_color, end_color, start_value, end_value) {\n        /**\n     * Simple linear gradient\n     */\n        this.start_color = new Color(start_color);\n        this.end_color = new Color(end_color);\n        this.start_value = start_value;\n        this.end_value = end_value;\n        this.value_range = end_value - start_value;\n    };\n\n    LinearRamp.prototype.map_value = function(value) {\n        value = Math.max(value, this.start_value);\n        value = Math.min(value, this.end_value);\n        value = (value - this.start_value) / this.value_range;\n        // HACK: just red for now\n        // return \"hsl(0,100%,\" + (value * 100) + \"%)\"\n        return this.start_color.mix(this.end_color, 1 - value).toCSS();\n    };\n\n    var SplitRamp = function(\n        start_color,\n        middle_color,\n        end_color,\n        start_value,\n        end_value\n    ) {\n        /**\n     * Two gradients split away from 0\n     */\n        this.positive_ramp = new LinearRamp(\n            middle_color,\n            end_color,\n            0,\n            end_value\n        );\n        this.negative_ramp = new LinearRamp(\n            middle_color,\n            start_color,\n            0,\n            -start_value\n        );\n        this.start_value = start_value;\n        this.end_value = end_value;\n    };\n\n    SplitRamp.prototype.map_value = function(value) {\n        value = Math.max(value, this.start_value);\n        value = Math.min(value, this.end_value);\n        if (value >= 0) {\n            return this.positive_ramp.map_value(value);\n        } else {\n            return this.negative_ramp.map_value(-value);\n        }\n    };\n\n    var DiagonalHeatmapPainter = function(\n        data,\n        view_start,\n        view_end,\n        prefs,\n        mode\n    ) {\n        Painter.call(this, data, view_start, view_end, prefs, mode);\n        var i, len;\n\n        if (this.prefs.min_value === undefined) {\n            var min_value = Infinity;\n            for (i = 0, len = this.data.length; i < len; i++) {\n                min_value = Math.min(min_value, this.data[i][6]);\n            }\n            this.prefs.min_value = min_value;\n        }\n        if (this.prefs.max_value === undefined) {\n            var max_value = -Infinity;\n            for (i = 0, len = this.data.length; i < len; i++) {\n                max_value = Math.max(max_value, this.data[i][6]);\n            }\n            this.prefs.max_value = max_value;\n        }\n    };\n\n    DiagonalHeatmapPainter.prototype.default_prefs = {\n        min_value: undefined,\n        max_value: undefined,\n        mode: \"Heatmap\",\n        pos_color: \"#FF8C00\",\n        neg_color: \"#4169E1\"\n    };\n\n    DiagonalHeatmapPainter.prototype.draw = function(\n        ctx,\n        width,\n        height,\n        w_scale\n    ) {\n        var min_value = this.prefs.min_value,\n            max_value = this.prefs.max_value,\n            value_range = max_value - min_value,\n            height_px = height,\n            view_start = this.view_start,\n            mode = this.mode,\n            data = this.data,\n            invsqrt2 = 1 / Math.sqrt(2);\n\n        var ramp = new SplitRamp(\n            this.prefs.neg_color,\n            \"#FFFFFF\",\n            this.prefs.pos_color,\n            min_value,\n            max_value\n        );\n\n        var d, s1, e1, s2, e2, value;\n\n        var scale = function(p) {\n            return (p - view_start) * w_scale;\n        };\n\n        ctx.save();\n\n        // Draw into triangle, then rotate and scale\n        ctx.rotate(-45 * Math.PI / 180);\n        ctx.scale(invsqrt2, invsqrt2);\n\n        // Paint track.\n        for (var i = 0, len = data.length; i < len; i++) {\n            d = data[i];\n\n            s1 = scale(d[1]);\n            e1 = scale(d[2]);\n            s2 = scale(d[4]);\n            e2 = scale(d[5]);\n            value = d[6];\n\n            ctx.fillStyle = ramp.map_value(value);\n            ctx.fillRect(s1, s2, e1 - s1, e2 - s2);\n        }\n\n        ctx.restore();\n    };\n\n    /**\n * Utilities for painting reads.\n */\n    var ReadPainterUtils = function(ctx, row_height, px_per_base, mode) {\n        this.ctx = ctx;\n        this.row_height = row_height;\n        this.px_per_base = px_per_base;\n        this.draw_details =\n            (mode === \"Pack\" || mode === \"Auto\") &&\n            px_per_base >= ctx.canvas.manager.char_width_px;\n        this.delete_details_thickness = 0.2;\n    };\n\n    _.extend(ReadPainterUtils.prototype, {\n        /**\n     * Draw deletion of base(s).\n     * @param draw_detail if true, drawing in detail and deletion is drawn more subtly\n     */\n        draw_deletion: function(x, y, len) {\n            this.ctx.fillStyle = \"black\";\n            var thickness =\n                (this.draw_details ? this.delete_details_thickness : 1) *\n                this.row_height;\n            y += 0.5 * (this.row_height - thickness);\n            this.ctx.fillRect(x, y, len * this.px_per_base, thickness);\n        }\n    });\n\n    /**\n * Paints variant data onto canvas.\n */\n    var VariantPainter = function(\n        data,\n        view_start,\n        view_end,\n        prefs,\n        mode,\n        base_color_fn\n    ) {\n        Painter.call(this, data, view_start, view_end, prefs, mode);\n        this.base_color_fn = base_color_fn;\n        this.divider_height = 1;\n    };\n\n    _.extend(VariantPainter.prototype, Painter.prototype, {\n        /**\n     * Height of a single row, depends on mode\n     */\n        get_row_height: function() {\n            var mode = this.mode,\n                height;\n            if (mode === \"Dense\") {\n                height = DENSE_TRACK_HEIGHT;\n            } else if (mode === \"Squish\") {\n                height = SQUISH_TRACK_HEIGHT;\n            } else {\n                // mode === \"Pack\"\n                height = PACK_TRACK_HEIGHT;\n            }\n            return height;\n        },\n\n        /**\n     * Returns required height to draw a particular number of samples in a given mode.\n     */\n        get_required_height: function(num_samples) {\n            // FIXME: for single-sample data, height should be summary_height when zoomed out and\n            // row_height when zoomed in.\n            var height = this.prefs.summary_height;\n\n            // If showing sample data, height is summary + divider + samples.\n            if (num_samples > 1 && this.prefs.show_sample_data) {\n                height +=\n                    this.divider_height + num_samples * this.get_row_height();\n            }\n            return height;\n        },\n\n        /**\n     * Draw on the context using a rectangle of width x height with scale w_scale.\n     */\n        draw: function(ctx, width, height, w_scale) {\n            ctx.save();\n\n            var /**\n         * Returns dictionary of information about an indel; returns empty if there no indel. Assumes indel is left-aligned.\n         * Dict attributes:\n         *    -type: 'insertion' or 'deletion'\n         *    -start: where the deletion starts relative to reference start\n         *    -len: how long the deletion is\n         */\n            get_indel_info = function(ref, alt) {\n                var ref_len = ref.length,\n                    alt_len = alt.length,\n                    start = 0,\n                    len = 1,\n                    type = null;\n                if (alt === \"-\") {\n                    type = \"deletion\";\n                    len = ref.length;\n                } else if (ref.indexOf(alt) === 0 && ref_len > alt_len) {\n                    type = \"deletion\";\n                    len = ref_len - alt_len;\n                    start = alt_len;\n                } else if (alt.indexOf(ref) === 0 && ref_len < alt_len) {\n                    // Insertion.\n                    type = \"insertion\";\n                    len = alt_len - ref_len;\n                    start = alt_len;\n                }\n\n                return type !== null\n                    ? { type: type, start: start, len: len }\n                    : {};\n            };\n\n            // Draw.\n            var locus_data,\n                pos,\n                id,\n                ref,\n                alt,\n                qual,\n                filter,\n                sample_gts,\n                allele_counts,\n                variant,\n                draw_x_start,\n                draw_y_start,\n                genotype,\n                // Always draw variants at least 1 pixel wide.\n                base_px = Math.max(1, Math.floor(w_scale)),\n                // Determine number of samples.\n                num_samples = this.data.length\n                    ? this.data[0][7].split(\",\").length\n                    : 0,\n                row_height =\n                    this.mode === \"Squish\"\n                        ? SQUISH_TRACK_HEIGHT\n                        : PACK_TRACK_HEIGHT,\n                // If zoomed out, fill the whole row with feature to make it easier to read;\n                // when zoomed in, use feature height so that there are gaps in sample rows.\n                feature_height =\n                    w_scale < 0.1\n                        ? row_height\n                        : this.mode === \"Squish\"\n                          ? SQUISH_FEATURE_HEIGHT\n                          : PACK_FEATURE_HEIGHT,\n                draw_summary = true,\n                paint_utils = new ReadPainterUtils(\n                    ctx,\n                    row_height,\n                    w_scale,\n                    this.mode\n                ),\n                j;\n\n            // If there's a single sample, update drawing variables.\n            if (num_samples === 1) {\n                row_height = feature_height =\n                    w_scale < ctx.canvas.manager.char_width_px\n                        ? this.prefs.summary_height\n                        : row_height;\n                paint_utils.row_height = row_height;\n                // No summary when there's a single sample.\n                draw_summary = false;\n            }\n\n            // Draw divider between summary and samples.\n            if (this.prefs.show_sample_data && draw_summary) {\n                ctx.fillStyle = \"#F3F3F3\";\n                ctx.globalAlpha = 1;\n                ctx.fillRect(\n                    0,\n                    this.prefs.summary_height - this.divider_height,\n                    width,\n                    this.divider_height\n                );\n            }\n\n            // Draw variants.\n            ctx.textAlign = \"center\";\n            for (var i = 0; i < this.data.length; i++) {\n                // Get locus data.\n                locus_data = this.data[i];\n                pos = locus_data[1];\n                ref = locus_data[3];\n                alt = [locus_data[4].split(\",\")];\n                sample_gts = locus_data[7].split(\",\");\n                allele_counts = locus_data.slice(8);\n\n                // Process alterate values to derive information about each alt.\n                alt = _.map(_.flatten(alt), function(a) {\n                    var alt_info = {\n                            type: \"snp\",\n                            value: a,\n                            start: 0\n                        },\n                        indel_info = get_indel_info(ref, a);\n\n                    return _.extend(alt_info, indel_info);\n                });\n\n                // Only draw locus data if it's in viewing region.\n                if (pos < this.view_start || pos > this.view_end) {\n                    continue;\n                }\n\n                // Draw summary for alleles.\n                if (draw_summary) {\n                    ctx.fillStyle = \"#999999\";\n                    ctx.globalAlpha = 1;\n                    for (j = 0; j < alt.length; j++) {\n                        // Draw background for summary.\n                        draw_x_start = this.get_start_draw_pos(\n                            pos + alt[j].start,\n                            w_scale\n                        );\n                        ctx.fillRect(\n                            draw_x_start,\n                            0,\n                            base_px,\n                            this.prefs.summary_height\n                        );\n                        draw_y_start = this.prefs.summary_height;\n                        // Draw allele fractions onto summary.\n                        for (j = 0; j < alt.length; j++) {\n                            ctx.fillStyle =\n                                alt[j].type === \"deletion\"\n                                    ? \"black\"\n                                    : this.base_color_fn(alt[j].value);\n                            var allele_frac = allele_counts / sample_gts.length;\n                            var draw_height = Math.ceil(\n                                this.prefs.summary_height * allele_frac\n                            );\n                            ctx.fillRect(\n                                draw_x_start,\n                                draw_y_start - draw_height,\n                                base_px,\n                                draw_height\n                            );\n                            draw_y_start -= draw_height;\n                        }\n                    }\n                }\n\n                // Done drawing if not showing samples data.\n                if (!this.prefs.show_sample_data) {\n                    continue;\n                }\n\n                // Draw sample genotype(s).\n                draw_y_start = draw_summary\n                    ? this.prefs.summary_height + this.divider_height\n                    : 0;\n                for (\n                    j = 0;\n                    j < sample_gts.length;\n                    j++, draw_y_start += row_height\n                ) {\n                    genotype = sample_gts[j]\n                        ? sample_gts[j].split(/\\/|\\|/)\n                        : [\"0\", \"0\"];\n\n                    // Get variant to draw and set drawing properties.\n                    variant = null;\n                    if (genotype[0] === genotype[1]) {\n                        if (genotype[0] === \".\") {\n                            // TODO: draw uncalled variant.\n                        } else if (genotype[0] !== \"0\") {\n                            // Homozygous for variant.\n                            variant = alt[parseInt(genotype[0], 10) - 1];\n                            ctx.globalAlpha = 1;\n                        }\n                        // else reference\n                    } else {\n                        // Heterozygous for variant.\n                        variant =\n                            genotype[0] !== \"0\" ? genotype[0] : genotype[1];\n                        variant = alt[parseInt(variant, 10) - 1];\n                        ctx.globalAlpha = 0.5;\n                    }\n\n                    // If there's a variant, draw it.\n                    if (variant) {\n                        draw_x_start = this.get_start_draw_pos(\n                            pos + variant.start,\n                            w_scale\n                        );\n                        if (variant.type === \"snp\") {\n                            var snp = variant.value;\n                            ctx.fillStyle = this.base_color_fn(snp);\n                            if (paint_utils.draw_details) {\n                                ctx.fillText(\n                                    snp,\n                                    this.get_draw_pos(pos, w_scale),\n                                    draw_y_start + row_height\n                                );\n                            } else {\n                                ctx.fillRect(\n                                    draw_x_start,\n                                    draw_y_start + 1,\n                                    base_px,\n                                    feature_height\n                                );\n                            }\n                        } else if (variant.type === \"deletion\") {\n                            paint_utils.draw_deletion(\n                                draw_x_start,\n                                draw_y_start + 1,\n                                variant.len\n                            );\n                        } else {\n                            // TODO: handle insertions.\n                        }\n                    }\n                }\n            }\n\n            ctx.restore();\n        }\n    });\n\n    return {\n        Scaler: Scaler,\n        LinePainter: LinePainter,\n        LinkedFeaturePainter: LinkedFeaturePainter,\n        ReadPainter: ReadPainter,\n        ArcLinkedFeaturePainter: ArcLinkedFeaturePainter,\n        DiagonalHeatmapPainter: DiagonalHeatmapPainter,\n        VariantPainter: VariantPainter\n    };\n});\n"]}