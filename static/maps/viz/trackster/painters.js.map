{"version":3,"sources":["viz/trackster/painters.js"],"names":["define","_","compute_overlap","first_region","second_region","CONTAINS","first_end","OVERLAP_START","second_end","CONTAINED_BY","AFTER","second_start","overlap","is_overlap","dashedLine","ctx","x1","y1","x2","y2","dashLen","undefined","dX","dY","dashes","Math","floor","sqrt","dashY","q","dashX","down_vertex_x","down_vertex_y","side_len","y","beginPath","moveTo","lineTo","this","fillStyle","closePath","default_val","Scaler","prototype","DrawResults","incomplete_features","options","feature_mapper","Painter","data","view_start","view_end","prefs","mode","extend","default_prefs","draw","width","height","w_scale","get_start_draw_pos","chrom_pos","get_end_draw_pos","_chrom_pos_to_draw_pos","get_draw_pos","offset","max","LinePainter","min_value","max_value","color","overflow_color","in_path","vertical_range","save","y_zero","round","delta_x_pxs","fillRect","map","slice","d","i","ceil","delta_x_px","block_color","pref_color","parseInt","painter_color","pref_r","pref_g","pref_b","top_overflow","bot_overflow","length","len","x_scaled","strokeStyle","height_px","saturation","new_r","new_g","new_b","overflow_x","stroke","restore","FeaturePositionMapper","feature_positions","slot_height","translation","y_translation","feature_data","slot","x_start","x_end","push","get_feature_data","x","feature_dict","alpha_scaler","height_scaler","call","max_label_length","FeaturePainter","connector_color","get_required_height","rows_required","required_height","y_scale","get_top_padding","slots","textAlign","x_draw_coords","feature","feature_uid","feature_start","feature_end","draw_element","map_feature_data","tile_low","tile_high","LinkedFeaturePainter","draw_background_connector","draw_individual_connectors","get_row_height","DENSE_TRACK_HEIGHT","NO_DETAIL_TRACK_HEIGHT","SQUISH_TRACK_HEIGHT","PACK_TRACK_HEIGHT","feature_name","feature_strand","f_start","f_end","draw_start","draw_end","y_start","thick_start","thick_end","reverse_strand_color","label_color","gen_val","globalAlpha","NO_DETAIL_FEATURE_HEIGHT","feature_te","feature_blocks","full_height","feature_ts","min","thin_height","thick_height","SQUISH_FEATURE_HEIGHT","DENSE_FEATURE_HEIGHT","cur_y_start","cur_height","CONNECTOR_COLOR","manager","get_pattern","canvas","k","k_len","last_block_start","block","start_and_height","block_end","block_start","last_block_end","block_thick_start","block_thick_end","hscale_factor","new_height","ws_height","measureText","LABEL_SPACING","ReadPainter","ref_seq","base_color_fn","show_insertions","_parse_cigar","cigar_str","blocks","cur_block","base_pos","parsed_cigar","cigar_ops","match","op","op_len","op_char","indexOf","cigar","strand","read_seq","get_draw_coord","sequence_coord","cig_op","s_start","s_end","tile_region","base_offset","seq_offset","char_width_px","pack_mode","draw_height","PACK_FEATURE_HEIGHT","paint_utils","ReadPainterUtils","drawing_blocks","draw_last","t","rect_y","cig_id","cig","seq_start","cig_len","cur_seq","start_pos","c","fillText","c_start","insert_x_coord","gap","x_center","seq","str_len","type","update_base_offset","update_seq_offset","item","font","drawDownwardEquilateralTriangle","connector","b1_end","draw_read","b2_start","line_height","longest_feature_length","calculate_longest_feature_length","ArcLinkedFeaturePainter","draw_connector","block1_end","block2_start","block2_end","radius","PI","view_range","Color","rgb","a","Array","isArray","substring","split","alpha","eval","toCSS","join","toString","toHSL","h","s","g","b","r","l","toARGB","concat","mix","color2","weight","color1","p","w1","w","w2","argb","start_color","end_color","start_value","end_value","value_range","LinearRamp","value","SplitRamp","middle_color","positive_ramp","negative_ramp","map_value","DiagonalHeatmapPainter","Infinity","pos_color","neg_color","invsqrt2","rotate","scale","s1","e1","s2","ramp","e2","row_height","px_per_base","draw_deletion","thickness","draw_details","delete_details_thickness","VariantPainter","divider_height","num_samples","summary_height","show_sample_data","locus_data","ref","sample_gts","allele_counts","start","genotype","j","get_indel_info","alt","alt_len","ref_len","base_px","feature_height","draw_summary","alt_info","indel_info","draw_x_start","pos","draw_y_start","allele_frac","variant","snp"],"mappings":"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","file":"../../../scripts/viz/trackster/painters.js","sourcesContent":["define( [\"libs/underscore\"], function( _ ) {\n\n/**\n * Compute the type of overlap between two regions. They are assumed to be on the same chrom/contig.\n * The overlap is computed relative to the second region; hence, OVERLAP_START indicates that the first\n * region overlaps the start (but not the end) of the second region.\n * NOTE: Coordinates are assumed to be in BED format: half open (start is closed, end is open).\n */\nvar BEFORE = 1001, CONTAINS = 1002, OVERLAP_START = 1003, OVERLAP_END = 1004, CONTAINED_BY = 1005, AFTER = 1006;\nvar compute_overlap = function(first_region, second_region) {\n    var\n        first_start = first_region[0], first_end = first_region[1],\n        second_start = second_region[0], second_end = second_region[1],\n        overlap;\n    if (first_start < second_start) {\n        if (first_end <= second_start) {\n            overlap = BEFORE;\n        }\n        else if (first_end <= second_end) {\n            overlap = OVERLAP_START;\n        }\n        else { // first_end > second_end\n            overlap = CONTAINS;\n        }\n    }\n    else { // first_start >= second_start\n        if (first_start > second_end) {\n            overlap = AFTER;\n        }\n        else if (first_end <= second_end) {\n            overlap = CONTAINED_BY;\n        }\n        else {\n            overlap = OVERLAP_END;\n        }\n    }\n\n    return overlap;\n};\n\n/**\n * Returns true if regions overlap.\n */\nvar is_overlap = function(first_region, second_region) {\n    var overlap = compute_overlap(first_region, second_region);\n    return (overlap !== BEFORE && overlap !== AFTER);\n};\n\n/**\n * Draw a dashed line on a canvas using filled rectangles. This function is based on:\n * http://vetruvet.blogspot.com/2010/10/drawing-dashed-lines-on-html5-canvas.html\n * However, that approach uses lines, which don't seem to render as well, so use\n * rectangles instead.\n */\nvar dashedLine = function(ctx, x1, y1, x2, y2, dashLen) {\n    if (dashLen === undefined) { dashLen = 4; }\n    var dX = x2 - x1;\n    var dY = y2 - y1;\n    var dashes = Math.floor(Math.sqrt(dX * dX + dY * dY) / dashLen);\n    var dashX = dX / dashes;\n    var dashY = dY / dashes;\n    var q;\n\n    for (q = 0; q < dashes; q++, x1 += dashX, y1 += dashY) {\n        if (q % 2 !== 0) {\n            continue;\n        }\n        ctx.fillRect(x1, y1, dashLen, 1);\n    }\n};\n\n/**\n * Draw an isosceles triangle that points down.\n */\nvar drawDownwardEquilateralTriangle = function(ctx, down_vertex_x, down_vertex_y, side_len) {\n    // Compute other two points of triangle.\n    var\n        x1 = down_vertex_x - side_len/2,\n        x2 = down_vertex_x + side_len/2,\n        y = down_vertex_y - Math.sqrt( side_len*3/2 );\n\n    // Draw and fill.\n    ctx.beginPath();\n    ctx.moveTo(x1, y);\n    ctx.lineTo(x2, y);\n    ctx.lineTo(down_vertex_x, down_vertex_y);\n    ctx.lineTo(x1, y);\n\n    ctx.strokeStyle = this.fillStyle;\n    ctx.fill();\n    ctx.stroke();\n    ctx.closePath();\n};\n\n/**\n * Base class for all scalers. Scalers produce values that are used to change (scale) drawing attributes.\n */\nvar Scaler = function(default_val) {\n    this.default_val = (default_val ? default_val : 1);\n};\n\n/**\n * Produce a scaling value.\n */\nScaler.prototype.gen_val = function(input) {\n    return this.default_val;\n};\n\n/**\n * Results from painter.draw()\n */\nvar DrawResults = function(options) {\n    this.incomplete_features = options.incomplete_features;\n    this.feature_mapper = options.feature_mapper;\n};\n\n/**\n * Base class for painters\n *\n * -- Mode and prefs are both optional\n */\nvar Painter = function(data, view_start, view_end, prefs, mode) {\n    // Data and data properties\n    this.data = data;\n    // View\n    this.view_start = view_start;\n    this.view_end = view_end;\n    // Drawing prefs\n    this.prefs = _.extend({}, this.default_prefs, prefs);\n    this.mode = mode;\n};\n\nPainter.prototype.default_prefs = {};\n\n/**\n * Draw on the context using a rectangle of width x height using scale w_scale.\n */\nPainter.prototype.draw = function(ctx, width, height, w_scale) {};\n\n/**\n * Get starting drawing position, which is offset a half-base left of coordinate.\n */\nPainter.prototype.get_start_draw_pos = function(chrom_pos, w_scale) {\n    return this._chrom_pos_to_draw_pos(chrom_pos, w_scale, -0.5);\n};\n\n/**\n * Get end drawing position, which is offset a half-base right of coordinate.\n */\nPainter.prototype.get_end_draw_pos = function(chrom_pos, w_scale) {\n    return this._chrom_pos_to_draw_pos(chrom_pos, w_scale, 0.5);\n};\n\n/**\n * Get drawing position.\n */\nPainter.prototype.get_draw_pos = function(chrom_pos, w_scale) {\n    return this._chrom_pos_to_draw_pos(chrom_pos, w_scale, 0);\n};\n\n/**\n * Convert chromosome position to drawing position.\n */\nPainter.prototype._chrom_pos_to_draw_pos = function(chrom_pos, w_scale, offset) {\n    return Math.floor( w_scale * ( Math.max(0, chrom_pos - this.view_start) + offset) );\n};\n\n\nvar LinePainter = function(data, view_start, view_end, prefs, mode) {\n    Painter.call( this, data, view_start, view_end, prefs, mode );\n};\n\nLinePainter.prototype.default_prefs = { min_value: undefined, max_value: undefined, mode: \"Histogram\", color: \"#000\", overflow_color: \"#F66\" };\n\nLinePainter.prototype.draw = function(ctx, width, height, w_scale) {\n    var in_path = false,\n        min_value = this.prefs.min_value,\n        max_value = this.prefs.max_value,\n        vertical_range = max_value - min_value,\n        height_px = height,\n        view_start = this.view_start,\n        mode = this.mode,\n        data = this.data;\n\n    ctx.save();\n\n    // Pixel position of 0 on the y axis\n    var y_zero = Math.round( height + min_value / vertical_range * height );\n\n    // Horizontal line to denote x-axis\n    if ( mode !== \"Intensity\" ) {\n        ctx.fillStyle = \"#aaa\";\n        ctx.fillRect( 0, y_zero, width, 1 );\n    }\n\n    ctx.beginPath();\n    var x_scaled, y, delta_x_pxs;\n    if (data.length > 1) {\n        delta_x_pxs = _.map(data.slice(0,-1), function(d, i) {\n            return Math.ceil((data[i+1][0] - data[i][0]) * w_scale);\n        });\n    }\n    else {\n        delta_x_pxs = [10];\n    }\n\n    // Painter color can be in either block_color (FeatureTrack) or color pref (LineTrack).\n    var painter_color = this.prefs.block_color || this.prefs.color,\n        // Extract RGB from preference color.\n        pref_color = parseInt( painter_color.slice(1), 16 ),\n        pref_r = (pref_color & 0xff0000) >> 16,\n        pref_g = (pref_color & 0x00ff00) >> 8,\n        pref_b = pref_color & 0x0000ff,\n        top_overflow = false,\n        bot_overflow = false;\n\n\n    // Paint track.\n    var delta_x_px;\n    for (var i = 0, len = data.length; i < len; i++) {\n        // Reset attributes for next point.\n        ctx.fillStyle = ctx.strokeStyle = painter_color;\n        top_overflow = bot_overflow = false;\n        delta_x_px = delta_x_pxs[i];\n\n        x_scaled = Math.floor((data[i][0] - view_start - 0.5) * w_scale);\n        y = data[i][1];\n\n        // Process Y (scaler) value.\n        if (y === null) {\n            if (in_path && mode === \"Filled\") {\n                ctx.lineTo(x_scaled, height_px);\n            }\n            in_path = false;\n            continue;\n        }\n\n        // Bound Y value by min, max.\n        if (y < min_value) {\n            bot_overflow = true;\n            y = min_value;\n        }\n        else if (y > max_value) {\n            top_overflow = true;\n            y = max_value;\n        }\n\n        // Draw point.\n        if (mode === \"Histogram\") {\n            // y becomes the bar height in pixels, which is the negated for canvas coords\n            y = Math.round( y / vertical_range * height_px );\n            ctx.fillRect(x_scaled, y_zero, delta_x_px, - y );\n        }\n        else if (mode === \"Intensity\") {\n            var\n                saturation = (y - min_value) / vertical_range,\n                // Range is [pref_color, 255] where saturation = 0 --> 255 and saturation = 1 --> pref color\n                new_r = Math.round( pref_r + (255 - pref_r) * (1 - saturation) ),\n                new_g = Math.round( pref_g + (255 - pref_g) * (1 - saturation) ),\n                new_b = Math.round( pref_b + (255 - pref_b) * (1 - saturation) );\n            ctx.fillStyle = \"rgb(\" + new_r + \",\" + new_g + \",\" + new_b + \")\";\n            ctx.fillRect(x_scaled, 0, delta_x_px, height_px);\n        }\n        else { // mode is Coverage/Line or Filled.\n\n            // Scale Y value.\n            y = Math.round( height_px - (y - min_value) / vertical_range * height_px );\n            if (in_path) {\n                ctx.lineTo(x_scaled, y);\n            }\n            else {\n                in_path = true;\n                if (mode === \"Filled\") {\n                    ctx.moveTo(x_scaled, height_px);\n                    ctx.lineTo(x_scaled, y);\n                }\n                else {\n                    ctx.moveTo(x_scaled, y);\n                    // Use this approach (note: same as for filled) to draw line from 0 to\n                    // first data point.\n                    //ctx.moveTo(x_scaled, height_px);\n                    //ctx.lineTo(x_scaled, y);\n                }\n            }\n        }\n\n        // Draw lines at boundaries if overflowing min or max\n        ctx.fillStyle = this.prefs.overflow_color;\n        if (top_overflow || bot_overflow) {\n            var overflow_x;\n            if (mode === \"Histogram\" || mode === \"Intensity\") {\n                overflow_x = delta_x_px;\n            }\n            else { // Line and Filled, which are points\n                x_scaled -= 2; // Move it over to the left so it's centered on the point\n                overflow_x = 4;\n            }\n            if (top_overflow) {\n                ctx.fillRect(x_scaled, 0, overflow_x, 3);\n            }\n            if (bot_overflow) {\n                ctx.fillRect(x_scaled, height_px - 3, overflow_x, 3);\n            }\n        }\n        ctx.fillStyle = painter_color;\n    }\n    if (mode === \"Filled\") {\n        if (in_path) {\n            ctx.lineTo( x_scaled, y_zero );\n            ctx.lineTo( 0, y_zero );\n        }\n        ctx.fill();\n    }\n    else {\n        ctx.stroke();\n    }\n\n    ctx.restore();\n};\n\n/**\n * Mapper that contains information about feature locations and data.\n */\nvar FeaturePositionMapper = function(slot_height) {\n    this.feature_positions = {};\n    this.slot_height = slot_height;\n    this.translation = 0;\n    this.y_translation = 0;\n};\n\n/**\n * Map feature data to a position defined by <slot, x_start, x_end>.\n */\nFeaturePositionMapper.prototype.map_feature_data = function(feature_data, slot, x_start, x_end) {\n    if (!this.feature_positions[slot]) {\n        this.feature_positions[slot] = [];\n    }\n    this.feature_positions[slot].push({\n        data: feature_data,\n        x_start: x_start,\n        x_end: x_end\n    });\n};\n\n/**\n * Get feature data for position <x, y>\n */\nFeaturePositionMapper.prototype.get_feature_data = function(x, y) {\n    // Find slot using Y.\n    var slot = Math.floor( (y-this.y_translation)/this.slot_height ),\n        feature_dict;\n\n    // May not be over a slot due to padding, margin, etc.\n    if (!this.feature_positions[slot]) {\n        return null;\n    }\n\n    // Find feature using X.\n    x += this.translation;\n    for (var i = 0; i < this.feature_positions[slot].length; i++) {\n        feature_dict = this.feature_positions[slot][i];\n        if (x >= feature_dict.x_start && x <= feature_dict.x_end) {\n            return feature_dict.data;\n        }\n    }\n};\n\n/**\n * Abstract object for painting feature tracks. Subclasses must implement draw_element() for painting to work.\n * Painter uses a 0-based, half-open coordinate system; start coordinate is closed--included--and the end is open.\n * This coordinate system matches the BED format.\n */\nvar FeaturePainter = function(data, view_start, view_end, prefs, mode, alpha_scaler, height_scaler) {\n    Painter.call(this, data, view_start, view_end, prefs, mode);\n    this.alpha_scaler = (alpha_scaler ? alpha_scaler : new Scaler());\n    this.height_scaler = (height_scaler ? height_scaler : new Scaler());\n    this.max_label_length = 200;\n};\n\nFeaturePainter.prototype.default_prefs = { block_color: \"#FFF\", connector_color: \"#FFF\" };\n\n_.extend(FeaturePainter.prototype, {\n    get_required_height: function(rows_required, width) {\n        // y_scale is the height per row\n        var required_height = this.get_row_height(),\n            y_scale = required_height,\n            mode = this.mode;\n        // If using a packing mode, need to multiply by the number of slots used\n        if (mode === \"no_detail\" || mode === \"Squish\" || mode === \"Pack\") {\n            required_height = rows_required * y_scale;\n        }\n        return required_height + this.get_top_padding(width);\n    },\n\n    /** Extra padding before first row of features */\n    get_top_padding: function(width) {\n        return 0;\n    },\n\n    /**\n     * Draw data on ctx using slots and within the rectangle defined by width and height. Returns\n     * a FeaturePositionMapper object with information about where features were drawn.\n     */\n    draw: function(ctx, width, height, w_scale, slots) {\n        var data = this.data,\n            view_start = this.view_start,\n            view_end = this.view_end;\n\n        ctx.save();\n\n        ctx.fillStyle = this.prefs.block_color;\n        ctx.textAlign = \"right\";\n\n        var y_scale = this.get_row_height(),\n            feature_mapper = new FeaturePositionMapper(y_scale),\n            x_draw_coords,\n            incomplete_features = [];\n\n        for (var i = 0, len = data.length; i < len; i++) {\n            var feature = data[i],\n                feature_uid = feature[0],\n                feature_start = feature[1],\n                feature_end = feature[2],\n                // Slot valid only if features are slotted and this feature is slotted;\n                // feature may not be due to lack of space.\n                slot = (slots && slots[feature_uid] !== undefined ? slots[feature_uid].slot : null);\n\n            // Draw feature if (a) mode is dense or feature is slotted (as it must be for all non-dense modes) and\n            // (b) there's overlap between the feature and drawing region.\n            if ( (this.mode === \"Dense\" || slot !== null) && ( feature_start < view_end && feature_end > view_start ) ) {\n                x_draw_coords = this.draw_element(ctx, this.mode, feature, slot, view_start, view_end, w_scale, y_scale, width);\n                feature_mapper.map_feature_data(feature, slot, x_draw_coords[0], x_draw_coords[1]);\n\n                // Add to incomplete features if it's not drawn completely in region.\n                if (feature_start < view_start || feature_end > view_end) {\n                    incomplete_features.push(feature);\n                }\n            }\n        }\n\n        ctx.restore();\n\n        feature_mapper.y_translation = this.get_top_padding(width);\n        return new DrawResults({\n            incomplete_features: incomplete_features,\n            feature_mapper: feature_mapper\n        });\n    },\n\n    /**\n     * Abstract function for drawing an individual feature.\n     */\n    draw_element: function(ctx, mode, feature, slot, tile_low, tile_high, w_scale, y_scale, width ) {\n        return [0, 0];\n    }\n});\n\n// Constants specific to feature tracks moved here (HACKING, these should\n// basically all be configuration options)\nvar DENSE_TRACK_HEIGHT = 10,\n    NO_DETAIL_TRACK_HEIGHT = 3,\n    SQUISH_TRACK_HEIGHT = 5,\n    PACK_TRACK_HEIGHT = 10,\n    NO_DETAIL_FEATURE_HEIGHT = 1,\n    DENSE_FEATURE_HEIGHT = 9,\n    SQUISH_FEATURE_HEIGHT = 3,\n    PACK_FEATURE_HEIGHT = 9,\n    LABEL_SPACING = 2,\n    CONNECTOR_COLOR = \"#ccc\";\n\nvar LinkedFeaturePainter = function(data, view_start, view_end, prefs, mode, alpha_scaler, height_scaler) {\n    FeaturePainter.call(this, data, view_start, view_end, prefs, mode, alpha_scaler, height_scaler);\n    // Whether to draw a single connector in the background that spans the entire feature (the intron fishbone)\n    this.draw_background_connector = true;\n    // Whether to call draw_connector for every pair of blocks\n    this.draw_individual_connectors = false;\n};\n\n_.extend(LinkedFeaturePainter.prototype, FeaturePainter.prototype, {\n\n    /**\n     * Height of a single row, depends on mode\n     */\n    get_row_height: function() {\n        var mode = this.mode, height;\n        if (mode === \"Dense\") {\n            height = DENSE_TRACK_HEIGHT;\n        }\n        else if (mode === \"no_detail\") {\n            height = NO_DETAIL_TRACK_HEIGHT;\n        }\n        else if (mode === \"Squish\") {\n            height = SQUISH_TRACK_HEIGHT;\n        }\n        else { // mode === \"Pack\"\n            height = PACK_TRACK_HEIGHT;\n        }\n        return height;\n    },\n\n    /**\n     * Draw a feature. Returns an array with feature's start and end X coordinates.\n     */\n    draw_element: function(ctx, mode, feature, slot, tile_low, tile_high, w_scale, y_scale, width) {\n        var feature_uid = feature[0],\n            feature_start = feature[1],\n            feature_end = feature[2],\n            feature_name = feature[3],\n            feature_strand = feature[4],\n            // -0.5 to offset region between bases.\n            f_start = Math.floor( Math.max(0, (feature_start - tile_low - 0.5) * w_scale) ),\n            f_end   = Math.ceil( Math.min(width, Math.max(0, (feature_end - tile_low - 0.5) * w_scale)) ),\n            draw_start = f_start,\n            draw_end = f_end,\n            y_start = (mode === \"Dense\" ? 0 : (0 + slot)) * y_scale + this.get_top_padding(width),\n            thickness, y_start, thick_start = null, thick_end = null,\n            // TODO: is there any reason why block, label color cannot be set at the Painter level?\n            // For now, assume '.' === '+'\n            block_color = (!feature_strand || feature_strand === \"+\" || feature_strand === \".\" ? this.prefs.block_color : this.prefs.reverse_strand_color);\n            label_color = this.prefs.label_color;\n\n        // Set global alpha.\n        ctx.globalAlpha = this.alpha_scaler.gen_val(feature);\n\n        // In dense mode, put all data in top slot.\n        if (mode === \"Dense\") {\n            slot = 1;\n        }\n\n        if (mode === \"no_detail\") {\n            // No details for feature, so only one way to display.\n            ctx.fillStyle = block_color;\n            ctx.fillRect(f_start, y_start + 5, f_end - f_start, NO_DETAIL_FEATURE_HEIGHT);\n        }\n        else { // Mode is either Squish or Pack:\n            // Feature details.\n            var feature_ts = feature[5],\n                feature_te = feature[6],\n                feature_blocks = feature[7],\n                // Whether we are drawing full height or squished features\n                full_height = true;\n\n            if (feature_ts && feature_te) {\n                thick_start = Math.floor( Math.max(0, (feature_ts - tile_low) * w_scale) );\n                thick_end = Math.ceil( Math.min(width, Math.max(0, (feature_te - tile_low) * w_scale)) );\n            }\n\n            // Set vars that depend on mode.\n            var thin_height, thick_height;\n            if (mode === \"Squish\" ) {\n                thin_height = 1;\n                thick_height = SQUISH_FEATURE_HEIGHT;\n                full_height = false;\n            } else if ( mode === \"Dense\" ) {\n                thin_height = 5;\n                thick_height = DENSE_FEATURE_HEIGHT;\n            } else { // mode === \"Pack\"\n                thin_height = 5;\n                thick_height = PACK_FEATURE_HEIGHT;\n            }\n\n            // Draw feature/feature blocks + connectors.\n            if (!feature_blocks) {\n                // If there are no blocks, treat the feature as one big exon.\n                ctx.fillStyle = block_color;\n                ctx.fillRect(f_start, y_start + 1, f_end - f_start, thick_height);\n                // If strand is specified, draw arrows over feature\n                if ( feature_strand && full_height ) {\n                    if (feature_strand === \"+\") {\n                        ctx.fillStyle = ctx.canvas.manager.get_pattern( 'right_strand_inv' );\n                    } else if (feature_strand === \"-\") {\n                        ctx.fillStyle = ctx.canvas.manager.get_pattern( 'left_strand_inv' );\n                    }\n                    ctx.fillRect(f_start, y_start + 1, f_end - f_start, thick_height);\n                }\n            } else {\n                //\n                // There are feature blocks and mode is either Squish or Pack.\n                //\n                // Approach: (a) draw whole feature as connector/intron and (b) draw blocks as\n                // needed. This ensures that whole feature, regardless of whether it starts with\n                // a block, is visible.\n                //\n\n                // Compute y axis start position and height\n                var cur_y_start, cur_height;\n                if (mode === \"Squish\" || mode === \"Dense\") {\n                    cur_y_start = y_start + Math.floor(SQUISH_FEATURE_HEIGHT/2) + 1;\n                    cur_height = 1;\n                }\n                else { // mode === \"Pack\"\n                    if (feature_strand) {\n                        cur_y_start = y_start;\n                        cur_height = thick_height;\n                    }\n                    else {\n                        cur_y_start += (SQUISH_FEATURE_HEIGHT/2) + 1;\n                        cur_height = 1;\n                    }\n                }\n\n                // Draw whole feature as connector/intron.\n                if ( this.draw_background_connector ) {\n                    if (mode === \"Squish\" || mode === \"Dense\") {\n                        ctx.fillStyle = CONNECTOR_COLOR;\n                    }\n                    else { // mode === \"Pack\"\n                        if (feature_strand) {\n                            if (feature_strand === \"+\") {\n                                ctx.fillStyle = ctx.canvas.manager.get_pattern( 'right_strand' );\n                            } else if (feature_strand === \"-\") {\n                                ctx.fillStyle = ctx.canvas.manager.get_pattern( 'left_strand' );\n                            }\n                        }\n                        else {\n                            ctx.fillStyle = CONNECTOR_COLOR;\n                        }\n                    }\n                    ctx.fillRect(f_start, cur_y_start, f_end - f_start, cur_height);\n                }\n\n                // Draw blocks.\n                var start_and_height;\n                for (var k = 0, k_len = feature_blocks.length; k < k_len; k++) {\n                    var block = feature_blocks[k],\n                        // -0.5 to offset block between bases.\n                        block_start = Math.floor( Math.max(0, (block[0] - tile_low - 0.5) * w_scale) ),\n                        block_end = Math.ceil( Math.min(width, Math.max((block[1] - tile_low - 0.5) * w_scale)) ),\n                        last_block_start, last_block_end;\n\n                    // Skip drawing if block not on tile.\n                    if (block_start > block_end) { continue; }\n\n                    // Draw thin block.\n                    ctx.fillStyle = block_color;\n                    ctx.fillRect(block_start, y_start + (thick_height-thin_height)/2 + 1, block_end - block_start, thin_height);\n\n                    // If block intersects with thick region, draw block as thick.\n                    // - No thick is sometimes encoded as thick_start == thick_end, so don't draw in that case\n                    if (thick_start !== undefined && feature_te > feature_ts && !(block_start > thick_end || block_end < thick_start) ) {\n                        var block_thick_start = Math.max(block_start, thick_start),\n                            block_thick_end = Math.min(block_end, thick_end);\n                        ctx.fillRect(block_thick_start, y_start + 1, block_thick_end - block_thick_start, thick_height);\n                        if ( feature_blocks.length === 1 && mode === \"Pack\") {\n                            // Exactly one block means we have no introns, but do have a distinct \"thick\" region,\n                            // draw arrows over it if in pack mode.\n                            if (feature_strand === \"+\") {\n                                ctx.fillStyle = ctx.canvas.manager.get_pattern( 'right_strand_inv' );\n                            } else if (feature_strand === \"-\") {\n                                ctx.fillStyle = ctx.canvas.manager.get_pattern( 'left_strand_inv' );\n                            }\n                            // If region is wide enough in pixels, pad a bit\n                            if ( block_thick_start + 14 < block_thick_end ) {\n                                block_thick_start += 2;\n                                block_thick_end -= 2;\n                            }\n                            ctx.fillRect(block_thick_start, y_start + 1, block_thick_end - block_thick_start, thick_height);\n                        }\n                    }\n                    // Draw individual connectors if required\n                    if ( this.draw_individual_connectors && last_block_start ) {\n                        this.draw_connector( ctx, last_block_start, last_block_end, block_start, block_end, y_start );\n                    }\n                    last_block_start = block_start;\n                    last_block_end = block_end;\n                }\n\n                // FIXME: Height scaling only works in Pack mode right now.\n                if (mode === \"Pack\") {\n                    // Reset alpha so height scaling is not impacted by alpha scaling.\n                    ctx.globalAlpha = 1;\n\n                    // Height scaling: draw white lines to reduce height according to height scale factor.\n                    ctx.fillStyle = \"white\"; // TODO: set this to background color.\n                    var\n                        hscale_factor = this.height_scaler.gen_val(feature),\n                        // Ceil ensures that min height is >= 1.\n                        new_height = Math.ceil(thick_height * hscale_factor),\n                        ws_height = Math.round( (thick_height-new_height)/2 );\n                    if (hscale_factor !== 1) {\n                        ctx.fillRect(f_start, cur_y_start + 1, f_end - f_start, ws_height);\n                        ctx.fillRect(f_start, cur_y_start + thick_height - ws_height + 1, f_end - f_start, ws_height);\n                    }\n                }\n            }\n\n            // Reset alpha so that label is not transparent.\n            ctx.globalAlpha = 1;\n\n            // Draw label for Pack mode.\n            if (feature_name && mode === \"Pack\" && feature_start > tile_low) {\n                ctx.fillStyle = label_color;\n                // FIXME: assumption here that the entire view starts at 0\n                if (tile_low === 0 && f_start - ctx.measureText(feature_name).width < 0) {\n                    ctx.textAlign = \"left\";\n                    ctx.fillText(feature_name, f_end + LABEL_SPACING, y_start + 8, this.max_label_length);\n                    draw_end += ctx.measureText(feature_name).width + LABEL_SPACING;\n                } else {\n                    ctx.textAlign = \"right\";\n                    ctx.fillText(feature_name, f_start - LABEL_SPACING, y_start + 8, this.max_label_length);\n                    draw_start -= ctx.measureText(feature_name).width + LABEL_SPACING;\n                }\n                //ctx.fillStyle = block_color;\n            }\n        }\n\n        // Reset global alpha.\n        ctx.globalAlpha = 1;\n\n        return [draw_start, draw_end];\n    }\n});\n\nvar ReadPainter = function(data, view_start, view_end, prefs, mode, alpha_scaler, height_scaler, ref_seq, base_color_fn) {\n    FeaturePainter.call(this, data, view_start, view_end, prefs, mode, alpha_scaler, height_scaler);\n    this.ref_seq = (ref_seq ? ref_seq.data : null);\n    this.base_color_fn = base_color_fn;\n};\n\n_.extend(ReadPainter.prototype, FeaturePainter.prototype, {\n    /**\n     * Returns height based on mode.\n     */\n    get_row_height: function() {\n        var height, mode = this.mode;\n        if (mode === \"Dense\") {\n            height = DENSE_TRACK_HEIGHT;\n        }\n        else if (mode === \"Squish\") {\n            height = SQUISH_TRACK_HEIGHT;\n        }\n        else { // mode === \"Pack\"\n            height = PACK_TRACK_HEIGHT;\n            if (this.prefs.show_insertions) {\n                height *= 2;\n            }\n        }\n        return height;\n    },\n\n    /**\n     * Parse CIGAR string to get (a) a list of contiguous drawing blocks (MD=X) and\n     * (b) an array of [ op_index, op_len ] pairs where op_index is an index into the\n     * string 'MIDNSHP=X' Return value is a dictionary with two entries, blocks and cigar\n     */\n    _parse_cigar: function(cigar_str) {\n        var cigar_ops = 'MIDNSHP=X';\n\n        // Parse cigar.\n        var blocks = [ [0, 0] ],\n            cur_block = blocks[0],\n            base_pos = 0,\n\n            // Parse cigar operations out and update/create blocks as needed.\n            parsed_cigar = _.map(cigar_str.match(/[0-9]+[MIDNSHP=X]/g), function(op) {\n                // Get operation length, character.\n                var op_len = parseInt(op.slice(0, -1), 10),\n                    op_char = op.slice(-1);\n\n                // Update drawing block.\n                if (op_char === 'N') {\n                    // At skip, so need to start new block if current block represents\n                    // drawing area.\n                    if (cur_block[1] !== 0) {\n                        cur_block = [base_pos + op_len, base_pos + op_len];\n                        blocks.push(cur_block);\n                    }\n                }\n                else if ('ISHP'.indexOf(op_char) === -1) {\n                    // Operation is M,D,=,X.\n                    cur_block[1] += op_len;\n                    base_pos += op_len;\n                }\n\n                // Return parsed cigar.\n                return [ cigar_ops.indexOf(op_char), op_len ];\n            });\n\n        return {\n            blocks: blocks,\n            cigar: parsed_cigar\n        };\n    },\n\n    /**\n     * Draw a single read from reference-based read sequence and cigar.\n     */\n    draw_read: function(ctx, mode, w_scale, y_start, tile_low, tile_high, feature_start, cigar, strand, read_seq) {\n        // Helper function to update base and sequnence offsets.\n        var update_base_offset = function(offset, cig_op, cig_len) {\n                if ('M=NXD'.indexOf(cig_op) !== -1) {\n                    offset += cig_len;\n                }\n                return offset;\n            },\n            update_seq_offset = function(offset, cig_op, cig_len) {\n                if ('IX'.indexOf(cig_op) !== -1) {\n                    offset += cig_len;\n                }\n                return offset;\n            },\n            // Gets drawing coordinate for a sequence coordinate. Assumes closure variables w_scale and tile_low.\n            get_draw_coord = function(sequence_coord) {\n                // -0.5 to offset sequence between bases.\n                return Math.floor( Math.max(0, (sequence_coord - tile_low - 0.5) * w_scale) );\n            };\n\n        ctx.textAlign = \"center\";\n        var tile_region = [tile_low, tile_high],\n            base_offset = 0,\n            seq_offset = 0,\n            gap = Math.round(w_scale/2),\n            char_width_px = ctx.canvas.manager.char_width_px,\n            block_color = (strand === \"+\" ? this.prefs.detail_block_color : this.prefs.reverse_strand_color),\n            pack_mode = (mode === 'Pack'),\n            draw_height = (pack_mode ? PACK_FEATURE_HEIGHT : SQUISH_FEATURE_HEIGHT),\n            rect_y = y_start + 1,\n            paint_utils = new ReadPainterUtils(ctx, draw_height, w_scale, mode),\n            drawing_blocks = [],\n            s_start,\n            s_end;\n\n        // Keep list of items that need to be drawn on top of initial drawing layer.\n        var draw_last = [];\n\n        // Parse cigar and get drawing blocks.\n        var t = this._parse_cigar(cigar);\n        cigar = t.cigar;\n        drawing_blocks = t.blocks;\n\n        // Draw blocks.\n        for (var i = 0; i < drawing_blocks.length; i++) {\n            var block = drawing_blocks[i];\n\n            if (is_overlap([feature_start + block[0], feature_start + block[1]], tile_region)) {\n                s_start = get_draw_coord(feature_start + block[0]);\n                s_end = get_draw_coord(feature_start + block[1]);\n\n                // Make sure that block is drawn even if it too small to be rendered officially; in this case,\n                // read is drawn at 1px.\n                // TODO: need to ensure that s_start, s_end are calculated the same for both slotting\n                // and drawing.\n                if (s_start === s_end) {\n                    s_end += 1;\n                }\n\n                // Draw read base as rectangle.\n                ctx.fillStyle = block_color;\n                ctx.fillRect(s_start, rect_y, s_end - s_start, draw_height);\n            }\n        }\n\n        // Draw read features.\n        for (var cig_id = 0, len = cigar.length; cig_id < len; cig_id++) {\n            var cig = cigar[cig_id],\n                cig_op = \"MIDNSHP=X\"[ cig[0] ],\n                cig_len = cig[1];\n\n            var seq_start = feature_start + base_offset;\n            s_start = get_draw_coord(seq_start);\n            s_end = get_draw_coord(seq_start + cig_len);\n\n            // Skip feature if it's not in tile.\n            if (!is_overlap([seq_start, seq_start + cig_len], tile_region)) {\n                // Update offsets.\n                base_offset = update_base_offset(base_offset, cig_op, cig_len);\n                seq_offset = update_seq_offset(seq_offset, cig_op, cig_len);\n                continue;\n            }\n\n            // Make sure that read is drawn even if it too small to be rendered officially; in this case,\n            // read is drawn at 1px.\n            // TODO: need to ensure that s_start, s_end are calculated the same for both slotting\n            // and drawing.\n            if (s_start === s_end) {\n                s_end += 1;\n            }\n\n            // Draw read feature.\n            switch (cig_op) {\n                case \"H\": // Hard clipping.\n                case \"S\": // Soft clipping.\n                case \"P\": // Padding.\n                    // Sequence not present and not related to alignment; do nothing.\n                    break;\n                case \"M\": // \"Match\".\n                    // Because it's not known whether there is a match, ignore.\n                    base_offset += cig_len;\n                    break;\n                case \"=\": // Match with reference.\n                case \"X\": // Mismatch with reference.\n                    //\n                    // Draw sequence and/or variants.\n                    //\n\n                    // Get sequence to draw.\n                    var cur_seq = '';\n                    if (cig_op === 'X') {\n                        // Get sequence from read_seq.\n                        cur_seq = read_seq.slice(seq_offset, seq_offset + cig_len);\n                    }\n                    else if (this.ref_seq) { // && cig_op === '='\n                        // Use reference sequence.\n                        cur_seq = this.ref_seq.slice(\n                            // If read starts after tile start, slice at read start.\n                            Math.max(0, seq_start - tile_low),\n                            // If read ends before tile end, slice at read end.\n                            Math.min(seq_start - tile_low + cig_len, tile_high - tile_low)\n                        );\n                    }\n\n                    // Draw sequence. Because cur_seq starts and read/tile start, go to there to start writing.\n                    var start_pos = Math.max(seq_start, tile_low);\n                    for (var c = 0; c < cur_seq.length; c++) {\n                        // Draw base if showing all (i.e. not showing differences) or there is a mismatch.\n                        if (cur_seq && !this.prefs.show_differences || cig_op === 'X') {\n                            // Draw base.\n                            var c_start = Math.floor( Math.max(0, (start_pos + c - tile_low) * w_scale) );\n                            ctx.fillStyle = this.base_color_fn(cur_seq[c]);\n                            if (pack_mode && w_scale > char_width_px) {\n                                ctx.fillText(cur_seq[c], c_start, y_start + 9);\n                            }\n                            // Require a minimum w_scale so that variants are only drawn when somewhat zoomed in.\n                            else if (w_scale > 0.05) {\n                                ctx.fillRect(c_start - gap, rect_y, Math.max( 1, Math.round(w_scale) ), draw_height);\n                            }\n                        }\n                    }\n\n                    // Move forward in sequence only if sequence used to get mismatches.\n                    if (cig_op === 'X') { seq_offset += cig_len; }\n                    base_offset += cig_len;\n\n                    break;\n                case \"N\": // Skipped bases.\n                    ctx.fillStyle = CONNECTOR_COLOR;\n                    ctx.fillRect(s_start, rect_y + (draw_height - 1)/2, s_end - s_start, 1);\n                    // No change in seq_offset because sequence not used when skipping.\n                    base_offset += cig_len;\n                    break;\n                case \"D\": // Deletion.\n                    paint_utils.draw_deletion(s_start, rect_y, cig_len);\n                    base_offset += cig_len;\n                    break;\n                case \"I\": // Insertion.\n                    // Check to see if sequence should be drawn at all by looking at the overlap between\n                    // the sequence region and the tile region.\n                    var insert_x_coord = s_start - gap;\n\n                    if (is_overlap([seq_start, seq_start + cig_len], tile_region)) {\n                        var seq = read_seq.slice(seq_offset, seq_offset + cig_len);\n                        // Insertion point is between the sequence start and the previous base: (-gap) moves\n                        // back from sequence start to insertion point.\n                        if (this.prefs.show_insertions) {\n                            //\n                            // Show inserted sequence above, centered on insertion point.\n                            //\n\n                            // Draw sequence.\n                            // X center is offset + start - <half_sequence_length>\n                            var x_center = s_start - (s_end - s_start)/2;\n                            if ( (mode === \"Pack\" || this.mode === \"Auto\") && read_seq !== undefined && w_scale > char_width_px) {\n                                // Draw sequence container.\n                                ctx.fillStyle = \"yellow\";\n                                ctx.fillRect(x_center - gap, y_start - 9, s_end - s_start, 9);\n                                draw_last[draw_last.length] = {type: \"triangle\", data: [insert_x_coord, y_start + 4, 5]};\n                                ctx.fillStyle = CONNECTOR_COLOR;\n                                // Based on overlap b/t sequence and tile, get sequence to be drawn.\n                                switch( compute_overlap( [seq_start, seq_start + cig_len], tile_region ) ) {\n                                    case(OVERLAP_START):\n                                        seq = seq.slice(tile_low-seq_start);\n                                        break;\n                                    case(OVERLAP_END):\n                                        seq = seq.slice(0, seq_start-tile_high);\n                                        break;\n                                    case(CONTAINED_BY):\n                                        // All of sequence drawn.\n                                        break;\n                                    case(CONTAINS):\n                                        seq = seq.slice(tile_low-seq_start, seq_start-tile_high);\n                                        break;\n                                }\n                                // Draw sequence.\n                                for (var c = 0, str_len = seq.length; c < str_len; c++) {\n                                    var c_start = Math.floor( Math.max(0, (seq_start + c -  tile_low) * w_scale) );\n                                    ctx.fillText(seq[c], c_start - (s_end - s_start)/2, y_start);\n                                }\n                            }\n                            else {\n                                // Draw block.\n                                ctx.fillStyle = \"yellow\";\n                                // TODO: This is a pretty hack-ish way to fill rectangle based on mode.\n                                ctx.fillRect(x_center, y_start + (this.mode !== \"Dense\" ? 2 : 5),\n                                             s_end - s_start, (mode !== \"Dense\" ? SQUISH_FEATURE_HEIGHT : DENSE_FEATURE_HEIGHT));\n                            }\n                        }\n                        else {\n                            if ( (mode === \"Pack\" || this.mode === \"Auto\") && read_seq !== undefined && w_scale > char_width_px) {\n                                // Show insertions with a single number at the insertion point.\n                                draw_last.push( { type: \"text\", data: [seq.length, insert_x_coord, y_start + 9] } );\n                            }\n                            else {\n                                // TODO: probably can merge this case with code above.\n                            }\n                        }\n                    }\n                    seq_offset += cig_len;\n                    // No change to base offset because insertions are drawn above sequence/read.\n                    break;\n            }\n        }\n\n        //\n        // Draw last items.\n        //\n        ctx.fillStyle = \"yellow\";\n        var item, type, data;\n        for (var i = 0; i < draw_last.length; i++) {\n            item = draw_last[i];\n            type = item.type;\n            data = item.data;\n            if (type === \"text\") {\n                ctx.save();\n                ctx.font = \"bold \" + ctx.font;\n                ctx.fillText(data[0], data[1], data[2]);\n                ctx.restore();\n            }\n            else if (type === \"triangle\") {\n                drawDownwardEquilateralTriangle(ctx, data[0], data[1], data[2]);\n            }\n        }\n    },\n\n    /**\n     * Draw a complete read pair\n     */\n    draw_element: function(ctx, mode, feature, slot, tile_low, tile_high, w_scale, y_scale, width ) {\n        // All features need a start, end, and vertical center.\n        var feature_uid = feature[0],\n            feature_start = feature[1],\n            feature_end = feature[2],\n            feature_name = feature[3],\n            // -0.5 to put element between bases.\n            f_start = Math.floor( Math.max(-0.5 * w_scale, (feature_start - tile_low - 0.5) * w_scale) ),\n            f_end   = Math.ceil( Math.min(width, Math.max(0, (feature_end - tile_low - 0.5) * w_scale)) ),\n            y_start = (mode === \"Dense\" ? 0 : (0 + slot)) * y_scale,\n            draw_height = (mode === 'Pack' ? PACK_FEATURE_HEIGHT : SQUISH_FEATURE_HEIGHT),\n            label_color = this.prefs.label_color;\n\n        // Draw read.\n        if (feature[5] instanceof Array) {\n            // Read is paired.\n            var connector = true;\n\n            // Draw left/forward read.\n            if (feature[4][1] >= tile_low && feature[4][0] <= tile_high && feature[4][2]) {\n                this.draw_read(ctx, mode, w_scale, y_start, tile_low, tile_high, feature[4][0], feature[4][2], feature[4][3], feature[4][4]);\n            }\n            else {\n                connector = false;\n            }\n\n            // Draw right/reverse read.\n            if (feature[5][1] >= tile_low && feature[5][0] <= tile_high && feature[5][2]) {\n                this.draw_read(ctx, mode, w_scale, y_start, tile_low, tile_high, feature[5][0], feature[5][2], feature[5][3], feature[5][4]);\n            }\n            else {\n                connector = false;\n            }\n\n            // Draw connector if both reads were drawn.\n            // TODO: currently, there is no way to connect reads drawn on different tiles; to connect reads on different tiles, data manager\n            // code is needed to join mate pairs from different regions. Alternatively, requesting multiple regions of data at once would\n            // make it possible to put together more easily.\n            // -0.5 to position connector correctly between reads.\n            var b1_end   = Math.ceil( Math.min(width, Math.max(-0.5 * w_scale, (feature[4][1] - tile_low - 0.5) * w_scale)) ),\n                b2_start = Math.floor( Math.max(-0.5 * w_scale, (feature[5][0] - tile_low - 0.5) * w_scale) );\n            if (connector && b2_start > b1_end) {\n                ctx.fillStyle = CONNECTOR_COLOR;\n                var line_height = y_start + 1 + (draw_height - 1)/2;\n                dashedLine(ctx, b1_end, line_height, b2_start, line_height);\n            }\n        } else {\n            // Read is single.\n            this.draw_read(ctx, mode, w_scale, y_start, tile_low, tile_high, feature_start, feature[4], feature[5], feature[6]);\n        }\n        if (mode === \"Pack\" && feature_start >= tile_low && feature_name !== \".\") {\n            // Draw label.\n            ctx.fillStyle = this.prefs.label_color;\n            if (tile_low === 0 && f_start - ctx.measureText(feature_name).width < 0) {\n                ctx.textAlign = \"left\";\n                ctx.fillText(feature_name, f_end + LABEL_SPACING, y_start + 9, this.max_label_length);\n            } else {\n                ctx.textAlign = \"right\";\n                ctx.fillText(feature_name, f_start - LABEL_SPACING, y_start + 9, this.max_label_length);\n            }\n        }\n\n        // FIXME: provide actual coordinates for drawn read.\n        return [0,0];\n    }\n});\n\nvar ArcLinkedFeaturePainter = function(data, view_start, view_end, prefs, mode, alpha_scaler, height_scaler) {\n    LinkedFeaturePainter.call(this, data, view_start, view_end, prefs, mode, alpha_scaler, height_scaler);\n    // Need to know the longest feature length for adding spacing\n    this.longest_feature_length = this.calculate_longest_feature_length();\n    this.draw_background_connector = false;\n    this.draw_individual_connectors = true;\n};\n\n_.extend(ArcLinkedFeaturePainter.prototype, FeaturePainter.prototype, LinkedFeaturePainter.prototype, {\n\n    calculate_longest_feature_length: function () {\n        var longest_feature_length = 0;\n        for (var i = 0, len = this.data.length; i < len; i++) {\n            var feature = this.data[i], feature_start = feature[1], feature_end = feature[2];\n            longest_feature_length = Math.max( longest_feature_length, feature_end - feature_start );\n        }\n        return longest_feature_length;\n    },\n\n    get_top_padding: function( width ) {\n        var view_range = this.view_end - this.view_start,\n            w_scale = width / view_range;\n        return Math.min( 128, Math.ceil( ( this.longest_feature_length / 2 ) * w_scale ) );\n    },\n\n    draw_connector: function( ctx, block1_start, block1_end, block2_start, block2_end, y_start ) {\n        // Arc drawing -- from closest endpoints\n        var x_center = ( block1_end + block2_start ) / 2,\n            radius = block2_start - x_center;\n        // For full half circles\n        var angle1 = Math.PI, angle2 = 0;\n        if ( radius > 0 ) {\n            ctx.beginPath();\n            ctx.arc( x_center, y_start, block2_start - x_center, Math.PI, 0 );\n            ctx.stroke();\n        }\n    }\n});\n\n// Color stuff from less.js\n\nvar Color = function (rgb, a) {\n    /**\n     * The end goal here, is to parse the arguments\n     * into an integer triplet, such as `128, 255, 0`\n     *\n     * This facilitates operations and conversions.\n     */\n    if (Array.isArray(rgb)) {\n        this.rgb = rgb;\n    } else if (rgb.length == 6) {\n        this.rgb = rgb.match(/.{2}/g).map(function (c) {\n            return parseInt(c, 16);\n        });\n    } else if (rgb.length == 7) {\n        this.rgb = rgb.substring(1,7).match(/.{2}/g).map(function (c) {\n            return parseInt(c, 16);\n        });\n    } else {\n        this.rgb = rgb.split('').map(function (c) {\n            return parseInt(c + c, 16);\n        });\n    }\n    this.alpha = typeof(a) === 'number' ? a : 1;\n};\nColor.prototype = {\n    eval: function () { return this; },\n\n    //\n    // If we have some transparency, the only way to represent it\n    // is via `rgba`. Otherwise, we use the hex representation,\n    // which has better compatibility with older browsers.\n    // Values are capped between `0` and `255`, rounded and zero-padded.\n    //\n    toCSS: function () {\n        if (this.alpha < 1.0) {\n            return \"rgba(\" + this.rgb.map(function (c) {\n                return Math.round(c);\n            }).concat(this.alpha).join(', ') + \")\";\n        } else {\n            return '#' + this.rgb.map(function (i) {\n                i = Math.round(i);\n                i = (i > 255 ? 255 : (i < 0 ? 0 : i)).toString(16);\n                return i.length === 1 ? '0' + i : i;\n            }).join('');\n        }\n    },\n\n    toHSL: function () {\n        var r = this.rgb[0] / 255,\n            g = this.rgb[1] / 255,\n            b = this.rgb[2] / 255,\n            a = this.alpha;\n\n        var max = Math.max(r, g, b), min = Math.min(r, g, b);\n        var h, s, l = (max + min) / 2, d = max - min;\n\n        if (max === min) {\n            h = s = 0;\n        } else {\n            s = l > 0.5 ? d / (2 - max - min) : d / (max + min);\n\n            switch (max) {\n                case r: h = (g - b) / d + (g < b ? 6 : 0); break;\n                case g: h = (b - r) / d + 2;               break;\n                case b: h = (r - g) / d + 4;               break;\n            }\n            h /= 6;\n        }\n        return { h: h * 360, s: s, l: l, a: a };\n    },\n\n    toARGB: function () {\n        var argb = [Math.round(this.alpha * 255)].concat(this.rgb);\n        return '#' + argb.map(function (i) {\n            i = Math.round(i);\n            i = (i > 255 ? 255 : (i < 0 ? 0 : i)).toString(16);\n            return i.length === 1 ? '0' + i : i;\n        }).join('');\n    },\n\n    mix: function (color2, weight) {\n        color1 = this;\n\n        var p = weight; // .value / 100.0;\n        var w = p * 2 - 1;\n        var a = color1.toHSL().a - color2.toHSL().a;\n\n        var w1 = (((w * a == -1) ? w : (w + a) / (1 + w * a)) + 1) / 2.0;\n        var w2 = 1 - w1;\n\n        var rgb = [color1.rgb[0] * w1 + color2.rgb[0] * w2,\n                   color1.rgb[1] * w1 + color2.rgb[1] * w2,\n                   color1.rgb[2] * w1 + color2.rgb[2] * w2];\n\n        var alpha = color1.alpha * p + color2.alpha * (1 - p);\n\n        return new Color(rgb, alpha);\n    }\n};\n\n\n// End colors from less.js\n\nvar LinearRamp = function( start_color, end_color, start_value, end_value ) {\n    /**\n     * Simple linear gradient\n     */\n    this.start_color = new Color( start_color );\n    this.end_color = new Color( end_color );\n    this.start_value = start_value;\n    this.end_value = end_value;\n    this.value_range = end_value - start_value;\n};\n\nLinearRamp.prototype.map_value = function( value ) {\n    value = Math.max( value, this.start_value );\n    value = Math.min( value, this.end_value );\n    value = ( value - this.start_value ) / this.value_range;\n    // HACK: just red for now\n    // return \"hsl(0,100%,\" + (value * 100) + \"%)\"\n    return this.start_color.mix( this.end_color, 1 - value ).toCSS();\n};\n\nvar SplitRamp = function( start_color, middle_color, end_color, start_value, end_value ) {\n    /**\n     * Two gradients split away from 0\n     */\n    this.positive_ramp = new LinearRamp( middle_color, end_color, 0, end_value );\n    this.negative_ramp = new LinearRamp( middle_color, start_color, 0, -start_value );\n    this.start_value = start_value;\n    this.end_value = end_value;\n};\n\nSplitRamp.prototype.map_value = function( value ) {\n    value = Math.max( value, this.start_value );\n    value = Math.min( value, this.end_value );\n    if ( value >= 0 ) {\n        return this.positive_ramp.map_value( value );\n    } else {\n        return this.negative_ramp.map_value( -value );\n    }\n};\n\nvar DiagonalHeatmapPainter = function(data, view_start, view_end, prefs, mode) {\n    Painter.call( this, data, view_start, view_end, prefs, mode );\n    var i, len;\n\n    if ( this.prefs.min_value === undefined ) {\n        var min_value = Infinity;\n        for (i = 0, len = this.data.length; i < len; i++) {\n            min_value = Math.min( min_value, this.data[i][6] );\n        }\n        this.prefs.min_value = min_value;\n    }\n    if ( this.prefs.max_value === undefined ) {\n        var max_value = -Infinity;\n        for (i = 0, len = this.data.length; i < len; i++) {\n            max_value = Math.max( max_value, this.data[i][6] );\n        }\n        this.prefs.max_value = max_value;\n    }\n};\n\nDiagonalHeatmapPainter.prototype.default_prefs = {\n    min_value: undefined,\n    max_value: undefined,\n    mode: \"Heatmap\",\n    pos_color: \"#FF8C00\",\n    neg_color: \"#4169E1\"\n};\n\nDiagonalHeatmapPainter.prototype.draw = function(ctx, width, height, w_scale) {\n    var\n        min_value = this.prefs.min_value,\n        max_value = this.prefs.max_value,\n        value_range = max_value - min_value,\n        height_px = height,\n        view_start = this.view_start,\n        mode = this.mode,\n        data = this.data,\n        invsqrt2 = 1 / Math.sqrt(2);\n\n    var ramp = ( new SplitRamp( this.prefs.neg_color, \"#FFFFFF\", this.prefs.pos_color, min_value, max_value ) );\n\n    var d, s1, e1, s2, e2, value;\n\n    var scale = function( p ) { return ( p - view_start ) * w_scale; };\n\n    ctx.save();\n\n    // Draw into triangle, then rotate and scale\n    ctx.rotate(-45 * Math.PI / 180);\n    ctx.scale( invsqrt2, invsqrt2 );\n\n    // Paint track.\n    for (var i = 0, len = data.length; i < len; i++) {\n        d = data[i];\n\n        s1 = scale( d[1] );\n        e1 = scale( d[2] );\n        s2 = scale( d[4] );\n        e2 = scale( d[5] );\n        value = d[6];\n\n        ctx.fillStyle = ( ramp.map_value( value ) );\n        ctx.fillRect( s1, s2, ( e1 - s1 ), ( e2 - s2 ) );\n    }\n\n    ctx.restore();\n};\n\n/**\n * Utilities for painting reads.\n */\nvar ReadPainterUtils = function(ctx, row_height, px_per_base, mode) {\n    this.ctx = ctx;\n    this.row_height = row_height;\n    this.px_per_base = px_per_base;\n    this.draw_details = (mode === 'Pack' || mode === 'Auto') && (px_per_base >= ctx.canvas.manager.char_width_px);\n    this.delete_details_thickness = 0.2;\n};\n\n_.extend(ReadPainterUtils.prototype, {\n    /**\n     * Draw deletion of base(s).\n     * @param draw_detail if true, drawing in detail and deletion is drawn more subtly\n     */\n    draw_deletion: function(x, y, len) {\n        this.ctx.fillStyle = \"black\";\n        var thickness = (this.draw_details ? this.delete_details_thickness : 1) * this.row_height;\n        y += 0.5 * ( this.row_height - thickness );\n        this.ctx.fillRect(x, y, len * this.px_per_base, thickness);\n    }\n});\n\n/**\n * Paints variant data onto canvas.\n */\nvar VariantPainter = function(data, view_start, view_end, prefs, mode, base_color_fn) {\n    Painter.call(this, data, view_start, view_end, prefs, mode);\n    this.base_color_fn = base_color_fn;\n    this.divider_height = 1;\n};\n\n_.extend(VariantPainter.prototype, Painter.prototype, {\n    /**\n     * Height of a single row, depends on mode\n     */\n    get_row_height: function() {\n        var mode = this.mode, height;\n        if (mode === \"Dense\") {\n            height = DENSE_TRACK_HEIGHT;\n        }\n        else if (mode === \"Squish\") {\n            height = SQUISH_TRACK_HEIGHT;\n        }\n        else { // mode === \"Pack\"\n            height = PACK_TRACK_HEIGHT;\n        }\n        return height;\n    },\n\n    /**\n     * Returns required height to draw a particular number of samples in a given mode.\n     */\n    get_required_height: function(num_samples) {\n        // FIXME: for single-sample data, height should be summary_height when zoomed out and\n        // row_height when zoomed in.\n        var height = this.prefs.summary_height;\n\n        // If showing sample data, height is summary + divider + samples.\n        if (num_samples > 1 && this.prefs.show_sample_data) {\n            height += this.divider_height + num_samples * this.get_row_height();\n        }\n        return height;\n    },\n\n    /**\n     * Draw on the context using a rectangle of width x height with scale w_scale.\n     */\n    draw: function(ctx, width, height, w_scale) {\n        ctx.save();\n\n        var\n        /**\n         * Returns dictionary of information about an indel; returns empty if there no indel. Assumes indel is left-aligned.\n         * Dict attributes:\n         *    -type: 'insertion' or 'deletion'\n         *    -start: where the deletion starts relative to reference start\n         *    -len: how long the deletion is\n         */\n        get_indel_info = function(ref, alt) {\n            var ref_len = ref.length,\n                alt_len = alt.length,\n                start = 0,\n                len = 1,\n                type = null;\n            if (alt === '-') {\n                type = 'deletion';\n                len = ref.length;\n            }\n            else if (ref.indexOf(alt) === 0 && ref_len > alt_len) {\n                type = 'deletion';\n                len = ref_len - alt_len;\n                start = alt_len;\n            }\n            else if (alt.indexOf(ref) === 0 && ref_len < alt_len) {\n                // Insertion.\n                type = 'insertion';\n                len = alt_len - ref_len;\n                start = alt_len;\n            }\n\n            return ( type !== null ? { type: type, start: start, len: len } : {} );\n        };\n\n        // Draw.\n        var locus_data,\n            pos,\n            id,\n            ref,\n            alt,\n            qual,\n            filter,\n            sample_gts,\n            allele_counts,\n            variant,\n            draw_x_start,\n            draw_y_start,\n            genotype,\n            // Always draw variants at least 1 pixel wide.\n            base_px = Math.max(1, Math.floor(w_scale)),\n            // Determine number of samples.\n            num_samples = (this.data.length ? this.data[0][7].split(',').length : 0),\n            row_height = (this.mode === 'Squish' ? SQUISH_TRACK_HEIGHT : PACK_TRACK_HEIGHT),\n            // If zoomed out, fill the whole row with feature to make it easier to read;\n            // when zoomed in, use feature height so that there are gaps in sample rows.\n            feature_height = (w_scale < 0.1 ?\n                              row_height :\n                              (this.mode === 'Squish' ? SQUISH_FEATURE_HEIGHT : PACK_FEATURE_HEIGHT)\n                             ),\n            draw_summary = true,\n            paint_utils = new ReadPainterUtils(ctx, row_height, w_scale, this.mode),\n            j;\n\n        // If there's a single sample, update drawing variables.\n        if (num_samples === 1) {\n            row_height = feature_height =\n                (w_scale < ctx.canvas.manager.char_width_px ? this.prefs.summary_height : row_height);\n            paint_utils.row_height = row_height;\n            // No summary when there's a single sample.\n            draw_summary = false;\n        }\n\n        // Draw divider between summary and samples.\n        if (this.prefs.show_sample_data && draw_summary) {\n            ctx.fillStyle = '#F3F3F3';\n            ctx.globalAlpha = 1;\n            ctx.fillRect(0, this.prefs.summary_height - this.divider_height, width, this.divider_height);\n        }\n\n        // Draw variants.\n        ctx.textAlign = \"center\";\n        for (var i = 0; i < this.data.length; i++) {\n            // Get locus data.\n            locus_data = this.data[i];\n            pos = locus_data[1];\n            ref = locus_data[3];\n            alt = [ locus_data[4].split(',') ];\n            sample_gts = locus_data[7].split(',');\n            allele_counts = locus_data.slice(8);\n\n            // Process alterate values to derive information about each alt.\n            alt = _.map(_.flatten(alt), function(a) {\n                var alt_info = {\n                        type: 'snp',\n                        value: a,\n                        start: 0\n                    },\n                    indel_info = get_indel_info(ref, a);\n\n                return _.extend(alt_info, indel_info);\n            });\n\n            // Only draw locus data if it's in viewing region.\n            if (pos < this.view_start || pos > this.view_end) {\n                continue;\n            }\n\n            // Draw summary for alleles.\n            if (draw_summary) {\n                ctx.fillStyle = '#999999';\n                ctx.globalAlpha = 1;\n                for (j = 0; j < alt.length; j++) {\n                    // Draw background for summary.\n                    draw_x_start = this.get_start_draw_pos(pos + alt[j].start, w_scale);\n                    ctx.fillRect(draw_x_start, 0, base_px, this.prefs.summary_height);\n                    draw_y_start = this.prefs.summary_height;\n                    // Draw allele fractions onto summary.\n                    for (j = 0; j < alt.length; j++) {\n                        ctx.fillStyle = ( alt[j].type === 'deletion' ? 'black' : this.base_color_fn(alt[j].value) );\n                        allele_frac = allele_counts / sample_gts.length;\n                        draw_height = Math.ceil(this.prefs.summary_height * allele_frac);\n                        ctx.fillRect(draw_x_start, draw_y_start - draw_height, base_px, draw_height);\n                        draw_y_start -= draw_height;\n                    }\n                }\n            }\n\n            // Done drawing if not showing samples data.\n            if (!this.prefs.show_sample_data) { continue; }\n\n            // Draw sample genotype(s).\n            draw_y_start = (draw_summary ? this.prefs.summary_height + this.divider_height : 0);\n            for (j = 0; j < sample_gts.length; j++, draw_y_start += row_height) {\n                genotype = (sample_gts[j] ? sample_gts[j].split(/\\/|\\|/) : ['0', '0']);\n\n                // Get variant to draw and set drawing properties.\n                variant = null;\n                if (genotype[0] === genotype[1]) {\n                    if (genotype[0] === '.') {\n                        // TODO: draw uncalled variant.\n                    }\n                    else if (genotype[0] !== '0') {\n                        // Homozygous for variant.\n                        variant = alt[ parseInt(genotype[0], 10) - 1 ];\n                        ctx.globalAlpha = 1;\n                    }\n                    // else reference\n                }\n                else { // Heterozygous for variant.\n                    variant = (genotype[0] !== '0' ? genotype[0] : genotype[1]);\n                    variant = alt[ parseInt(variant, 10) - 1 ];\n                    ctx.globalAlpha = 0.5;\n                }\n\n                // If there's a variant, draw it.\n                if (variant) {\n                    draw_x_start = this.get_start_draw_pos(pos + variant.start, w_scale);\n                    if (variant.type === 'snp') {\n                        var snp = variant.value;\n                        ctx.fillStyle = this.base_color_fn(snp);\n                        if (paint_utils.draw_details) {\n                            ctx.fillText(snp, this.get_draw_pos(pos, w_scale), draw_y_start + row_height);\n                        }\n                        else {\n                            ctx.fillRect(draw_x_start, draw_y_start + 1, base_px, feature_height);\n                        }\n                    }\n                    else if (variant.type === 'deletion') {\n                        paint_utils.draw_deletion(draw_x_start, draw_y_start + 1, variant.len);\n                    }\n                    else {\n                        // TODO: handle insertions.\n                    }\n                }\n            }\n        }\n\n        ctx.restore();\n    }\n});\n\nreturn {\n    Scaler: Scaler,\n    LinePainter: LinePainter,\n    LinkedFeaturePainter: LinkedFeaturePainter,\n    ReadPainter: ReadPainter,\n    ArcLinkedFeaturePainter: ArcLinkedFeaturePainter,\n    DiagonalHeatmapPainter: DiagonalHeatmapPainter,\n    VariantPainter: VariantPainter\n};\n\n\n});\n"]}