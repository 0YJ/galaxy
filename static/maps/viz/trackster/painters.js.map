{"version":3,"sources":["viz/trackster/painters.js"],"names":["_","compute_overlap","first_region","second_region","first_start","first_end","second_start","second_end","is_overlap","overlap","AFTER","x1","y1","x2","y2","dashLen","undefined","q","dY","dashes","Math","floor","sqrt","dX","dashX","dashY","ctx","drawDownwardEquilateralTriangle","down_vertex_x","down_vertex_y","side_len","y","beginPath","moveTo","lineTo","fillRect","fillStyle","fill","stroke","closePath","Scaler","this","default_val","input","options","incomplete_features","feature_mapper","Painter","data","view_start","view_end","prefs","mode","extend","default_prefs","prototype","draw","width","height","w_scale","get_start_draw_pos","chrom_pos","get_end_draw_pos","_chrom_pos_to_draw_pos","get_draw_pos","offset","LinePainter","call","min_value","max_value","color","overflow_color","in_path","vertical_range","height_px","y_zero","round","x_scaled","delta_x_pxs","length","map","slice","d","i","ceil","block_color","pref_color","parseInt","painter_color","pref_g","pref_b","bot_overflow","len","strokeStyle","top_overflow","delta_x_px","pref_r","saturation","new_b","new_r","new_g","overflow_x","restore","slot_height","y_translation","FeaturePositionMapper","map_feature_data","feature_data","slot","x_start","x_end","translation","feature_positions","push","get_feature_data","x","feature_dict","FeaturePainter","alpha_scaler","height_scaler","max_label_length","required_height","get_row_height","y_scale","rows_required","get_top_padding","slots","save","x_draw_coords","feature","feature_uid","feature_start","feature_end","PACK_TRACK_HEIGHT","DENSE_TRACK_HEIGHT","SQUISH_TRACK_HEIGHT","NO_DETAIL_FEATURE_HEIGHT","DENSE_FEATURE_HEIGHT","tile_low","tile_high","LinkedFeaturePainter","draw_element","f_start","draw_background_connector","feature_strand","NO_DETAIL_TRACK_HEIGHT","thick_start","thick_end","thin_height","thick_height","full_height","feature_name","max","f_end","feature_blocks","min","y_start","draw_start","canvas","reverse_strand_color","label_color","cur_y_start","cur_height","gen_val","feature_ts","start_and_height","block_end","last_block_end","new_height","hscale_factor","globalAlpha","SQUISH_FEATURE_HEIGHT","textAlign","fillText","measureText","get_pattern","manager","draw_end","ref_seq","base_color_fn","k","k_len","block","block_start","cigar_ops","cigar_str","parsed_cigar","feature_te","op_len","op","op_char","block_thick_start","block_thick_end","cur_block","blocks","indexOf","update_base_offset","cig_len","last_block_start","get_draw_coord","seq_offset","char_width_px","draw_height","pack_mode","rect_y","drawing_blocks","ws_height","cigar","draw_connector","s_start","cig_id","cig_op","seq_start","base_offset","update_seq_offset","s_end","ReadPainter","show_insertions","_parse_cigar","base_pos","draw_deletion","paint_utils","insert_x_coord","seq","read_seq","sequence_coord","type","gap","strand","ReadPainterUtils","tile_region","cig","draw_read","connector","cur_seq","ArcLinkedFeaturePainter","longest_feature_length","start_pos","c","view_range","show_differences","c_start","block1_end","block2_start","rgb","alpha","join","toString","x_center","draw_last","str_len","color2","w2","end_color","start_value","value_range","SplitRamp","start_color","LinearRamp","middle_color","CONTAINS","item","Infinity","pos_color","neg_color","DiagonalHeatmapPainter","invsqrt2","ramp","e2","scale","s1","Array","s2","map_value","e1","row_height","px_per_base","draw_details","VariantPainter","b2_start","b1_end","summary_height","dashedLine","line_height","alt_len","alt","ref_len","start","id","base_px","num_samples","feature_height","calculate_longest_feature_length","draw_individual_connectors","draw_summary","show_sample_data","locus_data","sample_gts","allele_counts","split","flatten","block1_start","block2_end","radius","PI","arc","j","Color","a","isArray","match","draw_y_start","genotype","variant","eval","toCSS","concat","h","s","b","r","g","l","toARGB","mix","weight","color1","p","w","toHSL","w1","end_value","value","positive_ramp","negative_ramp","rotate","delete_details_thickness","thickness","divider_height","get_required_height","pos","ref","draw_x_start","get_indel_info","alt_info","indel_info","allele_frac","snp"],"mappings":"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","file":"../../../scripts/viz/trackster/painters.js","sourcesContent":["import * as _ from \"libs/underscore\";\n/**\n * Compute the type of overlap between two regions. They are assumed to be on the same chrom/contig.\n * The overlap is computed relative to the second region; hence, OVERLAP_START indicates that the first\n * region overlaps the start (but not the end) of the second region.\n * NOTE: Coordinates are assumed to be in BED format: half open (start is closed, end is open).\n */\nvar BEFORE = 1001,\n    CONTAINS = 1002,\n    OVERLAP_START = 1003,\n    OVERLAP_END = 1004,\n    CONTAINED_BY = 1005,\n    AFTER = 1006;\nvar compute_overlap = function(first_region, second_region) {\n    var first_start = first_region[0],\n        first_end = first_region[1],\n        second_start = second_region[0],\n        second_end = second_region[1],\n        overlap;\n    if (first_start < second_start) {\n        if (first_end <= second_start) {\n            overlap = BEFORE;\n        } else if (first_end <= second_end) {\n            overlap = OVERLAP_START;\n        } else {\n            // first_end > second_end\n            overlap = CONTAINS;\n        }\n    } else {\n        // first_start >= second_start\n        if (first_start > second_end) {\n            overlap = AFTER;\n        } else if (first_end <= second_end) {\n            overlap = CONTAINED_BY;\n        } else {\n            overlap = OVERLAP_END;\n        }\n    }\n\n    return overlap;\n};\n\n/**\n * Returns true if regions overlap.\n */\nvar is_overlap = function(first_region, second_region) {\n    var overlap = compute_overlap(first_region, second_region);\n    return overlap !== BEFORE && overlap !== AFTER;\n};\n\n/**\n * Draw a dashed line on a canvas using filled rectangles. This function is based on:\n * http://vetruvet.blogspot.com/2010/10/drawing-dashed-lines-on-html5-canvas.html\n * However, that approach uses lines, which don't seem to render as well, so use\n * rectangles instead.\n */\nvar dashedLine = function(ctx, x1, y1, x2, y2, dashLen) {\n    if (dashLen === undefined) {\n        dashLen = 4;\n    }\n    var dX = x2 - x1;\n    var dY = y2 - y1;\n    var dashes = Math.floor(Math.sqrt(dX * dX + dY * dY) / dashLen);\n    var dashX = dX / dashes;\n    var dashY = dY / dashes;\n    var q;\n\n    for (q = 0; q < dashes; q++, x1 += dashX, y1 += dashY) {\n        if (q % 2 !== 0) {\n            continue;\n        }\n        ctx.fillRect(x1, y1, dashLen, 1);\n    }\n};\n\n/**\n * Draw an isosceles triangle that points down.\n */\nvar drawDownwardEquilateralTriangle = function(\n    ctx,\n    down_vertex_x,\n    down_vertex_y,\n    side_len\n) {\n    // Compute other two points of triangle.\n    var x1 = down_vertex_x - side_len / 2,\n        x2 = down_vertex_x + side_len / 2,\n        y = down_vertex_y - Math.sqrt(side_len * 3 / 2);\n\n    // Draw and fill.\n    ctx.beginPath();\n    ctx.moveTo(x1, y);\n    ctx.lineTo(x2, y);\n    ctx.lineTo(down_vertex_x, down_vertex_y);\n    ctx.lineTo(x1, y);\n\n    ctx.strokeStyle = this.fillStyle;\n    ctx.fill();\n    ctx.stroke();\n    ctx.closePath();\n};\n\n/**\n * Base class for all scalers. Scalers produce values that are used to change (scale) drawing attributes.\n */\nvar Scaler = function(default_val) {\n    this.default_val = default_val ? default_val : 1;\n};\n\n/**\n * Produce a scaling value.\n */\nScaler.prototype.gen_val = function(input) {\n    return this.default_val;\n};\n\n/**\n * Results from painter.draw()\n */\nvar DrawResults = function(options) {\n    this.incomplete_features = options.incomplete_features;\n    this.feature_mapper = options.feature_mapper;\n};\n\n/**\n * Base class for painters\n *\n * -- Mode and prefs are both optional\n */\nvar Painter = function(data, view_start, view_end, prefs, mode) {\n    // Data and data properties\n    this.data = data;\n    // View\n    this.view_start = view_start;\n    this.view_end = view_end;\n    // Drawing prefs\n    this.prefs = _.extend({}, this.default_prefs, prefs);\n    this.mode = mode;\n};\n\nPainter.prototype.default_prefs = {};\n\n/**\n * Draw on the context using a rectangle of width x height using scale w_scale.\n */\nPainter.prototype.draw = function(ctx, width, height, w_scale) {};\n\n/**\n * Get starting drawing position, which is offset a half-base left of coordinate.\n */\nPainter.prototype.get_start_draw_pos = function(chrom_pos, w_scale) {\n    return this._chrom_pos_to_draw_pos(chrom_pos, w_scale, -0.5);\n};\n\n/**\n * Get end drawing position, which is offset a half-base right of coordinate.\n */\nPainter.prototype.get_end_draw_pos = function(chrom_pos, w_scale) {\n    return this._chrom_pos_to_draw_pos(chrom_pos, w_scale, 0.5);\n};\n\n/**\n * Get drawing position.\n */\nPainter.prototype.get_draw_pos = function(chrom_pos, w_scale) {\n    return this._chrom_pos_to_draw_pos(chrom_pos, w_scale, 0);\n};\n\n/**\n * Convert chromosome position to drawing position.\n */\nPainter.prototype._chrom_pos_to_draw_pos = function(\n    chrom_pos,\n    w_scale,\n    offset\n) {\n    return Math.floor(\n        w_scale * (Math.max(0, chrom_pos - this.view_start) + offset)\n    );\n};\n\nvar LinePainter = function(data, view_start, view_end, prefs, mode) {\n    Painter.call(this, data, view_start, view_end, prefs, mode);\n};\n\nLinePainter.prototype.default_prefs = {\n    min_value: undefined,\n    max_value: undefined,\n    mode: \"Histogram\",\n    color: \"#000\",\n    overflow_color: \"#F66\"\n};\n\nLinePainter.prototype.draw = function(ctx, width, height, w_scale) {\n    var in_path = false,\n        min_value = this.prefs.min_value,\n        max_value = this.prefs.max_value,\n        vertical_range = max_value - min_value,\n        height_px = height,\n        view_start = this.view_start,\n        mode = this.mode,\n        data = this.data;\n\n    ctx.save();\n\n    // Pixel position of 0 on the y axis\n    var y_zero = Math.round(height + min_value / vertical_range * height);\n\n    // Horizontal line to denote x-axis\n    if (mode !== \"Intensity\") {\n        ctx.fillStyle = \"#aaa\";\n        ctx.fillRect(0, y_zero, width, 1);\n    }\n\n    ctx.beginPath();\n    var x_scaled, y, delta_x_pxs;\n    if (data.length > 1) {\n        delta_x_pxs = _.map(data.slice(0, -1), function(d, i) {\n            return Math.ceil((data[i + 1][0] - data[i][0]) * w_scale);\n        });\n    } else {\n        delta_x_pxs = [10];\n    }\n\n    // Painter color can be in either block_color (FeatureTrack) or color pref (LineTrack).\n    var painter_color = this.prefs.block_color || this.prefs.color,\n        // Extract RGB from preference color.\n        pref_color = parseInt(painter_color.slice(1), 16),\n        pref_r = (pref_color & 0xff0000) >> 16,\n        pref_g = (pref_color & 0x00ff00) >> 8,\n        pref_b = pref_color & 0x0000ff,\n        top_overflow = false,\n        bot_overflow = false;\n\n    // Paint track.\n    var delta_x_px;\n    for (var i = 0, len = data.length; i < len; i++) {\n        // Reset attributes for next point.\n        ctx.fillStyle = ctx.strokeStyle = painter_color;\n        top_overflow = bot_overflow = false;\n        delta_x_px = delta_x_pxs[i];\n\n        x_scaled = Math.floor((data[i][0] - view_start - 0.5) * w_scale);\n        y = data[i][1];\n\n        // Process Y (scaler) value.\n        if (y === null) {\n            if (in_path && mode === \"Filled\") {\n                ctx.lineTo(x_scaled, height_px);\n            }\n            in_path = false;\n            continue;\n        }\n\n        // Bound Y value by min, max.\n        if (y < min_value) {\n            bot_overflow = true;\n            y = min_value;\n        } else if (y > max_value) {\n            top_overflow = true;\n            y = max_value;\n        }\n\n        // Draw point.\n        if (mode === \"Histogram\") {\n            // y becomes the bar height in pixels, which is the negated for canvas coords\n            y = Math.round(y / vertical_range * height_px);\n            ctx.fillRect(x_scaled, y_zero, delta_x_px, -y);\n        } else if (mode === \"Intensity\") {\n            var saturation = (y - min_value) / vertical_range,\n                // Range is [pref_color, 255] where saturation = 0 --> 255 and saturation = 1 --> pref color\n                new_r = Math.round(pref_r + (255 - pref_r) * (1 - saturation)),\n                new_g = Math.round(pref_g + (255 - pref_g) * (1 - saturation)),\n                new_b = Math.round(pref_b + (255 - pref_b) * (1 - saturation));\n            ctx.fillStyle = \"rgb(\" + new_r + \",\" + new_g + \",\" + new_b + \")\";\n            ctx.fillRect(x_scaled, 0, delta_x_px, height_px);\n        } else {\n            // mode is Coverage/Line or Filled.\n\n            // Scale Y value.\n            y = Math.round(\n                height_px - (y - min_value) / vertical_range * height_px\n            );\n            if (in_path) {\n                ctx.lineTo(x_scaled, y);\n            } else {\n                in_path = true;\n                if (mode === \"Filled\") {\n                    ctx.moveTo(x_scaled, height_px);\n                    ctx.lineTo(x_scaled, y);\n                } else {\n                    ctx.moveTo(x_scaled, y);\n                    // Use this approach (note: same as for filled) to draw line from 0 to\n                    // first data point.\n                    //ctx.moveTo(x_scaled, height_px);\n                    //ctx.lineTo(x_scaled, y);\n                }\n            }\n        }\n\n        // Draw lines at boundaries if overflowing min or max\n        ctx.fillStyle = this.prefs.overflow_color;\n        if (top_overflow || bot_overflow) {\n            var overflow_x;\n            if (mode === \"Histogram\" || mode === \"Intensity\") {\n                overflow_x = delta_x_px;\n            } else {\n                // Line and Filled, which are points\n                x_scaled -= 2; // Move it over to the left so it's centered on the point\n                overflow_x = 4;\n            }\n            if (top_overflow) {\n                ctx.fillRect(x_scaled, 0, overflow_x, 3);\n            }\n            if (bot_overflow) {\n                ctx.fillRect(x_scaled, height_px - 3, overflow_x, 3);\n            }\n        }\n        ctx.fillStyle = painter_color;\n    }\n    if (mode === \"Filled\") {\n        if (in_path) {\n            ctx.lineTo(x_scaled, y_zero);\n            ctx.lineTo(0, y_zero);\n        }\n        ctx.fill();\n    } else {\n        ctx.stroke();\n    }\n\n    ctx.restore();\n};\n\n/**\n * Mapper that contains information about feature locations and data.\n */\nvar FeaturePositionMapper = function(slot_height) {\n    this.feature_positions = {};\n    this.slot_height = slot_height;\n    this.translation = 0;\n    this.y_translation = 0;\n};\n\n/**\n * Map feature data to a position defined by <slot, x_start, x_end>.\n */\nFeaturePositionMapper.prototype.map_feature_data = function(\n    feature_data,\n    slot,\n    x_start,\n    x_end\n) {\n    if (!this.feature_positions[slot]) {\n        this.feature_positions[slot] = [];\n    }\n    this.feature_positions[slot].push({\n        data: feature_data,\n        x_start: x_start,\n        x_end: x_end\n    });\n};\n\n/**\n * Get feature data for position <x, y>\n */\nFeaturePositionMapper.prototype.get_feature_data = function(x, y) {\n    // Find slot using Y.\n    var slot = Math.floor((y - this.y_translation) / this.slot_height),\n        feature_dict;\n\n    // May not be over a slot due to padding, margin, etc.\n    if (!this.feature_positions[slot]) {\n        return null;\n    }\n\n    // Find feature using X.\n    x += this.translation;\n    for (var i = 0; i < this.feature_positions[slot].length; i++) {\n        feature_dict = this.feature_positions[slot][i];\n        if (x >= feature_dict.x_start && x <= feature_dict.x_end) {\n            return feature_dict.data;\n        }\n    }\n};\n\n/**\n * Abstract object for painting feature tracks. Subclasses must implement draw_element() for painting to work.\n * Painter uses a 0-based, half-open coordinate system; start coordinate is closed--included--and the end is open.\n * This coordinate system matches the BED format.\n */\nvar FeaturePainter = function(\n    data,\n    view_start,\n    view_end,\n    prefs,\n    mode,\n    alpha_scaler,\n    height_scaler\n) {\n    Painter.call(this, data, view_start, view_end, prefs, mode);\n    this.alpha_scaler = alpha_scaler ? alpha_scaler : new Scaler();\n    this.height_scaler = height_scaler ? height_scaler : new Scaler();\n    this.max_label_length = 200;\n};\n\nFeaturePainter.prototype.default_prefs = {\n    block_color: \"#FFF\",\n    connector_color: \"#FFF\"\n};\n\n_.extend(FeaturePainter.prototype, {\n    get_required_height: function(rows_required, width) {\n        // y_scale is the height per row\n        var required_height = this.get_row_height(),\n            y_scale = required_height,\n            mode = this.mode;\n        // If using a packing mode, need to multiply by the number of slots used\n        if (mode === \"no_detail\" || mode === \"Squish\" || mode === \"Pack\") {\n            required_height = rows_required * y_scale;\n        }\n        return required_height + this.get_top_padding(width);\n    },\n\n    /** Extra padding before first row of features */\n    get_top_padding: function(width) {\n        return 0;\n    },\n\n    /**\n     * Draw data on ctx using slots and within the rectangle defined by width and height. Returns\n     * a FeaturePositionMapper object with information about where features were drawn.\n     */\n    draw: function(ctx, width, height, w_scale, slots) {\n        var data = this.data,\n            view_start = this.view_start,\n            view_end = this.view_end;\n\n        ctx.save();\n\n        ctx.fillStyle = this.prefs.block_color;\n        ctx.textAlign = \"right\";\n\n        var y_scale = this.get_row_height(),\n            feature_mapper = new FeaturePositionMapper(y_scale),\n            x_draw_coords,\n            incomplete_features = [];\n\n        for (var i = 0, len = data.length; i < len; i++) {\n            var feature = data[i],\n                feature_uid = feature[0],\n                feature_start = feature[1],\n                feature_end = feature[2],\n                // Slot valid only if features are slotted and this feature is slotted;\n                // feature may not be due to lack of space.\n                slot =\n                    slots && slots[feature_uid] !== undefined\n                        ? slots[feature_uid].slot\n                        : null;\n\n            // Draw feature if (a) mode is dense or feature is slotted (as it must be for all non-dense modes) and\n            // (b) there's overlap between the feature and drawing region.\n            if (\n                (this.mode === \"Dense\" || slot !== null) &&\n                (feature_start < view_end && feature_end > view_start)\n            ) {\n                x_draw_coords = this.draw_element(\n                    ctx,\n                    this.mode,\n                    feature,\n                    slot,\n                    view_start,\n                    view_end,\n                    w_scale,\n                    y_scale,\n                    width\n                );\n                feature_mapper.map_feature_data(\n                    feature,\n                    slot,\n                    x_draw_coords[0],\n                    x_draw_coords[1]\n                );\n\n                // Add to incomplete features if it's not drawn completely in region.\n                if (feature_start < view_start || feature_end > view_end) {\n                    incomplete_features.push(feature);\n                }\n            }\n        }\n\n        ctx.restore();\n\n        feature_mapper.y_translation = this.get_top_padding(width);\n        return new DrawResults({\n            incomplete_features: incomplete_features,\n            feature_mapper: feature_mapper\n        });\n    },\n\n    /**\n     * Abstract function for drawing an individual feature.\n     */\n    draw_element: function(\n        ctx,\n        mode,\n        feature,\n        slot,\n        tile_low,\n        tile_high,\n        w_scale,\n        y_scale,\n        width\n    ) {\n        return [0, 0];\n    }\n});\n\n// Constants specific to feature tracks moved here (HACKING, these should\n// basically all be configuration options)\nvar DENSE_TRACK_HEIGHT = 10,\n    NO_DETAIL_TRACK_HEIGHT = 3,\n    SQUISH_TRACK_HEIGHT = 5,\n    PACK_TRACK_HEIGHT = 10,\n    NO_DETAIL_FEATURE_HEIGHT = 1,\n    DENSE_FEATURE_HEIGHT = 9,\n    SQUISH_FEATURE_HEIGHT = 3,\n    PACK_FEATURE_HEIGHT = 9,\n    LABEL_SPACING = 2,\n    CONNECTOR_COLOR = \"#ccc\";\n\nvar LinkedFeaturePainter = function(\n    data,\n    view_start,\n    view_end,\n    prefs,\n    mode,\n    alpha_scaler,\n    height_scaler\n) {\n    FeaturePainter.call(\n        this,\n        data,\n        view_start,\n        view_end,\n        prefs,\n        mode,\n        alpha_scaler,\n        height_scaler\n    );\n    // Whether to draw a single connector in the background that spans the entire feature (the intron fishbone)\n    this.draw_background_connector = true;\n    // Whether to call draw_connector for every pair of blocks\n    this.draw_individual_connectors = false;\n};\n\n_.extend(LinkedFeaturePainter.prototype, FeaturePainter.prototype, {\n    /**\n     * Height of a single row, depends on mode\n     */\n    get_row_height: function() {\n        var mode = this.mode,\n            height;\n        if (mode === \"Dense\") {\n            height = DENSE_TRACK_HEIGHT;\n        } else if (mode === \"no_detail\") {\n            height = NO_DETAIL_TRACK_HEIGHT;\n        } else if (mode === \"Squish\") {\n            height = SQUISH_TRACK_HEIGHT;\n        } else {\n            // mode === \"Pack\"\n            height = PACK_TRACK_HEIGHT;\n        }\n        return height;\n    },\n\n    /**\n     * Draw a feature. Returns an array with feature's start and end X coordinates.\n     */\n    draw_element: function(\n        ctx,\n        mode,\n        feature,\n        slot,\n        tile_low,\n        tile_high,\n        w_scale,\n        y_scale,\n        width\n    ) {\n        var feature_uid = feature[0],\n            feature_start = feature[1],\n            feature_end = feature[2],\n            feature_name = feature[3],\n            feature_strand = feature[4],\n            // -0.5 to offset region between bases.\n            f_start = Math.floor(\n                Math.max(0, (feature_start - tile_low - 0.5) * w_scale)\n            ),\n            f_end = Math.ceil(\n                Math.min(\n                    width,\n                    Math.max(0, (feature_end - tile_low - 0.5) * w_scale)\n                )\n            ),\n            draw_start = f_start,\n            draw_end = f_end,\n            y_start =\n                (mode === \"Dense\" ? 0 : 0 + slot) * y_scale +\n                this.get_top_padding(width),\n            thickness,\n            y_start,\n            thick_start = null,\n            thick_end = null,\n            // TODO: is there any reason why block, label color cannot be set at the Painter level?\n            // For now, assume '.' === '+'\n            block_color =\n                !feature_strand ||\n                feature_strand === \"+\" ||\n                feature_strand === \".\"\n                    ? this.prefs.block_color\n                    : this.prefs.reverse_strand_color,\n            label_color = this.prefs.label_color;\n\n        // Set global alpha.\n        ctx.globalAlpha = this.alpha_scaler.gen_val(feature);\n\n        // In dense mode, put all data in top slot.\n        if (mode === \"Dense\") {\n            slot = 1;\n        }\n\n        if (mode === \"no_detail\") {\n            // No details for feature, so only one way to display.\n            ctx.fillStyle = block_color;\n            ctx.fillRect(\n                f_start,\n                y_start + 5,\n                f_end - f_start,\n                NO_DETAIL_FEATURE_HEIGHT\n            );\n        } else {\n            // Mode is either Squish or Pack:\n            // Feature details.\n            var feature_ts = feature[5],\n                feature_te = feature[6],\n                feature_blocks = feature[7],\n                // Whether we are drawing full height or squished features\n                full_height = true;\n\n            if (feature_ts && feature_te) {\n                thick_start = Math.floor(\n                    Math.max(0, (feature_ts - tile_low) * w_scale)\n                );\n                thick_end = Math.ceil(\n                    Math.min(\n                        width,\n                        Math.max(0, (feature_te - tile_low) * w_scale)\n                    )\n                );\n            }\n\n            // Set vars that depend on mode.\n            var thin_height, thick_height;\n            if (mode === \"Squish\") {\n                thin_height = 1;\n                thick_height = SQUISH_FEATURE_HEIGHT;\n                full_height = false;\n            } else if (mode === \"Dense\") {\n                thin_height = 5;\n                thick_height = DENSE_FEATURE_HEIGHT;\n            } else {\n                // mode === \"Pack\"\n                thin_height = 5;\n                thick_height = PACK_FEATURE_HEIGHT;\n            }\n\n            // Draw feature/feature blocks + connectors.\n            if (!feature_blocks) {\n                // If there are no blocks, treat the feature as one big exon.\n                ctx.fillStyle = block_color;\n                ctx.fillRect(\n                    f_start,\n                    y_start + 1,\n                    f_end - f_start,\n                    thick_height\n                );\n                // If strand is specified, draw arrows over feature\n                if (feature_strand && full_height) {\n                    if (feature_strand === \"+\") {\n                        ctx.fillStyle = ctx.canvas.manager.get_pattern(\n                            \"right_strand_inv\"\n                        );\n                    } else if (feature_strand === \"-\") {\n                        ctx.fillStyle = ctx.canvas.manager.get_pattern(\n                            \"left_strand_inv\"\n                        );\n                    }\n                    ctx.fillRect(\n                        f_start,\n                        y_start + 1,\n                        f_end - f_start,\n                        thick_height\n                    );\n                }\n            } else {\n                //\n                // There are feature blocks and mode is either Squish or Pack.\n                //\n                // Approach: (a) draw whole feature as connector/intron and (b) draw blocks as\n                // needed. This ensures that whole feature, regardless of whether it starts with\n                // a block, is visible.\n                //\n\n                // Compute y axis start position and height\n                var cur_y_start, cur_height;\n                if (mode === \"Squish\" || mode === \"Dense\") {\n                    cur_y_start =\n                        y_start + Math.floor(SQUISH_FEATURE_HEIGHT / 2) + 1;\n                    cur_height = 1;\n                } else {\n                    // mode === \"Pack\"\n                    if (feature_strand) {\n                        cur_y_start = y_start;\n                        cur_height = thick_height;\n                    } else {\n                        cur_y_start += SQUISH_FEATURE_HEIGHT / 2 + 1;\n                        cur_height = 1;\n                    }\n                }\n\n                // Draw whole feature as connector/intron.\n                if (this.draw_background_connector) {\n                    if (mode === \"Squish\" || mode === \"Dense\") {\n                        ctx.fillStyle = CONNECTOR_COLOR;\n                    } else {\n                        // mode === \"Pack\"\n                        if (feature_strand) {\n                            if (feature_strand === \"+\") {\n                                ctx.fillStyle = ctx.canvas.manager.get_pattern(\n                                    \"right_strand\"\n                                );\n                            } else if (feature_strand === \"-\") {\n                                ctx.fillStyle = ctx.canvas.manager.get_pattern(\n                                    \"left_strand\"\n                                );\n                            }\n                        } else {\n                            ctx.fillStyle = CONNECTOR_COLOR;\n                        }\n                    }\n                    ctx.fillRect(\n                        f_start,\n                        cur_y_start,\n                        f_end - f_start,\n                        cur_height\n                    );\n                }\n\n                // Draw blocks.\n                var start_and_height;\n                for (var k = 0, k_len = feature_blocks.length; k < k_len; k++) {\n                    var block = feature_blocks[k],\n                        // -0.5 to offset block between bases.\n                        block_start = Math.floor(\n                            Math.max(0, (block[0] - tile_low - 0.5) * w_scale)\n                        ),\n                        block_end = Math.ceil(\n                            Math.min(\n                                width,\n                                Math.max((block[1] - tile_low - 0.5) * w_scale)\n                            )\n                        ),\n                        last_block_start,\n                        last_block_end;\n\n                    // Skip drawing if block not on tile.\n                    if (block_start > block_end) {\n                        continue;\n                    }\n\n                    // Draw thin block.\n                    ctx.fillStyle = block_color;\n                    ctx.fillRect(\n                        block_start,\n                        y_start + (thick_height - thin_height) / 2 + 1,\n                        block_end - block_start,\n                        thin_height\n                    );\n\n                    // If block intersects with thick region, draw block as thick.\n                    // - No thick is sometimes encoded as thick_start == thick_end, so don't draw in that case\n                    if (\n                        thick_start !== undefined &&\n                        feature_te > feature_ts &&\n                        !(block_start > thick_end || block_end < thick_start)\n                    ) {\n                        var block_thick_start = Math.max(\n                                block_start,\n                                thick_start\n                            ),\n                            block_thick_end = Math.min(block_end, thick_end);\n                        ctx.fillRect(\n                            block_thick_start,\n                            y_start + 1,\n                            block_thick_end - block_thick_start,\n                            thick_height\n                        );\n                        if (feature_blocks.length === 1 && mode === \"Pack\") {\n                            // Exactly one block means we have no introns, but do have a distinct \"thick\" region,\n                            // draw arrows over it if in pack mode.\n                            if (feature_strand === \"+\") {\n                                ctx.fillStyle = ctx.canvas.manager.get_pattern(\n                                    \"right_strand_inv\"\n                                );\n                            } else if (feature_strand === \"-\") {\n                                ctx.fillStyle = ctx.canvas.manager.get_pattern(\n                                    \"left_strand_inv\"\n                                );\n                            }\n                            // If region is wide enough in pixels, pad a bit\n                            if (block_thick_start + 14 < block_thick_end) {\n                                block_thick_start += 2;\n                                block_thick_end -= 2;\n                            }\n                            ctx.fillRect(\n                                block_thick_start,\n                                y_start + 1,\n                                block_thick_end - block_thick_start,\n                                thick_height\n                            );\n                        }\n                    }\n                    // Draw individual connectors if required\n                    if (this.draw_individual_connectors && last_block_start) {\n                        this.draw_connector(\n                            ctx,\n                            last_block_start,\n                            last_block_end,\n                            block_start,\n                            block_end,\n                            y_start\n                        );\n                    }\n                    last_block_start = block_start;\n                    last_block_end = block_end;\n                }\n\n                // FIXME: Height scaling only works in Pack mode right now.\n                if (mode === \"Pack\") {\n                    // Reset alpha so height scaling is not impacted by alpha scaling.\n                    ctx.globalAlpha = 1;\n\n                    // Height scaling: draw white lines to reduce height according to height scale factor.\n                    ctx.fillStyle = \"white\"; // TODO: set this to background color.\n                    var hscale_factor = this.height_scaler.gen_val(feature),\n                        // Ceil ensures that min height is >= 1.\n                        new_height = Math.ceil(thick_height * hscale_factor),\n                        ws_height = Math.round((thick_height - new_height) / 2);\n                    if (hscale_factor !== 1) {\n                        ctx.fillRect(\n                            f_start,\n                            cur_y_start + 1,\n                            f_end - f_start,\n                            ws_height\n                        );\n                        ctx.fillRect(\n                            f_start,\n                            cur_y_start + thick_height - ws_height + 1,\n                            f_end - f_start,\n                            ws_height\n                        );\n                    }\n                }\n            }\n\n            // Reset alpha so that label is not transparent.\n            ctx.globalAlpha = 1;\n\n            // Draw label for Pack mode.\n            if (feature_name && mode === \"Pack\" && feature_start > tile_low) {\n                ctx.fillStyle = label_color;\n                // FIXME: assumption here that the entire view starts at 0\n                if (\n                    tile_low === 0 &&\n                    f_start - ctx.measureText(feature_name).width < 0\n                ) {\n                    ctx.textAlign = \"left\";\n                    ctx.fillText(\n                        feature_name,\n                        f_end + LABEL_SPACING,\n                        y_start + 8,\n                        this.max_label_length\n                    );\n                    draw_end +=\n                        ctx.measureText(feature_name).width + LABEL_SPACING;\n                } else {\n                    ctx.textAlign = \"right\";\n                    ctx.fillText(\n                        feature_name,\n                        f_start - LABEL_SPACING,\n                        y_start + 8,\n                        this.max_label_length\n                    );\n                    draw_start -=\n                        ctx.measureText(feature_name).width + LABEL_SPACING;\n                }\n                //ctx.fillStyle = block_color;\n            }\n        }\n\n        // Reset global alpha.\n        ctx.globalAlpha = 1;\n\n        return [draw_start, draw_end];\n    }\n});\n\nvar ReadPainter = function(\n    data,\n    view_start,\n    view_end,\n    prefs,\n    mode,\n    alpha_scaler,\n    height_scaler,\n    ref_seq,\n    base_color_fn\n) {\n    FeaturePainter.call(\n        this,\n        data,\n        view_start,\n        view_end,\n        prefs,\n        mode,\n        alpha_scaler,\n        height_scaler\n    );\n    this.ref_seq = ref_seq ? ref_seq.data : null;\n    this.base_color_fn = base_color_fn;\n};\n\n_.extend(ReadPainter.prototype, FeaturePainter.prototype, {\n    /**\n     * Returns height based on mode.\n     */\n    get_row_height: function() {\n        var height,\n            mode = this.mode;\n        if (mode === \"Dense\") {\n            height = DENSE_TRACK_HEIGHT;\n        } else if (mode === \"Squish\") {\n            height = SQUISH_TRACK_HEIGHT;\n        } else {\n            // mode === \"Pack\"\n            height = PACK_TRACK_HEIGHT;\n            if (this.prefs.show_insertions) {\n                height *= 2;\n            }\n        }\n        return height;\n    },\n\n    /**\n     * Parse CIGAR string to get (a) a list of contiguous drawing blocks (MD=X) and\n     * (b) an array of [ op_index, op_len ] pairs where op_index is an index into the\n     * string 'MIDNSHP=X' Return value is a dictionary with two entries, blocks and cigar\n     */\n    _parse_cigar: function(cigar_str) {\n        var cigar_ops = \"MIDNSHP=X\";\n\n        // Parse cigar.\n        var blocks = [[0, 0]],\n            cur_block = blocks[0],\n            base_pos = 0,\n            // Parse cigar operations out and update/create blocks as needed.\n            parsed_cigar = _.map(\n                cigar_str.match(/[0-9]+[MIDNSHP=X]/g),\n                function(op) {\n                    // Get operation length, character.\n                    var op_len = parseInt(op.slice(0, -1), 10),\n                        op_char = op.slice(-1);\n\n                    // Update drawing block.\n                    if (op_char === \"N\") {\n                        // At skip, so need to start new block if current block represents\n                        // drawing area.\n                        if (cur_block[1] !== 0) {\n                            cur_block = [base_pos + op_len, base_pos + op_len];\n                            blocks.push(cur_block);\n                        }\n                    } else if (\"ISHP\".indexOf(op_char) === -1) {\n                        // Operation is M,D,=,X.\n                        cur_block[1] += op_len;\n                        base_pos += op_len;\n                    }\n\n                    // Return parsed cigar.\n                    return [cigar_ops.indexOf(op_char), op_len];\n                }\n            );\n\n        return {\n            blocks: blocks,\n            cigar: parsed_cigar\n        };\n    },\n\n    /**\n     * Draw a single read from reference-based read sequence and cigar.\n     */\n    draw_read: function(\n        ctx,\n        mode,\n        w_scale,\n        y_start,\n        tile_low,\n        tile_high,\n        feature_start,\n        cigar,\n        strand,\n        read_seq\n    ) {\n        // Helper function to update base and sequnence offsets.\n        var update_base_offset = function(offset, cig_op, cig_len) {\n                if (\"M=NXD\".indexOf(cig_op) !== -1) {\n                    offset += cig_len;\n                }\n                return offset;\n            },\n            update_seq_offset = function(offset, cig_op, cig_len) {\n                if (\"IX\".indexOf(cig_op) !== -1) {\n                    offset += cig_len;\n                }\n                return offset;\n            },\n            // Gets drawing coordinate for a sequence coordinate. Assumes closure variables w_scale and tile_low.\n            get_draw_coord = function(sequence_coord) {\n                // -0.5 to offset sequence between bases.\n                return Math.floor(\n                    Math.max(0, (sequence_coord - tile_low - 0.5) * w_scale)\n                );\n            };\n\n        ctx.textAlign = \"center\";\n        var tile_region = [tile_low, tile_high],\n            base_offset = 0,\n            seq_offset = 0,\n            gap = Math.round(w_scale / 2),\n            char_width_px = ctx.canvas.manager.char_width_px,\n            block_color =\n                strand === \"+\"\n                    ? this.prefs.detail_block_color\n                    : this.prefs.reverse_strand_color,\n            pack_mode = mode === \"Pack\",\n            draw_height = pack_mode\n                ? PACK_FEATURE_HEIGHT\n                : SQUISH_FEATURE_HEIGHT,\n            rect_y = y_start + 1,\n            paint_utils = new ReadPainterUtils(ctx, draw_height, w_scale, mode),\n            drawing_blocks = [],\n            s_start,\n            s_end;\n\n        // Keep list of items that need to be drawn on top of initial drawing layer.\n        var draw_last = [];\n\n        // Parse cigar and get drawing blocks.\n        var t = this._parse_cigar(cigar);\n        cigar = t.cigar;\n        drawing_blocks = t.blocks;\n\n        // Draw blocks.\n        for (var i = 0; i < drawing_blocks.length; i++) {\n            var block = drawing_blocks[i];\n\n            if (\n                is_overlap(\n                    [feature_start + block[0], feature_start + block[1]],\n                    tile_region\n                )\n            ) {\n                s_start = get_draw_coord(feature_start + block[0]);\n                s_end = get_draw_coord(feature_start + block[1]);\n\n                // Make sure that block is drawn even if it too small to be rendered officially; in this case,\n                // read is drawn at 1px.\n                // TODO: need to ensure that s_start, s_end are calculated the same for both slotting\n                // and drawing.\n                if (s_start === s_end) {\n                    s_end += 1;\n                }\n\n                // Draw read base as rectangle.\n                ctx.fillStyle = block_color;\n                ctx.fillRect(s_start, rect_y, s_end - s_start, draw_height);\n            }\n        }\n\n        // Draw read features.\n        for (var cig_id = 0, len = cigar.length; cig_id < len; cig_id++) {\n            var cig = cigar[cig_id],\n                cig_op = \"MIDNSHP=X\"[cig[0]],\n                cig_len = cig[1];\n\n            var seq_start = feature_start + base_offset;\n            s_start = get_draw_coord(seq_start);\n            s_end = get_draw_coord(seq_start + cig_len);\n\n            // Skip feature if it's not in tile.\n            if (!is_overlap([seq_start, seq_start + cig_len], tile_region)) {\n                // Update offsets.\n                base_offset = update_base_offset(base_offset, cig_op, cig_len);\n                seq_offset = update_seq_offset(seq_offset, cig_op, cig_len);\n                continue;\n            }\n\n            // Make sure that read is drawn even if it too small to be rendered officially; in this case,\n            // read is drawn at 1px.\n            // TODO: need to ensure that s_start, s_end are calculated the same for both slotting\n            // and drawing.\n            if (s_start === s_end) {\n                s_end += 1;\n            }\n\n            // Draw read feature.\n            switch (cig_op) {\n                case \"H\": // Hard clipping.\n                case \"S\": // Soft clipping.\n                case \"P\": // Padding.\n                    // Sequence not present and not related to alignment; do nothing.\n                    break;\n                case \"M\": // \"Match\".\n                    // Because it's not known whether there is a match, ignore.\n                    base_offset += cig_len;\n                    break;\n                case \"=\": // Match with reference.\n                case \"X\": // Mismatch with reference.\n                    //\n                    // Draw sequence and/or variants.\n                    //\n\n                    // Get sequence to draw.\n                    var cur_seq = \"\";\n                    if (cig_op === \"X\") {\n                        // Get sequence from read_seq.\n                        cur_seq = read_seq.slice(\n                            seq_offset,\n                            seq_offset + cig_len\n                        );\n                    } else if (this.ref_seq) {\n                        // && cig_op === '='\n                        // Use reference sequence.\n                        cur_seq = this.ref_seq.slice(\n                            // If read starts after tile start, slice at read start.\n                            Math.max(0, seq_start - tile_low),\n                            // If read ends before tile end, slice at read end.\n                            Math.min(\n                                seq_start - tile_low + cig_len,\n                                tile_high - tile_low\n                            )\n                        );\n                    }\n\n                    // Draw sequence. Because cur_seq starts and read/tile start, go to there to start writing.\n                    var start_pos = Math.max(seq_start, tile_low);\n                    for (var c = 0; c < cur_seq.length; c++) {\n                        // Draw base if showing all (i.e. not showing differences) or there is a mismatch.\n                        if (\n                            (cur_seq && !this.prefs.show_differences) ||\n                            cig_op === \"X\"\n                        ) {\n                            // Draw base.\n                            var c_start = Math.floor(\n                                Math.max(\n                                    0,\n                                    (start_pos + c - tile_low) * w_scale\n                                )\n                            );\n                            ctx.fillStyle = this.base_color_fn(cur_seq[c]);\n                            if (pack_mode && w_scale > char_width_px) {\n                                ctx.fillText(cur_seq[c], c_start, y_start + 9);\n                            } else if (w_scale > 0.05) {\n                                // Require a minimum w_scale so that variants are only drawn when somewhat zoomed in.\n                                ctx.fillRect(\n                                    c_start - gap,\n                                    rect_y,\n                                    Math.max(1, Math.round(w_scale)),\n                                    draw_height\n                                );\n                            }\n                        }\n                    }\n\n                    // Move forward in sequence only if sequence used to get mismatches.\n                    if (cig_op === \"X\") {\n                        seq_offset += cig_len;\n                    }\n                    base_offset += cig_len;\n\n                    break;\n                case \"N\": // Skipped bases.\n                    ctx.fillStyle = CONNECTOR_COLOR;\n                    ctx.fillRect(\n                        s_start,\n                        rect_y + (draw_height - 1) / 2,\n                        s_end - s_start,\n                        1\n                    );\n                    // No change in seq_offset because sequence not used when skipping.\n                    base_offset += cig_len;\n                    break;\n                case \"D\": // Deletion.\n                    paint_utils.draw_deletion(s_start, rect_y, cig_len);\n                    base_offset += cig_len;\n                    break;\n                case \"I\": // Insertion.\n                    // Check to see if sequence should be drawn at all by looking at the overlap between\n                    // the sequence region and the tile region.\n                    var insert_x_coord = s_start - gap;\n\n                    if (\n                        is_overlap(\n                            [seq_start, seq_start + cig_len],\n                            tile_region\n                        )\n                    ) {\n                        var seq = read_seq.slice(\n                            seq_offset,\n                            seq_offset + cig_len\n                        );\n                        // Insertion point is between the sequence start and the previous base: (-gap) moves\n                        // back from sequence start to insertion point.\n                        if (this.prefs.show_insertions) {\n                            //\n                            // Show inserted sequence above, centered on insertion point.\n                            //\n\n                            // Draw sequence.\n                            // X center is offset + start - <half_sequence_length>\n                            var x_center = s_start - (s_end - s_start) / 2;\n                            if (\n                                (mode === \"Pack\" || this.mode === \"Auto\") &&\n                                read_seq !== undefined &&\n                                w_scale > char_width_px\n                            ) {\n                                // Draw sequence container.\n                                ctx.fillStyle = \"yellow\";\n                                ctx.fillRect(\n                                    x_center - gap,\n                                    y_start - 9,\n                                    s_end - s_start,\n                                    9\n                                );\n                                draw_last[draw_last.length] = {\n                                    type: \"triangle\",\n                                    data: [insert_x_coord, y_start + 4, 5]\n                                };\n                                ctx.fillStyle = CONNECTOR_COLOR;\n                                // Based on overlap b/t sequence and tile, get sequence to be drawn.\n                                switch (compute_overlap(\n                                    [seq_start, seq_start + cig_len],\n                                    tile_region\n                                )) {\n                                    case OVERLAP_START:\n                                        seq = seq.slice(tile_low - seq_start);\n                                        break;\n                                    case OVERLAP_END:\n                                        seq = seq.slice(\n                                            0,\n                                            seq_start - tile_high\n                                        );\n                                        break;\n                                    case CONTAINED_BY:\n                                        // All of sequence drawn.\n                                        break;\n                                    case CONTAINS:\n                                        seq = seq.slice(\n                                            tile_low - seq_start,\n                                            seq_start - tile_high\n                                        );\n                                        break;\n                                }\n                                // Draw sequence.\n                                for (\n                                    var c = 0, str_len = seq.length;\n                                    c < str_len;\n                                    c++\n                                ) {\n                                    var c_start = Math.floor(\n                                        Math.max(\n                                            0,\n                                            (seq_start + c - tile_low) * w_scale\n                                        )\n                                    );\n                                    ctx.fillText(\n                                        seq[c],\n                                        c_start - (s_end - s_start) / 2,\n                                        y_start\n                                    );\n                                }\n                            } else {\n                                // Draw block.\n                                ctx.fillStyle = \"yellow\";\n                                // TODO: This is a pretty hack-ish way to fill rectangle based on mode.\n                                ctx.fillRect(\n                                    x_center,\n                                    y_start + (this.mode !== \"Dense\" ? 2 : 5),\n                                    s_end - s_start,\n                                    mode !== \"Dense\"\n                                        ? SQUISH_FEATURE_HEIGHT\n                                        : DENSE_FEATURE_HEIGHT\n                                );\n                            }\n                        } else {\n                            if (\n                                (mode === \"Pack\" || this.mode === \"Auto\") &&\n                                read_seq !== undefined &&\n                                w_scale > char_width_px\n                            ) {\n                                // Show insertions with a single number at the insertion point.\n                                draw_last.push({\n                                    type: \"text\",\n                                    data: [\n                                        seq.length,\n                                        insert_x_coord,\n                                        y_start + 9\n                                    ]\n                                });\n                            } else {\n                                // TODO: probably can merge this case with code above.\n                            }\n                        }\n                    }\n                    seq_offset += cig_len;\n                    // No change to base offset because insertions are drawn above sequence/read.\n                    break;\n            }\n        }\n\n        //\n        // Draw last items.\n        //\n        ctx.fillStyle = \"yellow\";\n        var item, type, data;\n        for (var i = 0; i < draw_last.length; i++) {\n            item = draw_last[i];\n            type = item.type;\n            data = item.data;\n            if (type === \"text\") {\n                ctx.save();\n                ctx.font = \"bold \" + ctx.font;\n                ctx.fillText(data[0], data[1], data[2]);\n                ctx.restore();\n            } else if (type === \"triangle\") {\n                drawDownwardEquilateralTriangle(ctx, data[0], data[1], data[2]);\n            }\n        }\n    },\n\n    /**\n     * Draw a complete read pair\n     */\n    draw_element: function(\n        ctx,\n        mode,\n        feature,\n        slot,\n        tile_low,\n        tile_high,\n        w_scale,\n        y_scale,\n        width\n    ) {\n        // All features need a start, end, and vertical center.\n        var feature_uid = feature[0],\n            feature_start = feature[1],\n            feature_end = feature[2],\n            feature_name = feature[3],\n            // -0.5 to put element between bases.\n            f_start = Math.floor(\n                Math.max(\n                    -0.5 * w_scale,\n                    (feature_start - tile_low - 0.5) * w_scale\n                )\n            ),\n            f_end = Math.ceil(\n                Math.min(\n                    width,\n                    Math.max(0, (feature_end - tile_low - 0.5) * w_scale)\n                )\n            ),\n            y_start = (mode === \"Dense\" ? 0 : 0 + slot) * y_scale,\n            draw_height =\n                mode === \"Pack\" ? PACK_FEATURE_HEIGHT : SQUISH_FEATURE_HEIGHT,\n            label_color = this.prefs.label_color;\n\n        // Draw read.\n        if (feature[5] instanceof Array) {\n            // Read is paired.\n            var connector = true;\n\n            // Draw left/forward read.\n            if (\n                feature[4][1] >= tile_low &&\n                feature[4][0] <= tile_high &&\n                feature[4][2]\n            ) {\n                this.draw_read(\n                    ctx,\n                    mode,\n                    w_scale,\n                    y_start,\n                    tile_low,\n                    tile_high,\n                    feature[4][0],\n                    feature[4][2],\n                    feature[4][3],\n                    feature[4][4]\n                );\n            } else {\n                connector = false;\n            }\n\n            // Draw right/reverse read.\n            if (\n                feature[5][1] >= tile_low &&\n                feature[5][0] <= tile_high &&\n                feature[5][2]\n            ) {\n                this.draw_read(\n                    ctx,\n                    mode,\n                    w_scale,\n                    y_start,\n                    tile_low,\n                    tile_high,\n                    feature[5][0],\n                    feature[5][2],\n                    feature[5][3],\n                    feature[5][4]\n                );\n            } else {\n                connector = false;\n            }\n\n            // Draw connector if both reads were drawn.\n            // TODO: currently, there is no way to connect reads drawn on different tiles; to connect reads on different tiles, data manager\n            // code is needed to join mate pairs from different regions. Alternatively, requesting multiple regions of data at once would\n            // make it possible to put together more easily.\n            // -0.5 to position connector correctly between reads.\n            var b1_end = Math.ceil(\n                    Math.min(\n                        width,\n                        Math.max(\n                            -0.5 * w_scale,\n                            (feature[4][1] - tile_low - 0.5) * w_scale\n                        )\n                    )\n                ),\n                b2_start = Math.floor(\n                    Math.max(\n                        -0.5 * w_scale,\n                        (feature[5][0] - tile_low - 0.5) * w_scale\n                    )\n                );\n            if (connector && b2_start > b1_end) {\n                ctx.fillStyle = CONNECTOR_COLOR;\n                var line_height = y_start + 1 + (draw_height - 1) / 2;\n                dashedLine(ctx, b1_end, line_height, b2_start, line_height);\n            }\n        } else {\n            // Read is single.\n            this.draw_read(\n                ctx,\n                mode,\n                w_scale,\n                y_start,\n                tile_low,\n                tile_high,\n                feature_start,\n                feature[4],\n                feature[5],\n                feature[6]\n            );\n        }\n        if (\n            mode === \"Pack\" &&\n            feature_start >= tile_low &&\n            feature_name !== \".\"\n        ) {\n            // Draw label.\n            ctx.fillStyle = this.prefs.label_color;\n            if (\n                tile_low === 0 &&\n                f_start - ctx.measureText(feature_name).width < 0\n            ) {\n                ctx.textAlign = \"left\";\n                ctx.fillText(\n                    feature_name,\n                    f_end + LABEL_SPACING,\n                    y_start + 9,\n                    this.max_label_length\n                );\n            } else {\n                ctx.textAlign = \"right\";\n                ctx.fillText(\n                    feature_name,\n                    f_start - LABEL_SPACING,\n                    y_start + 9,\n                    this.max_label_length\n                );\n            }\n        }\n\n        // FIXME: provide actual coordinates for drawn read.\n        return [0, 0];\n    }\n});\n\nvar ArcLinkedFeaturePainter = function(\n    data,\n    view_start,\n    view_end,\n    prefs,\n    mode,\n    alpha_scaler,\n    height_scaler\n) {\n    LinkedFeaturePainter.call(\n        this,\n        data,\n        view_start,\n        view_end,\n        prefs,\n        mode,\n        alpha_scaler,\n        height_scaler\n    );\n    // Need to know the longest feature length for adding spacing\n    this.longest_feature_length = this.calculate_longest_feature_length();\n    this.draw_background_connector = false;\n    this.draw_individual_connectors = true;\n};\n\n_.extend(\n    ArcLinkedFeaturePainter.prototype,\n    FeaturePainter.prototype,\n    LinkedFeaturePainter.prototype,\n    {\n        calculate_longest_feature_length: function() {\n            var longest_feature_length = 0;\n            for (var i = 0, len = this.data.length; i < len; i++) {\n                var feature = this.data[i],\n                    feature_start = feature[1],\n                    feature_end = feature[2];\n                longest_feature_length = Math.max(\n                    longest_feature_length,\n                    feature_end - feature_start\n                );\n            }\n            return longest_feature_length;\n        },\n\n        get_top_padding: function(width) {\n            var view_range = this.view_end - this.view_start,\n                w_scale = width / view_range;\n            return Math.min(\n                128,\n                Math.ceil(this.longest_feature_length / 2 * w_scale)\n            );\n        },\n\n        draw_connector: function(\n            ctx,\n            block1_start,\n            block1_end,\n            block2_start,\n            block2_end,\n            y_start\n        ) {\n            // Arc drawing -- from closest endpoints\n            var x_center = (block1_end + block2_start) / 2,\n                radius = block2_start - x_center;\n            // For full half circles\n            var angle1 = Math.PI,\n                angle2 = 0;\n            if (radius > 0) {\n                ctx.beginPath();\n                ctx.arc(x_center, y_start, block2_start - x_center, Math.PI, 0);\n                ctx.stroke();\n            }\n        }\n    }\n);\n\n// Color stuff from less.js\n\nvar Color = function(rgb, a) {\n    /**\n     * The end goal here, is to parse the arguments\n     * into an integer triplet, such as `128, 255, 0`\n     *\n     * This facilitates operations and conversions.\n     */\n    if (Array.isArray(rgb)) {\n        this.rgb = rgb;\n    } else if (rgb.length == 6) {\n        this.rgb = rgb.match(/.{2}/g).map(function(c) {\n            return parseInt(c, 16);\n        });\n    } else if (rgb.length == 7) {\n        this.rgb = rgb\n            .substring(1, 7)\n            .match(/.{2}/g)\n            .map(function(c) {\n                return parseInt(c, 16);\n            });\n    } else {\n        this.rgb = rgb.split(\"\").map(function(c) {\n            return parseInt(c + c, 16);\n        });\n    }\n    this.alpha = typeof a === \"number\" ? a : 1;\n};\nColor.prototype = {\n    eval: function() {\n        return this;\n    },\n\n    //\n    // If we have some transparency, the only way to represent it\n    // is via `rgba`. Otherwise, we use the hex representation,\n    // which has better compatibility with older browsers.\n    // Values are capped between `0` and `255`, rounded and zero-padded.\n    //\n    toCSS: function() {\n        if (this.alpha < 1.0) {\n            return (\n                \"rgba(\" +\n                this.rgb\n                    .map(function(c) {\n                        return Math.round(c);\n                    })\n                    .concat(this.alpha)\n                    .join(\", \") +\n                \")\"\n            );\n        } else {\n            return (\n                \"#\" +\n                this.rgb\n                    .map(function(i) {\n                        i = Math.round(i);\n                        i = (i > 255 ? 255 : i < 0 ? 0 : i).toString(16);\n                        return i.length === 1 ? \"0\" + i : i;\n                    })\n                    .join(\"\")\n            );\n        }\n    },\n\n    toHSL: function() {\n        var r = this.rgb[0] / 255,\n            g = this.rgb[1] / 255,\n            b = this.rgb[2] / 255,\n            a = this.alpha;\n\n        var max = Math.max(r, g, b),\n            min = Math.min(r, g, b);\n        var h,\n            s,\n            l = (max + min) / 2,\n            d = max - min;\n\n        if (max === min) {\n            h = s = 0;\n        } else {\n            s = l > 0.5 ? d / (2 - max - min) : d / (max + min);\n\n            switch (max) {\n                case r:\n                    h = (g - b) / d + (g < b ? 6 : 0);\n                    break;\n                case g:\n                    h = (b - r) / d + 2;\n                    break;\n                case b:\n                    h = (r - g) / d + 4;\n                    break;\n            }\n            h /= 6;\n        }\n        return { h: h * 360, s: s, l: l, a: a };\n    },\n\n    toARGB: function() {\n        var argb = [Math.round(this.alpha * 255)].concat(this.rgb);\n        return (\n            \"#\" +\n            argb\n                .map(function(i) {\n                    i = Math.round(i);\n                    i = (i > 255 ? 255 : i < 0 ? 0 : i).toString(16);\n                    return i.length === 1 ? \"0\" + i : i;\n                })\n                .join(\"\")\n        );\n    },\n\n    mix: function(color2, weight) {\n        var color1 = this;\n\n        var p = weight; // .value / 100.0;\n        var w = p * 2 - 1;\n        var a = color1.toHSL().a - color2.toHSL().a;\n\n        var w1 = ((w * a == -1 ? w : (w + a) / (1 + w * a)) + 1) / 2.0;\n        var w2 = 1 - w1;\n\n        var rgb = [\n            color1.rgb[0] * w1 + color2.rgb[0] * w2,\n            color1.rgb[1] * w1 + color2.rgb[1] * w2,\n            color1.rgb[2] * w1 + color2.rgb[2] * w2\n        ];\n\n        var alpha = color1.alpha * p + color2.alpha * (1 - p);\n\n        return new Color(rgb, alpha);\n    }\n};\n\n// End colors from less.js\n\nvar LinearRamp = function(start_color, end_color, start_value, end_value) {\n    /**\n     * Simple linear gradient\n     */\n    this.start_color = new Color(start_color);\n    this.end_color = new Color(end_color);\n    this.start_value = start_value;\n    this.end_value = end_value;\n    this.value_range = end_value - start_value;\n};\n\nLinearRamp.prototype.map_value = function(value) {\n    value = Math.max(value, this.start_value);\n    value = Math.min(value, this.end_value);\n    value = (value - this.start_value) / this.value_range;\n    // HACK: just red for now\n    // return \"hsl(0,100%,\" + (value * 100) + \"%)\"\n    return this.start_color.mix(this.end_color, 1 - value).toCSS();\n};\n\nvar SplitRamp = function(\n    start_color,\n    middle_color,\n    end_color,\n    start_value,\n    end_value\n) {\n    /**\n     * Two gradients split away from 0\n     */\n    this.positive_ramp = new LinearRamp(middle_color, end_color, 0, end_value);\n    this.negative_ramp = new LinearRamp(\n        middle_color,\n        start_color,\n        0,\n        -start_value\n    );\n    this.start_value = start_value;\n    this.end_value = end_value;\n};\n\nSplitRamp.prototype.map_value = function(value) {\n    value = Math.max(value, this.start_value);\n    value = Math.min(value, this.end_value);\n    if (value >= 0) {\n        return this.positive_ramp.map_value(value);\n    } else {\n        return this.negative_ramp.map_value(-value);\n    }\n};\n\nvar DiagonalHeatmapPainter = function(data, view_start, view_end, prefs, mode) {\n    Painter.call(this, data, view_start, view_end, prefs, mode);\n    var i, len;\n\n    if (this.prefs.min_value === undefined) {\n        var min_value = Infinity;\n        for (i = 0, len = this.data.length; i < len; i++) {\n            min_value = Math.min(min_value, this.data[i][6]);\n        }\n        this.prefs.min_value = min_value;\n    }\n    if (this.prefs.max_value === undefined) {\n        var max_value = -Infinity;\n        for (i = 0, len = this.data.length; i < len; i++) {\n            max_value = Math.max(max_value, this.data[i][6]);\n        }\n        this.prefs.max_value = max_value;\n    }\n};\n\nDiagonalHeatmapPainter.prototype.default_prefs = {\n    min_value: undefined,\n    max_value: undefined,\n    mode: \"Heatmap\",\n    pos_color: \"#FF8C00\",\n    neg_color: \"#4169E1\"\n};\n\nDiagonalHeatmapPainter.prototype.draw = function(ctx, width, height, w_scale) {\n    var min_value = this.prefs.min_value,\n        max_value = this.prefs.max_value,\n        value_range = max_value - min_value,\n        height_px = height,\n        view_start = this.view_start,\n        mode = this.mode,\n        data = this.data,\n        invsqrt2 = 1 / Math.sqrt(2);\n\n    var ramp = new SplitRamp(\n        this.prefs.neg_color,\n        \"#FFFFFF\",\n        this.prefs.pos_color,\n        min_value,\n        max_value\n    );\n\n    var d, s1, e1, s2, e2, value;\n\n    var scale = function(p) {\n        return (p - view_start) * w_scale;\n    };\n\n    ctx.save();\n\n    // Draw into triangle, then rotate and scale\n    ctx.rotate(-45 * Math.PI / 180);\n    ctx.scale(invsqrt2, invsqrt2);\n\n    // Paint track.\n    for (var i = 0, len = data.length; i < len; i++) {\n        d = data[i];\n\n        s1 = scale(d[1]);\n        e1 = scale(d[2]);\n        s2 = scale(d[4]);\n        e2 = scale(d[5]);\n        value = d[6];\n\n        ctx.fillStyle = ramp.map_value(value);\n        ctx.fillRect(s1, s2, e1 - s1, e2 - s2);\n    }\n\n    ctx.restore();\n};\n\n/**\n * Utilities for painting reads.\n */\nvar ReadPainterUtils = function(ctx, row_height, px_per_base, mode) {\n    this.ctx = ctx;\n    this.row_height = row_height;\n    this.px_per_base = px_per_base;\n    this.draw_details =\n        (mode === \"Pack\" || mode === \"Auto\") &&\n        px_per_base >= ctx.canvas.manager.char_width_px;\n    this.delete_details_thickness = 0.2;\n};\n\n_.extend(ReadPainterUtils.prototype, {\n    /**\n     * Draw deletion of base(s).\n     * @param draw_detail if true, drawing in detail and deletion is drawn more subtly\n     */\n    draw_deletion: function(x, y, len) {\n        this.ctx.fillStyle = \"black\";\n        var thickness =\n            (this.draw_details ? this.delete_details_thickness : 1) *\n            this.row_height;\n        y += 0.5 * (this.row_height - thickness);\n        this.ctx.fillRect(x, y, len * this.px_per_base, thickness);\n    }\n});\n\n/**\n * Paints variant data onto canvas.\n */\nvar VariantPainter = function(\n    data,\n    view_start,\n    view_end,\n    prefs,\n    mode,\n    base_color_fn\n) {\n    Painter.call(this, data, view_start, view_end, prefs, mode);\n    this.base_color_fn = base_color_fn;\n    this.divider_height = 1;\n};\n\n_.extend(VariantPainter.prototype, Painter.prototype, {\n    /**\n     * Height of a single row, depends on mode\n     */\n    get_row_height: function() {\n        var mode = this.mode,\n            height;\n        if (mode === \"Dense\") {\n            height = DENSE_TRACK_HEIGHT;\n        } else if (mode === \"Squish\") {\n            height = SQUISH_TRACK_HEIGHT;\n        } else {\n            // mode === \"Pack\"\n            height = PACK_TRACK_HEIGHT;\n        }\n        return height;\n    },\n\n    /**\n     * Returns required height to draw a particular number of samples in a given mode.\n     */\n    get_required_height: function(num_samples) {\n        // FIXME: for single-sample data, height should be summary_height when zoomed out and\n        // row_height when zoomed in.\n        var height = this.prefs.summary_height;\n\n        // If showing sample data, height is summary + divider + samples.\n        if (num_samples > 1 && this.prefs.show_sample_data) {\n            height += this.divider_height + num_samples * this.get_row_height();\n        }\n        return height;\n    },\n\n    /**\n     * Draw on the context using a rectangle of width x height with scale w_scale.\n     */\n    draw: function(ctx, width, height, w_scale) {\n        ctx.save();\n\n        var /**\n         * Returns dictionary of information about an indel; returns empty if there no indel. Assumes indel is left-aligned.\n         * Dict attributes:\n         *    -type: 'insertion' or 'deletion'\n         *    -start: where the deletion starts relative to reference start\n         *    -len: how long the deletion is\n         */\n        get_indel_info = function(ref, alt) {\n            var ref_len = ref.length,\n                alt_len = alt.length,\n                start = 0,\n                len = 1,\n                type = null;\n            if (alt === \"-\") {\n                type = \"deletion\";\n                len = ref.length;\n            } else if (ref.indexOf(alt) === 0 && ref_len > alt_len) {\n                type = \"deletion\";\n                len = ref_len - alt_len;\n                start = alt_len;\n            } else if (alt.indexOf(ref) === 0 && ref_len < alt_len) {\n                // Insertion.\n                type = \"insertion\";\n                len = alt_len - ref_len;\n                start = alt_len;\n            }\n\n            return type !== null ? { type: type, start: start, len: len } : {};\n        };\n\n        // Draw.\n        var locus_data,\n            pos,\n            id,\n            ref,\n            alt,\n            qual,\n            filter,\n            sample_gts,\n            allele_counts,\n            variant,\n            draw_x_start,\n            draw_y_start,\n            genotype,\n            // Always draw variants at least 1 pixel wide.\n            base_px = Math.max(1, Math.floor(w_scale)),\n            // Determine number of samples.\n            num_samples = this.data.length\n                ? this.data[0][7].split(\",\").length\n                : 0,\n            row_height =\n                this.mode === \"Squish\"\n                    ? SQUISH_TRACK_HEIGHT\n                    : PACK_TRACK_HEIGHT,\n            // If zoomed out, fill the whole row with feature to make it easier to read;\n            // when zoomed in, use feature height so that there are gaps in sample rows.\n            feature_height =\n                w_scale < 0.1\n                    ? row_height\n                    : this.mode === \"Squish\"\n                      ? SQUISH_FEATURE_HEIGHT\n                      : PACK_FEATURE_HEIGHT,\n            draw_summary = true,\n            paint_utils = new ReadPainterUtils(\n                ctx,\n                row_height,\n                w_scale,\n                this.mode\n            ),\n            j;\n\n        // If there's a single sample, update drawing variables.\n        if (num_samples === 1) {\n            row_height = feature_height =\n                w_scale < ctx.canvas.manager.char_width_px\n                    ? this.prefs.summary_height\n                    : row_height;\n            paint_utils.row_height = row_height;\n            // No summary when there's a single sample.\n            draw_summary = false;\n        }\n\n        // Draw divider between summary and samples.\n        if (this.prefs.show_sample_data && draw_summary) {\n            ctx.fillStyle = \"#F3F3F3\";\n            ctx.globalAlpha = 1;\n            ctx.fillRect(\n                0,\n                this.prefs.summary_height - this.divider_height,\n                width,\n                this.divider_height\n            );\n        }\n\n        // Draw variants.\n        ctx.textAlign = \"center\";\n        for (var i = 0; i < this.data.length; i++) {\n            // Get locus data.\n            locus_data = this.data[i];\n            pos = locus_data[1];\n            ref = locus_data[3];\n            alt = [locus_data[4].split(\",\")];\n            sample_gts = locus_data[7].split(\",\");\n            allele_counts = locus_data.slice(8);\n\n            // Process alterate values to derive information about each alt.\n            alt = _.map(_.flatten(alt), function(a) {\n                var alt_info = {\n                        type: \"snp\",\n                        value: a,\n                        start: 0\n                    },\n                    indel_info = get_indel_info(ref, a);\n\n                return _.extend(alt_info, indel_info);\n            });\n\n            // Only draw locus data if it's in viewing region.\n            if (pos < this.view_start || pos > this.view_end) {\n                continue;\n            }\n\n            // Draw summary for alleles.\n            if (draw_summary) {\n                ctx.fillStyle = \"#999999\";\n                ctx.globalAlpha = 1;\n                for (j = 0; j < alt.length; j++) {\n                    // Draw background for summary.\n                    draw_x_start = this.get_start_draw_pos(\n                        pos + alt[j].start,\n                        w_scale\n                    );\n                    ctx.fillRect(\n                        draw_x_start,\n                        0,\n                        base_px,\n                        this.prefs.summary_height\n                    );\n                    draw_y_start = this.prefs.summary_height;\n                    // Draw allele fractions onto summary.\n                    for (j = 0; j < alt.length; j++) {\n                        ctx.fillStyle =\n                            alt[j].type === \"deletion\"\n                                ? \"black\"\n                                : this.base_color_fn(alt[j].value);\n                        var allele_frac = allele_counts / sample_gts.length;\n                        var draw_height = Math.ceil(\n                            this.prefs.summary_height * allele_frac\n                        );\n                        ctx.fillRect(\n                            draw_x_start,\n                            draw_y_start - draw_height,\n                            base_px,\n                            draw_height\n                        );\n                        draw_y_start -= draw_height;\n                    }\n                }\n            }\n\n            // Done drawing if not showing samples data.\n            if (!this.prefs.show_sample_data) {\n                continue;\n            }\n\n            // Draw sample genotype(s).\n            draw_y_start = draw_summary\n                ? this.prefs.summary_height + this.divider_height\n                : 0;\n            for (\n                j = 0;\n                j < sample_gts.length;\n                j++, draw_y_start += row_height\n            ) {\n                genotype = sample_gts[j]\n                    ? sample_gts[j].split(/\\/|\\|/)\n                    : [\"0\", \"0\"];\n\n                // Get variant to draw and set drawing properties.\n                variant = null;\n                if (genotype[0] === genotype[1]) {\n                    if (genotype[0] === \".\") {\n                        // TODO: draw uncalled variant.\n                    } else if (genotype[0] !== \"0\") {\n                        // Homozygous for variant.\n                        variant = alt[parseInt(genotype[0], 10) - 1];\n                        ctx.globalAlpha = 1;\n                    }\n                    // else reference\n                } else {\n                    // Heterozygous for variant.\n                    variant = genotype[0] !== \"0\" ? genotype[0] : genotype[1];\n                    variant = alt[parseInt(variant, 10) - 1];\n                    ctx.globalAlpha = 0.5;\n                }\n\n                // If there's a variant, draw it.\n                if (variant) {\n                    draw_x_start = this.get_start_draw_pos(\n                        pos + variant.start,\n                        w_scale\n                    );\n                    if (variant.type === \"snp\") {\n                        var snp = variant.value;\n                        ctx.fillStyle = this.base_color_fn(snp);\n                        if (paint_utils.draw_details) {\n                            ctx.fillText(\n                                snp,\n                                this.get_draw_pos(pos, w_scale),\n                                draw_y_start + row_height\n                            );\n                        } else {\n                            ctx.fillRect(\n                                draw_x_start,\n                                draw_y_start + 1,\n                                base_px,\n                                feature_height\n                            );\n                        }\n                    } else if (variant.type === \"deletion\") {\n                        paint_utils.draw_deletion(\n                            draw_x_start,\n                            draw_y_start + 1,\n                            variant.len\n                        );\n                    } else {\n                        // TODO: handle insertions.\n                    }\n                }\n            }\n        }\n\n        ctx.restore();\n    }\n});\n\nexport default {\n    Scaler: Scaler,\n    LinePainter: LinePainter,\n    LinkedFeaturePainter: LinkedFeaturePainter,\n    ReadPainter: ReadPainter,\n    ArcLinkedFeaturePainter: ArcLinkedFeaturePainter,\n    DiagonalHeatmapPainter: DiagonalHeatmapPainter,\n    VariantPainter: VariantPainter\n};\n"]}