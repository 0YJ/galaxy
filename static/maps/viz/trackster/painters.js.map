{"version":3,"sources":["viz/trackster/painters.js"],"names":["_","compute_overlap","first_region","second_region","first_start","first_end","second_start","second_end","BEFORE","overlap","OVERLAP_START","dashedLine","dashLen","q","dX","x2","x1","dY","y2","y1","dashes","Math","floor","sqrt","dashX","dashY","ctx","fillRect","drawDownwardEquilateralTriangle","down_vertex_x","down_vertex_y","side_len","y","beginPath","moveTo","lineTo","strokeStyle","this","fillStyle","fill","stroke","closePath","Scaler","default_val","DrawResults","options","incomplete_features","feature_mapper","Painter","data","view_start","view_end","prefs","mode","prototype","extend","default_prefs","draw","width","height","w_scale","get_start_draw_pos","chrom_pos","_chrom_pos_to_draw_pos","get_end_draw_pos","offset","LinePainter","call","min_value","undefined","max_value","color","vertical_range","overflow_color","height_px","x_scaled","delta_x_pxs","length","round","ceil","i","delta_x_px","block_color","pref_color","painter_color","slice","pref_g","pref_b","top_overflow","parseInt","y_zero","bot_overflow","pref_r","saturation","new_g","new_b","new_r","in_path","overflow_x","restore","slot_height","feature_positions","translation","y_translation","FeaturePositionMapper","map_feature_data","feature_data","slot","x_start","x_end","push","get_feature_data","x","feature_dict","FeaturePainter","alpha_scaler","height_scaler","max_label_length","connector_color","get_required_height","required_height","rows_required","get_row_height","y_scale","get_top_padding","slots","textAlign","x_draw_coords","feature_uid","feature","len","feature_start","feature_end","draw_element","SQUISH_FEATURE_HEIGHT","PACK_TRACK_HEIGHT","DENSE_FEATURE_HEIGHT","PACK_FEATURE_HEIGHT","LABEL_SPACING","tile_low","tile_high","LinkedFeaturePainter","f_start","draw_background_connector","feature_strand","thick_start","thick_end","thin_height","thick_height","full_height","feature_name","f_end","min","max","draw_start","draw_end","y_start","canvas","reverse_strand_color","label_color","cur_y_start","cur_height","feature_ts","feature_blocks","feature_te","start_and_height","k","k_len","block_start","ws_height","fillText","measureText","manager","get_pattern","ReadPainter","ref_seq","base_color_fn","last_block_start","last_block_end","block","DENSE_TRACK_HEIGHT","block_end","op_len","blocks","cur_block","base_pos","op_char","block_thick_start","block_thick_end","update_base_offset","cig_len","draw_individual_connectors","draw_connector","get_draw_coord","tile_region","base_offset","globalAlpha","draw_height","pack_mode","hscale_factor","gen_val","drawing_blocks","new_height","_parse_cigar","s_start","s_end","cig_id","cig","cigar","is_overlap","seq_start","seq_offset","cur_seq","start_pos","show_insertions","cigar_str","parsed_cigar","map","match","op","paint_utils","draw_deletion","insert_x_coord","indexOf","read_seq","seq","strand","sequence_coord","draw_last","type","char_width_px","detail_block_color","item","t","Array","draw_read","cig_op","connector","ArcLinkedFeaturePainter","calculate_longest_feature_length","longest_feature_length","c","view_range","c_start","block1_end","block2_start","gap","isArray","rgb","rect_y","alpha","concat","join","x_center","d","s","weight","str_len","color2","w","w1","LinearRamp","start_color","map_value","start_value","end_value","end_color","update_seq_offset","DiagonalHeatmapPainter","pos_color","neg_color","ramp","SplitRamp","e1","s2","value","save","PI","e2","ReadPainterUtils","px_per_base","thickness","b1_end","b2_start","line_height","num_samples","get_indel_info","alt_len","start","alt","ref","locus_data","base_px","feature_height","row_height","draw_summary","show_sample_data","pos","allele_counts","block1_start","radius","arc","draw_y_start","substring","split","genotype","a","Color","eval","variant","toCSS","draw_x_start","snp","toString","toHSL","VariantPainter","l","h","r","g","b","toARGB","mix","color1","p","w2","value_range","middle_color","positive_ramp","negative_ramp","Infinity","s1","invsqrt2","scale","rotate","draw_details","delete_details_thickness","divider_height","summary_height","sample_gts","j","ref_len","flatten","alt_info","indel_info","allele_frac","get_draw_pos"],"mappings":"8IAAYA,6JAeRC,EAAkB,SAASC,EAAcC,GACzC,IAAIC,EAAcF,EAAa,GAC3BG,EAAYH,EAAa,GACzBI,EAAeH,EAAc,GAC7BI,EAAaJ,EAAc,GAF/B,OAIIC,EAAcE,EACVD,GAAaC,EAdZ,KAgBMD,GAAaE,EAbZ,KADL,KAFXC,EAAJD,EAMY,KAJGF,GAAfE,EAGmB,KADD,MAWNE,EAAAA,SAAUD,EAAVL,GACH,IAAAM,EAFDR,EAEWI,EAAyBF,GAChCM,OAjBC,OAiBDA,GAXA,OAWUC,GASbC,EAFD,SAEWN,EAAAA,EAAAA,EAAaE,EAAAA,EAAjBK,QACHH,IAAAA,IACHG,EAFM,GAIN,IA6BDC,EA7BCC,EAAAC,EAAAC,EACJC,EAAAC,EAAAC,EAyBGC,EAASC,KAAKC,MAAMD,KAAKE,KAAKT,EAAKA,EAAKG,EAAKA,GAAML,GAvBvDY,EAAOf,EAAAA,EA1BXgB,EAAAR,EAAAG,EAsDI,IAAKP,EAAI,EAAGA,EAAIO,EAAQP,IAAKG,GAAMQ,EAAOL,GAAMM,EACxCZ,EAAI,GAAM,GArBlBa,EAAAC,SAAOlB,EAAAA,EAAYD,EAAUC,IA+B7BmB,EAAkC,SAClCF,EAvBJG,EACIC,EACIlB,GAGJ,IAAAI,EAAIC,EAAJc,EAAA,EAEAhB,EAAIS,EAAaJ,EAAjB,EACAY,EAAIP,EAAaL,KAAjBG,KAAA,EAAAQ,EAAA,GAGAL,EAAAO,YACIP,EAAAQ,OAAAlB,EAAIH,GACAa,EAAAS,OAAApB,EAAAiB,GACHN,EAAAS,OAAAN,EAAAC,GACDJ,EAAAA,OAAAA,EAAIC,GAEXD,EAjBDU,YAAAC,KAAAC,UA0CIZ,EAAIa,OAvBRb,EAAAc,SAyBId,EAAIe,aAbJC,EAAI3B,SAAKc,GACTQ,KAAAM,YAAQb,GAA0BC,GAMlCL,EAAAA,UAAIS,QAAON,SAAeC,GAC1BJ,OAAAA,KAAIS,aAMP,IAAAS,EAvBD,SAAAC,GA2CIR,KAAKS,oBAAsBD,EAAQC,oBAlBvCT,KAAAU,eAAAF,EAAAE,gBA2BIC,EAAU,SAASC,EAAMC,EAAYC,EAAUC,EAAOC,GAjB1DX,KAAAA,KAAOY,EAENjB,KAFDa,WAAAA,EAsBIb,KAAKc,SAAWA,EAEhBd,KAAKe,MAAQpD,EAAEuD,UAAWlB,KAAKmB,cAAeJ,GAC9Cf,KAAKgB,KAAOA,GAhBZL,EAAAM,UAAKP,iBAwBTC,EAAQM,UAAUG,KAAO,SAAS/B,EAAKgC,EAAOC,EAAQC,KAdlDZ,EAAAM,UAAAO,mBAAA,SAAAC,EAAAF,GACA,OAAAvB,KAAA0B,uBAAAD,EAAAF,GAAA,KAMHZ,EATDM,UAAAU,iBAAA,SAAAF,EAAAF,GA6BI,OAAOvB,KAAK0B,uBAAuBD,EAAWF,EAAS,KAb3DZ,EAAAA,UAAQM,aAAiB,SAAAQ,EAAqBH,GAoB1C,OAAOtB,KAAK0B,uBAAuBD,EAAWF,EAAS,IAb1DZ,EAFDM,UAAAS,uBAAA,SAsBID,EAlBJF,EAoBIK,GAjBJjB,OAAAA,KAAQM,MACJM,GAAOvC,KAAK0C,IAAAA,EAAAA,EAAuBD,KAAAA,YAA5BG,KAuBX,IAAIC,EAAc,SAASjB,EAAMC,EAAYC,EAAUC,EAAOC,GAC1DL,EAAQmB,KAAK9B,KAAMY,EAAMC,EAAYC,EAAUC,EAAOC,IAhBzDa,EAFDZ,UAAAE,eAsBIY,eAAWC,EAlBfC,eAAAD,EAoBIhB,KAAM,YACNkB,MAAO,OAlBXvB,eAAQM,QAsBRY,EAAYZ,UAAUG,KAAO,SAAS/B,EAAKgC,EAAOC,EAAQC,GAZ1D,IAAIM,GAAAA,EACAlB,EAAAX,KAAAe,MAAAgB,UADJE,EAAAjC,KAAAe,MAAAkB,UAgBQE,EAAiBF,EAAYF,EAZrCF,EAAYZ,EACRc,EAAWC,KAAAA,WACXC,EAAAA,KAAWD,KACXhB,EAAMhB,KAAAY,KAENwB,EAAAA,OAGJP,IAAAA,EAAYZ,KAAAA,MAAUG,EAAOW,EAAcV,EAAeE,GAGlDU,cAAJjB,IACA3B,EAAI8C,UAAAA,OACJ9C,EAAIgD,SAAAA,EAAYf,EAAhBD,EAAA,IAGAhC,EAAAO,YAcA,IAAI0C,EAZJjD,EAcIkD,EAXJA,EADA3B,EAAA4B,OAAA,EACaxD,EAAAA,IAAKyD,EAAMnB,MAAAA,GAASS,GAAAA,SAAYI,EAAAA,GAcrC,OAAOnD,KAAK0D,MAAM9B,EAAK+B,EAAI,GAAG,GAAK/B,EAAK+B,GAAG,IAAMpB,MAVjDtB,IAiBR,IAAA,IADA2C,EAZAvD,EAAAW,KAAAe,MAAA8B,aAAA7C,KAAAe,MAAAmB,MAGAY,EAAIP,SAAJQ,EAAAC,MAAA,GAAA,IAEIT,GAAc,SAAdA,IAAoB,GAChBU,GAAYP,MAAZI,IAAkB,EACrBI,EAFD,IAAAJ,EAGHK,GAAM,EACHZ,GAAAA,EAIAQ,EAAAA,EAAAA,EAAAA,EAAgBP,OAAWK,EAAAA,EAAAA,IAuB3B,GArBJxD,EAAIY,UAAAZ,EAAAU,YAAAgD,EACJD,EAAaM,GAASL,EAclBH,EAAaL,EAAYI,GAX7BL,EAAIW,KAAUH,OAAAA,EAAaH,GAAA,GAAd9B,EAAb,IAAAU,GAiBc,QAhBd5B,EAAIuD,EAAAA,GAAAA,IAgBA,CAKI,GATJZ,EAAAA,GACA3C,GAAA,EAcIA,EAAIoC,GAZRpC,EAAAsC,IACAkB,GAAA,EACIxD,EAAAsC,GAIA,cAAAjB,EAeArB,EAAIX,KAAKyD,MAAM9C,EAAIwC,EAAiBE,GAZxChD,EAAAC,SAAAgD,EAAAe,EAAAT,GAAAjD,QACA,GAAQoC,cAAJpC,EAAe,CACf2D,IAAAA,GAAAA,EAAevB,GAAfI,EAGAgB,EAAAA,KAAAA,MAAeI,GAAf,IAAAA,IAAA,EAAAC,IAEHC,EAAAzE,KAAAyD,MAAAQ,GAAA,IAAAA,IAAA,EAAAO,IAcOE,EAAQ1E,KAAKyD,MAAMS,GAAU,IAAMA,IAAW,EAAIM,IAZ1DnE,EAAAY,UAAA,OAAA0D,EAAA,IAAAF,EAAA,IAAAC,EAAA,IACArE,EAAI2B,SAASsB,EAAA,EAAaM,EAAAP,QAKtB1C,EAAAX,KAAIwE,MAcAnB,GAAa1C,EAAIoC,GAAaI,EAAiBE,GAXnDsB,EAcItE,EAAIS,OAAOwC,EAAU3C,IAXzBiE,GAAIF,EACJ,WAAIzD,GACAX,EAAAA,OAASgD,EAAbD,GACGhD,EAAAS,OAAAwC,EAAA3C,IAeKN,EAAIQ,OAAOyC,EAAU3C,IAArBN,GADHA,EAAAY,UAHDD,KAGOe,MAAAqB,eACH/C,GAAIQ,EAAOyC,CACX,IAAAuB,EACA,cAAA7C,GAAA,cAAAA,EACA6C,EAAAjB,GAGPN,GAAA,EACJuB,EAAA,GAEDV,GACIlD,EAAAA,SAAYqC,EAAWF,EAAAA,EAA3B,GAEIkB,GACAjE,EAAI2B,SAASsB,EAAAD,EAAerB,EAAS6C,EAAa,GAG9CxE,EAAAY,UAAA8C,OA3EZa,GAAA,WAAA5C,GACI4B,EAAAA,OAAJN,EAAAD,GAEIuB,GAAA,EA0EQC,WAAAA,GACHD,IACDvE,EAAAS,OAAIqD,EAAJE,GACIhE,EAAAA,OAAAA,EAAIC,IAERD,EAAAa,QAECb,EAAAc,SAGRd,EAAAyE,WAMGzE,IAAAA,EAAA,SAAA0E,GACH/D,KANDgE,qBAOI3E,KAAAA,YAAA0E,EACH/D,KAAAiE,YAAA,EAYDjE,KAAKkE,cAAgB,GAMzBC,EAAsBlD,UAAUmD,iBAAmB,SAVnDC,EACIC,EACAC,EACAC,GAHJxE,KAAAgE,kBAAAM,KAiBQtE,KAAKgE,kBAAkBM,OAE3BtE,KAAKgE,kBAAkBM,GAAMG,MACzB7D,KAAMyD,EAVdF,QAAAA,EAMIK,MAAKA,KAG6BL,EAAlClD,UAAAyD,iBAAA,SAAAC,EAAAhF,GAYA,IAEIiF,EAFAN,EAAOtF,KAAKC,OAAOU,EAAIK,KAAKkE,eAAiBlE,KAAK+D,aADtD,IAAA/D,KAAAgE,kBAAAM,GACA,OAAIA,KAIJK,GAAA3E,KAAAiE,YACA,IAAA,IAAKtB,EAAA,EAAKqB,EAAAA,KAAAA,kBAAyBM,GAAA9B,OAAAG,IAElC,GADGiC,EAAA5E,KAAAgE,kBAAAM,GAAA3B,GACHgC,GAAAC,EAAAL,SAAAI,GAAAC,EAAAJ,MAOO,OAAOI,EAAahE,MAUhC,IAAIiE,EAAiB,SALrBjE,EAOIC,EACAC,EACAC,EACAC,EALJ8D,EASInE,GAEAA,EAAAmB,KAAKiD,KAAAA,EAAgBA,EAAAA,EAAgBA,EAAhB/D,GACrBhB,KAAA8E,aAAKE,GAAL,IAAA3E,EACHL,KAbD+E,cAAAA,GAAA,IAAA1E,EAYIL,KAAKgF,iBAAmB,KAKxBC,EAAAA,UAAiB9D,eAFoB0B,YAAzC,OAEIoC,gBAAiB,QAKbtH,EAAAuD,OAAA2D,EAAA5D,WACAiE,oBAAIC,SAAkBC,EAAKC,GAE3B,IAAAF,EAAcA,KAAAA,iBAEdG,EAAAH,EACAnE,EAAIA,KAAAA,KAGJ,MADC,cAAAA,GAAA,WAAAA,GAAA,SAAAA,IACDmE,EAAOA,EAAuBI,GAAvBJ,EAAkBnF,KAAKuF,gBAAgBlE,IAMjDkE,gBAjB8B,SAAAlE,GAgB3B,OAAO,GASPD,KAAA,SAAIP,EAAAA,EAAaS,EAAKT,EAAtB2E,GACA,IAAA5E,EAAIE,KAAAA,KADAD,EAAab,KAAKa,WAGtBxB,EAAAW,KAAAc,SAEAzB,EAAAA,OAAAA,EAAIY,UAAYD,KAAKe,MAAM8B,YAG3BxD,EAAAoG,UAAIH,QAOA,IAAA,IALAI,EAAJJ,EAAII,KAAAA,iBACJhF,EAAID,IAAAA,EAAJ6E,GAEA7E,KAEIkC,EAAIgD,EAAAA,EAAAA,EAAcC,OAAAjD,EAAlBkD,EAAAlD,IAAA,CACA,IAAAiD,EAAIE,EAAAA,GACJH,EAAII,EAAcH,GADdE,EAAgBF,EAAQ,GAG5BG,EAAIH,EAAA,GAOJtB,EACAkB,QAAAxD,IAAAwD,EAAAG,GAEKH,EAAKxE,GAASsD,KAGfoB,MAoBIjF,UAAAA,KAAAA,MAAyBmF,OAAzBnF,IACHqF,EAAAhF,GAAAiF,EAAAlF,IAER6E,EAAA1F,KAAAgG,aAtBW3G,EAwBRyE,KAAJ9C,KAtBY4E,EAwBZlF,EACOG,EACHJ,EACAC,EAFJ4E,EArF2BjE,GA2F/BX,EAAA0D,iBAtBgBwB,EACAtB,EAwBhB0B,EAAc,GAWFN,EAAR,KAIRI,EAAAjF,GAAAkF,EAAAjF,IACAL,EAAAgE,KAAAmB,IAQIK,OAHAC,EAAAA,UAEAC,EAAAA,cAAJnG,KAAAuF,gBAAAlE,GACI4E,IAAAA,GACAG,oBAAJ3F,EACI4F,eAAJ3F,KAwBIsF,aAAA,SACA3G,EAtBJ2B,EA1BQ4E,EAmDN1E,EACEoF,EAjDIC,EACAhF,EAmDJ8D,EACIhE,GAEA,OAAIL,EAAAA,MAMH,IAsBDwF,EAAIV,SACJlF,EACAC,EACAC,EA3DJC,EA6DIC,EACAyF,EA3DJ1B,GAEAF,EAAe/C,KAoEX9B,KACAY,EAlEAC,EAoEAC,EAlEAC,EAsEAC,EACA8D,EACAC,GAGA/E,KAAA0G,2BAAI,EAEJ7D,KAAAA,4BACK8D,GAnEbhJ,EAAEuD,OAAOsF,EAAqBvF,UAAW4D,EAAe5D,WA4EhDoE,eAAA,WACA,IAAArE,EAAIA,KAAAA,KA5DJ,MA8DC,UAAAA,EAlEM,GAoEM,cAATA,EAlESkF,EAoELjG,WAAJZ,EAnEH,EACMiC,IAMX0E,aAAc,SA8EN3G,EACIuH,EAGAC,EAMHvC,EAnFLgC,EAqFIC,EACAhF,EAnFJ+D,EAqFIjE,GAEIyF,EAAc,GAAdA,IACAC,EAAAA,EAAed,GACfe,EAAAA,EAAc,GACjBC,EAAUjG,EAAAA,GACP8F,EAAAA,EAAA,GAGAL,EAAAzH,KAAAC,MACA6H,KAAAA,IAAAA,GAAAA,EAAAR,EAAA,IAAA/E,IAjFJ2F,EAAQlI,KAAK0D,KAqFb1D,KAAAmI,IACA9F,EACIrC,KAAAoI,IAAA,GAAArB,EAAAO,EAAA,IAAA/E,KASA8F,EAAIV,EACAW,EAAAJ,EAICK,GACGlI,UAAAA,EAAIY,EAAAA,EAAAA,GAAgBuH,EAGvBxH,KAAAuF,gBAAAlE,GASLuF,EAAA,KACAC,EAAA,KAIAhE,EACA8D,GAAA,MAAAA,GAAA,MAAAA,EAEA3G,KAAAe,MAAA0G,qBAnGEzH,KAAKe,MAAM8B,YAGjB6E,EAAc1H,KAAKe,MAAM2G,YA6GhB,GARDC,EAAAA,YAAAA,KAAAA,aACIJ,QAAUvI,GAGd,UAAAgC,IACAsD,EAAA,GAGC,cAAAtD,EAEG4G,EAAAA,UAAAA,EACHvI,EAAAC,SACJmH,EAlGDc,EAAU,EAoGVL,EAAAT,EA1LmD,OA6L3CpH,CAGA,IAAAwI,EAAAjC,EAAIe,GAEItH,EAAAA,EAAAA,GAGHyI,EAJDlC,EAIO,GAKVoB,GAAA,EAEAa,GAAAE,IACJnB,EAAA5H,KAAAC,MACDI,KAAAA,IAAIC,GAAAA,EAEAqI,GAFJpG,IArGJsF,EAAY7H,KAAK0D,KA6GjB1D,KAAAmI,IACIa,EACJhJ,KAASiJ,IAAI,GAAGC,EAAQJ,GAAetF,MAQnC,IAAAsE,EAOAC,EAwBI,GAvBJ,WAAA/F,GAlHJ8F,EAAc,EAoHVC,EAtNhB,EAuNgBC,GAAImB,IAEHrB,EAAA,EAlHLC,EA1JW,GA8RHe,EAjGL,CA8JC,IAAAH,EAlJAC,EAqJIQ,WAAJpH,GAAgB,UAAAhC,GAChB2I,EACItI,EAAIC,KAAAA,MACAmH,KAEAS,EAGJ7H,EAAIC,GAQfqH,GA7JWgB,EAAcJ,EA+J1BK,EAAAb,IA5JYY,GAAe1B,IA+J3B2B,EAAA,GAQQvI,KAAAA,4BACIgJ,WAAJhJ,GAEI6H,UADAD,EAKJK,EAAAA,UA5UF,OAgVMe,EAOIC,MADRjB,EAEHhI,EAAAY,UAAAZ,EAAAmI,OAAAe,QAAAC,YACD,gBAEP,MAAA7B,IA5KuBtH,EAAIY,UAAYZ,EAAImI,OAAOe,QAAQC,YA8K3D,gBAIHnJ,EAAAY,UAjWa,OAoWdwI,EAAcnJ,SAWCwC,EAUA4G,EACVC,EAAgBA,EAtBzBf,IA6BIvC,IAAAA,IAAgB4C,EAAA,EAAAC,EAAAJ,EAAWtF,OAAAyF,EAAAC,EAAAD,IAAA,CACnB3G,IAL8CsH,EA5KlCC,EAiLhBC,EAAAhB,EAAAG,GAGI3G,EAASyH,KAAAA,MACF/H,KAAAA,IAAS,GAAA8H,EAAU,GAAAxC,EAAA,IAAA/E,IAG1ByH,EAAAhK,KAAA0D,KACApB,KAAS4E,IACAnF,EACLO,KAAA8F,KAAA0B,EAAA,GAAAxC,EAAA,IAAA/E,KAxLI,KAAI4G,EAAca,GAAlB,CAiNJC,GA5MI5J,EAAIY,UAAY4C,EAiM5BxD,EAAAC,SACI4J,EA/LY3B,GAAWR,EAAeD,GAAe,EAAI,EAiMzDqC,EAAYhB,EACZiB,QAQwBpH,IAApBqH,GAjMQtB,EAAaF,KAmMzBM,EAAAtB,GAAAmC,EAAApC,GACIyC,CACA,IAAAC,EAAAtK,KAAAoI,IACAe,EACIgB,GAGHI,EAAAvK,KAAAmI,IAAA6B,EAAAnC,GACExH,EAAIC,SACPgK,EACAH,EAAgBF,EAChBG,EAAAE,EACHvC,GAED,IAAAe,EAAAtF,QAAA,SAAAxB,IA/LuC,MAAnB2F,EAmMjBtH,EAAAY,UAAAZ,EAAAmI,OAAAe,QAAAC,YAAA,oBAAP,MAAA7B,IA7DkDtH,EAAAY,UAAAZ,EAAAmI,OAAAe,QAAAC,YAhItB,oBAsMrBc,EAGP/H,GAHOgI,IAYPD,GAAA,EACIE,GAAAA,GAEI5H,EAAU6H,SACbH,EACD/B,EAAA,EAJJgC,EAAAD,EAvMwBvC,IAkNbnF,KAAP8H,4BAAAd,GAJJ5I,KAAA2J,eAvMoBtK,EA8MhBuJ,EACJgB,EACIzB,EACYlJ,EAHhBsI,GASIsC,EAAc1B,EACd2B,EAAJd,GA3MQ,GAAa,SAAThI,EAAiB,CAEjB3B,EAAI0K,YAAc,EAqN1BC,EAAAA,UAAcC,QAjNN,IAAIC,EAAgBlK,KAAK+E,cAAcoF,QAAQvE,GAuNvDwE,EAAiBpL,KAArB0D,KAAAqE,EAAAmD,GAEA9B,EAAApJ,KAAAyD,OAAAsE,EAAAsD,GAAA,GAnNkC,IAAlBH,IAqNhB7K,EAAAC,SACgBmH,EAnNIkB,EAAc,EAqNlCT,EAAAT,EACa6D,GAEbF,EAAAA,SAnNoB3D,EAqNpBkB,EAAAZ,EAAAqB,EAAA,EACgBzF,EAAIyH,EACJA,UA3RA/K,EAAAY,UAAIsJ,EACJlK,EAAAA,SAMAoH,EACIc,EAAA,EACAL,EAAAT,EACAM,GAKI1H,GAAAA,IAGH,MAAAsH,EACDtH,EAAAY,UAAAZ,EAAAmI,OAAAe,QAAAC,YACA,oBAEIe,MAAAA,IACHlK,EAAAY,UAAAZ,EAAAmI,OAAAe,QAAAC,YACDnJ,oBAQRA,EAAAC,SACAmH,EACIc,EAAKoC,EAQRzC,EAAAT,EACDmC,IA4PJvJ,EAAA0K,YAAA,EAGA9C,GAAA,SAAIsD,GAAmBzE,EAAAQ,IACnBkE,EAAAA,UAAAA,EAGJ,IAAAlE,GACAjH,EAAIY,EAAJqI,YAAgBzF,GAAhBxB,MAAA,GAEHhC,EAAAoG,UAAA,OACJpG,EAAAgJ,SAxNepB,EA0NhBC,EAplBY,EAqlBHuD,EAAY5E,EACb6E,KAAMC,kBAENlB,GAxNQpK,EAAIiJ,YAAYrB,GAAc5F,MAhYlC,IA2lBRkJ,EAAAA,UAAUX,QACVY,EAAQZ,SAxNI3C,EA0NZR,EA9lBQ,EA+lBHmE,EAAYC,EACb7K,KAAAgF,kBAEA8F,GACAzL,EAAAiJ,YAAArB,GAAA5F,MAnmBI,IA4mBP,OAFDhC,EAAA0K,YAAIQ,GAEHlD,EAAAC,MAIG,IAAAmB,EAAA,SACA7H,EACAC,EAAUC,EACNC,EACAC,EACJ8D,EAAUC,EACN2D,EACAoB,GAEJjF,EAAA/C,KACA9B,KAAUY,EACNC,EACAC,EACAC,EArNZC,EAuNY8D,EACAC,GAEI/E,KAAA0I,QAAAA,EAAAA,EAAA9H,KAAA,KACAmK,KAAAA,cAAAA,GAMApN,EAAAuD,OAAAuH,EAAAxH,UAAA4D,EAAA5D,WAIIoE,eAAA,WACArG,IAAAA,EAKPgC,EAAAhB,KAAAgB,KAoBQ,MAhPR,UAATA,EA8NQM,EA5mBL,GA6mBS0J,WAAJhK,EACAM,EA3mBX,GAinBmBA,EAhnBbA,GAinBatB,KAAAe,MAAAkK,kBAMA5L,GAAAA,IAGCiC,GAaTgJ,aAAA,SAAAY,GACIJ,IAvOZ5B,IAAW,EAAG,IA4OVC,EAAAD,EAAA,GAAUE,EAAA,EAQN+B,EAAAxN,EAAAyN,IAAAF,EAAAG,MAAA,sBAAA,SACAvB,GAEM,IAAAb,EAAA7F,SAAAkI,EAAAtI,MAAA,GAAA,GAAA,IACNuI,EAAAA,EAAAA,OAAYC,GA5NpB,MA+NI,MAAAnC,EAEI,IAAAF,EAAA,KACAA,GAAIsC,EAAAA,EAAiBlB,EAArBtB,GA3OAC,EAAOzE,KAAK0E,KAmPE,IAAV,OAAAuC,QAAUC,KAKVxC,EAAA,IAAAF,EACAG,GAAAH,IArCA6B,YA3MMY,QAAQrC,GAAUJ,KAuPpB,OACAC,OAAAA,EAKIyB,MAAAQ,IAYA9L,UAAAA,SACAA,EACA2B,EAIIO,EACIqK,EACAtF,EACJC,EACIqF,EAIAjB,EACJkB,EACIF,GAGAC,IAsCZhC,EAAA,SAAAkC,GAMIC,OAAAA,KAAAA,MACIC,KAAAA,IAAAA,GAAAA,EAAM1F,EADK,IAAA/E,KASflC,EAAAoG,UAAA,SACH,IAoBjB8E,EACIlL,EArBawK,GAAAvD,EAAAC,GACJuD,EAAA,EACJgB,EAAA,EACDA,EAAAA,KAAAA,MAAAA,EAAcrB,GACdwC,EAAA5M,EAAAmI,OAAAe,QAAA0D,cAjNRpJ,EAoNH,MAAAgJ,EAjSS7L,KAAKe,MAAMmL,mBAmSrBlM,KAAAe,MAAA0G,qBAEAwC,EAAA,SAAAjJ,EAEAgJ,EAAAC,EA10BkB,EAiDtB,EA6xBQkC,EAAAA,EAAOJ,EACPC,EAAOG,IAAKH,EAAZ3M,EAAA2K,EAAAzI,EAAAP,GACAJ,KAKIvB,KAGH+M,EAAApM,KAAAsK,aAAAK,GACJA,EAAAyB,EAAAzB,MACJP,EAzaqDgC,EAAAlD,OA0IlD,IAASvG,EAAI,EAAGA,EAAIyH,EAAe5H,OAAQG,IAAK,CAC5C,IAAImG,EAAQsB,EAAezH,GA+S3BgD,GA3SSG,EAAgBgD,EAAM,GAAIhD,EAAgBgD,EAAM,IA6SzDhD,MAzSIyE,EAAUX,EAAe9D,EAAgBgD,EAAM,QA6SnD0B,EAAAZ,EAAA9D,EAAAgD,EAAA,OAcAkB,GAAAA,GAKJ3K,EAAAY,UAAA4C,EACI+C,EAAAA,SAAA2E,EAAsB8B,EAAO7B,EAAAD,EAAAP,IAK7B,IAAA,IAAAS,EACI7E,EAAAC,EAAA8E,EAAiBrE,OACjBV,EAAAC,EAAA4E,IAAiBlE,CAGjB,IAAAmE,EAAAC,EAAK2B,GAYRC,EAAM,YAAA7B,EAAA,IACH8B,EAAAA,EAAAA,GAjUA3B,EAAY/E,EAAgBgE,EAuV5B0C,GAnBJjC,EAAAX,EAAAiB,GACAL,EACI5E,EAAAiF,EAAApB,GAiBA+C,GAAAA,EAAA3B,EAAApB,GAAAI,GA6BH,OApWGU,IAAYC,IAgWhBA,GAAIgC,GAIHD,GA1EL,IA2EO,IACH,IAAA,IACA,IAAKD,IAcLtL,MAIA,IAAA,IAGIsF,GAAAmD,EAGApK,MACAA,IAAAA,IAMH,IAXD,IAsBJ,IAAA0L,EAAA,GACA,MAAOwB,EA5kBfxB,EAAAY,EAAA3I,MAoN4B8H,EA4XxB2B,EAA0BhD,GAmB1BzJ,KAAA0I,UAGKgB,EAAAA,KAALhB,QAAA1F,MA1YwBhE,KAAKoI,IAAI,EAAGyD,EAAYvE,GAkZ5CoG,KAAAA,IACQC,EAAJrG,EAAAmD,EACgB5D,EAAgBrD,KAHxC,IAAA,IAYemK,EAAAA,KAAPvF,IAAAyD,EAAAvE,GAZRsG,EAAA,EAAAA,EAAA7B,EAAAvI,OAAAoK,IAeIrH,GACqBwF,IAAKjK,KAAWC,MAAKF,kBAChBgM,MAARxL,EACF8F,CAjZQ2F,EAAU9N,KAAKC,MAuZvBD,KAAAoI,IAQZ,GACgB2F,EAAaC,EAAd1G,GAAf/E,IA1ZgBlC,EAAIY,UAAYD,KAAK2I,cAAcoC,EAAQ6B,IA8Z3D3C,GAAA1I,EAAA0K,EACA5M,EAAAgJ,SAAA0C,EAAA6B,GAAAE,EAAAvF,EAAA,GA5Z2BhG,EAAU,KA+ZrBlC,EAAAC,SACZwN,EAAAG,EACkB1F,EAClBvI,KAAAoI,IAAA,EAAApI,KAAAyD,MAAAlB,IACHyI,GAQT,MAAAuC,IA7ZoBzB,GAAcrB,GAElBK,GAAeL,EAEf,MA+ZZ4C,IAAMa,IACN7N,EAAW8N,UAtiCD,OAuiCHA,EAAI3K,SACA2K,EACA/J,GAAA4G,EAAP,GAAA,EADJQ,EAAAD,EAGW/H,GACXsH,GAAAL,EAMG,MACH,IAAA,IACI8B,EAAgBqB,cAAhBrC,EAAA6C,EAAA3D,GADJK,GAAAL,EAGH,MACI4D,IAAQ,IAGP,IAAA5B,EAAWlB,EAAA0C,EADH,GA7ZMrC,GAkapBC,EAAAA,EAAApB,GACAI,GAEA,CACA,IAAA+B,EAAAD,EAAA3I,MACA8H,EACOA,EAAWrB,GAQD6D,GAAOtN,KAAKqN,MACZE,gBAPT,CAqBH,IAAAC,EAAAjD,GAAAC,EAAAD,GAAA,EAlCS,IAzYwB,SAATvJ,GAAiC,SAAdhB,KAAKgB,YA8anCgB,IAAA2J,GACNpK,EAAR0K,EACQ,CAeJ,OAbJ5M,EAAAY,UAAA,SACUZ,EAAAC,SACAkO,EAAVP,EACA1F,EAAA,EACAiD,EAAAD,EACA,GA3awBwB,EAAUA,EAAUvJ,SA8a3BwJ,KAAA,WACbpL,MAAA6K,EAAAlE,EAAA,EAAA,IAEckG,EAAKxN,UA7mCb,OA+mCNrC,GACIiN,EAAAA,EAAApB,GACQI,IAER,KAvrDI,KAwrDI+B,EAAJA,EAAA5I,MAAAsD,EAAAuE,GACA,MACJ,KAzrDE,KA0rDMe,EAAJA,EAAA5I,MACA,EATR6H,EAAAtE,GAYH,MACuBmH,KA9rDb,KAmxCqB,MA8ajB,KApsDR,KAqsDqBL,EAALzB,EAAa5I,MAIdL,EAAGkI,EACbA,EAAAtE,GA3aY,IAmbNoH,IAAjBf,EAAyB,EAAAgB,EAAAhC,EAAApJ,OAC1BoK,EAAAgB,EAjb4BhB,IAmbZ,CAChB,IAAAE,EAAA9N,KAAAC,MAC2B4O,KAAAA,IAjbS,GAmbNC,EAAcA,EAAfxH,GAA8B/E,IAIvDlC,EAAgB0O,SAlbYnC,EAAIgB,GAubxBE,GAA0BO,EAAS9C,GAA/C,EArbgChD,SA2bxClI,EAAAY,UAAA,SAEI+N,EAAAA,SACAR,EArbgCjG,GAAyB,UAAdvH,KAAKgB,KAAmB,EAAI,GACvCwJ,EAAQD,EAubX0D,UAAVjN,EA5qCnB,EAnDuB,QAsuCM,SAAZkN,GAA4B,SAAhBlO,KAAgBgB,YAChBmN,IAALxC,GACApK,EAAK6M,GAG7BrC,EAAAtH,MAC4BuH,KAAKqC,OANrCzN,MA9awCgL,EAAIpJ,OAwbxCyL,EAMA1G,EAAA,KApbgBuD,GAAcrB,OA9NlBK,EAqKwB8B,SAAAA,EAAMA,EAAI5I,GAOlB,OAHQ,IAAA,QAAA0I,QAAAa,KArBR3K,GAAA6H,GAwBA7H,EA5KF4H,CAAmBM,EAAayC,EAAQ9C,GAmV1DqB,EAvJqB,SAAAlJ,EAAA2K,EAAA9C,GAID,OAHG,IAAN,KAAAiC,QAAAa,KACG3K,GAAA6H,GAEA7H,EAmJpB0M,CAAAxD,EAAAyB,EAAA9C,GA6UZpK,EAAAY,UAAA,SAYI,IAAA,IApcQkM,EAkcRoC,EACA5N,EACAgC,EAAA,EAAAA,EAAAoJ,EAAAvJ,OAAAG,IA/bQqJ,GAgcJnG,EAAJkG,EAAApJ,IAhcoBqJ,KAkchBpL,EAAKG,EAAMgB,KACPA,SAAAA,GACJ1C,EAAKsD,OACDZ,EAAAA,KAAAA,QAAqBA,EAAAA,KACxB1C,EAAAgJ,SAAAzH,EAAA,GAAAA,EAAA,GAAAA,EAAA,IACDvB,EAAK0B,WACR,aAAAiL,GACGzM,EAAoCF,EAAAuB,EAAA,GAAAA,EAAA,GAAAA,EAAA,KAzbxCoF,aAAc,SAkclBuI,EACIxM,EACAE,EACAjB,EACAwN,EACAC,EALJlN,EA1bQ+D,EAkcRiJ,GAGsBtM,EAAAA,GAAlB,IAEIpB,EAAa+E,EAAK/E,GAClBG,EAAYA,EAAhB,GACIJ,EAAYA,EAAhB,GAGA6F,EAAIiI,KAAWC,MAhcP3P,KAAKoI,KAAK,GAAM7F,GAAUuE,EAAgBQ,EAAW,IAAO/E,IA0chEqN,EAAJ5P,KAAA0D,KACImM,KAAJ1H,IACA9F,EACIyN,KAAJ1H,IAAA,GAAArB,EAAAO,EAAA,IAAA/E,KAEAgG,GAAA,UAAAvG,EAAA,EAAA,EAAAsD,GAAAgB,EAIIyJ,EAtca,SAAT/N,EAh4Bc,EAiDtB,EAwxCiBhC,KAAKgQ,MAAKtH,YAG3B,GAAA9B,EAAA,aAAAyG,MAAA,CAEIoB,IAAI7M,GAAJ,EAIAiO,EAAWpB,GAAN,IAALnH,GACA2I,EAAWxB,GAAN,IAALlH,GACAuI,EAAA,GAAA,GAEI7O,KAAAA,UACAX,EACP0B,EAtceO,EAwchBgG,EAjDJjB,EApZoBC,EAwcpBX,EAAA,GAAA,GAtcoBA,EAAQ,GAAG,GACXA,EAAQ,GAAG,GAwc3BsJ,EAAmB,GAAA,IAGdC,GAAcA,EAOdD,EAAAA,GAAAA,IAAiBjO,GACtB2E,EAAA,GAAA,IAAAW,GAxcYX,EAAQ,GAAG,GAEX5F,KAAKsM,UA0cjBd,EACIxK,EACIoO,EAGC7H,EACLjB,EACHC,EAZLX,EAAA,GAAA,GA7boBA,EAAQ,GAAG,GA4c/BA,EAAA,GAAA,GA1coBA,EAAQ,GAAG,IAqdnB9D,GAAWlB,EA1cX,IAAIyO,EAASrQ,KAAK0D,KAmd1B2C,KAAAA,IACQrE,EACAM,KAAJ8F,KACa,GAAA7F,GACAwH,EAAAA,GAAAA,GAAAA,EAAT,IAAAxH,KAKAD,EAAS4E,KAAAA,MACZlH,KAAAoI,KACM9F,GAAPC,GAf8CqE,EAAA,GAAA,GAAAU,EAAA,IAAA/E,IA9b1C,GAAIiL,GAAa8C,EAAWD,EAAQ,CAmd5CnK,EAAAA,UA12Cc,OA22CV,IAAAqK,EAAAhI,EAAA,GAAAyC,EAAA,GAAA,EACA1L,EAAAe,EAAAgQ,EAAAE,EAAAD,EAAAC,SAIAvP,KAAIwP,UACAlO,EACHN,EACDO,EA9B8CgG,EAlbtCjB,EAmdZC,EAjdYT,EACAF,EAAQ,GAmddA,EAAA,GACEmJ,EAAJ,IAiCA,MA/ea,SAAT/N,GACA8E,GAAiBQ,GACA,MAAjBW,IAqdJwI,EAAAA,UAAAA,KAAiB1O,MAAjB0O,YAEQC,IAAJpJ,GACAG,EAAIkJ,EAAJrH,YAAArB,GAAA5F,MAAA,GAEAhC,EAAI2M,UAAJ,OACA3M,EAAIuQ,SACA5D,EACAnG,EA97CI,EA47CR0B,EAGWsI,EACP7D,KAAAA,oBAGH3M,EAJMoG,UAIQiG,QACXrM,EAAAgJ,SACA2D,EACAnG,EAt8CI,EAu8CJ8J,EAAQD,EACX1P,KAAAgF,qBAMD8K,EAAAA,MAIJ,IAAArD,EAAA,SACA7L,EACAC,EACAC,EACAC,EACAC,EACA8D,EACAC,GAEAyB,EAAA1E,KAjdA9B,KAmdAY,EACAmP,EAjdAjP,EAmdAC,EACAyO,EAjdA1K,EAmdAC,GAIA/E,KAAA2M,uBAAA3M,KAAA0M,mCACAsD,KAAAA,2BACIzO,EAndRvB,KAAK0J,4BAA6B,GA2d9B/L,EAAAuD,OAvdJuL,EAAwBxL,UA8dpB4D,EAAA5D,UA5dJuF,EAAqBvF,WA+djByL,iCAAuB,WAKnBnB,IAAAA,IAJA0E,EAAaD,EAIbzE,EAAAA,EAAY0E,EAAAA,KAAZrP,KAAyBqP,OAAzBtN,EAAAkD,EAAAlD,IAAA,CACA,IAAAiD,EAAA5F,KAAAY,KAAA+B,GACAuN,EAAAtK,EAAA,GACHG,EAAAH,EAAA,GA/dO+G,EAAyB3N,KAAKoI,IAietCuF,EACI5G,EAAWoK,GAGX9Q,OAAAA,GAQJkG,gBAAA,SAAAlE,GACAhC,IACAkC,EAAAF,GADgBrB,KAAAc,SAAhBd,KAAAa,YAEI,OAAA7B,KAAAmI,IACA2I,IACAM,KAAAA,KAAMN,KAAAA,uBAAN,EAAAvO,KAIA8O,eAAAA,SApeAhR,EAseAiR,EACAV,EACI5C,EACIhB,EACA8C,GAleR,IAAItB,GAAYT,EAAaC,GAAgB,EAEzCuD,EAASvD,EAAeQ,EAGfxO,KAAKgQ,GAweduB,EAAA,IACHlR,EAAAO,YApeGP,EAAImR,IAAIhD,EAAUjG,EAASyF,EAAeQ,EAAUxO,KAAKgQ,GAAI,GAsejE3P,EAAAc,aAgBQsQ,IAAAA,EAAAA,SAAAA,EAAAA,GAiBIA,MAAAA,QAAAA,GACHzQ,KAAAmN,IAAAA,EACJ,GAAAA,EAAA3K,OACJxC,KAAAmN,IAAAA,EAAA9B,MAAA,SAAAD,IAAA,SAAAwB,GAtfD,OAAOxJ,SAASwJ,EAAG,MAyfT7L,GAAVoM,EAAA3K,OACIxC,KAAAmN,IAAAA,EACHuD,UAAA,EAAA,GAtfArF,MAAM,SAwfPD,IAAA,SAAAwB,GACA6D,OAAAA,SAAeP,EAAAA,MApfnBlQ,KAAKmN,IAAMA,EAAIwD,MAAM,IAAIvF,IAAI,SAASwB,GAggB9B,OAAAxJ,SAAAwJ,EAAAA,EAAA,MAGI5M,KAAAqN,MAAIuD,iBAAJC,EAAIA,EAAgB,GAEnBC,EAAA7P,WACG8P,KAAA,WACAC,OAAAA,MASPC,MAAA,WA9fT,OAAIjR,KAAKqN,MAAQ,EAigBT,QACI6D,KAAAA,IAIA9F,IAAA,SAAI4F,GACA,OAAAhS,KAAImS,MAAMH,KAEV1D,OAAAtN,KAAIuL,OACAlM,KAAAA,MAKH,IASDkM,IAKHvL,KAAAmN,IACG/B,IAAA,SAAAzI,GAGX,OAFQA,EAAA3D,KAAAyD,MAAAE,GAER,KADIA,GAAAA,EAAA,IAAA,IAAAA,EAAA,EAAA,EAAAA,GAAAyO,SAAA,KACJ5O,OAAA,IAAAG,EAAAA,IA7gBQ4K,KAAK,KAKtB8D,MAAO,WAghBPhR,IAMAiR,EA9gBQ5D,EAwgBRrN,EAAQA,KAAAA,IADG,GAAA,IAEXwB,EAAAA,KAAaA,IAAAA,GAAAA,IACb2E,EAAAA,KAAAA,IAAAA,GAAsBA,IACtBiC,EAAAA,KAAaA,MACbgE,EAAAA,KAAAA,IAAAA,EAAAA,EAAyBA,GACzB8B,EAAAA,KAAAA,IAAAA,EAAAA,EAAwBA,GA5gBhBgD,GAAKnK,EAAMD,GAAO,EAClBsG,EAAIrG,EAAMD,EAEd,GAAIC,IAAQD,EACRqK,EAAI9D,EAAI,MACL,CAGH,OAFAA,EAAI6D,EAAI,GAAM9D,GAAK,EAAIrG,EAAMD,GAAOsG,GAAKrG,EAAMD,GAEvCC,GACJ,KAAKqK,EACDD,GAAKE,EAAIC,GAAKlE,GAAKiE,EAAIC,EAAI,EAAI,GAC/B,MACJ,KAAKD,EACDF,GAAKG,EAAIF,GAAKhE,EAAI,EAClB,MACJ,KAAKkE,EACDH,GAAKC,EAAIC,GAAKjE,EAAI,EAG1B+D,GAAK,EAET,OAASA,EAAO,IAAJA,EAAS9D,EAAGA,EAAG6D,EAAGA,EAAGV,EAAGA,IAGxCe,OAAQ,WAEJ,MACI,KAFQ5S,KAAKyD,MAAmB,IAAbzC,KAAKqN,QAAcC,OAAOtN,KAAKmN,KAI7C/B,IAAI,SAASzI,GAGV,OAFAA,EAAI3D,KAAKyD,MAAME,GAEK,KADpBA,GAAKA,EAAI,IAAM,IAAMA,EAAI,EAAI,EAAIA,GAAGyO,SAAS,KACpC5O,OAAe,IAAMG,EAAIA,IAErC4K,KAAK,KAIlBsE,IAAK,SAAShE,EAAQF,GAClB,IAAImE,EAAS9R,KAET+R,EAAIpE,EACJG,EAAQ,EAAJiE,EAAQ,EACZlB,EAAIiB,EAAOT,QAAQR,EAAIhD,EAAOwD,QAAQR,EAEtC9C,IAAOD,EAAI+C,IAAM,EAAI/C,GAAKA,EAAI+C,IAAM,EAAI/C,EAAI+C,IAAM,GAAK,EACvDmB,EAAK,EAAIjE,EAETZ,GACA2E,EAAO3E,IAAI,GAAKY,EAAKF,EAAOV,IAAI,GAAK6E,EACrCF,EAAO3E,IAAI,GAAKY,EAAKF,EAAOV,IAAI,GAAK6E,EACrCF,EAAO3E,IAAI,GAAKY,EAAKF,EAAOV,IAAI,GAAK6E,GAGrC3E,EAAQyE,EAAOzE,MAAQ0E,EAAIlE,EAAOR,OAAS,EAAI0E,GAEnD,OAAO,IAAIjB,EAAM3D,EAAKE,KAM9B,IAAIW,EAAa,SAASC,EAAaI,EAAWF,EAAaC,GAI3DpO,KAAKiO,YAAc,IAAI6C,EAAM7C,GAC7BjO,KAAKqO,UAAY,IAAIyC,EAAMzC,GAC3BrO,KAAKmO,YAAcA,EACnBnO,KAAKoO,UAAYA,EACjBpO,KAAKiS,YAAc7D,EAAYD,GAGnCH,EAAW/M,UAAUiN,UAAY,SAASY,GAMtC,OALAA,EAAQ9P,KAAKoI,IAAI0H,EAAO9O,KAAKmO,aAC7BW,EAAQ9P,KAAKmI,IAAI2H,EAAO9O,KAAKoO,WAC7BU,GAASA,EAAQ9O,KAAKmO,aAAenO,KAAKiS,YAGnCjS,KAAKiO,YAAY4D,IAAI7R,KAAKqO,UAAW,EAAIS,GAAOmC,SAG3D,IAAItC,EAAY,SACZV,EACAiE,EACA7D,EACAF,EACAC,GAKApO,KAAKmS,cAAgB,IAAInE,EAAWkE,EAAc7D,EAAW,EAAGD,GAChEpO,KAAKoS,cAAgB,IAAIpE,EACrBkE,EACAjE,EACA,GACCE,GAELnO,KAAKmO,YAAcA,EACnBnO,KAAKoO,UAAYA,GAGrBO,EAAU1N,UAAUiN,UAAY,SAASY,GAGrC,OAFAA,EAAQ9P,KAAKoI,IAAI0H,EAAO9O,KAAKmO,cAC7BW,EAAQ9P,KAAKmI,IAAI2H,EAAO9O,KAAKoO,aAChB,EACFpO,KAAKmS,cAAcjE,UAAUY,GAE7B9O,KAAKoS,cAAclE,WAAWY,IAI7C,IAAIP,EAAyB,SAAS3N,EAAMC,EAAYC,EAAUC,EAAOC,GACrEL,EAAQmB,KAAK9B,KAAMY,EAAMC,EAAYC,EAAUC,EAAOC,GACtD,IAAI2B,EACAkD,EAEJ,QAA6B7D,IAAzBhC,KAAKe,MAAMgB,UAAyB,CACpC,IAAIA,EAAYsQ,EAAAA,EAChB,IAAK1P,EAAI,EAAGkD,EAAM7F,KAAKY,KAAK4B,OAAQG,EAAIkD,EAAKlD,IACzCZ,EAAY/C,KAAKmI,IAAIpF,EAAW/B,KAAKY,KAAK+B,GAAG,IAEjD3C,KAAKe,MAAMgB,UAAYA,EAE3B,QAA6BC,IAAzBhC,KAAKe,MAAMkB,UAAyB,CACpC,IAAIA,GAAaoQ,EAAAA,EACjB,IAAK1P,EAAI,EAAGkD,EAAM7F,KAAKY,KAAK4B,OAAQG,EAAIkD,EAAKlD,IACzCV,EAAYjD,KAAKoI,IAAInF,EAAWjC,KAAKY,KAAK+B,GAAG,IAEjD3C,KAAKe,MAAMkB,UAAYA,IAI/BsM,EAAuBtN,UAAUE,eAC7BY,eAAWC,EACXC,eAAWD,EACXhB,KAAM,UACNwN,UAAW,UACXC,UAAW,WAGfF,EAAuBtN,UAAUG,KAAO,SAAS/B,EAAKgC,EAAOC,EAAQC,GACjE,IAiBIkM,EACA6E,EACA1D,EACAC,EACAI,EACAH,EAtBA/M,EAAY/B,KAAKe,MAAMgB,UACvBE,EAAYjC,KAAKe,MAAMkB,UAGvBpB,EAAab,KAAKa,WAElBD,GADOZ,KAAKgB,KACLhB,KAAKY,MACZ2R,EAAW,EAAIvT,KAAKE,KAAK,GAEzBwP,EAAO,IAAIC,EACX3O,KAAKe,MAAM0N,UACX,UACAzO,KAAKe,MAAMyN,UACXzM,EACAE,GAUAuQ,EAAQ,SAAST,GACjB,OAAQA,EAAIlR,GAAcU,GAG9BlC,EAAI0P,OAGJ1P,EAAIoT,QAAQ,GAAKzT,KAAKgQ,GAAK,KAC3B3P,EAAImT,MAAMD,EAAUA,GAGpB,IAAK,IAAI5P,EAAI,EAAGkD,EAAMjF,EAAK4B,OAAQG,EAAIkD,EAAKlD,IAGxC2P,EAAKE,GAFL/E,EAAI7M,EAAK+B,IAEI,IACbiM,EAAK4D,EAAM/E,EAAE,IACboB,EAAK2D,EAAM/E,EAAE,IACbwB,EAAKuD,EAAM/E,EAAE,IACbqB,EAAQrB,EAAE,GAEVpO,EAAIY,UAAYyO,EAAKR,UAAUY,GAC/BzP,EAAIC,SAASgT,EAAIzD,EAAID,EAAK0D,EAAIrD,EAAKJ,GAGvCxP,EAAIyE,WAMR,IAAIoL,EAAmB,SAAS7P,EAAK4Q,EAAYd,EAAanO,GAC1DhB,KAAKX,IAAMA,EACXW,KAAKiQ,WAAaA,EAClBjQ,KAAKmP,YAAcA,EACnBnP,KAAK0S,cACS,SAAT1R,GAA4B,SAATA,IACpBmO,GAAe9P,EAAImI,OAAOe,QAAQ0D,cACtCjM,KAAK2S,yBAA2B,IAGpChV,EAAEuD,OAAOgO,EAAiBjO,WAKtBuK,cAAe,SAAS7G,EAAGhF,EAAGkG,GAC1B7F,KAAKX,IAAIY,UAAY,QACrB,IAAImP,GACCpP,KAAK0S,aAAe1S,KAAK2S,yBAA2B,GACrD3S,KAAKiQ,WACTtQ,GAAK,IAAOK,KAAKiQ,WAAab,GAC9BpP,KAAKX,IAAIC,SAASqF,EAAGhF,EAAGkG,EAAM7F,KAAKmP,YAAaC,MAOxD,IAAIkC,EAAiB,SACjB1Q,EACAC,EACAC,EACAC,EACAC,EACA2H,GAEAhI,EAAQmB,KAAK9B,KAAMY,EAAMC,EAAYC,EAAUC,EAAOC,GACtDhB,KAAK2I,cAAgBA,EACrB3I,KAAK4S,eAAiB,GAG1BjV,EAAEuD,OAAOoQ,EAAerQ,UAAWN,EAAQM,WAIvCoE,eAAgB,WACZ,IAAIrE,EAAOhB,KAAKgB,KAUhB,MARa,UAATA,EAt2CG,GAw2Ca,WAATA,EAr2CV,EACMM,IAg3CX4D,oBAAqB,SAASsK,GAG1B,IAAIlO,EAAStB,KAAKe,MAAM8R,eAMxB,OAHIrD,EAAc,GAAKxP,KAAKe,MAAMoP,mBAC9B7O,GAAUtB,KAAK4S,eAAiBpD,EAAcxP,KAAKqF,kBAEhD/D,GAMXF,KAAM,SAAS/B,EAAKgC,EAAOC,EAAQC,GAC/BlC,EAAI0P,OAEJ,IA+BIe,EAEAM,EAEAP,EACAD,EAGAkD,EACAzC,EACAW,EACAE,EACAT,EACAG,EA6BAmC,EAlEJtD,EAAiB,SAASI,EAAKD,GAC3B,IAAIoD,EAAUnD,EAAIrN,OACdkN,EAAUE,EAAIpN,OACdmN,EAAQ,EACR9J,EAAM,EACNmG,EAAO,KAeX,MAdY,MAAR4D,GACA5D,EAAO,WACPnG,EAAMgK,EAAIrN,QACkB,IAArBqN,EAAInE,QAAQkE,IAAcoD,EAAUtD,GAC3C1D,EAAO,WACPnG,EAAMmN,EAAUtD,EAChBC,EAAQD,GACoB,IAArBE,EAAIlE,QAAQmE,IAAcmD,EAAUtD,IAE3C1D,EAAO,YACPnG,EAAM6J,EAAUsD,EAChBrD,EAAQD,GAGI,OAAT1D,GAAkBA,KAAMA,EAAM2D,MAAOA,EAAO9J,IAAKA,OAoB5DkK,EAAU/Q,KAAKoI,IAAI,EAAGpI,KAAKC,MAAMsC,IAGjCiO,EAAcxP,KAAKY,KAAK4B,OAASxC,KAAKY,KAAK,GAAG,GAAG+P,MAAM,KAAKnO,OAAS,EAEjEyN,EACc,WAAdjQ,KAAKgB,KAx7CR,EACMM,GA27CP0O,EACIzO,EAAU,GACJ0O,EACc,WAAdjQ,KAAKgB,KA37CnB,EAjDsB,EAg/CdkP,GAAe,EAEf3E,EAAc,IAAI2D,EAClB7P,EACA4Q,EACA1O,EACAvB,KAAKgB,MAMW,IAAhBwO,IACAS,EAAaD,EACTzO,EAAUlC,EAAImI,OAAOe,QAAQ0D,cACvBjM,KAAKe,MAAM8R,eACX5C,EACV1E,EAAY0E,WAAaA,EAEzBC,GAAe,GAIflQ,KAAKe,MAAMoP,kBAAoBD,IAC/B7Q,EAAIY,UAAY,UAChBZ,EAAI0K,YAAc,EAClB1K,EAAIC,SACA,EACAU,KAAKe,MAAM8R,eAAiB7S,KAAK4S,eACjCvR,EACArB,KAAK4S,iBAKbvT,EAAIoG,UAAY,SAChB,IAAK,IAAI9C,EAAI,EAAGA,EAAI3C,KAAKY,KAAK4B,OAAQG,IAuBlC,GArBAmN,EAAa9P,KAAKY,KAAK+B,GACvByN,EAAMN,EAAW,GACjBD,EAAMC,EAAW,GACjBF,GAAOE,EAAW,GAAGa,MAAM,MAC3BmC,EAAahD,EAAW,GAAGa,MAAM,KACjCN,EAAgBP,EAAW9M,MAAM,GAGjC4M,EAAMjS,EAAEyN,IAAIzN,EAAEsV,QAAQrD,GAAM,SAASiB,GACjC,IAAIqC,GACAlH,KAAM,MACN8C,MAAO+B,EACPlB,MAAO,GAGPwD,EAAa1D,EAAeI,EAAKgB,GAErC,OAAOlT,EAAEuD,OAAOgS,EAAUC,OAI1B/C,EAAMpQ,KAAKa,YAAcuP,EAAMpQ,KAAKc,UAAxC,CAKA,GAAIoP,EAGA,IAFA7Q,EAAIY,UAAY,UAChBZ,EAAI0K,YAAc,EACbgJ,EAAI,EAAGA,EAAInD,EAAIpN,OAAQuQ,IAcxB,IAZA7B,EAAelR,KAAKwB,mBAChB4O,EAAMR,EAAImD,GAAGpD,MACbpO,GAEJlC,EAAIC,SACA4R,EACA,EACAnB,EACA/P,KAAKe,MAAM8R,gBAEfpC,EAAezQ,KAAKe,MAAM8R,eAErBE,EAAI,EAAGA,EAAInD,EAAIpN,OAAQuQ,IAAK,CAC7B1T,EAAIY,UACgB,aAAhB2P,EAAImD,GAAG/G,KACD,QACAhM,KAAK2I,cAAciH,EAAImD,GAAGjE,OACpC,IAAIsE,EAAc/C,EAAgByC,EAAWtQ,OACzCwH,EAAchL,KAAK0D,KACnB1C,KAAKe,MAAM8R,eAAiBO,GAEhC/T,EAAIC,SACA4R,EACAT,EAAezG,EACf+F,EACA/F,GAEJyG,GAAgBzG,EAM5B,GAAKhK,KAAKe,MAAMoP,iBAQhB,IAHAM,EAAeP,EACTlQ,KAAKe,MAAM8R,eAAiB7S,KAAK4S,eACjC,EAEFG,EAAI,EACJA,EAAID,EAAWtQ,OACfuQ,IAAKtC,GAAgBR,EAyBrB,GAvBAW,EAAWkC,EAAWC,GAChBD,EAAWC,GAAGpC,MAAM,UACnB,IAAK,KAGZK,EAAU,KACNJ,EAAS,KAAOA,EAAS,GACL,MAAhBA,EAAS,IAEc,MAAhBA,EAAS,KAEhBI,EAAUpB,EAAIxM,SAASwN,EAAS,GAAI,IAAM,GAC1CvR,EAAI0K,YAAc,IAKtBiH,EAA0B,MAAhBJ,EAAS,GAAaA,EAAS,GAAKA,EAAS,GACvDI,EAAUpB,EAAIxM,SAAS4N,EAAS,IAAM,GACtC3R,EAAI0K,YAAc,IAIlBiH,EAKA,GAJAE,EAAelR,KAAKwB,mBAChB4O,EAAMY,EAAQrB,MACdpO,GAEiB,QAAjByP,EAAQhF,KAAgB,CACxB,IAAImF,EAAMH,EAAQlC,MAClBzP,EAAIY,UAAYD,KAAK2I,cAAcwI,GAC/B5F,EAAYmH,aACZrT,EAAIgJ,SACA8I,EACAnR,KAAKqT,aAAajD,EAAK7O,GACvBkP,EAAeR,GAGnB5Q,EAAIC,SACA4R,EACAT,EAAe,EACfV,EACAC,OAGgB,aAAjBgB,EAAQhF,MACfT,EAAYC,cACR0F,EACAT,EAAe,EACfO,EAAQnL,KAS5BxG,EAAIyE,wBAKRzD,OAAQA,EACRwB,YAAaA,EACb2E,qBAAsBA,EACtBiC,YAAaA,EACbgE,wBAAyBA,EACzB8B,uBAAwBA,EACxB+C,eAAgBA","file":"../../../scripts/viz/trackster/painters.js","sourcesContent":["import * as _ from \"libs/underscore\";\n\n/**\n * Compute the type of overlap between two regions. They are assumed to be on the same chrom/contig.\n * The overlap is computed relative to the second region; hence, OVERLAP_START indicates that the first\n * region overlaps the start (but not the end) of the second region.\n * NOTE: Coordinates are assumed to be in BED format: half open (start is closed, end is open).\n */\nvar BEFORE = 1001;\n\nvar CONTAINS = 1002;\nvar OVERLAP_START = 1003;\nvar OVERLAP_END = 1004;\nvar CONTAINED_BY = 1005;\nvar AFTER = 1006;\nvar compute_overlap = function(first_region, second_region) {\n    var first_start = first_region[0];\n    var first_end = first_region[1];\n    var second_start = second_region[0];\n    var second_end = second_region[1];\n    var overlap;\n    if (first_start < second_start) {\n        if (first_end <= second_start) {\n            overlap = BEFORE;\n        } else if (first_end <= second_end) {\n            overlap = OVERLAP_START;\n        } else {\n            // first_end > second_end\n            overlap = CONTAINS;\n        }\n    } else {\n        // first_start >= second_start\n        if (first_start > second_end) {\n            overlap = AFTER;\n        } else if (first_end <= second_end) {\n            overlap = CONTAINED_BY;\n        } else {\n            overlap = OVERLAP_END;\n        }\n    }\n\n    return overlap;\n};\n\n/**\n * Returns true if regions overlap.\n */\nvar is_overlap = function(first_region, second_region) {\n    var overlap = compute_overlap(first_region, second_region);\n    return overlap !== BEFORE && overlap !== AFTER;\n};\n\n/**\n * Draw a dashed line on a canvas using filled rectangles. This function is based on:\n * http://vetruvet.blogspot.com/2010/10/drawing-dashed-lines-on-html5-canvas.html\n * However, that approach uses lines, which don't seem to render as well, so use\n * rectangles instead.\n */\nvar dashedLine = function(ctx, x1, y1, x2, y2, dashLen) {\n    if (dashLen === undefined) {\n        dashLen = 4;\n    }\n    var dX = x2 - x1;\n    var dY = y2 - y1;\n    var dashes = Math.floor(Math.sqrt(dX * dX + dY * dY) / dashLen);\n    var dashX = dX / dashes;\n    var dashY = dY / dashes;\n    var q;\n\n    for (q = 0; q < dashes; q++, x1 += dashX, y1 += dashY) {\n        if (q % 2 !== 0) {\n            continue;\n        }\n        ctx.fillRect(x1, y1, dashLen, 1);\n    }\n};\n\n/**\n * Draw an isosceles triangle that points down.\n */\nvar drawDownwardEquilateralTriangle = function(\n    ctx,\n    down_vertex_x,\n    down_vertex_y,\n    side_len\n) {\n    // Compute other two points of triangle.\n    var x1 = down_vertex_x - side_len / 2;\n\n    var x2 = down_vertex_x + side_len / 2;\n    var y = down_vertex_y - Math.sqrt(side_len * 3 / 2);\n\n    // Draw and fill.\n    ctx.beginPath();\n    ctx.moveTo(x1, y);\n    ctx.lineTo(x2, y);\n    ctx.lineTo(down_vertex_x, down_vertex_y);\n    ctx.lineTo(x1, y);\n\n    ctx.strokeStyle = this.fillStyle;\n    ctx.fill();\n    ctx.stroke();\n    ctx.closePath();\n};\n\n/**\n * Base class for all scalers. Scalers produce values that are used to change (scale) drawing attributes.\n */\nvar Scaler = function(default_val) {\n    this.default_val = default_val ? default_val : 1;\n};\n\n/**\n * Produce a scaling value.\n */\nScaler.prototype.gen_val = function(input) {\n    return this.default_val;\n};\n\n/**\n * Results from painter.draw()\n */\nvar DrawResults = function(options) {\n    this.incomplete_features = options.incomplete_features;\n    this.feature_mapper = options.feature_mapper;\n};\n\n/**\n * Base class for painters\n *\n * -- Mode and prefs are both optional\n */\nvar Painter = function(data, view_start, view_end, prefs, mode) {\n    // Data and data properties\n    this.data = data;\n    // View\n    this.view_start = view_start;\n    this.view_end = view_end;\n    // Drawing prefs\n    this.prefs = _.extend({}, this.default_prefs, prefs);\n    this.mode = mode;\n};\n\nPainter.prototype.default_prefs = {};\n\n/**\n * Draw on the context using a rectangle of width x height using scale w_scale.\n */\nPainter.prototype.draw = function(ctx, width, height, w_scale) {};\n\n/**\n * Get starting drawing position, which is offset a half-base left of coordinate.\n */\nPainter.prototype.get_start_draw_pos = function(chrom_pos, w_scale) {\n    return this._chrom_pos_to_draw_pos(chrom_pos, w_scale, -0.5);\n};\n\n/**\n * Get end drawing position, which is offset a half-base right of coordinate.\n */\nPainter.prototype.get_end_draw_pos = function(chrom_pos, w_scale) {\n    return this._chrom_pos_to_draw_pos(chrom_pos, w_scale, 0.5);\n};\n\n/**\n * Get drawing position.\n */\nPainter.prototype.get_draw_pos = function(chrom_pos, w_scale) {\n    return this._chrom_pos_to_draw_pos(chrom_pos, w_scale, 0);\n};\n\n/**\n * Convert chromosome position to drawing position.\n */\nPainter.prototype._chrom_pos_to_draw_pos = function(\n    chrom_pos,\n    w_scale,\n    offset\n) {\n    return Math.floor(\n        w_scale * (Math.max(0, chrom_pos - this.view_start) + offset)\n    );\n};\n\nvar LinePainter = function(data, view_start, view_end, prefs, mode) {\n    Painter.call(this, data, view_start, view_end, prefs, mode);\n};\n\nLinePainter.prototype.default_prefs = {\n    min_value: undefined,\n    max_value: undefined,\n    mode: \"Histogram\",\n    color: \"#000\",\n    overflow_color: \"#F66\"\n};\n\nLinePainter.prototype.draw = function(ctx, width, height, w_scale) {\n    var in_path = false;\n    var min_value = this.prefs.min_value;\n    var max_value = this.prefs.max_value;\n    var vertical_range = max_value - min_value;\n    var height_px = height;\n    var view_start = this.view_start;\n    var mode = this.mode;\n    var data = this.data;\n\n    ctx.save();\n\n    // Pixel position of 0 on the y axis\n    var y_zero = Math.round(height + min_value / vertical_range * height);\n\n    // Horizontal line to denote x-axis\n    if (mode !== \"Intensity\") {\n        ctx.fillStyle = \"#aaa\";\n        ctx.fillRect(0, y_zero, width, 1);\n    }\n\n    ctx.beginPath();\n    var x_scaled;\n    var y;\n    var delta_x_pxs;\n    if (data.length > 1) {\n        delta_x_pxs = _.map(data.slice(0, -1), function(d, i) {\n            return Math.ceil((data[i + 1][0] - data[i][0]) * w_scale);\n        });\n    } else {\n        delta_x_pxs = [10];\n    }\n\n    // Painter color can be in either block_color (FeatureTrack) or color pref (LineTrack).\n    var painter_color = this.prefs.block_color || this.prefs.color;\n\n    var // Extract RGB from preference color.\n    pref_color = parseInt(painter_color.slice(1), 16);\n\n    var pref_r = (pref_color & 0xff0000) >> 16;\n    var pref_g = (pref_color & 0x00ff00) >> 8;\n    var pref_b = pref_color & 0x0000ff;\n    var top_overflow = false;\n    var bot_overflow = false;\n\n    // Paint track.\n    var delta_x_px;\n    for (var i = 0, len = data.length; i < len; i++) {\n        // Reset attributes for next point.\n        ctx.fillStyle = ctx.strokeStyle = painter_color;\n        top_overflow = bot_overflow = false;\n        delta_x_px = delta_x_pxs[i];\n\n        x_scaled = Math.floor((data[i][0] - view_start - 0.5) * w_scale);\n        y = data[i][1];\n\n        // Process Y (scaler) value.\n        if (y === null) {\n            if (in_path && mode === \"Filled\") {\n                ctx.lineTo(x_scaled, height_px);\n            }\n            in_path = false;\n            continue;\n        }\n\n        // Bound Y value by min, max.\n        if (y < min_value) {\n            bot_overflow = true;\n            y = min_value;\n        } else if (y > max_value) {\n            top_overflow = true;\n            y = max_value;\n        }\n\n        // Draw point.\n        if (mode === \"Histogram\") {\n            // y becomes the bar height in pixels, which is the negated for canvas coords\n            y = Math.round(y / vertical_range * height_px);\n            ctx.fillRect(x_scaled, y_zero, delta_x_px, -y);\n        } else if (mode === \"Intensity\") {\n            var saturation = (y - min_value) / vertical_range;\n\n            var // Range is [pref_color, 255] where saturation = 0 --> 255 and saturation = 1 --> pref color\n            new_r = Math.round(pref_r + (255 - pref_r) * (1 - saturation));\n\n            var new_g = Math.round(pref_g + (255 - pref_g) * (1 - saturation));\n            var new_b = Math.round(pref_b + (255 - pref_b) * (1 - saturation));\n            ctx.fillStyle = \"rgb(\" + new_r + \",\" + new_g + \",\" + new_b + \")\";\n            ctx.fillRect(x_scaled, 0, delta_x_px, height_px);\n        } else {\n            // mode is Coverage/Line or Filled.\n\n            // Scale Y value.\n            y = Math.round(\n                height_px - (y - min_value) / vertical_range * height_px\n            );\n            if (in_path) {\n                ctx.lineTo(x_scaled, y);\n            } else {\n                in_path = true;\n                if (mode === \"Filled\") {\n                    ctx.moveTo(x_scaled, height_px);\n                    ctx.lineTo(x_scaled, y);\n                } else {\n                    ctx.moveTo(x_scaled, y);\n                    // Use this approach (note: same as for filled) to draw line from 0 to\n                    // first data point.\n                    //ctx.moveTo(x_scaled, height_px);\n                    //ctx.lineTo(x_scaled, y);\n                }\n            }\n        }\n\n        // Draw lines at boundaries if overflowing min or max\n        ctx.fillStyle = this.prefs.overflow_color;\n        if (top_overflow || bot_overflow) {\n            var overflow_x;\n            if (mode === \"Histogram\" || mode === \"Intensity\") {\n                overflow_x = delta_x_px;\n            } else {\n                // Line and Filled, which are points\n                x_scaled -= 2; // Move it over to the left so it's centered on the point\n                overflow_x = 4;\n            }\n            if (top_overflow) {\n                ctx.fillRect(x_scaled, 0, overflow_x, 3);\n            }\n            if (bot_overflow) {\n                ctx.fillRect(x_scaled, height_px - 3, overflow_x, 3);\n            }\n        }\n        ctx.fillStyle = painter_color;\n    }\n    if (mode === \"Filled\") {\n        if (in_path) {\n            ctx.lineTo(x_scaled, y_zero);\n            ctx.lineTo(0, y_zero);\n        }\n        ctx.fill();\n    } else {\n        ctx.stroke();\n    }\n\n    ctx.restore();\n};\n\n/**\n * Mapper that contains information about feature locations and data.\n */\nvar FeaturePositionMapper = function(slot_height) {\n    this.feature_positions = {};\n    this.slot_height = slot_height;\n    this.translation = 0;\n    this.y_translation = 0;\n};\n\n/**\n * Map feature data to a position defined by <slot, x_start, x_end>.\n */\nFeaturePositionMapper.prototype.map_feature_data = function(\n    feature_data,\n    slot,\n    x_start,\n    x_end\n) {\n    if (!this.feature_positions[slot]) {\n        this.feature_positions[slot] = [];\n    }\n    this.feature_positions[slot].push({\n        data: feature_data,\n        x_start: x_start,\n        x_end: x_end\n    });\n};\n\n/**\n * Get feature data for position <x, y>\n */\nFeaturePositionMapper.prototype.get_feature_data = function(x, y) {\n    // Find slot using Y.\n    var slot = Math.floor((y - this.y_translation) / this.slot_height);\n\n    var feature_dict;\n\n    // May not be over a slot due to padding, margin, etc.\n    if (!this.feature_positions[slot]) {\n        return null;\n    }\n\n    // Find feature using X.\n    x += this.translation;\n    for (var i = 0; i < this.feature_positions[slot].length; i++) {\n        feature_dict = this.feature_positions[slot][i];\n        if (x >= feature_dict.x_start && x <= feature_dict.x_end) {\n            return feature_dict.data;\n        }\n    }\n};\n\n/**\n * Abstract object for painting feature tracks. Subclasses must implement draw_element() for painting to work.\n * Painter uses a 0-based, half-open coordinate system; start coordinate is closed--included--and the end is open.\n * This coordinate system matches the BED format.\n */\nvar FeaturePainter = function(\n    data,\n    view_start,\n    view_end,\n    prefs,\n    mode,\n    alpha_scaler,\n    height_scaler\n) {\n    Painter.call(this, data, view_start, view_end, prefs, mode);\n    this.alpha_scaler = alpha_scaler ? alpha_scaler : new Scaler();\n    this.height_scaler = height_scaler ? height_scaler : new Scaler();\n    this.max_label_length = 200;\n};\n\nFeaturePainter.prototype.default_prefs = {\n    block_color: \"#FFF\",\n    connector_color: \"#FFF\"\n};\n\n_.extend(FeaturePainter.prototype, {\n    get_required_height: function(rows_required, width) {\n        // y_scale is the height per row\n        var required_height = this.get_row_height();\n\n        var y_scale = required_height;\n        var mode = this.mode;\n        // If using a packing mode, need to multiply by the number of slots used\n        if (mode === \"no_detail\" || mode === \"Squish\" || mode === \"Pack\") {\n            required_height = rows_required * y_scale;\n        }\n        return required_height + this.get_top_padding(width);\n    },\n\n    /** Extra padding before first row of features */\n    get_top_padding: function(width) {\n        return 0;\n    },\n\n    /**\n     * Draw data on ctx using slots and within the rectangle defined by width and height. Returns\n     * a FeaturePositionMapper object with information about where features were drawn.\n     */\n    draw: function(ctx, width, height, w_scale, slots) {\n        var data = this.data;\n        var view_start = this.view_start;\n        var view_end = this.view_end;\n\n        ctx.save();\n\n        ctx.fillStyle = this.prefs.block_color;\n        ctx.textAlign = \"right\";\n\n        var y_scale = this.get_row_height();\n        var feature_mapper = new FeaturePositionMapper(y_scale);\n        var x_draw_coords;\n        var incomplete_features = [];\n\n        for (var i = 0, len = data.length; i < len; i++) {\n            var feature = data[i];\n            var feature_uid = feature[0];\n            var feature_start = feature[1];\n            var feature_end = feature[2];\n\n            var // Slot valid only if features are slotted and this feature is slotted;\n            // feature may not be due to lack of space.\n            slot =\n                slots && slots[feature_uid] !== undefined\n                    ? slots[feature_uid].slot\n                    : null;\n\n            // Draw feature if (a) mode is dense or feature is slotted (as it must be for all non-dense modes) and\n            // (b) there's overlap between the feature and drawing region.\n            if (\n                (this.mode === \"Dense\" || slot !== null) &&\n                (feature_start < view_end && feature_end > view_start)\n            ) {\n                x_draw_coords = this.draw_element(\n                    ctx,\n                    this.mode,\n                    feature,\n                    slot,\n                    view_start,\n                    view_end,\n                    w_scale,\n                    y_scale,\n                    width\n                );\n                feature_mapper.map_feature_data(\n                    feature,\n                    slot,\n                    x_draw_coords[0],\n                    x_draw_coords[1]\n                );\n\n                // Add to incomplete features if it's not drawn completely in region.\n                if (feature_start < view_start || feature_end > view_end) {\n                    incomplete_features.push(feature);\n                }\n            }\n        }\n\n        ctx.restore();\n\n        feature_mapper.y_translation = this.get_top_padding(width);\n        return new DrawResults({\n            incomplete_features: incomplete_features,\n            feature_mapper: feature_mapper\n        });\n    },\n\n    /**\n     * Abstract function for drawing an individual feature.\n     */\n    draw_element: function(\n        ctx,\n        mode,\n        feature,\n        slot,\n        tile_low,\n        tile_high,\n        w_scale,\n        y_scale,\n        width\n    ) {\n        return [0, 0];\n    }\n});\n\n// Constants specific to feature tracks moved here (HACKING, these should\n// basically all be configuration options)\nvar DENSE_TRACK_HEIGHT = 10;\n\nvar NO_DETAIL_TRACK_HEIGHT = 3;\nvar SQUISH_TRACK_HEIGHT = 5;\nvar PACK_TRACK_HEIGHT = 10;\nvar NO_DETAIL_FEATURE_HEIGHT = 1;\nvar DENSE_FEATURE_HEIGHT = 9;\nvar SQUISH_FEATURE_HEIGHT = 3;\nvar PACK_FEATURE_HEIGHT = 9;\nvar LABEL_SPACING = 2;\nvar CONNECTOR_COLOR = \"#ccc\";\n\nvar LinkedFeaturePainter = function(\n    data,\n    view_start,\n    view_end,\n    prefs,\n    mode,\n    alpha_scaler,\n    height_scaler\n) {\n    FeaturePainter.call(\n        this,\n        data,\n        view_start,\n        view_end,\n        prefs,\n        mode,\n        alpha_scaler,\n        height_scaler\n    );\n    // Whether to draw a single connector in the background that spans the entire feature (the intron fishbone)\n    this.draw_background_connector = true;\n    // Whether to call draw_connector for every pair of blocks\n    this.draw_individual_connectors = false;\n};\n\n_.extend(LinkedFeaturePainter.prototype, FeaturePainter.prototype, {\n    /**\n     * Height of a single row, depends on mode\n     */\n    get_row_height: function() {\n        var mode = this.mode;\n        var height;\n        if (mode === \"Dense\") {\n            height = DENSE_TRACK_HEIGHT;\n        } else if (mode === \"no_detail\") {\n            height = NO_DETAIL_TRACK_HEIGHT;\n        } else if (mode === \"Squish\") {\n            height = SQUISH_TRACK_HEIGHT;\n        } else {\n            // mode === \"Pack\"\n            height = PACK_TRACK_HEIGHT;\n        }\n        return height;\n    },\n\n    /**\n     * Draw a feature. Returns an array with feature's start and end X coordinates.\n     */\n    draw_element: function(\n        ctx,\n        mode,\n        feature,\n        slot,\n        tile_low,\n        tile_high,\n        w_scale,\n        y_scale,\n        width\n    ) {\n        var feature_uid = feature[0];\n        var feature_start = feature[1];\n        var feature_end = feature[2];\n        var feature_name = feature[3];\n        var feature_strand = feature[4];\n\n        var // -0.5 to offset region between bases.\n        f_start = Math.floor(\n            Math.max(0, (feature_start - tile_low - 0.5) * w_scale)\n        );\n\n        var f_end = Math.ceil(\n            Math.min(\n                width,\n                Math.max(0, (feature_end - tile_low - 0.5) * w_scale)\n            )\n        );\n\n        var draw_start = f_start;\n        var draw_end = f_end;\n\n        var y_start =\n            (mode === \"Dense\" ? 0 : 0 + slot) * y_scale +\n            this.get_top_padding(width);\n\n        var thickness;\n        var y_start;\n        var thick_start = null;\n        var thick_end = null;\n\n        var // TODO: is there any reason why block, label color cannot be set at the Painter level?\n        // For now, assume '.' === '+'\n        block_color =\n            !feature_strand || feature_strand === \"+\" || feature_strand === \".\"\n                ? this.prefs.block_color\n                : this.prefs.reverse_strand_color;\n\n        var label_color = this.prefs.label_color;\n\n        // Set global alpha.\n        ctx.globalAlpha = this.alpha_scaler.gen_val(feature);\n\n        // In dense mode, put all data in top slot.\n        if (mode === \"Dense\") {\n            slot = 1;\n        }\n\n        if (mode === \"no_detail\") {\n            // No details for feature, so only one way to display.\n            ctx.fillStyle = block_color;\n            ctx.fillRect(\n                f_start,\n                y_start + 5,\n                f_end - f_start,\n                NO_DETAIL_FEATURE_HEIGHT\n            );\n        } else {\n            // Mode is either Squish or Pack:\n            // Feature details.\n            var feature_ts = feature[5];\n\n            var feature_te = feature[6];\n            var feature_blocks = feature[7];\n\n            var // Whether we are drawing full height or squished features\n            full_height = true;\n\n            if (feature_ts && feature_te) {\n                thick_start = Math.floor(\n                    Math.max(0, (feature_ts - tile_low) * w_scale)\n                );\n                thick_end = Math.ceil(\n                    Math.min(\n                        width,\n                        Math.max(0, (feature_te - tile_low) * w_scale)\n                    )\n                );\n            }\n\n            // Set vars that depend on mode.\n            var thin_height;\n\n            var thick_height;\n            if (mode === \"Squish\") {\n                thin_height = 1;\n                thick_height = SQUISH_FEATURE_HEIGHT;\n                full_height = false;\n            } else if (mode === \"Dense\") {\n                thin_height = 5;\n                thick_height = DENSE_FEATURE_HEIGHT;\n            } else {\n                // mode === \"Pack\"\n                thin_height = 5;\n                thick_height = PACK_FEATURE_HEIGHT;\n            }\n\n            // Draw feature/feature blocks + connectors.\n            if (!feature_blocks) {\n                // If there are no blocks, treat the feature as one big exon.\n                ctx.fillStyle = block_color;\n                ctx.fillRect(\n                    f_start,\n                    y_start + 1,\n                    f_end - f_start,\n                    thick_height\n                );\n                // If strand is specified, draw arrows over feature\n                if (feature_strand && full_height) {\n                    if (feature_strand === \"+\") {\n                        ctx.fillStyle = ctx.canvas.manager.get_pattern(\n                            \"right_strand_inv\"\n                        );\n                    } else if (feature_strand === \"-\") {\n                        ctx.fillStyle = ctx.canvas.manager.get_pattern(\n                            \"left_strand_inv\"\n                        );\n                    }\n                    ctx.fillRect(\n                        f_start,\n                        y_start + 1,\n                        f_end - f_start,\n                        thick_height\n                    );\n                }\n            } else {\n                //\n                // There are feature blocks and mode is either Squish or Pack.\n                //\n                // Approach: (a) draw whole feature as connector/intron and (b) draw blocks as\n                // needed. This ensures that whole feature, regardless of whether it starts with\n                // a block, is visible.\n                //\n\n                // Compute y axis start position and height\n                var cur_y_start;\n\n                var cur_height;\n                if (mode === \"Squish\" || mode === \"Dense\") {\n                    cur_y_start =\n                        y_start + Math.floor(SQUISH_FEATURE_HEIGHT / 2) + 1;\n                    cur_height = 1;\n                } else {\n                    // mode === \"Pack\"\n                    if (feature_strand) {\n                        cur_y_start = y_start;\n                        cur_height = thick_height;\n                    } else {\n                        cur_y_start += SQUISH_FEATURE_HEIGHT / 2 + 1;\n                        cur_height = 1;\n                    }\n                }\n\n                // Draw whole feature as connector/intron.\n                if (this.draw_background_connector) {\n                    if (mode === \"Squish\" || mode === \"Dense\") {\n                        ctx.fillStyle = CONNECTOR_COLOR;\n                    } else {\n                        // mode === \"Pack\"\n                        if (feature_strand) {\n                            if (feature_strand === \"+\") {\n                                ctx.fillStyle = ctx.canvas.manager.get_pattern(\n                                    \"right_strand\"\n                                );\n                            } else if (feature_strand === \"-\") {\n                                ctx.fillStyle = ctx.canvas.manager.get_pattern(\n                                    \"left_strand\"\n                                );\n                            }\n                        } else {\n                            ctx.fillStyle = CONNECTOR_COLOR;\n                        }\n                    }\n                    ctx.fillRect(\n                        f_start,\n                        cur_y_start,\n                        f_end - f_start,\n                        cur_height\n                    );\n                }\n\n                // Draw blocks.\n                var start_and_height;\n                for (var k = 0, k_len = feature_blocks.length; k < k_len; k++) {\n                    var block = feature_blocks[k];\n\n                    var // -0.5 to offset block between bases.\n                    block_start = Math.floor(\n                        Math.max(0, (block[0] - tile_low - 0.5) * w_scale)\n                    );\n\n                    var block_end = Math.ceil(\n                        Math.min(\n                            width,\n                            Math.max((block[1] - tile_low - 0.5) * w_scale)\n                        )\n                    );\n\n                    var last_block_start;\n                    var last_block_end;\n\n                    // Skip drawing if block not on tile.\n                    if (block_start > block_end) {\n                        continue;\n                    }\n\n                    // Draw thin block.\n                    ctx.fillStyle = block_color;\n                    ctx.fillRect(\n                        block_start,\n                        y_start + (thick_height - thin_height) / 2 + 1,\n                        block_end - block_start,\n                        thin_height\n                    );\n\n                    // If block intersects with thick region, draw block as thick.\n                    // - No thick is sometimes encoded as thick_start == thick_end, so don't draw in that case\n                    if (\n                        thick_start !== undefined &&\n                        feature_te > feature_ts &&\n                        !(block_start > thick_end || block_end < thick_start)\n                    ) {\n                        var block_thick_start = Math.max(\n                            block_start,\n                            thick_start\n                        );\n\n                        var block_thick_end = Math.min(block_end, thick_end);\n                        ctx.fillRect(\n                            block_thick_start,\n                            y_start + 1,\n                            block_thick_end - block_thick_start,\n                            thick_height\n                        );\n                        if (feature_blocks.length === 1 && mode === \"Pack\") {\n                            // Exactly one block means we have no introns, but do have a distinct \"thick\" region,\n                            // draw arrows over it if in pack mode.\n                            if (feature_strand === \"+\") {\n                                ctx.fillStyle = ctx.canvas.manager.get_pattern(\n                                    \"right_strand_inv\"\n                                );\n                            } else if (feature_strand === \"-\") {\n                                ctx.fillStyle = ctx.canvas.manager.get_pattern(\n                                    \"left_strand_inv\"\n                                );\n                            }\n                            // If region is wide enough in pixels, pad a bit\n                            if (block_thick_start + 14 < block_thick_end) {\n                                block_thick_start += 2;\n                                block_thick_end -= 2;\n                            }\n                            ctx.fillRect(\n                                block_thick_start,\n                                y_start + 1,\n                                block_thick_end - block_thick_start,\n                                thick_height\n                            );\n                        }\n                    }\n                    // Draw individual connectors if required\n                    if (this.draw_individual_connectors && last_block_start) {\n                        this.draw_connector(\n                            ctx,\n                            last_block_start,\n                            last_block_end,\n                            block_start,\n                            block_end,\n                            y_start\n                        );\n                    }\n                    last_block_start = block_start;\n                    last_block_end = block_end;\n                }\n\n                // FIXME: Height scaling only works in Pack mode right now.\n                if (mode === \"Pack\") {\n                    // Reset alpha so height scaling is not impacted by alpha scaling.\n                    ctx.globalAlpha = 1;\n\n                    // Height scaling: draw white lines to reduce height according to height scale factor.\n                    ctx.fillStyle = \"white\"; // TODO: set this to background color.\n                    var hscale_factor = this.height_scaler.gen_val(feature);\n\n                    var // Ceil ensures that min height is >= 1.\n                    new_height = Math.ceil(thick_height * hscale_factor);\n\n                    var ws_height = Math.round((thick_height - new_height) / 2);\n                    if (hscale_factor !== 1) {\n                        ctx.fillRect(\n                            f_start,\n                            cur_y_start + 1,\n                            f_end - f_start,\n                            ws_height\n                        );\n                        ctx.fillRect(\n                            f_start,\n                            cur_y_start + thick_height - ws_height + 1,\n                            f_end - f_start,\n                            ws_height\n                        );\n                    }\n                }\n            }\n\n            // Reset alpha so that label is not transparent.\n            ctx.globalAlpha = 1;\n\n            // Draw label for Pack mode.\n            if (feature_name && mode === \"Pack\" && feature_start > tile_low) {\n                ctx.fillStyle = label_color;\n                // FIXME: assumption here that the entire view starts at 0\n                if (\n                    tile_low === 0 &&\n                    f_start - ctx.measureText(feature_name).width < 0\n                ) {\n                    ctx.textAlign = \"left\";\n                    ctx.fillText(\n                        feature_name,\n                        f_end + LABEL_SPACING,\n                        y_start + 8,\n                        this.max_label_length\n                    );\n                    draw_end +=\n                        ctx.measureText(feature_name).width + LABEL_SPACING;\n                } else {\n                    ctx.textAlign = \"right\";\n                    ctx.fillText(\n                        feature_name,\n                        f_start - LABEL_SPACING,\n                        y_start + 8,\n                        this.max_label_length\n                    );\n                    draw_start -=\n                        ctx.measureText(feature_name).width + LABEL_SPACING;\n                }\n                //ctx.fillStyle = block_color;\n            }\n        }\n\n        // Reset global alpha.\n        ctx.globalAlpha = 1;\n\n        return [draw_start, draw_end];\n    }\n});\n\nvar ReadPainter = function(\n    data,\n    view_start,\n    view_end,\n    prefs,\n    mode,\n    alpha_scaler,\n    height_scaler,\n    ref_seq,\n    base_color_fn\n) {\n    FeaturePainter.call(\n        this,\n        data,\n        view_start,\n        view_end,\n        prefs,\n        mode,\n        alpha_scaler,\n        height_scaler\n    );\n    this.ref_seq = ref_seq ? ref_seq.data : null;\n    this.base_color_fn = base_color_fn;\n};\n\n_.extend(ReadPainter.prototype, FeaturePainter.prototype, {\n    /**\n     * Returns height based on mode.\n     */\n    get_row_height: function() {\n        var height;\n        var mode = this.mode;\n        if (mode === \"Dense\") {\n            height = DENSE_TRACK_HEIGHT;\n        } else if (mode === \"Squish\") {\n            height = SQUISH_TRACK_HEIGHT;\n        } else {\n            // mode === \"Pack\"\n            height = PACK_TRACK_HEIGHT;\n            if (this.prefs.show_insertions) {\n                height *= 2;\n            }\n        }\n        return height;\n    },\n\n    /**\n     * Parse CIGAR string to get (a) a list of contiguous drawing blocks (MD=X) and\n     * (b) an array of [ op_index, op_len ] pairs where op_index is an index into the\n     * string 'MIDNSHP=X' Return value is a dictionary with two entries, blocks and cigar\n     */\n    _parse_cigar: function(cigar_str) {\n        var cigar_ops = \"MIDNSHP=X\";\n\n        // Parse cigar.\n        var blocks = [[0, 0]];\n\n        var cur_block = blocks[0];\n        var base_pos = 0;\n\n        var // Parse cigar operations out and update/create blocks as needed.\n        parsed_cigar = _.map(cigar_str.match(/[0-9]+[MIDNSHP=X]/g), function(\n            op\n        ) {\n            // Get operation length, character.\n            var op_len = parseInt(op.slice(0, -1), 10),\n                op_char = op.slice(-1);\n\n            // Update drawing block.\n            if (op_char === \"N\") {\n                // At skip, so need to start new block if current block represents\n                // drawing area.\n                if (cur_block[1] !== 0) {\n                    cur_block = [base_pos + op_len, base_pos + op_len];\n                    blocks.push(cur_block);\n                }\n            } else if (\"ISHP\".indexOf(op_char) === -1) {\n                // Operation is M,D,=,X.\n                cur_block[1] += op_len;\n                base_pos += op_len;\n            }\n\n            // Return parsed cigar.\n            return [cigar_ops.indexOf(op_char), op_len];\n        });\n\n        return {\n            blocks: blocks,\n            cigar: parsed_cigar\n        };\n    },\n\n    /**\n     * Draw a single read from reference-based read sequence and cigar.\n     */\n    draw_read: function(\n        ctx,\n        mode,\n        w_scale,\n        y_start,\n        tile_low,\n        tile_high,\n        feature_start,\n        cigar,\n        strand,\n        read_seq\n    ) {\n        // Helper function to update base and sequnence offsets.\n        var update_base_offset = function(offset, cig_op, cig_len) {\n            if (\"M=NXD\".indexOf(cig_op) !== -1) {\n                offset += cig_len;\n            }\n            return offset;\n        };\n\n        var update_seq_offset = function(offset, cig_op, cig_len) {\n            if (\"IX\".indexOf(cig_op) !== -1) {\n                offset += cig_len;\n            }\n            return offset;\n        };\n\n        var // Gets drawing coordinate for a sequence coordinate. Assumes closure variables w_scale and tile_low.\n        get_draw_coord = function(sequence_coord) {\n            // -0.5 to offset sequence between bases.\n            return Math.floor(\n                Math.max(0, (sequence_coord - tile_low - 0.5) * w_scale)\n            );\n        };\n\n        ctx.textAlign = \"center\";\n        var tile_region = [tile_low, tile_high];\n        var base_offset = 0;\n        var seq_offset = 0;\n        var gap = Math.round(w_scale / 2);\n        var char_width_px = ctx.canvas.manager.char_width_px;\n\n        var block_color =\n            strand === \"+\"\n                ? this.prefs.detail_block_color\n                : this.prefs.reverse_strand_color;\n\n        var pack_mode = mode === \"Pack\";\n\n        var draw_height = pack_mode\n            ? PACK_FEATURE_HEIGHT\n            : SQUISH_FEATURE_HEIGHT;\n\n        var rect_y = y_start + 1;\n        var paint_utils = new ReadPainterUtils(ctx, draw_height, w_scale, mode);\n        var drawing_blocks = [];\n        var s_start;\n        var s_end;\n\n        // Keep list of items that need to be drawn on top of initial drawing layer.\n        var draw_last = [];\n\n        // Parse cigar and get drawing blocks.\n        var t = this._parse_cigar(cigar);\n        cigar = t.cigar;\n        drawing_blocks = t.blocks;\n\n        // Draw blocks.\n        for (var i = 0; i < drawing_blocks.length; i++) {\n            var block = drawing_blocks[i];\n\n            if (\n                is_overlap(\n                    [feature_start + block[0], feature_start + block[1]],\n                    tile_region\n                )\n            ) {\n                s_start = get_draw_coord(feature_start + block[0]);\n                s_end = get_draw_coord(feature_start + block[1]);\n\n                // Make sure that block is drawn even if it too small to be rendered officially; in this case,\n                // read is drawn at 1px.\n                // TODO: need to ensure that s_start, s_end are calculated the same for both slotting\n                // and drawing.\n                if (s_start === s_end) {\n                    s_end += 1;\n                }\n\n                // Draw read base as rectangle.\n                ctx.fillStyle = block_color;\n                ctx.fillRect(s_start, rect_y, s_end - s_start, draw_height);\n            }\n        }\n\n        // Draw read features.\n        for (var cig_id = 0, len = cigar.length; cig_id < len; cig_id++) {\n            var cig = cigar[cig_id];\n            var cig_op = \"MIDNSHP=X\"[cig[0]];\n            var cig_len = cig[1];\n\n            var seq_start = feature_start + base_offset;\n            s_start = get_draw_coord(seq_start);\n            s_end = get_draw_coord(seq_start + cig_len);\n\n            // Skip feature if it's not in tile.\n            if (!is_overlap([seq_start, seq_start + cig_len], tile_region)) {\n                // Update offsets.\n                base_offset = update_base_offset(base_offset, cig_op, cig_len);\n                seq_offset = update_seq_offset(seq_offset, cig_op, cig_len);\n                continue;\n            }\n\n            // Make sure that read is drawn even if it too small to be rendered officially; in this case,\n            // read is drawn at 1px.\n            // TODO: need to ensure that s_start, s_end are calculated the same for both slotting\n            // and drawing.\n            if (s_start === s_end) {\n                s_end += 1;\n            }\n\n            // Draw read feature.\n            switch (cig_op) {\n                case \"H\": // Hard clipping.\n                case \"S\": // Soft clipping.\n                case \"P\": // Padding.\n                    // Sequence not present and not related to alignment; do nothing.\n                    break;\n                case \"M\": // \"Match\".\n                    // Because it's not known whether there is a match, ignore.\n                    base_offset += cig_len;\n                    break;\n                case \"=\": // Match with reference.\n                case \"X\": // Mismatch with reference.\n                    //\n                    // Draw sequence and/or variants.\n                    //\n\n                    // Get sequence to draw.\n                    var cur_seq = \"\";\n                    if (cig_op === \"X\") {\n                        // Get sequence from read_seq.\n                        cur_seq = read_seq.slice(\n                            seq_offset,\n                            seq_offset + cig_len\n                        );\n                    } else if (this.ref_seq) {\n                        // && cig_op === '='\n                        // Use reference sequence.\n                        cur_seq = this.ref_seq.slice(\n                            // If read starts after tile start, slice at read start.\n                            Math.max(0, seq_start - tile_low),\n                            // If read ends before tile end, slice at read end.\n                            Math.min(\n                                seq_start - tile_low + cig_len,\n                                tile_high - tile_low\n                            )\n                        );\n                    }\n\n                    // Draw sequence. Because cur_seq starts and read/tile start, go to there to start writing.\n                    var start_pos = Math.max(seq_start, tile_low);\n                    for (var c = 0; c < cur_seq.length; c++) {\n                        // Draw base if showing all (i.e. not showing differences) or there is a mismatch.\n                        if (\n                            (cur_seq && !this.prefs.show_differences) ||\n                            cig_op === \"X\"\n                        ) {\n                            // Draw base.\n                            var c_start = Math.floor(\n                                Math.max(\n                                    0,\n                                    (start_pos + c - tile_low) * w_scale\n                                )\n                            );\n                            ctx.fillStyle = this.base_color_fn(cur_seq[c]);\n                            if (pack_mode && w_scale > char_width_px) {\n                                ctx.fillText(cur_seq[c], c_start, y_start + 9);\n                            } else if (w_scale > 0.05) {\n                                // Require a minimum w_scale so that variants are only drawn when somewhat zoomed in.\n                                ctx.fillRect(\n                                    c_start - gap,\n                                    rect_y,\n                                    Math.max(1, Math.round(w_scale)),\n                                    draw_height\n                                );\n                            }\n                        }\n                    }\n\n                    // Move forward in sequence only if sequence used to get mismatches.\n                    if (cig_op === \"X\") {\n                        seq_offset += cig_len;\n                    }\n                    base_offset += cig_len;\n\n                    break;\n                case \"N\": // Skipped bases.\n                    ctx.fillStyle = CONNECTOR_COLOR;\n                    ctx.fillRect(\n                        s_start,\n                        rect_y + (draw_height - 1) / 2,\n                        s_end - s_start,\n                        1\n                    );\n                    // No change in seq_offset because sequence not used when skipping.\n                    base_offset += cig_len;\n                    break;\n                case \"D\": // Deletion.\n                    paint_utils.draw_deletion(s_start, rect_y, cig_len);\n                    base_offset += cig_len;\n                    break;\n                case \"I\": // Insertion.\n                    // Check to see if sequence should be drawn at all by looking at the overlap between\n                    // the sequence region and the tile region.\n                    var insert_x_coord = s_start - gap;\n\n                    if (\n                        is_overlap(\n                            [seq_start, seq_start + cig_len],\n                            tile_region\n                        )\n                    ) {\n                        var seq = read_seq.slice(\n                            seq_offset,\n                            seq_offset + cig_len\n                        );\n                        // Insertion point is between the sequence start and the previous base: (-gap) moves\n                        // back from sequence start to insertion point.\n                        if (this.prefs.show_insertions) {\n                            //\n                            // Show inserted sequence above, centered on insertion point.\n                            //\n\n                            // Draw sequence.\n                            // X center is offset + start - <half_sequence_length>\n                            var x_center = s_start - (s_end - s_start) / 2;\n                            if (\n                                (mode === \"Pack\" || this.mode === \"Auto\") &&\n                                read_seq !== undefined &&\n                                w_scale > char_width_px\n                            ) {\n                                // Draw sequence container.\n                                ctx.fillStyle = \"yellow\";\n                                ctx.fillRect(\n                                    x_center - gap,\n                                    y_start - 9,\n                                    s_end - s_start,\n                                    9\n                                );\n                                draw_last[draw_last.length] = {\n                                    type: \"triangle\",\n                                    data: [insert_x_coord, y_start + 4, 5]\n                                };\n                                ctx.fillStyle = CONNECTOR_COLOR;\n                                // Based on overlap b/t sequence and tile, get sequence to be drawn.\n                                switch (compute_overlap(\n                                    [seq_start, seq_start + cig_len],\n                                    tile_region\n                                )) {\n                                    case OVERLAP_START:\n                                        seq = seq.slice(tile_low - seq_start);\n                                        break;\n                                    case OVERLAP_END:\n                                        seq = seq.slice(\n                                            0,\n                                            seq_start - tile_high\n                                        );\n                                        break;\n                                    case CONTAINED_BY:\n                                        // All of sequence drawn.\n                                        break;\n                                    case CONTAINS:\n                                        seq = seq.slice(\n                                            tile_low - seq_start,\n                                            seq_start - tile_high\n                                        );\n                                        break;\n                                }\n                                // Draw sequence.\n                                for (\n                                    var c = 0, str_len = seq.length;\n                                    c < str_len;\n                                    c++\n                                ) {\n                                    var c_start = Math.floor(\n                                        Math.max(\n                                            0,\n                                            (seq_start + c - tile_low) * w_scale\n                                        )\n                                    );\n                                    ctx.fillText(\n                                        seq[c],\n                                        c_start - (s_end - s_start) / 2,\n                                        y_start\n                                    );\n                                }\n                            } else {\n                                // Draw block.\n                                ctx.fillStyle = \"yellow\";\n                                // TODO: This is a pretty hack-ish way to fill rectangle based on mode.\n                                ctx.fillRect(\n                                    x_center,\n                                    y_start + (this.mode !== \"Dense\" ? 2 : 5),\n                                    s_end - s_start,\n                                    mode !== \"Dense\"\n                                        ? SQUISH_FEATURE_HEIGHT\n                                        : DENSE_FEATURE_HEIGHT\n                                );\n                            }\n                        } else {\n                            if (\n                                (mode === \"Pack\" || this.mode === \"Auto\") &&\n                                read_seq !== undefined &&\n                                w_scale > char_width_px\n                            ) {\n                                // Show insertions with a single number at the insertion point.\n                                draw_last.push({\n                                    type: \"text\",\n                                    data: [\n                                        seq.length,\n                                        insert_x_coord,\n                                        y_start + 9\n                                    ]\n                                });\n                            } else {\n                                // TODO: probably can merge this case with code above.\n                            }\n                        }\n                    }\n                    seq_offset += cig_len;\n                    // No change to base offset because insertions are drawn above sequence/read.\n                    break;\n            }\n        }\n\n        //\n        // Draw last items.\n        //\n        ctx.fillStyle = \"yellow\";\n        var item;\n        var type;\n        var data;\n        for (var i = 0; i < draw_last.length; i++) {\n            item = draw_last[i];\n            type = item.type;\n            data = item.data;\n            if (type === \"text\") {\n                ctx.save();\n                ctx.font = \"bold \" + ctx.font;\n                ctx.fillText(data[0], data[1], data[2]);\n                ctx.restore();\n            } else if (type === \"triangle\") {\n                drawDownwardEquilateralTriangle(ctx, data[0], data[1], data[2]);\n            }\n        }\n    },\n\n    /**\n     * Draw a complete read pair\n     */\n    draw_element: function(\n        ctx,\n        mode,\n        feature,\n        slot,\n        tile_low,\n        tile_high,\n        w_scale,\n        y_scale,\n        width\n    ) {\n        // All features need a start, end, and vertical center.\n        var feature_uid = feature[0];\n\n        var feature_start = feature[1];\n        var feature_end = feature[2];\n        var feature_name = feature[3];\n\n        var // -0.5 to put element between bases.\n        f_start = Math.floor(\n            Math.max(-0.5 * w_scale, (feature_start - tile_low - 0.5) * w_scale)\n        );\n\n        var f_end = Math.ceil(\n            Math.min(\n                width,\n                Math.max(0, (feature_end - tile_low - 0.5) * w_scale)\n            )\n        );\n\n        var y_start = (mode === \"Dense\" ? 0 : 0 + slot) * y_scale;\n\n        var draw_height =\n            mode === \"Pack\" ? PACK_FEATURE_HEIGHT : SQUISH_FEATURE_HEIGHT;\n\n        var label_color = this.prefs.label_color;\n\n        // Draw read.\n        if (feature[5] instanceof Array) {\n            // Read is paired.\n            var connector = true;\n\n            // Draw left/forward read.\n            if (\n                feature[4][1] >= tile_low &&\n                feature[4][0] <= tile_high &&\n                feature[4][2]\n            ) {\n                this.draw_read(\n                    ctx,\n                    mode,\n                    w_scale,\n                    y_start,\n                    tile_low,\n                    tile_high,\n                    feature[4][0],\n                    feature[4][2],\n                    feature[4][3],\n                    feature[4][4]\n                );\n            } else {\n                connector = false;\n            }\n\n            // Draw right/reverse read.\n            if (\n                feature[5][1] >= tile_low &&\n                feature[5][0] <= tile_high &&\n                feature[5][2]\n            ) {\n                this.draw_read(\n                    ctx,\n                    mode,\n                    w_scale,\n                    y_start,\n                    tile_low,\n                    tile_high,\n                    feature[5][0],\n                    feature[5][2],\n                    feature[5][3],\n                    feature[5][4]\n                );\n            } else {\n                connector = false;\n            }\n\n            // Draw connector if both reads were drawn.\n            // TODO: currently, there is no way to connect reads drawn on different tiles; to connect reads on different tiles, data manager\n            // code is needed to join mate pairs from different regions. Alternatively, requesting multiple regions of data at once would\n            // make it possible to put together more easily.\n            // -0.5 to position connector correctly between reads.\n            var b1_end = Math.ceil(\n                Math.min(\n                    width,\n                    Math.max(\n                        -0.5 * w_scale,\n                        (feature[4][1] - tile_low - 0.5) * w_scale\n                    )\n                )\n            );\n\n            var b2_start = Math.floor(\n                Math.max(\n                    -0.5 * w_scale,\n                    (feature[5][0] - tile_low - 0.5) * w_scale\n                )\n            );\n\n            if (connector && b2_start > b1_end) {\n                ctx.fillStyle = CONNECTOR_COLOR;\n                var line_height = y_start + 1 + (draw_height - 1) / 2;\n                dashedLine(ctx, b1_end, line_height, b2_start, line_height);\n            }\n        } else {\n            // Read is single.\n            this.draw_read(\n                ctx,\n                mode,\n                w_scale,\n                y_start,\n                tile_low,\n                tile_high,\n                feature_start,\n                feature[4],\n                feature[5],\n                feature[6]\n            );\n        }\n        if (\n            mode === \"Pack\" &&\n            feature_start >= tile_low &&\n            feature_name !== \".\"\n        ) {\n            // Draw label.\n            ctx.fillStyle = this.prefs.label_color;\n            if (\n                tile_low === 0 &&\n                f_start - ctx.measureText(feature_name).width < 0\n            ) {\n                ctx.textAlign = \"left\";\n                ctx.fillText(\n                    feature_name,\n                    f_end + LABEL_SPACING,\n                    y_start + 9,\n                    this.max_label_length\n                );\n            } else {\n                ctx.textAlign = \"right\";\n                ctx.fillText(\n                    feature_name,\n                    f_start - LABEL_SPACING,\n                    y_start + 9,\n                    this.max_label_length\n                );\n            }\n        }\n\n        // FIXME: provide actual coordinates for drawn read.\n        return [0, 0];\n    }\n});\n\nvar ArcLinkedFeaturePainter = function(\n    data,\n    view_start,\n    view_end,\n    prefs,\n    mode,\n    alpha_scaler,\n    height_scaler\n) {\n    LinkedFeaturePainter.call(\n        this,\n        data,\n        view_start,\n        view_end,\n        prefs,\n        mode,\n        alpha_scaler,\n        height_scaler\n    );\n    // Need to know the longest feature length for adding spacing\n    this.longest_feature_length = this.calculate_longest_feature_length();\n    this.draw_background_connector = false;\n    this.draw_individual_connectors = true;\n};\n\n_.extend(\n    ArcLinkedFeaturePainter.prototype,\n    FeaturePainter.prototype,\n    LinkedFeaturePainter.prototype,\n    {\n        calculate_longest_feature_length: function() {\n            var longest_feature_length = 0;\n            for (var i = 0, len = this.data.length; i < len; i++) {\n                var feature = this.data[i];\n                var feature_start = feature[1];\n                var feature_end = feature[2];\n                longest_feature_length = Math.max(\n                    longest_feature_length,\n                    feature_end - feature_start\n                );\n            }\n            return longest_feature_length;\n        },\n\n        get_top_padding: function(width) {\n            var view_range = this.view_end - this.view_start;\n            var w_scale = width / view_range;\n            return Math.min(\n                128,\n                Math.ceil(this.longest_feature_length / 2 * w_scale)\n            );\n        },\n\n        draw_connector: function(\n            ctx,\n            block1_start,\n            block1_end,\n            block2_start,\n            block2_end,\n            y_start\n        ) {\n            // Arc drawing -- from closest endpoints\n            var x_center = (block1_end + block2_start) / 2;\n\n            var radius = block2_start - x_center;\n\n            // For full half circles\n            var angle1 = Math.PI;\n\n            var angle2 = 0;\n            if (radius > 0) {\n                ctx.beginPath();\n                ctx.arc(x_center, y_start, block2_start - x_center, Math.PI, 0);\n                ctx.stroke();\n            }\n        }\n    }\n);\n\n// Color stuff from less.js\n\nvar Color = function(rgb, a) {\n    /**\n     * The end goal here, is to parse the arguments\n     * into an integer triplet, such as `128, 255, 0`\n     *\n     * This facilitates operations and conversions.\n     */\n    if (Array.isArray(rgb)) {\n        this.rgb = rgb;\n    } else if (rgb.length == 6) {\n        this.rgb = rgb.match(/.{2}/g).map(function(c) {\n            return parseInt(c, 16);\n        });\n    } else if (rgb.length == 7) {\n        this.rgb = rgb\n            .substring(1, 7)\n            .match(/.{2}/g)\n            .map(function(c) {\n                return parseInt(c, 16);\n            });\n    } else {\n        this.rgb = rgb.split(\"\").map(function(c) {\n            return parseInt(c + c, 16);\n        });\n    }\n    this.alpha = typeof a === \"number\" ? a : 1;\n};\nColor.prototype = {\n    eval: function() {\n        return this;\n    },\n\n    //\n    // If we have some transparency, the only way to represent it\n    // is via `rgba`. Otherwise, we use the hex representation,\n    // which has better compatibility with older browsers.\n    // Values are capped between `0` and `255`, rounded and zero-padded.\n    //\n    toCSS: function() {\n        if (this.alpha < 1.0) {\n            return (\n                \"rgba(\" +\n                this.rgb\n                    .map(function(c) {\n                        return Math.round(c);\n                    })\n                    .concat(this.alpha)\n                    .join(\", \") +\n                \")\"\n            );\n        } else {\n            return (\n                \"#\" +\n                this.rgb\n                    .map(function(i) {\n                        i = Math.round(i);\n                        i = (i > 255 ? 255 : i < 0 ? 0 : i).toString(16);\n                        return i.length === 1 ? \"0\" + i : i;\n                    })\n                    .join(\"\")\n            );\n        }\n    },\n\n    toHSL: function() {\n        var r = this.rgb[0] / 255;\n        var g = this.rgb[1] / 255;\n        var b = this.rgb[2] / 255;\n        var a = this.alpha;\n        var max = Math.max(r, g, b);\n        var min = Math.min(r, g, b);\n        var h;\n        var s;\n        var l = (max + min) / 2;\n        var d = max - min;\n\n        if (max === min) {\n            h = s = 0;\n        } else {\n            s = l > 0.5 ? d / (2 - max - min) : d / (max + min);\n\n            switch (max) {\n                case r:\n                    h = (g - b) / d + (g < b ? 6 : 0);\n                    break;\n                case g:\n                    h = (b - r) / d + 2;\n                    break;\n                case b:\n                    h = (r - g) / d + 4;\n                    break;\n            }\n            h /= 6;\n        }\n        return { h: h * 360, s: s, l: l, a: a };\n    },\n\n    toARGB: function() {\n        var argb = [Math.round(this.alpha * 255)].concat(this.rgb);\n        return (\n            \"#\" +\n            argb\n                .map(function(i) {\n                    i = Math.round(i);\n                    i = (i > 255 ? 255 : i < 0 ? 0 : i).toString(16);\n                    return i.length === 1 ? \"0\" + i : i;\n                })\n                .join(\"\")\n        );\n    },\n\n    mix: function(color2, weight) {\n        var color1 = this;\n\n        var p = weight; // .value / 100.0;\n        var w = p * 2 - 1;\n        var a = color1.toHSL().a - color2.toHSL().a;\n\n        var w1 = ((w * a == -1 ? w : (w + a) / (1 + w * a)) + 1) / 2.0;\n        var w2 = 1 - w1;\n\n        var rgb = [\n            color1.rgb[0] * w1 + color2.rgb[0] * w2,\n            color1.rgb[1] * w1 + color2.rgb[1] * w2,\n            color1.rgb[2] * w1 + color2.rgb[2] * w2\n        ];\n\n        var alpha = color1.alpha * p + color2.alpha * (1 - p);\n\n        return new Color(rgb, alpha);\n    }\n};\n\n// End colors from less.js\n\nvar LinearRamp = function(start_color, end_color, start_value, end_value) {\n    /**\n     * Simple linear gradient\n     */\n    this.start_color = new Color(start_color);\n    this.end_color = new Color(end_color);\n    this.start_value = start_value;\n    this.end_value = end_value;\n    this.value_range = end_value - start_value;\n};\n\nLinearRamp.prototype.map_value = function(value) {\n    value = Math.max(value, this.start_value);\n    value = Math.min(value, this.end_value);\n    value = (value - this.start_value) / this.value_range;\n    // HACK: just red for now\n    // return \"hsl(0,100%,\" + (value * 100) + \"%)\"\n    return this.start_color.mix(this.end_color, 1 - value).toCSS();\n};\n\nvar SplitRamp = function(\n    start_color,\n    middle_color,\n    end_color,\n    start_value,\n    end_value\n) {\n    /**\n     * Two gradients split away from 0\n     */\n    this.positive_ramp = new LinearRamp(middle_color, end_color, 0, end_value);\n    this.negative_ramp = new LinearRamp(\n        middle_color,\n        start_color,\n        0,\n        -start_value\n    );\n    this.start_value = start_value;\n    this.end_value = end_value;\n};\n\nSplitRamp.prototype.map_value = function(value) {\n    value = Math.max(value, this.start_value);\n    value = Math.min(value, this.end_value);\n    if (value >= 0) {\n        return this.positive_ramp.map_value(value);\n    } else {\n        return this.negative_ramp.map_value(-value);\n    }\n};\n\nvar DiagonalHeatmapPainter = function(data, view_start, view_end, prefs, mode) {\n    Painter.call(this, data, view_start, view_end, prefs, mode);\n    var i;\n    var len;\n\n    if (this.prefs.min_value === undefined) {\n        var min_value = Infinity;\n        for (i = 0, len = this.data.length; i < len; i++) {\n            min_value = Math.min(min_value, this.data[i][6]);\n        }\n        this.prefs.min_value = min_value;\n    }\n    if (this.prefs.max_value === undefined) {\n        var max_value = -Infinity;\n        for (i = 0, len = this.data.length; i < len; i++) {\n            max_value = Math.max(max_value, this.data[i][6]);\n        }\n        this.prefs.max_value = max_value;\n    }\n};\n\nDiagonalHeatmapPainter.prototype.default_prefs = {\n    min_value: undefined,\n    max_value: undefined,\n    mode: \"Heatmap\",\n    pos_color: \"#FF8C00\",\n    neg_color: \"#4169E1\"\n};\n\nDiagonalHeatmapPainter.prototype.draw = function(ctx, width, height, w_scale) {\n    var min_value = this.prefs.min_value;\n    var max_value = this.prefs.max_value;\n    var value_range = max_value - min_value;\n    var height_px = height;\n    var view_start = this.view_start;\n    var mode = this.mode;\n    var data = this.data;\n    var invsqrt2 = 1 / Math.sqrt(2);\n\n    var ramp = new SplitRamp(\n        this.prefs.neg_color,\n        \"#FFFFFF\",\n        this.prefs.pos_color,\n        min_value,\n        max_value\n    );\n\n    var d;\n    var s1;\n    var e1;\n    var s2;\n    var e2;\n    var value;\n\n    var scale = function(p) {\n        return (p - view_start) * w_scale;\n    };\n\n    ctx.save();\n\n    // Draw into triangle, then rotate and scale\n    ctx.rotate(-45 * Math.PI / 180);\n    ctx.scale(invsqrt2, invsqrt2);\n\n    // Paint track.\n    for (var i = 0, len = data.length; i < len; i++) {\n        d = data[i];\n\n        s1 = scale(d[1]);\n        e1 = scale(d[2]);\n        s2 = scale(d[4]);\n        e2 = scale(d[5]);\n        value = d[6];\n\n        ctx.fillStyle = ramp.map_value(value);\n        ctx.fillRect(s1, s2, e1 - s1, e2 - s2);\n    }\n\n    ctx.restore();\n};\n\n/**\n * Utilities for painting reads.\n */\nvar ReadPainterUtils = function(ctx, row_height, px_per_base, mode) {\n    this.ctx = ctx;\n    this.row_height = row_height;\n    this.px_per_base = px_per_base;\n    this.draw_details =\n        (mode === \"Pack\" || mode === \"Auto\") &&\n        px_per_base >= ctx.canvas.manager.char_width_px;\n    this.delete_details_thickness = 0.2;\n};\n\n_.extend(ReadPainterUtils.prototype, {\n    /**\n     * Draw deletion of base(s).\n     * @param draw_detail if true, drawing in detail and deletion is drawn more subtly\n     */\n    draw_deletion: function(x, y, len) {\n        this.ctx.fillStyle = \"black\";\n        var thickness =\n            (this.draw_details ? this.delete_details_thickness : 1) *\n            this.row_height;\n        y += 0.5 * (this.row_height - thickness);\n        this.ctx.fillRect(x, y, len * this.px_per_base, thickness);\n    }\n});\n\n/**\n * Paints variant data onto canvas.\n */\nvar VariantPainter = function(\n    data,\n    view_start,\n    view_end,\n    prefs,\n    mode,\n    base_color_fn\n) {\n    Painter.call(this, data, view_start, view_end, prefs, mode);\n    this.base_color_fn = base_color_fn;\n    this.divider_height = 1;\n};\n\n_.extend(VariantPainter.prototype, Painter.prototype, {\n    /**\n     * Height of a single row, depends on mode\n     */\n    get_row_height: function() {\n        var mode = this.mode;\n        var height;\n        if (mode === \"Dense\") {\n            height = DENSE_TRACK_HEIGHT;\n        } else if (mode === \"Squish\") {\n            height = SQUISH_TRACK_HEIGHT;\n        } else {\n            // mode === \"Pack\"\n            height = PACK_TRACK_HEIGHT;\n        }\n        return height;\n    },\n\n    /**\n     * Returns required height to draw a particular number of samples in a given mode.\n     */\n    get_required_height: function(num_samples) {\n        // FIXME: for single-sample data, height should be summary_height when zoomed out and\n        // row_height when zoomed in.\n        var height = this.prefs.summary_height;\n\n        // If showing sample data, height is summary + divider + samples.\n        if (num_samples > 1 && this.prefs.show_sample_data) {\n            height += this.divider_height + num_samples * this.get_row_height();\n        }\n        return height;\n    },\n\n    /**\n     * Draw on the context using a rectangle of width x height with scale w_scale.\n     */\n    draw: function(ctx, width, height, w_scale) {\n        ctx.save();\n\n        var /**\n         * Returns dictionary of information about an indel; returns empty if there no indel. Assumes indel is left-aligned.\n         * Dict attributes:\n         *    -type: 'insertion' or 'deletion'\n         *    -start: where the deletion starts relative to reference start\n         *    -len: how long the deletion is\n         */\n        get_indel_info = function(ref, alt) {\n            var ref_len = ref.length;\n            var alt_len = alt.length;\n            var start = 0;\n            var len = 1;\n            var type = null;\n            if (alt === \"-\") {\n                type = \"deletion\";\n                len = ref.length;\n            } else if (ref.indexOf(alt) === 0 && ref_len > alt_len) {\n                type = \"deletion\";\n                len = ref_len - alt_len;\n                start = alt_len;\n            } else if (alt.indexOf(ref) === 0 && ref_len < alt_len) {\n                // Insertion.\n                type = \"insertion\";\n                len = alt_len - ref_len;\n                start = alt_len;\n            }\n\n            return type !== null ? { type: type, start: start, len: len } : {};\n        };\n\n        // Draw.\n        var locus_data;\n\n        var pos;\n        var id;\n        var ref;\n        var alt;\n        var qual;\n        var filter;\n        var sample_gts;\n        var allele_counts;\n        var variant;\n        var draw_x_start;\n        var draw_y_start;\n        var genotype;\n\n        var // Always draw variants at least 1 pixel wide.\n        base_px = Math.max(1, Math.floor(w_scale));\n\n        var // Determine number of samples.\n        num_samples = this.data.length ? this.data[0][7].split(\",\").length : 0;\n\n        var row_height =\n            this.mode === \"Squish\" ? SQUISH_TRACK_HEIGHT : PACK_TRACK_HEIGHT;\n\n        var // If zoomed out, fill the whole row with feature to make it easier to read;\n        // when zoomed in, use feature height so that there are gaps in sample rows.\n        feature_height =\n            w_scale < 0.1\n                ? row_height\n                : this.mode === \"Squish\"\n                  ? SQUISH_FEATURE_HEIGHT\n                  : PACK_FEATURE_HEIGHT;\n\n        var draw_summary = true;\n\n        var paint_utils = new ReadPainterUtils(\n            ctx,\n            row_height,\n            w_scale,\n            this.mode\n        );\n\n        var j;\n\n        // If there's a single sample, update drawing variables.\n        if (num_samples === 1) {\n            row_height = feature_height =\n                w_scale < ctx.canvas.manager.char_width_px\n                    ? this.prefs.summary_height\n                    : row_height;\n            paint_utils.row_height = row_height;\n            // No summary when there's a single sample.\n            draw_summary = false;\n        }\n\n        // Draw divider between summary and samples.\n        if (this.prefs.show_sample_data && draw_summary) {\n            ctx.fillStyle = \"#F3F3F3\";\n            ctx.globalAlpha = 1;\n            ctx.fillRect(\n                0,\n                this.prefs.summary_height - this.divider_height,\n                width,\n                this.divider_height\n            );\n        }\n\n        // Draw variants.\n        ctx.textAlign = \"center\";\n        for (var i = 0; i < this.data.length; i++) {\n            // Get locus data.\n            locus_data = this.data[i];\n            pos = locus_data[1];\n            ref = locus_data[3];\n            alt = [locus_data[4].split(\",\")];\n            sample_gts = locus_data[7].split(\",\");\n            allele_counts = locus_data.slice(8);\n\n            // Process alterate values to derive information about each alt.\n            alt = _.map(_.flatten(alt), function(a) {\n                var alt_info = {\n                    type: \"snp\",\n                    value: a,\n                    start: 0\n                };\n\n                var indel_info = get_indel_info(ref, a);\n\n                return _.extend(alt_info, indel_info);\n            });\n\n            // Only draw locus data if it's in viewing region.\n            if (pos < this.view_start || pos > this.view_end) {\n                continue;\n            }\n\n            // Draw summary for alleles.\n            if (draw_summary) {\n                ctx.fillStyle = \"#999999\";\n                ctx.globalAlpha = 1;\n                for (j = 0; j < alt.length; j++) {\n                    // Draw background for summary.\n                    draw_x_start = this.get_start_draw_pos(\n                        pos + alt[j].start,\n                        w_scale\n                    );\n                    ctx.fillRect(\n                        draw_x_start,\n                        0,\n                        base_px,\n                        this.prefs.summary_height\n                    );\n                    draw_y_start = this.prefs.summary_height;\n                    // Draw allele fractions onto summary.\n                    for (j = 0; j < alt.length; j++) {\n                        ctx.fillStyle =\n                            alt[j].type === \"deletion\"\n                                ? \"black\"\n                                : this.base_color_fn(alt[j].value);\n                        var allele_frac = allele_counts / sample_gts.length;\n                        var draw_height = Math.ceil(\n                            this.prefs.summary_height * allele_frac\n                        );\n                        ctx.fillRect(\n                            draw_x_start,\n                            draw_y_start - draw_height,\n                            base_px,\n                            draw_height\n                        );\n                        draw_y_start -= draw_height;\n                    }\n                }\n            }\n\n            // Done drawing if not showing samples data.\n            if (!this.prefs.show_sample_data) {\n                continue;\n            }\n\n            // Draw sample genotype(s).\n            draw_y_start = draw_summary\n                ? this.prefs.summary_height + this.divider_height\n                : 0;\n            for (\n                j = 0;\n                j < sample_gts.length;\n                j++, draw_y_start += row_height\n            ) {\n                genotype = sample_gts[j]\n                    ? sample_gts[j].split(/\\/|\\|/)\n                    : [\"0\", \"0\"];\n\n                // Get variant to draw and set drawing properties.\n                variant = null;\n                if (genotype[0] === genotype[1]) {\n                    if (genotype[0] === \".\") {\n                        // TODO: draw uncalled variant.\n                    } else if (genotype[0] !== \"0\") {\n                        // Homozygous for variant.\n                        variant = alt[parseInt(genotype[0], 10) - 1];\n                        ctx.globalAlpha = 1;\n                    }\n                    // else reference\n                } else {\n                    // Heterozygous for variant.\n                    variant = genotype[0] !== \"0\" ? genotype[0] : genotype[1];\n                    variant = alt[parseInt(variant, 10) - 1];\n                    ctx.globalAlpha = 0.5;\n                }\n\n                // If there's a variant, draw it.\n                if (variant) {\n                    draw_x_start = this.get_start_draw_pos(\n                        pos + variant.start,\n                        w_scale\n                    );\n                    if (variant.type === \"snp\") {\n                        var snp = variant.value;\n                        ctx.fillStyle = this.base_color_fn(snp);\n                        if (paint_utils.draw_details) {\n                            ctx.fillText(\n                                snp,\n                                this.get_draw_pos(pos, w_scale),\n                                draw_y_start + row_height\n                            );\n                        } else {\n                            ctx.fillRect(\n                                draw_x_start,\n                                draw_y_start + 1,\n                                base_px,\n                                feature_height\n                            );\n                        }\n                    } else if (variant.type === \"deletion\") {\n                        paint_utils.draw_deletion(\n                            draw_x_start,\n                            draw_y_start + 1,\n                            variant.len\n                        );\n                    } else {\n                        // TODO: handle insertions.\n                    }\n                }\n            }\n        }\n\n        ctx.restore();\n    }\n});\n\nexport default {\n    Scaler: Scaler,\n    LinePainter: LinePainter,\n    LinkedFeaturePainter: LinkedFeaturePainter,\n    ReadPainter: ReadPainter,\n    ArcLinkedFeaturePainter: ArcLinkedFeaturePainter,\n    DiagonalHeatmapPainter: DiagonalHeatmapPainter,\n    VariantPainter: VariantPainter\n};\n"]}