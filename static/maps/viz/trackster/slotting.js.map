{"version":3,"sources":["viz/trackster/slotting.js"],"names":["define","_","SlottedInfo","slot","feature","this","FeatureSlotter","w_scale","mode","max_rows","measureText","slots","start_end_dct","include_label","extend","prototype","_get_draw_coords","draw_start","Math","floor","ceil","f_name","undefined","width","text_len","draw_end","_find_slot","draw_coords","slot_num","has_overlap","k","k_len","length","s_e","slot_features","features","feature_uid","undone","highest_slot","i","len","slotted_info","old_draw_coords","slotted_coords","new_draw_coords","push","dc","max"],"mappings":"kCAAAA,QAAQ,mBAAoB,SAASC,GACjC,IAMAC,EAAA,SAAAC,EAAAC,GAIIC,KAAKF,KAAOA,EACZE,KAAKD,QAAUA,GAUfE,EAAiB,SAASC,EAASC,EAAMC,EAAUC,GACnDL,KAAKM,SACLN,KAAKO,iBAFTP,KAAIC,QAAAA,EACAD,KAAAG,KAAKG,EACLN,KAAAQ,cAAA,SAAKD,EACLP,KAAAI,SAAAA,EACAJ,KAAAK,YAAYF,GA6LhB,OAnLAM,EAnCab,EAAEa,QAmCRR,EAAeS,WAClBC,iBAAA,SAAAZ,GAKI,IAAIa,EAAaC,KAAKC,MAAMf,EAAQ,GAAKC,KAAKE,SAFlDS,EAAAA,KAAkBI,KAAAhB,EAAA,GAAAC,KAAAE,SACdc,EAAAjB,EAAA,GAQA,QAAekB,IAAXD,GAAwBhB,KAAKQ,cAAe,CAAhD,IAAIQ,EACAhB,KAAAK,YAAAW,GAAAE,MAAA,EAEAN,EAAIO,GACKd,GAETO,GAAIA,EACAA,SAEHQ,GAAMD,EACHC,SA2BR,OAAAR,EAAQA,IAOZS,WAAAA,SAAYC,GAIR,IAAA,IAFAV,EAAIA,EAAaU,GAAjBF,EACIA,EAAWE,GACVC,EAAIA,EAAAA,GAAcA,KAAYnB,SAAKA,IAAUmB,CAC9C,IAAAC,GAAIA,EAAJ1B,EACIA,KAAOS,cAAKA,GAChB,QAAIT,IAAJA,EAEI,IAAA,IAAK2B,EAAIA,EAAAA,EAAOC,EAAQ5B,OAAK6B,EAAQF,EAAIC,IAAOD,CAC5C,IAAAG,EAAIA,EAAM9B,GACV,GAAAsB,EAAIA,EAAWQ,IAAXhB,EAAqBA,EAAagB,GAAI,CAEtCJ,GAAAA,EACA,OAIZ,IAAAA,EACI,OAAAD,EAGR,OAAA,GAMJM,cAAAA,SAAeC,GAUX,IAAA,IATA/B,EAAAgC,EAAAxB,EAAIA,KAAgBA,cAApByB,KAAAC,EAEIA,EAOCC,EAAIA,EAAAA,EAAOC,EAAML,OAASH,EAAQO,EAAIC,IAAKD,CAE5CH,GADAhC,EAAAA,EAAU+B,IACI/B,GACd,IAAAqC,EAAIA,KAAe9B,MAAKA,GAGxB,GAAA8B,EAAIA,CAGA,GAIIrC,EAAA,GAAAqC,EAAArC,QAAA,IACAqC,EAAArC,QAAA,GAAAA,EAAA,GAkBH,IAAA,IAVGsC,EAAgBZ,KAAIa,iBAChBF,EAASE,SAKLC,EAAAvC,KAAAW,iBAAAZ,GACAuC,EAAAA,KAAAA,cACHF,EAAAtC,MAER2B,EAAA,EAAAA,EAAAa,EAAAX,OAAAF,IAAA,CACDQ,IAAAA,EAAAA,EACIA,GAIGO,EAAP,KAAAH,EAAA,IACHI,EAAA,KAAAJ,EAAA,KAGLC,EAAAb,GAAAc,GAIIxC,EAAU+B,KAASE,IACnBD,EACIT,KAAAA,MAAAA,GAAmBX,WAGvBqB,EAAIT,KAAAA,GAOC,IAAA,IAAAW,EAAA,EAAAC,EAAAH,EAAAL,OAAAO,EAAAC,EAAAD,IAAA,CAEDH,GADAxB,EAAAA,EAAAA,EAAcgB,KACHQ,GAIXE,IAAAA,EAAAA,KAAepB,iBAASoB,GAbxBV,EAAWvB,KAAKqB,WAAWC,GAG3BC,GAAY,SAEoBN,IAA5BV,EAAcgB,KACdhB,EAAcgB,OAElBhB,EAAcgB,GAAUiB,KAAKlB,GAC7BtB,KAAKM,MAAMyB,GAAe,IAAIlC,EAC1B0B,EACAxB,GAkBZkC,EAAOA,KAAPS,IAAAT,EAAAV,IAAA,OAAOU,EAAe,MAK1BhC,eAAgBA","file":"../../../scripts/viz/trackster/slotting.js","sourcesContent":["define([\"libs/underscore\"], function(_) {\n    var extend = _.extend;\n\n    // HACK: LABEL_SPACING is currently duplicated between here and painters\n    var LABEL_SPACING = 2,\n        PACK_SPACING = 5;\n\n    /**\n * Hold slotting information for a feature.\n */\n    var SlottedInfo = function(slot, feature) {\n        this.slot = slot;\n        this.feature = feature;\n    };\n\n    /**\n * FeatureSlotter determines slots in which to draw features for vertical\n * packing.\n *\n * This implementation is incremental, any feature assigned a slot will be\n * retained for slotting future features.\n */\n    var FeatureSlotter = function(w_scale, mode, max_rows, measureText) {\n        this.slots = {};\n        this.start_end_dct = {};\n        this.w_scale = w_scale;\n        this.mode = mode;\n        this.include_label = mode === \"Pack\";\n        this.max_rows = max_rows;\n        this.measureText = measureText;\n    };\n\n    /**\n * Slot a set of features, `this.slots` will be updated with slots by id, and\n * the largest slot required for the passed set of features is returned\n */\n    extend(FeatureSlotter.prototype, {\n        /**\n     * Get drawing coordinate for a feature.\n     */\n        _get_draw_coords: function(feature) {\n            // Get initial draw coordinates using w_scale.\n            var draw_start = Math.floor(feature[1] * this.w_scale),\n                draw_end = Math.ceil(feature[2] * this.w_scale),\n                f_name = feature[3],\n                text_align;\n\n            // Update start, end drawing locations to include feature name.\n            // Try to put the name on the left, if not, put on right.\n            if (f_name !== undefined && this.include_label) {\n                // Add gap for label spacing and extra pack space padding\n                // TODO: Fix constants\n                var text_len =\n                    this.measureText(f_name).width +\n                    (LABEL_SPACING + PACK_SPACING);\n                if (draw_start - text_len >= 0) {\n                    draw_start -= text_len;\n                    text_align = \"left\";\n                } else {\n                    draw_end += text_len;\n                    text_align = \"right\";\n                }\n            }\n\n            /*\n        if (slot_num < 0) {\n            \n            TODO: this is not yet working --\n            console.log(feature_uid, \"looking for slot with text on the right\");\n            // Slot not found. If text was on left, try on right and see\n            // if slot can be found.\n            // TODO: are there any checks we need to do to ensure that text\n            // will fit on tile?\n            if (text_align === \"left\") {\n                draw_start -= text_len;\n                draw_end -= text_len;\n                text_align = \"right\";\n                slot_num = find_slot(draw_start, draw_end);\n            }\n            if (slot_num >= 0) {\n                console.log(feature_uid, \"found slot with text on the right\");\n            }\n\n        }\n        */\n\n            return [draw_start, draw_end];\n        },\n\n        /**\n     * Find the first slot such that current feature doesn't overlap any other features in that slot.\n     * Returns -1 if no slot was found.\n     */\n        _find_slot: function(draw_coords) {\n            // TODO: Use a data structure for faster searching of available slots.\n            var draw_start = draw_coords[0],\n                draw_end = draw_coords[1];\n            for (var slot_num = 0; slot_num <= this.max_rows; slot_num++) {\n                var has_overlap = false,\n                    slot = this.start_end_dct[slot_num];\n                if (slot !== undefined) {\n                    // Iterate through features already in slot to see if current feature will fit.\n                    for (var k = 0, k_len = slot.length; k < k_len; k++) {\n                        var s_e = slot[k];\n                        if (draw_end > s_e[0] && draw_start < s_e[1]) {\n                            // There is overlap\n                            has_overlap = true;\n                            break;\n                        }\n                    }\n                }\n                if (!has_overlap) {\n                    return slot_num;\n                }\n            }\n            return -1;\n        },\n\n        /**\n     * Slot features.\n     */\n        slot_features: function(features) {\n            var start_end_dct = this.start_end_dct,\n                undone = [],\n                highest_slot = 0,\n                feature,\n                feature_uid;\n\n            // Loop through features to (a) find those that are not yet slotted and (b) update\n            // those that are slotted if new information is availabe. For (a), features already\n            // slotted (based on slotting from other tiles) will retain their current slot.\n            for (var i = 0, len = features.length; i < len; i++) {\n                feature = features[i];\n                feature_uid = feature[0];\n                var slotted_info = this.slots[feature_uid];\n\n                // Separate and handle slotted vs. unslotted features.\n                if (slotted_info) {\n                    // Feature is slotted; if feature now has larger start/end coordinates,\n                    // update drawing coordinates.\n                    if (\n                        feature[1] < slotted_info.feature[1] ||\n                        slotted_info.feature[2] < feature[2]\n                    ) {\n                        // Feature has changed (e.g. a single read now has its pair), so recalculate its\n                        // drawing coordinates.\n                        var old_draw_coords = this._get_draw_coords(\n                                slotted_info.feature\n                            ),\n                            new_draw_coords = this._get_draw_coords(feature),\n                            slotted_coords = this.start_end_dct[\n                                slotted_info.slot\n                            ];\n                        for (var k = 0; k < slotted_coords.length; k++) {\n                            var dc = slotted_coords[k];\n                            if (\n                                dc[0] === old_draw_coords[0] &&\n                                dc[1] === old_draw_coords[1]\n                            ) {\n                                // Replace old drawing coordinates with new ones.\n                                slotted_coords[k] = new_draw_coords;\n                            }\n                        }\n                    }\n                    highest_slot = Math.max(\n                        highest_slot,\n                        this.slots[feature_uid].slot\n                    );\n                } else {\n                    undone.push(i);\n                }\n            }\n\n            // Slot unslotted features.\n\n            // Do slotting.\n            for (var i = 0, len = undone.length; i < len; i++) {\n                feature = features[undone[i]];\n                feature_uid = feature[0];\n                var draw_coords = this._get_draw_coords(feature);\n\n                // Find slot.\n                var slot_num = this._find_slot(draw_coords);\n\n                // Do slotting.\n                if (slot_num >= 0) {\n                    // Add current feature to slot.\n                    if (start_end_dct[slot_num] === undefined) {\n                        start_end_dct[slot_num] = [];\n                    }\n                    start_end_dct[slot_num].push(draw_coords);\n                    this.slots[feature_uid] = new SlottedInfo(\n                        slot_num,\n                        feature\n                    );\n                    highest_slot = Math.max(highest_slot, slot_num);\n                }\n            }\n\n            // Debugging: view slots data.\n            /*\n        for (var i = 0; i < MAX_FEATURE_DEPTH; i++) {\n            var slot = start_end_dct[i];\n            if (slot !== undefined) {\n                console.log(i, \"*************\");\n                for (var k = 0, k_len = slot.length; k < k_len; k++) {\n                    console.log(\"\\t\", slot[k][0], slot[k][1]);\n                }\n            }\n        }\n        */\n            return highest_slot + 1;\n        }\n    });\n\n    return {\n        FeatureSlotter: FeatureSlotter\n    };\n});\n"]}