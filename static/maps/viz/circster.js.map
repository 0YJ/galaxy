{"version":3,"sources":["viz/circster.js"],"names":["require","mod_utils","cssLoadFile","define","_","d3","visualization","config","mod_icon_btn","SVGUtils","svgBRect","$","extend","eltBRect","svg_elt","svg","getBoundingClientRect","right","left","bottom","top","UsesTicks","drawTicks","tick_coords","parent_elt","data","dataHandler","textTransform","horizontal","text_anchor","append","text_coords","enter","ticks","d","attr","angle","Math","PI","radius","sigDigits","rval","toPrecision","roundedNum","round","style","CircsterLabelTrack","Backbone","text","label","formatNum","label_arc_height","circular_views","num","abs","vis_config","track","get","toFixed","model","Model","CircsterView","View","className","initialize","options","track_gap","this","scale","tracks_start_radii","chords_views","map","on","remove_track","self","update_track_bounds","height","circular_tracks","get_circular_tracks","call","filter","event","clearTimeout","setTimeout","zoom_drag_timeout","get_tracks_bounds","dataset_arc_height","get_value","width","min_dimension","min","$el","radius_start","el","length","radius_bounds","tracks_bounds","total_gap","view","range","CircsterChromInteractionsTrackView","chords_tracks","get_chord_tracks","outermost_radius","track_bounds","label_track_view","genome","behavior","zoom","translate","innermost_radius_bounds","track_index","select","new_track","track_view","index","CircsterBigWigTrackView","render","remove","new_track_bounds","each","update_radius_bounds","CircsterChromLabelTrackView","CircsterTrackView","tagName","bg_stroke","add_track","_chroms_layout","chroms_layout","new_view","color","push","i","chroms_elts","track_parent_elt","chroms_paths","render_labels","tracks","splice","_transition_chrom_data","update_scale","new_scale","old_scale","loading_bg_fill","bg_fill","utils","selectAll","data_bounds","get_fill_color","data_deferred","data_manager","can_get_more_detailed_data","path_elt","_update_data_bounds","arc_gen","arc","innerRadius","chrom_arc","find","outerRadius","layout","num_paths","data_is_ready","when","data_ready_deferred","then","_render_data","p_data","_transition_labels","new_d","old_bounds","new_bounds","transition","duration","layout_and_data","chrom_info","_render_chrom_data","rendered_deferred","get_chrom_region","chrom","chrom_region","_get_path_function","chroms_info","get_chroms_info","gap_per_chrom","new_endAngle","endAngle","chrom_arcs","get_genome_wide_data","genome_wide_data","path_data","reject","chrom_data","path_fn","k","chrom_data_paths","path","CircsterQuantitativeTrackView","get_data_bounds","track_config","Deferred","set_value","silent","zip","parent","resolve","area","interpolate","init_arcs","value","len","sort","pie_layout","collection","tick","startAngle","prototype","min_arc_len","visibleChroms","labeledChroms","new_data","_data_bounds_ticks_fn","c","v","cur_chrom","source_angle","_get_region_angle","source","_quantile","numbers","quantile","ascending","chrom_angle_data","datum","vis","add","key","type","linear","viz_view","domain","line","radial","menu","icon_class","on_click","title","dataType","id","Galaxy","modal","dbkey","success","vis_info","error","GalaxyApp","Circster","flatten","values","p","parseInt","max","chord_data","chrom_chord_data","target_angle","target","concat","chord","position","chrom_layout","Genome","galaxy_config","app","GenomeVisualization","viz_config","hidden","create_icon_buttons_menu","select_datasets","add_tracks","ConfigSettingCollectionView","render_in_modal","show","body","ajax","url","root","vis_json","JSON","stringify","hide","set","vis_id","buttons","Cancel","window","location","tooltip_config","placement","tooltip"],"mappings":"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","file":"../../scripts/viz/circster.js","sourcesContent":["// load required libraries\nrequire([\"utils/utils\"], function(mod_utils) {\n    // load css\n    mod_utils.cssLoadFile(\"static/style/circster.css\");\n});\n\ndefine(\n    [\n        \"libs/underscore\",\n        \"libs/d3\",\n        \"viz/visualization\",\n        \"utils/config\",\n        \"mvc/ui/icon-button\",\n        \"libs/farbtastic\"\n    ],\n    function(_, d3, visualization, config, mod_icon_btn) {\n        /**\n * Utility class for working with SVG.\n */\n        var SVGUtils = Backbone.Model.extend({\n            /**\n     * Returns true if element is visible.\n     */\n            is_visible: function(svg_elt, svg) {\n                var eltBRect = svg_elt.getBoundingClientRect(),\n                    svgBRect = $(\"svg\")[0].getBoundingClientRect();\n\n                if (\n                    // To the left of screen?\n                    eltBRect.right < 0 ||\n                    // To the right of screen?\n                    eltBRect.left > svgBRect.right ||\n                    // Above screen?\n                    eltBRect.bottom < 0 ||\n                    // Below screen?\n                    eltBRect.top > svgBRect.bottom\n                ) {\n                    return false;\n                }\n                return true;\n            }\n        });\n\n        /**\n * Mixin for using ticks.\n */\n        var UsesTicks = {\n            drawTicks: function(\n                parent_elt,\n                data,\n                dataHandler,\n                textTransform,\n                horizontal\n            ) {\n                // Set up group elements for chroms and for each tick.\n                var ticks = parent_elt\n                    .append(\"g\")\n                    .selectAll(\"g\")\n                    .data(data)\n                    .enter()\n                    .append(\"g\")\n                    .selectAll(\"g\")\n                    .data(dataHandler)\n                    .enter()\n                    .append(\"g\")\n                    .attr(\"class\", \"tick\")\n                    .attr(\"transform\", function(d) {\n                        return (\n                            \"rotate(\" +\n                            (d.angle * 180 / Math.PI - 90) +\n                            \")\" +\n                            \"translate(\" +\n                            d.radius +\n                            \",0)\"\n                        );\n                    });\n\n                // Add line + text for ticks.\n                var tick_coords = [],\n                    text_coords = [],\n                    text_anchor = function(d) {\n                        return d.angle > Math.PI ? \"end\" : null;\n                    };\n                if (horizontal) {\n                    tick_coords = [0, 0, 0, -4];\n                    text_coords = [4, 0, \"\", \".35em\"];\n                    text_anchor = null;\n                } else {\n                    tick_coords = [1, 0, 4, 0];\n                    text_coords = [0, 4, \".35em\", \"\"];\n                }\n\n                ticks\n                    .append(\"line\")\n                    .attr(\"x1\", tick_coords[0])\n                    .attr(\"y1\", tick_coords[1])\n                    .attr(\"x2\", tick_coords[2])\n                    .attr(\"y1\", tick_coords[3])\n                    .style(\"stroke\", \"#000\");\n\n                return ticks\n                    .append(\"text\")\n                    .attr(\"x\", text_coords[0])\n                    .attr(\"y\", text_coords[1])\n                    .attr(\"dx\", text_coords[2])\n                    .attr(\"dy\", text_coords[3])\n                    .attr(\"text-anchor\", text_anchor)\n                    .attr(\"transform\", textTransform)\n                    .text(function(d) {\n                        return d.label;\n                    });\n            },\n\n            /**\n     * Format number for display at a tick.\n     */\n            formatNum: function(num, sigDigits) {\n                // Use default of 2 sig. digits.\n                if (sigDigits === undefined) sigDigits = 2;\n\n                // Verify input number\n                if (num === null) return null;\n\n                // Calculate return value\n                var rval = null;\n                if (Math.abs(num) < 1) {\n                    rval = num.toPrecision(sigDigits);\n                } else {\n                    // Use round to turn string from toPrecision() back into a number.\n                    var roundedNum = Math.round(num.toPrecision(sigDigits));\n\n                    // Use abbreviations.\n                    num = Math.abs(num);\n                    if (num < 1000) {\n                        rval = roundedNum;\n                    } else if (num < 1000000) {\n                        // Use K.\n                        rval =\n                            Math.round(\n                                (roundedNum / 1000).toPrecision(3)\n                            ).toFixed(0) + \"K\";\n                    } else if (num < 1000000000) {\n                        // Use M.\n                        rval =\n                            Math.round(\n                                (roundedNum / 1000000).toPrecision(3)\n                            ).toFixed(0) + \"M\";\n                    }\n                }\n\n                return rval;\n            }\n        };\n\n        /**\n * A label track.\n */\n        var CircsterLabelTrack = Backbone.Model.extend({});\n\n        /**\n * Renders a full circster visualization.\n */\n        var CircsterView = Backbone.View.extend({\n            className: \"circster\",\n\n            initialize: function(options) {\n                this.genome = options.genome;\n                this.label_arc_height = 50;\n                this.scale = 1;\n                this.circular_views = null;\n                this.chords_views = null;\n\n                // When tracks added to/removed from model, update view.\n                this.model.get(\"drawables\").on(\"add\", this.add_track, this);\n                this.model\n                    .get(\"drawables\")\n                    .on(\"remove\", this.remove_track, this);\n\n                // When config settings change, update view.\n                var vis_config = this.model.get(\"config\");\n                vis_config\n                    .get(\"arc_dataset_height\")\n                    .on(\"change:value\", this.update_track_bounds, this);\n                vis_config\n                    .get(\"track_gap\")\n                    .on(\"change:value\", this.update_track_bounds, this);\n            },\n\n            // HACKs: using track_type for circular/chord distinction in the functions below for now.\n\n            /**\n     * Returns tracks to be rendered using circular view.\n     */\n            get_circular_tracks: function() {\n                return this.model.get(\"drawables\").filter(function(track) {\n                    return track.get(\"track_type\") !== \"DiagonalHeatmapTrack\";\n                });\n            },\n\n            /**\n     * Returns tracks to be rendered using chords view.\n     */\n            get_chord_tracks: function() {\n                return this.model.get(\"drawables\").filter(function(track) {\n                    return track.get(\"track_type\") === \"DiagonalHeatmapTrack\";\n                });\n            },\n\n            /**\n     * Returns a list of circular tracks' radius bounds.\n     */\n            get_tracks_bounds: function() {\n                var circular_tracks = this.get_circular_tracks(),\n                    dataset_arc_height = this.model\n                        .get(\"config\")\n                        .get_value(\"arc_dataset_height\"),\n                    track_gap = this.model.get(\"config\").get_value(\"track_gap\"),\n                    // Subtract 20 to make sure chrom labels are on screen.\n                    min_dimension =\n                        Math.min(this.$el.width(), this.$el.height()) - 20,\n                    // Compute radius start based on model, will be centered\n                    // and fit entirely inside element by default.\n                    radius_start =\n                        min_dimension / 2 -\n                        circular_tracks.length *\n                            (dataset_arc_height + track_gap) +\n                        // Add track_gap back in because no gap is needed for last track.\n                        track_gap -\n                        this.label_arc_height,\n                    // Compute range of track starting radii.\n                    tracks_start_radii = d3.range(\n                        radius_start,\n                        min_dimension / 2,\n                        dataset_arc_height + track_gap\n                    );\n\n                // Map from track start to bounds.\n                var self = this;\n                return _.map(tracks_start_radii, function(radius) {\n                    return [radius, radius + dataset_arc_height];\n                });\n            },\n\n            /**\n     * Renders circular tracks, chord tracks, and label tracks.\n     */\n            render: function() {\n                var self = this,\n                    width = self.$el.width(),\n                    height = self.$el.height(),\n                    circular_tracks = this.get_circular_tracks(),\n                    chords_tracks = this.get_chord_tracks(),\n                    total_gap = self.model.get(\"config\").get_value(\"total_gap\"),\n                    tracks_bounds = this.get_tracks_bounds(),\n                    // Set up SVG element.\n                    svg = d3\n                        .select(self.$el[0])\n                        .append(\"svg\")\n                        .attr(\"width\", width)\n                        .attr(\"height\", height)\n                        .attr(\"pointer-events\", \"all\")\n                        // Set up zooming, dragging.\n                        .append(\"svg:g\")\n                        .call(\n                            d3.behavior.zoom().on(\"zoom\", function() {\n                                // Do zoom, drag.\n                                var scale = d3.event.scale;\n                                svg.attr(\n                                    \"transform\",\n                                    \"translate(\" +\n                                        d3.event.translate +\n                                        \")\" +\n                                        \" scale(\" +\n                                        scale +\n                                        \")\"\n                                );\n\n                                // Propagate scale changes to views.\n                                if (self.scale !== scale) {\n                                    // Use timeout to wait for zooming/dragging to stop before rendering more detail.\n                                    if (self.zoom_drag_timeout) {\n                                        clearTimeout(self.zoom_drag_timeout);\n                                    }\n                                    self.zoom_drag_timeout = setTimeout(\n                                        function() {\n                                            // Render more detail in tracks' visible elements.\n                                            // FIXME: do not do this right now; it is not fully implemented--e.g. data bounds\n                                            // are not updated when new data is fetched--and fetching more detailed quantitative\n                                            // data is not that useful.\n                                            /*\n                            _.each(self.circular_views, function(view) {\n                                view.update_scale(scale);\n                            });\n                            */\n                                        },\n                                        400\n                                    );\n                                }\n                            })\n                        )\n                        .attr(\n                            \"transform\",\n                            \"translate(\" + width / 2 + \",\" + height / 2 + \")\"\n                        )\n                        .append(\"svg:g\")\n                        .attr(\"class\", \"tracks\");\n\n                // -- Render circular tracks. --\n\n                // Create a view for each track in the visualization and render.\n                this.circular_views = circular_tracks.map(function(\n                    track,\n                    index\n                ) {\n                    var view = new CircsterBigWigTrackView({\n                        el: svg.append(\"g\")[0],\n                        track: track,\n                        radius_bounds: tracks_bounds[index],\n                        genome: self.genome,\n                        total_gap: total_gap\n                    });\n\n                    view.render();\n\n                    return view;\n                });\n\n                // -- Render chords tracks. --\n\n                this.chords_views = chords_tracks.map(function(track) {\n                    var view = new CircsterChromInteractionsTrackView({\n                        el: svg.append(\"g\")[0],\n                        track: track,\n                        radius_bounds: tracks_bounds[0],\n                        genome: self.genome,\n                        total_gap: total_gap\n                    });\n\n                    view.render();\n\n                    return view;\n                });\n\n                // -- Render label track. --\n\n                // Track bounds are:\n                // (a) outer radius of last circular track;\n                // (b)\n                var outermost_radius = this.circular_views[\n                        this.circular_views.length - 1\n                    ].radius_bounds[1],\n                    track_bounds = [\n                        outermost_radius,\n                        outermost_radius + this.label_arc_height\n                    ];\n                this.label_track_view = new CircsterChromLabelTrackView({\n                    el: svg.append(\"g\")[0],\n                    track: new CircsterLabelTrack(),\n                    radius_bounds: track_bounds,\n                    genome: self.genome,\n                    total_gap: total_gap\n                });\n\n                this.label_track_view.render();\n            },\n\n            /**\n     * Render a single track on the outside of the current visualization.\n     */\n            add_track: function(new_track) {\n                var total_gap = this.model.get(\"config\").get_value(\"total_gap\");\n\n                if (new_track.get(\"track_type\") === \"DiagonalHeatmapTrack\") {\n                    // Added chords track.\n                    var innermost_radius_bounds = this.circular_views[0]\n                            .radius_bounds,\n                        new_view = new CircsterChromInteractionsTrackView({\n                            el: d3.select(\"g.tracks\").append(\"g\")[0],\n                            track: new_track,\n                            radius_bounds: innermost_radius_bounds,\n                            genome: this.genome,\n                            total_gap: total_gap\n                        });\n                    new_view.render();\n                    this.chords_views.push(new_view);\n                } else {\n                    // Added circular track.\n\n                    // Recompute and update circular track bounds.\n                    var new_track_bounds = this.get_tracks_bounds();\n                    _.each(this.circular_views, function(track_view, i) {\n                        track_view.update_radius_bounds(new_track_bounds[i]);\n                    });\n\n                    // Update chords tracks.\n                    _.each(this.chords_views, function(track_view) {\n                        track_view.update_radius_bounds(new_track_bounds[0]);\n                    });\n\n                    // Render new track.\n                    var track_index = this.circular_views.length,\n                        track_view = new CircsterBigWigTrackView({\n                            el: d3.select(\"g.tracks\").append(\"g\")[0],\n                            track: new_track,\n                            radius_bounds: new_track_bounds[track_index],\n                            genome: this.genome,\n                            total_gap: total_gap\n                        });\n                    track_view.render();\n                    this.circular_views.push(track_view);\n\n                    // Update label track.\n                    /*\n            FIXME: should never have to update label track because vis always expands to fit area\n            within label track.\n            var track_bounds = new_track_bounds[ new_track_bounds.length-1 ];\n            track_bounds[1] = track_bounds[0];\n            this.label_track_view.update_radius_bounds(track_bounds);\n            */\n                }\n            },\n\n            /**\n     * Remove a track from the view.\n     */\n            remove_track: function(track, tracks, options) {\n                // -- Remove track from view. --\n                var track_view = this.circular_views[options.index];\n                this.circular_views.splice(options.index, 1);\n                track_view.$el.remove();\n\n                // Recompute and update track bounds.\n                var new_track_bounds = this.get_tracks_bounds();\n                _.each(this.circular_views, function(track_view, i) {\n                    track_view.update_radius_bounds(new_track_bounds[i]);\n                });\n            },\n\n            update_track_bounds: function() {\n                // Recompute and update track bounds.\n                var new_track_bounds = this.get_tracks_bounds();\n                _.each(this.circular_views, function(track_view, i) {\n                    track_view.update_radius_bounds(new_track_bounds[i]);\n                });\n\n                // Update chords tracks.\n                _.each(this.chords_views, function(track_view) {\n                    track_view.update_radius_bounds(new_track_bounds[0]);\n                });\n            }\n        });\n\n        /**\n * Renders a track in a Circster visualization.\n */\n        var CircsterTrackView = Backbone.View.extend({\n            tagName: \"g\",\n\n            /* ----------------------- Public Methods ------------------------- */\n\n            initialize: function(options) {\n                this.bg_stroke = \"#ddd\";\n                // Fill color when loading data.\n                this.loading_bg_fill = \"#ffc\";\n                // Fill color when data has been loaded.\n                this.bg_fill = \"#ddd\";\n                this.total_gap = options.total_gap;\n                this.track = options.track;\n                this.radius_bounds = options.radius_bounds;\n                this.genome = options.genome;\n                this.chroms_layout = this._chroms_layout();\n                this.data_bounds = [];\n                this.scale = 1;\n                this.parent_elt = d3.select(this.$el[0]);\n            },\n\n            /**\n     * Get fill color from config.\n     */\n            get_fill_color: function() {\n                var color = this.track.get(\"config\").get_value(\"block_color\");\n                if (!color) {\n                    color = this.track.get(\"config\").get_value(\"color\");\n                }\n                return color;\n            },\n\n            /**\n     * Render track's data by adding SVG elements to parent.\n     */\n            render: function() {\n                // -- Create track group element. --\n                var track_parent_elt = this.parent_elt;\n\n                // -- Render background arcs. --\n                var genome_arcs = this.chroms_layout,\n                    arc_gen = d3.svg\n                        .arc()\n                        .innerRadius(this.radius_bounds[0])\n                        .outerRadius(this.radius_bounds[1]),\n                    // Attach data to group element.\n                    chroms_elts = track_parent_elt\n                        .selectAll(\"g\")\n                        .data(genome_arcs)\n                        .enter()\n                        .append(\"svg:g\"),\n                    // Draw chrom arcs/paths.\n                    chroms_paths = chroms_elts\n                        .append(\"path\")\n                        .attr(\"d\", arc_gen)\n                        .attr(\"class\", \"chrom-background\")\n                        .style(\"stroke\", this.bg_stroke)\n                        .style(\"fill\", this.loading_bg_fill);\n\n                // Append titles to paths.\n                chroms_paths.append(\"title\").text(function(d) {\n                    return d.data.chrom;\n                });\n\n                // -- Render track data and, when track data is rendered, apply preferences and update chrom_elts fill. --\n\n                var self = this,\n                    data_manager = self.track.get(\"data_manager\"),\n                    // If track has a data manager, get deferred that resolves when data is ready.\n                    data_ready_deferred = data_manager\n                        ? data_manager.data_is_ready()\n                        : true;\n\n                // When data is ready, render track.\n                $.when(data_ready_deferred).then(function() {\n                    $.when(\n                        self._render_data(track_parent_elt)\n                    ).then(function() {\n                        chroms_paths.style(\"fill\", self.bg_fill);\n\n                        // Render labels after data is available so that data attributes are available.\n                        self.render_labels();\n                    });\n                });\n            },\n\n            /**\n     * Render track labels.\n     */\n            render_labels: function() {},\n\n            /**\n     * Update radius bounds.\n     */\n            update_radius_bounds: function(radius_bounds) {\n                // Update bounds.\n                this.radius_bounds = radius_bounds;\n\n                // -- Update background arcs. --\n                var new_d = d3.svg\n                    .arc()\n                    .innerRadius(this.radius_bounds[0])\n                    .outerRadius(this.radius_bounds[1]);\n\n                this.parent_elt\n                    .selectAll(\"g>path.chrom-background\")\n                    .transition()\n                    .duration(1000)\n                    .attr(\"d\", new_d);\n\n                this._transition_chrom_data();\n\n                this._transition_labels();\n            },\n\n            /**\n     * Update view scale. This fetches more data if scale is increased.\n     */\n            update_scale: function(new_scale) {\n                // -- Update scale and return if new scale is less than old scale. --\n\n                var old_scale = this.scale;\n                this.scale = new_scale;\n                if (new_scale <= old_scale) {\n                    return;\n                }\n\n                // -- Scale increased, so render visible data with more detail. --\n\n                var self = this,\n                    utils = new SVGUtils();\n\n                // Select all chrom data and filter to operate on those that are visible.\n                this.parent_elt\n                    .selectAll(\"path.chrom-data\")\n                    .filter(function(d, i) {\n                        return utils.is_visible(this);\n                    })\n                    .each(function(d, i) {\n                        // -- Now operating on a single path element representing chromosome data. --\n\n                        var path_elt = d3.select(this),\n                            chrom = path_elt.attr(\"chrom\"),\n                            chrom_region = self.genome.get_chrom_region(chrom),\n                            data_manager = self.track.get(\"data_manager\"),\n                            data_deferred;\n\n                        // If can't get more detailed data, return.\n                        if (\n                            !data_manager.can_get_more_detailed_data(\n                                chrom_region\n                            )\n                        ) {\n                            return;\n                        }\n\n                        // -- Get more detailed data. --\n                        data_deferred = self.track\n                            .get(\"data_manager\")\n                            .get_more_detailed_data(\n                                chrom_region,\n                                \"Coverage\",\n                                0,\n                                new_scale\n                            );\n\n                        // When more data is available, use new data to redraw path.\n                        $.when(data_deferred).then(function(data) {\n                            // Remove current data path.\n                            path_elt.remove();\n\n                            // Update data bounds with new data.\n                            self._update_data_bounds();\n\n                            // Find chromosome arc to draw data on.\n                            var chrom_arc = _.find(self.chroms_layout, function(\n                                layout\n                            ) {\n                                return layout.data.chrom === chrom;\n                            });\n\n                            // Add new data path and apply preferences.\n                            var color = self.get_fill_color();\n                            self\n                                ._render_chrom_data(\n                                    self.parent_elt,\n                                    chrom_arc,\n                                    data\n                                )\n                                .style(\"stroke\", color)\n                                .style(\"fill\", color);\n                        });\n                    });\n\n                return self;\n            },\n\n            /* ----------------------- Internal Methods ------------------------- */\n\n            /**\n     * Transitions chrom data to new values (e.g new radius or data bounds).\n     */\n            _transition_chrom_data: function() {\n                var track = this.track,\n                    chrom_arcs = this.chroms_layout,\n                    chrom_data_paths = this.parent_elt.selectAll(\n                        \"g>path.chrom-data\"\n                    ),\n                    num_paths = chrom_data_paths[0].length;\n\n                if (num_paths > 0) {\n                    var self = this;\n                    $.when(\n                        track\n                            .get(\"data_manager\")\n                            .get_genome_wide_data(this.genome)\n                    ).then(function(genome_wide_data) {\n                        // Map chrom data to path data, filtering out null values.\n                        var path_data = _.reject(\n                            _.map(genome_wide_data, function(chrom_data, i) {\n                                var rval = null,\n                                    path_fn = self._get_path_function(\n                                        chrom_arcs[i],\n                                        chrom_data\n                                    );\n                                if (path_fn) {\n                                    rval = path_fn(chrom_data.data);\n                                }\n                                return rval;\n                            }),\n                            function(p_data) {\n                                return p_data === null;\n                            }\n                        );\n\n                        // Transition each path for data and color.\n                        var color = track.get(\"config\").get_value(\"color\");\n                        chrom_data_paths.each(function(path, index) {\n                            d3\n                                .select(this)\n                                .transition()\n                                .duration(1000)\n                                .style(\"stroke\", color)\n                                .style(\"fill\", color)\n                                .attr(\"d\", path_data[index]);\n                        });\n                    });\n                }\n            },\n\n            /**\n     * Transition labels to new values (e.g new radius or data bounds).\n     */\n            _transition_labels: function() {},\n\n            /**\n     * Update data bounds. If there are new_bounds, use them; otherwise use\n     * default data bounds.\n     */\n            _update_data_bounds: function(new_bounds) {\n                var old_bounds = this.data_bounds;\n                this.data_bounds =\n                    new_bounds ||\n                    this.get_data_bounds(\n                        this.track\n                            .get(\"data_manager\")\n                            .get_genome_wide_data(this.genome)\n                    );\n                this._transition_chrom_data();\n            },\n\n            /**\n     * Render data as elements attached to svg.\n     */\n            _render_data: function(svg) {\n                var self = this,\n                    chrom_arcs = this.chroms_layout,\n                    track = this.track,\n                    rendered_deferred = $.Deferred();\n\n                // When genome-wide data is available, render data.\n                $.when(\n                    track.get(\"data_manager\").get_genome_wide_data(this.genome)\n                ).then(function(genome_wide_data) {\n                    // Set bounds.\n                    self.data_bounds = self.get_data_bounds(genome_wide_data);\n\n                    // Set min, max value in config so that they can be adjusted. Make this silent\n                    // because these attributes are watched for changes and the viz is updated\n                    // accordingly (set up in initialize). Because we are setting up, we don't want\n                    // the watch to trigger events here.\n                    track\n                        .get(\"config\")\n                        .set_value(\"min_value\", self.data_bounds[0], {\n                            silent: true\n                        });\n                    track\n                        .get(\"config\")\n                        .set_value(\"max_value\", self.data_bounds[1], {\n                            silent: true\n                        });\n\n                    // Merge chroms layout with data.\n                    var layout_and_data = _.zip(chrom_arcs, genome_wide_data);\n\n                    // Render each chromosome's data.\n                    _.each(layout_and_data, function(chrom_info) {\n                        var chrom_arc = chrom_info[0],\n                            data = chrom_info[1];\n                        return self._render_chrom_data(svg, chrom_arc, data);\n                    });\n\n                    // Apply prefs to all track data.\n                    var color = self.get_fill_color();\n                    self.parent_elt\n                        .selectAll(\"path.chrom-data\")\n                        .style(\"stroke\", color)\n                        .style(\"fill\", color);\n\n                    rendered_deferred.resolve(svg);\n                });\n\n                return rendered_deferred;\n            },\n\n            /**\n     * Render a chromosome data and attach elements to svg.\n     */\n            _render_chrom_data: function(svg, chrom_arc, data) {},\n\n            /**\n     * Returns data for creating a path for the given data using chrom_arc and data bounds.\n     */\n            _get_path_function: function(chrom_arc, chrom_data) {},\n\n            /**\n     * Returns arc layouts for genome's chromosomes/contigs. Arcs are arranged in a circle\n     * separated by gaps.\n     */\n            _chroms_layout: function() {\n                // Setup chroms layout using pie.\n                var chroms_info = this.genome.get_chroms_info(),\n                    pie_layout = d3.layout\n                        .pie()\n                        .value(function(d) {\n                            return d.len;\n                        })\n                        .sort(null),\n                    init_arcs = pie_layout(chroms_info),\n                    gap_per_chrom =\n                        2 * Math.PI * this.total_gap / chroms_info.length,\n                    chrom_arcs = _.map(init_arcs, function(arc, index) {\n                        // For short chroms, endAngle === startAngle.\n                        var new_endAngle = arc.endAngle - gap_per_chrom;\n                        arc.endAngle =\n                            new_endAngle > arc.startAngle\n                                ? new_endAngle\n                                : arc.startAngle;\n                        return arc;\n                    });\n                return chrom_arcs;\n            }\n        });\n\n        /**\n * Render chromosome labels.\n */\n        var CircsterChromLabelTrackView = CircsterTrackView.extend({\n            initialize: function(options) {\n                CircsterTrackView.prototype.initialize.call(this, options);\n                // Use a single arc for rendering data.\n                this.innerRadius = this.radius_bounds[0];\n                this.radius_bounds[0] = this.radius_bounds[1];\n                this.bg_stroke = \"#fff\";\n                this.bg_fill = \"#fff\";\n\n                // Minimum arc distance for labels to be applied.\n                this.min_arc_len = 0.05;\n            },\n\n            /**\n     * Render labels.\n     */\n            _render_data: function(svg) {\n                // -- Add chromosome label where it will fit; an alternative labeling mechanism\n                // would be nice for small chromosomes. --\n                var self = this,\n                    chrom_arcs = svg.selectAll(\"g\");\n\n                chrom_arcs.selectAll(\"path\").attr(\"id\", function(d) {\n                    return \"label-\" + d.data.chrom;\n                });\n\n                chrom_arcs\n                    .append(\"svg:text\")\n                    .filter(function(d) {\n                        return d.endAngle - d.startAngle > self.min_arc_len;\n                    })\n                    .attr(\"text-anchor\", \"middle\")\n                    .append(\"svg:textPath\")\n                    .attr(\"class\", \"chrom-label\")\n                    .attr(\"xlink:href\", function(d) {\n                        return \"#label-\" + d.data.chrom;\n                    })\n                    .attr(\"startOffset\", \"25%\")\n                    .text(function(d) {\n                        return d.data.chrom;\n                    });\n\n                // -- Add ticks to denote chromosome length. --\n\n                /** Returns an array of tick angles and labels, given a chrom arc. */\n                var chromArcTicks = function(d) {\n                    var k = (d.endAngle - d.startAngle) / d.value,\n                        ticks = d3\n                            .range(0, d.value, 25000000)\n                            .map(function(v, i) {\n                                return {\n                                    radius: self.innerRadius,\n                                    angle: v * k + d.startAngle,\n                                    label:\n                                        i === 0\n                                            ? 0\n                                            : i % 3 ? null : self.formatNum(v)\n                                };\n                            });\n\n                    // If there are fewer that 4 ticks, label last tick so that at least one non-zero tick is labeled.\n                    if (ticks.length < 4) {\n                        ticks[ticks.length - 1].label = self.formatNum(\n                            Math.round(\n                                (ticks[ticks.length - 1].angle - d.startAngle) /\n                                    k\n                            )\n                        );\n                    }\n\n                    return ticks;\n                };\n\n                /** Rotate and move text as needed. */\n                var textTransform = function(d) {\n                    return d.angle > Math.PI\n                        ? \"rotate(180)translate(-16)\"\n                        : null;\n                };\n\n                // Filter chroms for only those large enough for display.\n                var visibleChroms = _.filter(this.chroms_layout, function(c) {\n                    return c.endAngle - c.startAngle > self.min_arc_len;\n                });\n\n                this.drawTicks(\n                    this.parent_elt,\n                    visibleChroms,\n                    chromArcTicks,\n                    textTransform\n                );\n            }\n        });\n        _.extend(CircsterChromLabelTrackView.prototype, UsesTicks);\n\n        /**\n * View for quantitative track in Circster.\n */\n        var CircsterQuantitativeTrackView = CircsterTrackView.extend({\n            initialize: function(options) {\n                CircsterTrackView.prototype.initialize.call(this, options);\n\n                // When config settings change, update view.\n                var track_config = this.track.get(\"config\");\n                track_config\n                    .get(\"min_value\")\n                    .on(\"change:value\", this._update_min_max, this);\n                track_config\n                    .get(\"max_value\")\n                    .on(\"change:value\", this._update_min_max, this);\n                track_config\n                    .get(\"color\")\n                    .on(\"change:value\", this._transition_chrom_data, this);\n            },\n\n            /**\n     * Update track when min and/or max are changed.\n     */\n            _update_min_max: function() {\n                var track_config = this.track.get(\"config\"),\n                    new_bounds = [\n                        track_config.get_value(\"min_value\"),\n                        track_config.get_value(\"max_value\")\n                    ];\n                this._update_data_bounds(new_bounds);\n\n                // FIXME: this works to update tick/text bounds, but there's probably a better way to do this\n                // by updating the data itself.\n                this.parent_elt.selectAll(\".min_max\").text(function(d, i) {\n                    return new_bounds[i];\n                });\n            },\n\n            /**\n     * Returns quantile for an array of numbers.\n     */\n            _quantile: function(numbers, quantile) {\n                numbers.sort(d3.ascending);\n                return d3.quantile(numbers, quantile);\n            },\n\n            /**\n     * Renders quantitative data with the form [x, value] and assumes data is equally spaced across\n     * chromosome. Attachs a dict with track and chrom name information to DOM element.\n     */\n            _render_chrom_data: function(svg, chrom_arc, chrom_data) {\n                var path_data = this._get_path_function(chrom_arc, chrom_data);\n\n                if (!path_data) {\n                    return null;\n                }\n\n                // There is path data, so render as path.\n                var parent = svg.datum(chrom_data.data),\n                    path = parent\n                        .append(\"path\")\n                        .attr(\"class\", \"chrom-data\")\n                        .attr(\"chrom\", chrom_arc.data.chrom)\n                        .attr(\"d\", path_data);\n\n                return path;\n            },\n\n            /**\n     * Returns function for creating a path across the chrom arc.\n     */\n            _get_path_function: function(chrom_arc, chrom_data) {\n                // If no chrom data, return null.\n                if (\n                    typeof chrom_data === \"string\" ||\n                    !chrom_data.data ||\n                    chrom_data.data.length === 0\n                ) {\n                    return null;\n                }\n\n                // Radius scaler.\n                var radius = d3.scale\n                    .linear()\n                    .domain(this.data_bounds)\n                    .range(this.radius_bounds)\n                    .clamp(true);\n\n                // Scaler for placing data points across arc.\n                var angle = d3.scale\n                    .linear()\n                    .domain([0, chrom_data.data.length])\n                    .range([chrom_arc.startAngle, chrom_arc.endAngle]);\n\n                // Use line generator to create area.\n                var line = d3.svg.line\n                    .radial()\n                    .interpolate(\"linear\")\n                    .radius(function(d) {\n                        return radius(d[1]);\n                    })\n                    .angle(function(d, i) {\n                        return angle(i);\n                    });\n\n                return d3.svg.area\n                    .radial()\n                    .interpolate(line.interpolate())\n                    .innerRadius(radius(0))\n                    .outerRadius(line.radius())\n                    .angle(line.angle());\n            },\n\n            /**\n     * Render track min, max using ticks.\n     */\n            render_labels: function() {\n                var self = this,\n                    // Keep counter of visible chroms.\n                    textTransform = function() {\n                        return \"rotate(90)\";\n                    };\n\n                // FIXME:\n                // (1) using min_max class below is needed for _update_min_max, which could be improved.\n                // (2) showing config on tick click should be replaced by proper track config icon.\n\n                // Draw min, max on first chrom only.\n                var ticks = this.drawTicks(\n                    this.parent_elt,\n                    [this.chroms_layout[0]],\n                    this._data_bounds_ticks_fn(),\n                    textTransform,\n                    true\n                ).classed(\"min_max\", true);\n\n                // Show config when ticks are clicked on.\n                _.each(ticks, function(tick) {\n                    $(tick).click(function() {\n                        var view = new config.ConfigSettingCollectionView({\n                            collection: self.track.get(\"config\")\n                        });\n                        view.render_in_modal(\"Configure Track\");\n                    });\n                });\n\n                /*\n        // Filter for visible chroms, then for every third chrom so that labels attached to only every\n        // third chrom.\n        var visibleChroms = _.filter(this.chroms_layout, function(c) { return c.endAngle - c.startAngle > 0.08; }),\n            labeledChroms = _.filter(visibleChroms, function(c, i) { return i % 3 === 0; });\n        this.drawTicks(this.parent_elt, labeledChroms, this._data_bounds_ticks_fn(), textTransform, true);\n        */\n            },\n\n            /**\n     * Transition labels to new values (e.g new radius or data bounds).\n     */\n            _transition_labels: function() {\n                // FIXME: (a) pull out function for getting labeled chroms? and (b) function used in transition below\n                // is copied from UseTicks mixin, so pull out and make generally available.\n\n                // If there are no data bounds, nothing to transition.\n                if (this.data_bounds.length === 0) {\n                    return;\n                }\n\n                // Transition labels to new radius bounds.\n                var self = this,\n                    visibleChroms = _.filter(this.chroms_layout, function(c) {\n                        return c.endAngle - c.startAngle > 0.08;\n                    }),\n                    labeledChroms = _.filter(visibleChroms, function(c, i) {\n                        return i % 3 === 0;\n                    }),\n                    new_data = _.flatten(\n                        _.map(labeledChroms, function(c) {\n                            return self._data_bounds_ticks_fn()(c);\n                        })\n                    );\n                this.parent_elt\n                    .selectAll(\"g.tick\")\n                    .data(new_data)\n                    .transition()\n                    .attr(\"transform\", function(d) {\n                        return (\n                            \"rotate(\" +\n                            (d.angle * 180 / Math.PI - 90) +\n                            \")\" +\n                            \"translate(\" +\n                            d.radius +\n                            \",0)\"\n                        );\n                    });\n            },\n\n            /**\n     * Get function for locating data bounds ticks.\n     */\n            _data_bounds_ticks_fn: function() {\n                // Closure vars.\n                var self = this;\n                visibleChroms = 0;\n\n                // Return function for locating ticks based on chrom arc data.\n                return function(d) {\n                    // Set up data to display min, max ticks.\n                    return [\n                        {\n                            radius: self.radius_bounds[0],\n                            angle: d.startAngle,\n                            label: self.formatNum(self.data_bounds[0])\n                        },\n                        {\n                            radius: self.radius_bounds[1],\n                            angle: d.startAngle,\n                            label: self.formatNum(self.data_bounds[1])\n                        }\n                    ];\n                };\n            },\n\n            /**\n     * Returns an array with two values denoting the minimum and maximum\n     * values for the track.\n     */\n            get_data_bounds: function(data) {}\n        });\n        _.extend(CircsterQuantitativeTrackView.prototype, UsesTicks);\n\n        /**\n * Bigwig track view in Circster.\n */\n        var CircsterBigWigTrackView = CircsterQuantitativeTrackView.extend({\n            get_data_bounds: function(data) {\n                // Set max across dataset by extracting all values, flattening them into a\n                // single array, and getting third quartile.\n                var values = _.flatten(\n                    _.map(data, function(d) {\n                        if (d) {\n                            // Each data point has the form [position, value], so return all values.\n                            return _.map(d.data, function(p) {\n                                // Null is used for a lack of data; resolve null to 0 for comparison.\n                                return parseInt(p[1], 10) || 0;\n                            });\n                        } else {\n                            return 0;\n                        }\n                    })\n                );\n\n                // For max, use 98% quantile in attempt to avoid very large values. However, this max may be 0\n                // for sparsely populated data, so use max in that case.\n                return [\n                    _.min(values),\n                    this._quantile(values, 0.98) || _.max(values)\n                ];\n            }\n        });\n\n        /**\n * Chromosome interactions track view in Circster.\n */\n        var CircsterChromInteractionsTrackView = CircsterTrackView.extend({\n            render: function() {\n                var self = this;\n\n                // When data is ready, render track.\n                $.when(\n                    self.track.get(\"data_manager\").data_is_ready()\n                ).then(function() {\n                    // When data has been fetched, render track.\n                    $.when(\n                        self.track\n                            .get(\"data_manager\")\n                            .get_genome_wide_data(self.genome)\n                    ).then(function(genome_wide_data) {\n                        var chord_data = [],\n                            chroms_info = self.genome.get_chroms_info();\n                        // Convert chromosome data into chord data.\n                        _.each(genome_wide_data, function(chrom_data, index) {\n                            // Map each interaction into chord data.\n                            var cur_chrom = chroms_info[index].chrom;\n                            var chrom_chord_data = _.map(\n                                chrom_data.data,\n                                function(datum) {\n                                    // Each datum is an interaction/chord.\n                                    var source_angle = self._get_region_angle(\n                                            cur_chrom,\n                                            datum[1]\n                                        ),\n                                        target_angle = self._get_region_angle(\n                                            datum[3],\n                                            datum[4]\n                                        );\n                                    return {\n                                        source: {\n                                            startAngle: source_angle,\n                                            endAngle: source_angle + 0.01\n                                        },\n                                        target: {\n                                            startAngle: target_angle,\n                                            endAngle: target_angle + 0.01\n                                        }\n                                    };\n                                }\n                            );\n\n                            chord_data = chord_data.concat(chrom_chord_data);\n                        });\n\n                        self.parent_elt\n                            .append(\"g\")\n                            .attr(\"class\", \"chord\")\n                            .selectAll(\"path\")\n                            .data(chord_data)\n                            .enter()\n                            .append(\"path\")\n                            .style(\"fill\", self.get_fill_color())\n                            .attr(\n                                \"d\",\n                                d3.svg.chord().radius(self.radius_bounds[0])\n                            )\n                            .style(\"opacity\", 1);\n                    });\n                });\n            },\n\n            update_radius_bounds: function(radius_bounds) {\n                this.radius_bounds = radius_bounds;\n                this.parent_elt\n                    .selectAll(\"path\")\n                    .transition()\n                    .attr(\"d\", d3.svg.chord().radius(this.radius_bounds[0]));\n            },\n\n            /**\n     * Returns radians for a genomic position.\n     */\n            _get_region_angle: function(chrom, position) {\n                // Find chrom angle data\n                var chrom_angle_data = _.find(this.chroms_layout, function(\n                    chrom_layout\n                ) {\n                    return chrom_layout.data.chrom === chrom;\n                });\n\n                // Return angle at position.\n                return (\n                    chrom_angle_data.endAngle -\n                    (chrom_angle_data.endAngle - chrom_angle_data.startAngle) *\n                        (chrom_angle_data.data.len - position) /\n                        chrom_angle_data.data.len\n                );\n            }\n        });\n\n        // circster app loader\n        var Circster = Backbone.View.extend({\n            initialize: function() {\n                // -- Configure visualization --\n                var genome = new visualization.Genome(galaxy_config.app.genome),\n                    vis = new visualization.GenomeVisualization(\n                        galaxy_config.app.viz_config\n                    );\n\n                // Add Circster-specific config options.\n                vis.get(\"config\").add([\n                    {\n                        key: \"arc_dataset_height\",\n                        label: \"Arc Dataset Height\",\n                        type: \"int\",\n                        value: 25,\n                        view: \"circster\"\n                    },\n                    {\n                        key: \"track_gap\",\n                        label: \"Gap Between Tracks\",\n                        type: \"int\",\n                        value: 5,\n                        view: \"circster\"\n                    },\n                    {\n                        key: \"total_gap\",\n                        label: \"Gap [0-1]\",\n                        type: \"float\",\n                        value: 0.4,\n                        view: \"circster\",\n                        hidden: true\n                    }\n                ]);\n\n                var viz_view = new CircsterView({\n                    // view pane\n                    el: $(\"#center .unified-panel-body\"),\n                    genome: genome,\n                    model: vis\n                });\n\n                // Render vizualization\n                viz_view.render();\n\n                // setup title\n                $(\"#center .unified-panel-header-inner\").append(\n                    galaxy_config.app.viz_config.title +\n                        \" \" +\n                        galaxy_config.app.viz_config.dbkey\n                );\n\n                // setup menu\n                var menu = mod_icon_btn.create_icon_buttons_menu(\n                    [\n                        {\n                            icon_class: \"plus-button\",\n                            title: \"Add tracks\",\n                            on_click: function() {\n                                visualization.select_datasets(\n                                    { dbkey: vis.get(\"dbkey\") },\n                                    function(tracks) {\n                                        vis.add_tracks(tracks);\n                                    }\n                                );\n                            }\n                        },\n                        {\n                            icon_class: \"gear\",\n                            title: \"Settings\",\n                            on_click: function() {\n                                var view = new config.ConfigSettingCollectionView(\n                                    {\n                                        collection: vis.get(\"config\")\n                                    }\n                                );\n                                view.render_in_modal(\"Configure Visualization\");\n                            }\n                        },\n                        {\n                            icon_class: \"disk--arrow\",\n                            title: \"Save\",\n                            on_click: function() {\n                                // show saving dialog box\n                                Galaxy.modal.show({\n                                    title: \"Saving...\",\n                                    body: \"progress\"\n                                });\n\n                                // send to server\n                                $.ajax({\n                                    url: Galaxy.root + \"visualization/save\",\n                                    type: \"POST\",\n                                    dataType: \"json\",\n                                    data: {\n                                        id: vis.get(\"vis_id\"),\n                                        title: vis.get(\"title\"),\n                                        dbkey: vis.get(\"dbkey\"),\n                                        type: \"trackster\",\n                                        vis_json: JSON.stringify(vis)\n                                    }\n                                })\n                                    .success(function(vis_info) {\n                                        Galaxy.modal.hide();\n                                        vis.set(\"vis_id\", vis_info.vis_id);\n                                    })\n                                    .error(function() {\n                                        // show dialog\n                                        Galaxy.modal.show({\n                                            title: \"Could Not Save\",\n                                            body:\n                                                \"Could not save visualization. Please try again later.\",\n                                            buttons: {\n                                                Cancel: function() {\n                                                    Galaxy.modal.hide();\n                                                }\n                                            }\n                                        });\n                                    });\n                            }\n                        },\n                        {\n                            icon_class: \"cross-circle\",\n                            title: \"Close\",\n                            on_click: function() {\n                                window.location =\n                                    Galaxy.root + \"visualizations/list\";\n                            }\n                        }\n                    ],\n                    { tooltip_config: { placement: \"bottom\" } }\n                );\n\n                // add menu\n                menu.$el.attr(\"style\", \"float: right\");\n                $(\"#center .unified-panel-header-inner\").append(menu.$el);\n\n                // manual tooltip config because default gravity is S and cannot be changed\n                $(\".menu-button\").tooltip({ placement: \"bottom\" });\n            }\n        });\n\n        // Module exports.\n        return {\n            GalaxyApp: Circster\n        };\n    }\n);\n"]}