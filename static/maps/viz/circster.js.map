{"version":3,"sources":["viz/circster.js"],"names":["_utils2","default","cssLoadFile","SVGUtils","Backbone","Model","extend","is_visible","svg_elt","svg","eltBRect","getBoundingClientRect","svgBRect","$","right","left","bottom","UsesTicks","parent_elt","dataHandler","horizontal","ticks","append","selectAll","data","enter","drawTicks","attr","d","angle","Math","PI","text_coords","text_anchor","tick_coords","label","formatNum","sigDigits","undefined","style","rval","num","toPrecision","textTransform","text","roundedNum","abs","round","options","toFixed","genome","label_arc_height","chords_views","CircsterLabelTrack","CircsterView","model","className","initialize","this","scale","circular_views","get_chord_tracks","get","on","add_track","remove_track","vis_config","get_tracks_bounds","circular_tracks","update_track_bounds","track_gap","filter","track","height","get_circular_tracks","dataset_arc_height","total_gap","tracks_bounds","get_value","select","self","$el","width","radius_start","min_dimension","length","tracks_start_radii","zoom_drag_timeout","clearTimeout","_underscore2","map","radius","render","chords_tracks","CircsterBigWigTrackView","el","view","call","_d2","behavior","zoom","radius_bounds","setTimeout","new_view","CircsterChromInteractionsTrackView","new_track","index","track_view","update_radius_bounds","outermost_radius","track_bounds","label_track_view","CircsterChromLabelTrackView","new_track_bounds","each","innermost_radius_bounds","push","i","track_index","loading_bg_fill","bg_fill","chroms_layout","data_bounds","tracks","splice","remove","genome_arcs","arc_gen","arc","chroms_paths","chroms_elts","CircsterTrackView","View","render_labels","_chroms_layout","get_fill_color","new_d","color","track_parent_elt","new_scale","innerRadius","outerRadius","utils","path_elt","bg_stroke","chrom","data_deferred","data_manager","data_ready_deferred","data_is_ready","when","then","_render_data","_update_data_bounds","_transition_chrom_data","chrom_arcs","chrom_data_paths","num_paths","transition","_transition_labels","update_scale","old_scale","chrom_region","get_chrom_region","can_get_more_detailed_data","get_more_detailed_data","silent","chrom_arc","find","layout","chrom_info","_get_path_function","get_genome_wide_data","genome_wide_data","pie_layout","reject","len","chrom_data","chroms_info","new_endAngle","startAngle","p_data","path","path_data","get_data_bounds","chromArcTicks","endAngle","rendered_deferred","Deferred","track_config","set_value","visibleChroms","zip","layout_and_data","_render_chrom_data","CircsterQuantitativeTrackView","prototype","resolve","get_chroms_info","init_arcs","pie","_quantile","sort","gap_per_chrom","min_arc_len","area","c","tick","value","ConfigSettingCollectionView","collection","render_in_modal","v","k","_update_min_max","new_bounds","numbers","quantile","values","datum","chord_data","cur_chrom","source","range","target","linear","domain","line","interpolate","radial","_get_region_angle","chrom_angle_data","vis","key","type","classed","_config2","menu","icon_class","title","new_data","_data_bounds_ticks_fn","on_click","Galaxy","body","success","error","buttons","Cancel","GalaxyApp","Circster","p","parseInt","min","max","chrom_chord_data","source_angle","target_angle","concat","chord","position","chrom_layout","_visualization2","Genome","galaxy_config","app","GenomeVisualization","viz_config","add","hidden","dbkey","_iconButton2","create_icon_buttons_menu","select_datasets","add_tracks","modal","show","ajax","url","root","dataType","id","vis_json","JSON","stringify","vis_info","hide","set","vis_id","window","location","tooltip_config","placement","tooltip"],"mappings":"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","file":"../../scripts/viz/circster.js","sourcesContent":["import _ from \"libs/underscore\";\nimport d3 from \"libs/d3\";\nimport visualization from \"viz/visualization\";\nimport mod_utils from \"utils/utils\";\nimport config from \"utils/config\";\nimport mod_icon_btn from \"mvc/ui/icon-button\";\nimport \"libs/farbtastic\";\n/**\n * Utility class for working with SVG.\n */\n// load css\nmod_utils.cssLoadFile(\"static/style/circster.css\");\n\nvar SVGUtils = Backbone.Model.extend({\n    /**\n     * Returns true if element is visible.\n     */\n    is_visible: function(svg_elt, svg) {\n        var eltBRect = svg_elt.getBoundingClientRect(),\n            svgBRect = $(\"svg\")[0].getBoundingClientRect();\n\n        if (\n            // To the left of screen?\n            eltBRect.right < 0 ||\n            // To the right of screen?\n            eltBRect.left > svgBRect.right ||\n            // Above screen?\n            eltBRect.bottom < 0 ||\n            // Below screen?\n            eltBRect.top > svgBRect.bottom\n        ) {\n            return false;\n        }\n        return true;\n    }\n});\n\n/**\n * Mixin for using ticks.\n */\nvar UsesTicks = {\n    drawTicks: function(\n        parent_elt,\n        data,\n        dataHandler,\n        textTransform,\n        horizontal\n    ) {\n        // Set up group elements for chroms and for each tick.\n        var ticks = parent_elt\n            .append(\"g\")\n            .selectAll(\"g\")\n            .data(data)\n            .enter()\n            .append(\"g\")\n            .selectAll(\"g\")\n            .data(dataHandler)\n            .enter()\n            .append(\"g\")\n            .attr(\"class\", \"tick\")\n            .attr(\"transform\", function(d) {\n                return (\n                    \"rotate(\" +\n                    (d.angle * 180 / Math.PI - 90) +\n                    \")\" +\n                    \"translate(\" +\n                    d.radius +\n                    \",0)\"\n                );\n            });\n\n        // Add line + text for ticks.\n        var tick_coords = [],\n            text_coords = [],\n            text_anchor = function(d) {\n                return d.angle > Math.PI ? \"end\" : null;\n            };\n        if (horizontal) {\n            tick_coords = [0, 0, 0, -4];\n            text_coords = [4, 0, \"\", \".35em\"];\n            text_anchor = null;\n        } else {\n            tick_coords = [1, 0, 4, 0];\n            text_coords = [0, 4, \".35em\", \"\"];\n        }\n\n        ticks\n            .append(\"line\")\n            .attr(\"x1\", tick_coords[0])\n            .attr(\"y1\", tick_coords[1])\n            .attr(\"x2\", tick_coords[2])\n            .attr(\"y1\", tick_coords[3])\n            .style(\"stroke\", \"#000\");\n\n        return ticks\n            .append(\"text\")\n            .attr(\"x\", text_coords[0])\n            .attr(\"y\", text_coords[1])\n            .attr(\"dx\", text_coords[2])\n            .attr(\"dy\", text_coords[3])\n            .attr(\"text-anchor\", text_anchor)\n            .attr(\"transform\", textTransform)\n            .text(function(d) {\n                return d.label;\n            });\n    },\n\n    /**\n     * Format number for display at a tick.\n     */\n    formatNum: function(num, sigDigits) {\n        // Use default of 2 sig. digits.\n        if (sigDigits === undefined) sigDigits = 2;\n\n        // Verify input number\n        if (num === null) return null;\n\n        // Calculate return value\n        var rval = null;\n        if (Math.abs(num) < 1) {\n            rval = num.toPrecision(sigDigits);\n        } else {\n            // Use round to turn string from toPrecision() back into a number.\n            var roundedNum = Math.round(num.toPrecision(sigDigits));\n\n            // Use abbreviations.\n            num = Math.abs(num);\n            if (num < 1000) {\n                rval = roundedNum;\n            } else if (num < 1000000) {\n                // Use K.\n                rval =\n                    Math.round((roundedNum / 1000).toPrecision(3)).toFixed(0) +\n                    \"K\";\n            } else if (num < 1000000000) {\n                // Use M.\n                rval =\n                    Math.round((roundedNum / 1000000).toPrecision(3)).toFixed(\n                        0\n                    ) + \"M\";\n            }\n        }\n\n        return rval;\n    }\n};\n\n/**\n * A label track.\n */\nvar CircsterLabelTrack = Backbone.Model.extend({});\n\n/**\n * Renders a full circster visualization.\n */\nvar CircsterView = Backbone.View.extend({\n    className: \"circster\",\n\n    initialize: function(options) {\n        this.genome = options.genome;\n        this.label_arc_height = 50;\n        this.scale = 1;\n        this.circular_views = null;\n        this.chords_views = null;\n\n        // When tracks added to/removed from model, update view.\n        this.model.get(\"drawables\").on(\"add\", this.add_track, this);\n        this.model.get(\"drawables\").on(\"remove\", this.remove_track, this);\n\n        // When config settings change, update view.\n        var vis_config = this.model.get(\"config\");\n        vis_config\n            .get(\"arc_dataset_height\")\n            .on(\"change:value\", this.update_track_bounds, this);\n        vis_config\n            .get(\"track_gap\")\n            .on(\"change:value\", this.update_track_bounds, this);\n    },\n\n    // HACKs: using track_type for circular/chord distinction in the functions below for now.\n\n    /**\n     * Returns tracks to be rendered using circular view.\n     */\n    get_circular_tracks: function() {\n        return this.model.get(\"drawables\").filter(function(track) {\n            return track.get(\"track_type\") !== \"DiagonalHeatmapTrack\";\n        });\n    },\n\n    /**\n     * Returns tracks to be rendered using chords view.\n     */\n    get_chord_tracks: function() {\n        return this.model.get(\"drawables\").filter(function(track) {\n            return track.get(\"track_type\") === \"DiagonalHeatmapTrack\";\n        });\n    },\n\n    /**\n     * Returns a list of circular tracks' radius bounds.\n     */\n    get_tracks_bounds: function() {\n        var circular_tracks = this.get_circular_tracks(),\n            dataset_arc_height = this.model\n                .get(\"config\")\n                .get_value(\"arc_dataset_height\"),\n            track_gap = this.model.get(\"config\").get_value(\"track_gap\"),\n            // Subtract 20 to make sure chrom labels are on screen.\n            min_dimension = Math.min(this.$el.width(), this.$el.height()) - 20,\n            // Compute radius start based on model, will be centered\n            // and fit entirely inside element by default.\n            radius_start =\n                min_dimension / 2 -\n                circular_tracks.length * (dataset_arc_height + track_gap) +\n                // Add track_gap back in because no gap is needed for last track.\n                track_gap -\n                this.label_arc_height,\n            // Compute range of track starting radii.\n            tracks_start_radii = d3.range(\n                radius_start,\n                min_dimension / 2,\n                dataset_arc_height + track_gap\n            );\n\n        // Map from track start to bounds.\n        var self = this;\n        return _.map(tracks_start_radii, function(radius) {\n            return [radius, radius + dataset_arc_height];\n        });\n    },\n\n    /**\n     * Renders circular tracks, chord tracks, and label tracks.\n     */\n    render: function() {\n        var self = this,\n            width = self.$el.width(),\n            height = self.$el.height(),\n            circular_tracks = this.get_circular_tracks(),\n            chords_tracks = this.get_chord_tracks(),\n            total_gap = self.model.get(\"config\").get_value(\"total_gap\"),\n            tracks_bounds = this.get_tracks_bounds(),\n            // Set up SVG element.\n            svg = d3\n                .select(self.$el[0])\n                .append(\"svg\")\n                .attr(\"width\", width)\n                .attr(\"height\", height)\n                .attr(\"pointer-events\", \"all\")\n                // Set up zooming, dragging.\n                .append(\"svg:g\")\n                .call(\n                    d3.behavior.zoom().on(\"zoom\", function() {\n                        // Do zoom, drag.\n                        var scale = d3.event.scale;\n                        svg.attr(\n                            \"transform\",\n                            \"translate(\" +\n                                d3.event.translate +\n                                \")\" +\n                                \" scale(\" +\n                                scale +\n                                \")\"\n                        );\n\n                        // Propagate scale changes to views.\n                        if (self.scale !== scale) {\n                            // Use timeout to wait for zooming/dragging to stop before rendering more detail.\n                            if (self.zoom_drag_timeout) {\n                                clearTimeout(self.zoom_drag_timeout);\n                            }\n                            self.zoom_drag_timeout = setTimeout(function() {\n                                // Render more detail in tracks' visible elements.\n                                // FIXME: do not do this right now; it is not fully implemented--e.g. data bounds\n                                // are not updated when new data is fetched--and fetching more detailed quantitative\n                                // data is not that useful.\n                                /*\n                            _.each(self.circular_views, function(view) {\n                                view.update_scale(scale);\n                            });\n                            */\n                            }, 400);\n                        }\n                    })\n                )\n                .attr(\n                    \"transform\",\n                    \"translate(\" + width / 2 + \",\" + height / 2 + \")\"\n                )\n                .append(\"svg:g\")\n                .attr(\"class\", \"tracks\");\n\n        // -- Render circular tracks. --\n\n        // Create a view for each track in the visualization and render.\n        this.circular_views = circular_tracks.map(function(track, index) {\n            var view = new CircsterBigWigTrackView({\n                el: svg.append(\"g\")[0],\n                track: track,\n                radius_bounds: tracks_bounds[index],\n                genome: self.genome,\n                total_gap: total_gap\n            });\n\n            view.render();\n\n            return view;\n        });\n\n        // -- Render chords tracks. --\n\n        this.chords_views = chords_tracks.map(function(track) {\n            var view = new CircsterChromInteractionsTrackView({\n                el: svg.append(\"g\")[0],\n                track: track,\n                radius_bounds: tracks_bounds[0],\n                genome: self.genome,\n                total_gap: total_gap\n            });\n\n            view.render();\n\n            return view;\n        });\n\n        // -- Render label track. --\n\n        // Track bounds are:\n        // (a) outer radius of last circular track;\n        // (b)\n        var outermost_radius = this.circular_views[\n                this.circular_views.length - 1\n            ].radius_bounds[1],\n            track_bounds = [\n                outermost_radius,\n                outermost_radius + this.label_arc_height\n            ];\n        this.label_track_view = new CircsterChromLabelTrackView({\n            el: svg.append(\"g\")[0],\n            track: new CircsterLabelTrack(),\n            radius_bounds: track_bounds,\n            genome: self.genome,\n            total_gap: total_gap\n        });\n\n        this.label_track_view.render();\n    },\n\n    /**\n     * Render a single track on the outside of the current visualization.\n     */\n    add_track: function(new_track) {\n        var total_gap = this.model.get(\"config\").get_value(\"total_gap\");\n\n        if (new_track.get(\"track_type\") === \"DiagonalHeatmapTrack\") {\n            // Added chords track.\n            var innermost_radius_bounds = this.circular_views[0].radius_bounds,\n                new_view = new CircsterChromInteractionsTrackView({\n                    el: d3.select(\"g.tracks\").append(\"g\")[0],\n                    track: new_track,\n                    radius_bounds: innermost_radius_bounds,\n                    genome: this.genome,\n                    total_gap: total_gap\n                });\n            new_view.render();\n            this.chords_views.push(new_view);\n        } else {\n            // Added circular track.\n\n            // Recompute and update circular track bounds.\n            var new_track_bounds = this.get_tracks_bounds();\n            _.each(this.circular_views, function(track_view, i) {\n                track_view.update_radius_bounds(new_track_bounds[i]);\n            });\n\n            // Update chords tracks.\n            _.each(this.chords_views, function(track_view) {\n                track_view.update_radius_bounds(new_track_bounds[0]);\n            });\n\n            // Render new track.\n            var track_index = this.circular_views.length,\n                track_view = new CircsterBigWigTrackView({\n                    el: d3.select(\"g.tracks\").append(\"g\")[0],\n                    track: new_track,\n                    radius_bounds: new_track_bounds[track_index],\n                    genome: this.genome,\n                    total_gap: total_gap\n                });\n            track_view.render();\n            this.circular_views.push(track_view);\n\n            // Update label track.\n            /*\n            FIXME: should never have to update label track because vis always expands to fit area\n            within label track.\n            var track_bounds = new_track_bounds[ new_track_bounds.length-1 ];\n            track_bounds[1] = track_bounds[0];\n            this.label_track_view.update_radius_bounds(track_bounds);\n            */\n        }\n    },\n\n    /**\n     * Remove a track from the view.\n     */\n    remove_track: function(track, tracks, options) {\n        // -- Remove track from view. --\n        var track_view = this.circular_views[options.index];\n        this.circular_views.splice(options.index, 1);\n        track_view.$el.remove();\n\n        // Recompute and update track bounds.\n        var new_track_bounds = this.get_tracks_bounds();\n        _.each(this.circular_views, function(track_view, i) {\n            track_view.update_radius_bounds(new_track_bounds[i]);\n        });\n    },\n\n    update_track_bounds: function() {\n        // Recompute and update track bounds.\n        var new_track_bounds = this.get_tracks_bounds();\n        _.each(this.circular_views, function(track_view, i) {\n            track_view.update_radius_bounds(new_track_bounds[i]);\n        });\n\n        // Update chords tracks.\n        _.each(this.chords_views, function(track_view) {\n            track_view.update_radius_bounds(new_track_bounds[0]);\n        });\n    }\n});\n\n/**\n * Renders a track in a Circster visualization.\n */\nvar CircsterTrackView = Backbone.View.extend({\n    tagName: \"g\",\n\n    /* ----------------------- Public Methods ------------------------- */\n\n    initialize: function(options) {\n        this.bg_stroke = \"#ddd\";\n        // Fill color when loading data.\n        this.loading_bg_fill = \"#ffc\";\n        // Fill color when data has been loaded.\n        this.bg_fill = \"#ddd\";\n        this.total_gap = options.total_gap;\n        this.track = options.track;\n        this.radius_bounds = options.radius_bounds;\n        this.genome = options.genome;\n        this.chroms_layout = this._chroms_layout();\n        this.data_bounds = [];\n        this.scale = 1;\n        this.parent_elt = d3.select(this.$el[0]);\n    },\n\n    /**\n     * Get fill color from config.\n     */\n    get_fill_color: function() {\n        var color = this.track.get(\"config\").get_value(\"block_color\");\n        if (!color) {\n            color = this.track.get(\"config\").get_value(\"color\");\n        }\n        return color;\n    },\n\n    /**\n     * Render track's data by adding SVG elements to parent.\n     */\n    render: function() {\n        // -- Create track group element. --\n        var track_parent_elt = this.parent_elt;\n\n        // -- Render background arcs. --\n        var genome_arcs = this.chroms_layout,\n            arc_gen = d3.svg\n                .arc()\n                .innerRadius(this.radius_bounds[0])\n                .outerRadius(this.radius_bounds[1]),\n            // Attach data to group element.\n            chroms_elts = track_parent_elt\n                .selectAll(\"g\")\n                .data(genome_arcs)\n                .enter()\n                .append(\"svg:g\"),\n            // Draw chrom arcs/paths.\n            chroms_paths = chroms_elts\n                .append(\"path\")\n                .attr(\"d\", arc_gen)\n                .attr(\"class\", \"chrom-background\")\n                .style(\"stroke\", this.bg_stroke)\n                .style(\"fill\", this.loading_bg_fill);\n\n        // Append titles to paths.\n        chroms_paths.append(\"title\").text(function(d) {\n            return d.data.chrom;\n        });\n\n        // -- Render track data and, when track data is rendered, apply preferences and update chrom_elts fill. --\n\n        var self = this,\n            data_manager = self.track.get(\"data_manager\"),\n            // If track has a data manager, get deferred that resolves when data is ready.\n            data_ready_deferred = data_manager\n                ? data_manager.data_is_ready()\n                : true;\n\n        // When data is ready, render track.\n        $.when(data_ready_deferred).then(function() {\n            $.when(self._render_data(track_parent_elt)).then(function() {\n                chroms_paths.style(\"fill\", self.bg_fill);\n\n                // Render labels after data is available so that data attributes are available.\n                self.render_labels();\n            });\n        });\n    },\n\n    /**\n     * Render track labels.\n     */\n    render_labels: function() {},\n\n    /**\n     * Update radius bounds.\n     */\n    update_radius_bounds: function(radius_bounds) {\n        // Update bounds.\n        this.radius_bounds = radius_bounds;\n\n        // -- Update background arcs. --\n        var new_d = d3.svg\n            .arc()\n            .innerRadius(this.radius_bounds[0])\n            .outerRadius(this.radius_bounds[1]);\n\n        this.parent_elt\n            .selectAll(\"g>path.chrom-background\")\n            .transition()\n            .duration(1000)\n            .attr(\"d\", new_d);\n\n        this._transition_chrom_data();\n\n        this._transition_labels();\n    },\n\n    /**\n     * Update view scale. This fetches more data if scale is increased.\n     */\n    update_scale: function(new_scale) {\n        // -- Update scale and return if new scale is less than old scale. --\n\n        var old_scale = this.scale;\n        this.scale = new_scale;\n        if (new_scale <= old_scale) {\n            return;\n        }\n\n        // -- Scale increased, so render visible data with more detail. --\n\n        var self = this,\n            utils = new SVGUtils();\n\n        // Select all chrom data and filter to operate on those that are visible.\n        this.parent_elt\n            .selectAll(\"path.chrom-data\")\n            .filter(function(d, i) {\n                return utils.is_visible(this);\n            })\n            .each(function(d, i) {\n                // -- Now operating on a single path element representing chromosome data. --\n\n                var path_elt = d3.select(this),\n                    chrom = path_elt.attr(\"chrom\"),\n                    chrom_region = self.genome.get_chrom_region(chrom),\n                    data_manager = self.track.get(\"data_manager\"),\n                    data_deferred;\n\n                // If can't get more detailed data, return.\n                if (!data_manager.can_get_more_detailed_data(chrom_region)) {\n                    return;\n                }\n\n                // -- Get more detailed data. --\n                data_deferred = self.track\n                    .get(\"data_manager\")\n                    .get_more_detailed_data(\n                        chrom_region,\n                        \"Coverage\",\n                        0,\n                        new_scale\n                    );\n\n                // When more data is available, use new data to redraw path.\n                $.when(data_deferred).then(function(data) {\n                    // Remove current data path.\n                    path_elt.remove();\n\n                    // Update data bounds with new data.\n                    self._update_data_bounds();\n\n                    // Find chromosome arc to draw data on.\n                    var chrom_arc = _.find(self.chroms_layout, function(\n                        layout\n                    ) {\n                        return layout.data.chrom === chrom;\n                    });\n\n                    // Add new data path and apply preferences.\n                    var color = self.get_fill_color();\n                    self\n                        ._render_chrom_data(self.parent_elt, chrom_arc, data)\n                        .style(\"stroke\", color)\n                        .style(\"fill\", color);\n                });\n            });\n\n        return self;\n    },\n\n    /* ----------------------- Internal Methods ------------------------- */\n\n    /**\n     * Transitions chrom data to new values (e.g new radius or data bounds).\n     */\n    _transition_chrom_data: function() {\n        var track = this.track,\n            chrom_arcs = this.chroms_layout,\n            chrom_data_paths = this.parent_elt.selectAll(\"g>path.chrom-data\"),\n            num_paths = chrom_data_paths[0].length;\n\n        if (num_paths > 0) {\n            var self = this;\n            $.when(\n                track.get(\"data_manager\").get_genome_wide_data(this.genome)\n            ).then(function(genome_wide_data) {\n                // Map chrom data to path data, filtering out null values.\n                var path_data = _.reject(\n                    _.map(genome_wide_data, function(chrom_data, i) {\n                        var rval = null,\n                            path_fn = self._get_path_function(\n                                chrom_arcs[i],\n                                chrom_data\n                            );\n                        if (path_fn) {\n                            rval = path_fn(chrom_data.data);\n                        }\n                        return rval;\n                    }),\n                    function(p_data) {\n                        return p_data === null;\n                    }\n                );\n\n                // Transition each path for data and color.\n                var color = track.get(\"config\").get_value(\"color\");\n                chrom_data_paths.each(function(path, index) {\n                    d3\n                        .select(this)\n                        .transition()\n                        .duration(1000)\n                        .style(\"stroke\", color)\n                        .style(\"fill\", color)\n                        .attr(\"d\", path_data[index]);\n                });\n            });\n        }\n    },\n\n    /**\n     * Transition labels to new values (e.g new radius or data bounds).\n     */\n    _transition_labels: function() {},\n\n    /**\n     * Update data bounds. If there are new_bounds, use them; otherwise use\n     * default data bounds.\n     */\n    _update_data_bounds: function(new_bounds) {\n        var old_bounds = this.data_bounds;\n        this.data_bounds =\n            new_bounds ||\n            this.get_data_bounds(\n                this.track.get(\"data_manager\").get_genome_wide_data(this.genome)\n            );\n        this._transition_chrom_data();\n    },\n\n    /**\n     * Render data as elements attached to svg.\n     */\n    _render_data: function(svg) {\n        var self = this,\n            chrom_arcs = this.chroms_layout,\n            track = this.track,\n            rendered_deferred = $.Deferred();\n\n        // When genome-wide data is available, render data.\n        $.when(\n            track.get(\"data_manager\").get_genome_wide_data(this.genome)\n        ).then(function(genome_wide_data) {\n            // Set bounds.\n            self.data_bounds = self.get_data_bounds(genome_wide_data);\n\n            // Set min, max value in config so that they can be adjusted. Make this silent\n            // because these attributes are watched for changes and the viz is updated\n            // accordingly (set up in initialize). Because we are setting up, we don't want\n            // the watch to trigger events here.\n            track.get(\"config\").set_value(\"min_value\", self.data_bounds[0], {\n                silent: true\n            });\n            track.get(\"config\").set_value(\"max_value\", self.data_bounds[1], {\n                silent: true\n            });\n\n            // Merge chroms layout with data.\n            var layout_and_data = _.zip(chrom_arcs, genome_wide_data);\n\n            // Render each chromosome's data.\n            _.each(layout_and_data, function(chrom_info) {\n                var chrom_arc = chrom_info[0],\n                    data = chrom_info[1];\n                return self._render_chrom_data(svg, chrom_arc, data);\n            });\n\n            // Apply prefs to all track data.\n            var color = self.get_fill_color();\n            self.parent_elt\n                .selectAll(\"path.chrom-data\")\n                .style(\"stroke\", color)\n                .style(\"fill\", color);\n\n            rendered_deferred.resolve(svg);\n        });\n\n        return rendered_deferred;\n    },\n\n    /**\n     * Render a chromosome data and attach elements to svg.\n     */\n    _render_chrom_data: function(svg, chrom_arc, data) {},\n\n    /**\n     * Returns data for creating a path for the given data using chrom_arc and data bounds.\n     */\n    _get_path_function: function(chrom_arc, chrom_data) {},\n\n    /**\n     * Returns arc layouts for genome's chromosomes/contigs. Arcs are arranged in a circle\n     * separated by gaps.\n     */\n    _chroms_layout: function() {\n        // Setup chroms layout using pie.\n        var chroms_info = this.genome.get_chroms_info(),\n            pie_layout = d3.layout\n                .pie()\n                .value(function(d) {\n                    return d.len;\n                })\n                .sort(null),\n            init_arcs = pie_layout(chroms_info),\n            gap_per_chrom = 2 * Math.PI * this.total_gap / chroms_info.length,\n            chrom_arcs = _.map(init_arcs, function(arc, index) {\n                // For short chroms, endAngle === startAngle.\n                var new_endAngle = arc.endAngle - gap_per_chrom;\n                arc.endAngle =\n                    new_endAngle > arc.startAngle\n                        ? new_endAngle\n                        : arc.startAngle;\n                return arc;\n            });\n        return chrom_arcs;\n    }\n});\n\n/**\n * Render chromosome labels.\n */\nvar CircsterChromLabelTrackView = CircsterTrackView.extend({\n    initialize: function(options) {\n        CircsterTrackView.prototype.initialize.call(this, options);\n        // Use a single arc for rendering data.\n        this.innerRadius = this.radius_bounds[0];\n        this.radius_bounds[0] = this.radius_bounds[1];\n        this.bg_stroke = \"#fff\";\n        this.bg_fill = \"#fff\";\n\n        // Minimum arc distance for labels to be applied.\n        this.min_arc_len = 0.05;\n    },\n\n    /**\n     * Render labels.\n     */\n    _render_data: function(svg) {\n        // -- Add chromosome label where it will fit; an alternative labeling mechanism\n        // would be nice for small chromosomes. --\n        var self = this,\n            chrom_arcs = svg.selectAll(\"g\");\n\n        chrom_arcs.selectAll(\"path\").attr(\"id\", function(d) {\n            return \"label-\" + d.data.chrom;\n        });\n\n        chrom_arcs\n            .append(\"svg:text\")\n            .filter(function(d) {\n                return d.endAngle - d.startAngle > self.min_arc_len;\n            })\n            .attr(\"text-anchor\", \"middle\")\n            .append(\"svg:textPath\")\n            .attr(\"class\", \"chrom-label\")\n            .attr(\"xlink:href\", function(d) {\n                return \"#label-\" + d.data.chrom;\n            })\n            .attr(\"startOffset\", \"25%\")\n            .text(function(d) {\n                return d.data.chrom;\n            });\n\n        // -- Add ticks to denote chromosome length. --\n\n        /** Returns an array of tick angles and labels, given a chrom arc. */\n        var chromArcTicks = function(d) {\n            var k = (d.endAngle - d.startAngle) / d.value,\n                ticks = d3.range(0, d.value, 25000000).map(function(v, i) {\n                    return {\n                        radius: self.innerRadius,\n                        angle: v * k + d.startAngle,\n                        label: i === 0 ? 0 : i % 3 ? null : self.formatNum(v)\n                    };\n                });\n\n            // If there are fewer that 4 ticks, label last tick so that at least one non-zero tick is labeled.\n            if (ticks.length < 4) {\n                ticks[ticks.length - 1].label = self.formatNum(\n                    Math.round(\n                        (ticks[ticks.length - 1].angle - d.startAngle) / k\n                    )\n                );\n            }\n\n            return ticks;\n        };\n\n        /** Rotate and move text as needed. */\n        var textTransform = function(d) {\n            return d.angle > Math.PI ? \"rotate(180)translate(-16)\" : null;\n        };\n\n        // Filter chroms for only those large enough for display.\n        var visibleChroms = _.filter(this.chroms_layout, function(c) {\n            return c.endAngle - c.startAngle > self.min_arc_len;\n        });\n\n        this.drawTicks(\n            this.parent_elt,\n            visibleChroms,\n            chromArcTicks,\n            textTransform\n        );\n    }\n});\n_.extend(CircsterChromLabelTrackView.prototype, UsesTicks);\n\n/**\n * View for quantitative track in Circster.\n */\nvar CircsterQuantitativeTrackView = CircsterTrackView.extend({\n    initialize: function(options) {\n        CircsterTrackView.prototype.initialize.call(this, options);\n\n        // When config settings change, update view.\n        var track_config = this.track.get(\"config\");\n        track_config\n            .get(\"min_value\")\n            .on(\"change:value\", this._update_min_max, this);\n        track_config\n            .get(\"max_value\")\n            .on(\"change:value\", this._update_min_max, this);\n        track_config\n            .get(\"color\")\n            .on(\"change:value\", this._transition_chrom_data, this);\n    },\n\n    /**\n     * Update track when min and/or max are changed.\n     */\n    _update_min_max: function() {\n        var track_config = this.track.get(\"config\"),\n            new_bounds = [\n                track_config.get_value(\"min_value\"),\n                track_config.get_value(\"max_value\")\n            ];\n        this._update_data_bounds(new_bounds);\n\n        // FIXME: this works to update tick/text bounds, but there's probably a better way to do this\n        // by updating the data itself.\n        this.parent_elt.selectAll(\".min_max\").text(function(d, i) {\n            return new_bounds[i];\n        });\n    },\n\n    /**\n     * Returns quantile for an array of numbers.\n     */\n    _quantile: function(numbers, quantile) {\n        numbers.sort(d3.ascending);\n        return d3.quantile(numbers, quantile);\n    },\n\n    /**\n     * Renders quantitative data with the form [x, value] and assumes data is equally spaced across\n     * chromosome. Attachs a dict with track and chrom name information to DOM element.\n     */\n    _render_chrom_data: function(svg, chrom_arc, chrom_data) {\n        var path_data = this._get_path_function(chrom_arc, chrom_data);\n\n        if (!path_data) {\n            return null;\n        }\n\n        // There is path data, so render as path.\n        var parent = svg.datum(chrom_data.data),\n            path = parent\n                .append(\"path\")\n                .attr(\"class\", \"chrom-data\")\n                .attr(\"chrom\", chrom_arc.data.chrom)\n                .attr(\"d\", path_data);\n\n        return path;\n    },\n\n    /**\n     * Returns function for creating a path across the chrom arc.\n     */\n    _get_path_function: function(chrom_arc, chrom_data) {\n        // If no chrom data, return null.\n        if (\n            typeof chrom_data === \"string\" ||\n            !chrom_data.data ||\n            chrom_data.data.length === 0\n        ) {\n            return null;\n        }\n\n        // Radius scaler.\n        var radius = d3.scale\n            .linear()\n            .domain(this.data_bounds)\n            .range(this.radius_bounds)\n            .clamp(true);\n\n        // Scaler for placing data points across arc.\n        var angle = d3.scale\n            .linear()\n            .domain([0, chrom_data.data.length])\n            .range([chrom_arc.startAngle, chrom_arc.endAngle]);\n\n        // Use line generator to create area.\n        var line = d3.svg.line\n            .radial()\n            .interpolate(\"linear\")\n            .radius(function(d) {\n                return radius(d[1]);\n            })\n            .angle(function(d, i) {\n                return angle(i);\n            });\n\n        return d3.svg.area\n            .radial()\n            .interpolate(line.interpolate())\n            .innerRadius(radius(0))\n            .outerRadius(line.radius())\n            .angle(line.angle());\n    },\n\n    /**\n     * Render track min, max using ticks.\n     */\n    render_labels: function() {\n        var self = this,\n            // Keep counter of visible chroms.\n            textTransform = function() {\n                return \"rotate(90)\";\n            };\n\n        // FIXME:\n        // (1) using min_max class below is needed for _update_min_max, which could be improved.\n        // (2) showing config on tick click should be replaced by proper track config icon.\n\n        // Draw min, max on first chrom only.\n        var ticks = this.drawTicks(\n            this.parent_elt,\n            [this.chroms_layout[0]],\n            this._data_bounds_ticks_fn(),\n            textTransform,\n            true\n        ).classed(\"min_max\", true);\n\n        // Show config when ticks are clicked on.\n        _.each(ticks, function(tick) {\n            $(tick).click(function() {\n                var view = new config.ConfigSettingCollectionView({\n                    collection: self.track.get(\"config\")\n                });\n                view.render_in_modal(\"Configure Track\");\n            });\n        });\n\n        /*\n        // Filter for visible chroms, then for every third chrom so that labels attached to only every\n        // third chrom.\n        var visibleChroms = _.filter(this.chroms_layout, function(c) { return c.endAngle - c.startAngle > 0.08; }),\n            labeledChroms = _.filter(visibleChroms, function(c, i) { return i % 3 === 0; });\n        this.drawTicks(this.parent_elt, labeledChroms, this._data_bounds_ticks_fn(), textTransform, true);\n        */\n    },\n\n    /**\n     * Transition labels to new values (e.g new radius or data bounds).\n     */\n    _transition_labels: function() {\n        // FIXME: (a) pull out function for getting labeled chroms? and (b) function used in transition below\n        // is copied from UseTicks mixin, so pull out and make generally available.\n\n        // If there are no data bounds, nothing to transition.\n        if (this.data_bounds.length === 0) {\n            return;\n        }\n\n        // Transition labels to new radius bounds.\n        var self = this,\n            visibleChroms = _.filter(this.chroms_layout, function(c) {\n                return c.endAngle - c.startAngle > 0.08;\n            }),\n            labeledChroms = _.filter(visibleChroms, function(c, i) {\n                return i % 3 === 0;\n            }),\n            new_data = _.flatten(\n                _.map(labeledChroms, function(c) {\n                    return self._data_bounds_ticks_fn()(c);\n                })\n            );\n        this.parent_elt\n            .selectAll(\"g.tick\")\n            .data(new_data)\n            .transition()\n            .attr(\"transform\", function(d) {\n                return (\n                    \"rotate(\" +\n                    (d.angle * 180 / Math.PI - 90) +\n                    \")\" +\n                    \"translate(\" +\n                    d.radius +\n                    \",0)\"\n                );\n            });\n    },\n\n    /**\n     * Get function for locating data bounds ticks.\n     */\n    _data_bounds_ticks_fn: function() {\n        // Closure vars.\n        var self = this;\n        visibleChroms = 0;\n\n        // Return function for locating ticks based on chrom arc data.\n        return function(d) {\n            // Set up data to display min, max ticks.\n            return [\n                {\n                    radius: self.radius_bounds[0],\n                    angle: d.startAngle,\n                    label: self.formatNum(self.data_bounds[0])\n                },\n                {\n                    radius: self.radius_bounds[1],\n                    angle: d.startAngle,\n                    label: self.formatNum(self.data_bounds[1])\n                }\n            ];\n        };\n    },\n\n    /**\n     * Returns an array with two values denoting the minimum and maximum\n     * values for the track.\n     */\n    get_data_bounds: function(data) {}\n});\n_.extend(CircsterQuantitativeTrackView.prototype, UsesTicks);\n\n/**\n * Bigwig track view in Circster.\n */\nvar CircsterBigWigTrackView = CircsterQuantitativeTrackView.extend({\n    get_data_bounds: function(data) {\n        // Set max across dataset by extracting all values, flattening them into a\n        // single array, and getting third quartile.\n        var values = _.flatten(\n            _.map(data, function(d) {\n                if (d) {\n                    // Each data point has the form [position, value], so return all values.\n                    return _.map(d.data, function(p) {\n                        // Null is used for a lack of data; resolve null to 0 for comparison.\n                        return parseInt(p[1], 10) || 0;\n                    });\n                } else {\n                    return 0;\n                }\n            })\n        );\n\n        // For max, use 98% quantile in attempt to avoid very large values. However, this max may be 0\n        // for sparsely populated data, so use max in that case.\n        return [_.min(values), this._quantile(values, 0.98) || _.max(values)];\n    }\n});\n\n/**\n * Chromosome interactions track view in Circster.\n */\nvar CircsterChromInteractionsTrackView = CircsterTrackView.extend({\n    render: function() {\n        var self = this;\n\n        // When data is ready, render track.\n        $.when(self.track.get(\"data_manager\").data_is_ready()).then(function() {\n            // When data has been fetched, render track.\n            $.when(\n                self.track.get(\"data_manager\").get_genome_wide_data(self.genome)\n            ).then(function(genome_wide_data) {\n                var chord_data = [],\n                    chroms_info = self.genome.get_chroms_info();\n                // Convert chromosome data into chord data.\n                _.each(genome_wide_data, function(chrom_data, index) {\n                    // Map each interaction into chord data.\n                    var cur_chrom = chroms_info[index].chrom;\n                    var chrom_chord_data = _.map(chrom_data.data, function(\n                        datum\n                    ) {\n                        // Each datum is an interaction/chord.\n                        var source_angle = self._get_region_angle(\n                                cur_chrom,\n                                datum[1]\n                            ),\n                            target_angle = self._get_region_angle(\n                                datum[3],\n                                datum[4]\n                            );\n                        return {\n                            source: {\n                                startAngle: source_angle,\n                                endAngle: source_angle + 0.01\n                            },\n                            target: {\n                                startAngle: target_angle,\n                                endAngle: target_angle + 0.01\n                            }\n                        };\n                    });\n\n                    chord_data = chord_data.concat(chrom_chord_data);\n                });\n\n                self.parent_elt\n                    .append(\"g\")\n                    .attr(\"class\", \"chord\")\n                    .selectAll(\"path\")\n                    .data(chord_data)\n                    .enter()\n                    .append(\"path\")\n                    .style(\"fill\", self.get_fill_color())\n                    .attr(\"d\", d3.svg.chord().radius(self.radius_bounds[0]))\n                    .style(\"opacity\", 1);\n            });\n        });\n    },\n\n    update_radius_bounds: function(radius_bounds) {\n        this.radius_bounds = radius_bounds;\n        this.parent_elt\n            .selectAll(\"path\")\n            .transition()\n            .attr(\"d\", d3.svg.chord().radius(this.radius_bounds[0]));\n    },\n\n    /**\n     * Returns radians for a genomic position.\n     */\n    _get_region_angle: function(chrom, position) {\n        // Find chrom angle data\n        var chrom_angle_data = _.find(this.chroms_layout, function(\n            chrom_layout\n        ) {\n            return chrom_layout.data.chrom === chrom;\n        });\n\n        // Return angle at position.\n        return (\n            chrom_angle_data.endAngle -\n            (chrom_angle_data.endAngle - chrom_angle_data.startAngle) *\n                (chrom_angle_data.data.len - position) /\n                chrom_angle_data.data.len\n        );\n    }\n});\n\n// circster app loader\nvar Circster = Backbone.View.extend({\n    initialize: function() {\n        // -- Configure visualization --\n        var genome = new visualization.Genome(galaxy_config.app.genome),\n            vis = new visualization.GenomeVisualization(\n                galaxy_config.app.viz_config\n            );\n\n        // Add Circster-specific config options.\n        vis.get(\"config\").add([\n            {\n                key: \"arc_dataset_height\",\n                label: \"Arc Dataset Height\",\n                type: \"int\",\n                value: 25,\n                view: \"circster\"\n            },\n            {\n                key: \"track_gap\",\n                label: \"Gap Between Tracks\",\n                type: \"int\",\n                value: 5,\n                view: \"circster\"\n            },\n            {\n                key: \"total_gap\",\n                label: \"Gap [0-1]\",\n                type: \"float\",\n                value: 0.4,\n                view: \"circster\",\n                hidden: true\n            }\n        ]);\n\n        var viz_view = new CircsterView({\n            // view pane\n            el: $(\"#center .unified-panel-body\"),\n            genome: genome,\n            model: vis\n        });\n\n        // Render vizualization\n        viz_view.render();\n\n        // setup title\n        $(\"#center .unified-panel-header-inner\").append(\n            galaxy_config.app.viz_config.title +\n                \" \" +\n                galaxy_config.app.viz_config.dbkey\n        );\n\n        // setup menu\n        var menu = mod_icon_btn.create_icon_buttons_menu(\n            [\n                {\n                    icon_class: \"plus-button\",\n                    title: \"Add tracks\",\n                    on_click: function() {\n                        visualization.select_datasets(\n                            { dbkey: vis.get(\"dbkey\") },\n                            function(tracks) {\n                                vis.add_tracks(tracks);\n                            }\n                        );\n                    }\n                },\n                {\n                    icon_class: \"gear\",\n                    title: \"Settings\",\n                    on_click: function() {\n                        var view = new config.ConfigSettingCollectionView({\n                            collection: vis.get(\"config\")\n                        });\n                        view.render_in_modal(\"Configure Visualization\");\n                    }\n                },\n                {\n                    icon_class: \"disk--arrow\",\n                    title: \"Save\",\n                    on_click: function() {\n                        // show saving dialog box\n                        Galaxy.modal.show({\n                            title: \"Saving...\",\n                            body: \"progress\"\n                        });\n\n                        // send to server\n                        $.ajax({\n                            url: Galaxy.root + \"visualization/save\",\n                            type: \"POST\",\n                            dataType: \"json\",\n                            data: {\n                                id: vis.get(\"vis_id\"),\n                                title: vis.get(\"title\"),\n                                dbkey: vis.get(\"dbkey\"),\n                                type: \"trackster\",\n                                vis_json: JSON.stringify(vis)\n                            }\n                        })\n                            .success(function(vis_info) {\n                                Galaxy.modal.hide();\n                                vis.set(\"vis_id\", vis_info.vis_id);\n                            })\n                            .error(function() {\n                                // show dialog\n                                Galaxy.modal.show({\n                                    title: \"Could Not Save\",\n                                    body:\n                                        \"Could not save visualization. Please try again later.\",\n                                    buttons: {\n                                        Cancel: function() {\n                                            Galaxy.modal.hide();\n                                        }\n                                    }\n                                });\n                            });\n                    }\n                },\n                {\n                    icon_class: \"cross-circle\",\n                    title: \"Close\",\n                    on_click: function() {\n                        window.location = Galaxy.root + \"visualizations/list\";\n                    }\n                }\n            ],\n            { tooltip_config: { placement: \"bottom\" } }\n        );\n\n        // add menu\n        menu.$el.attr(\"style\", \"float: right\");\n        $(\"#center .unified-panel-header-inner\").append(menu.$el);\n\n        // manual tooltip config because default gravity is S and cannot be changed\n        $(\".menu-button\").tooltip({ placement: \"bottom\" });\n    }\n});\n\n// Module exports.\nexport default {\n    GalaxyApp: Circster\n};\n"]}