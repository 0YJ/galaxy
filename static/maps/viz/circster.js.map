{"version":3,"sources":["viz/circster.js"],"names":["require","mod_utils","cssLoadFile","define","_","d3","visualization","config","mod_icon_btn","SVGUtils","Backbone","Model","extend","is_visible","svg_elt","svg","eltBRect","bottom","getBoundingClientRect","svgBRect","$","right","left","top","UsesTicks","drawTicks","text_coords","data","dataHandler","textTransform","horizontal","ticks","parent_elt","append","PI","selectAll","tick_coords","text_anchor","enter","d","angle","Math","radius","num","formatNum","abs","rval","toPrecision","attr","roundedNum","style","text","label","sigDigits","CircsterLabelTrack","undefined","CircsterView","className","initialize","label_arc_height","round","chords_views","model","toFixed","vis_config","get_chord_tracks","View","options","this","genome","scale","circular_views","dataset_arc_height","add_track","get_value","track_gap","get","min_dimension","on","update_track_bounds","tracks_start_radii","filter","track","get_tracks_bounds","total_gap","circular_tracks","tracks_bounds","get_circular_tracks","self","$el","height","radius_start","length","zoom_drag_timeout","map","render","width","chords_tracks","el","radius_bounds","view","zoom","event","translate","CircsterChromInteractionsTrackView","outermost_radius","track_bounds","index","label_track_view","new_view","select","new_track","track_view","track_index","CircsterChromLabelTrackView","innermost_radius_bounds","remove_track","splice","update_radius_bounds","each","i","new_track_bounds","push","chroms_layout","tracks","_chroms_layout","remove","get_fill_color","track_parent_elt","CircsterTrackView","tagName","chroms_paths","loading_bg_fill","bg_fill","data_manager","data_ready_deferred","color","genome_arcs","arc_gen","innerRadius","outerRadius","chroms_elts","_transition_labels","bg_stroke","chrom","new_scale","data_is_ready","when","then","utils","_render_data","render_labels","new_d","arc","data_deferred","transition","duration","update_scale","old_scale","chrom_arcs","chrom_data_paths","num_paths","path_elt","chrom_region","get_chrom_region","path_data","reject","get_more_detailed_data","_update_data_bounds","chrom_arc","find","layout","_render_chrom_data","rendered_deferred","Deferred","get_genome_wide_data","genome_wide_data","chrom_data","path_fn","_get_path_function","p_data","path","chroms_data_layout","layout_and_data","chrom_info","new_bounds","data_bounds","get_data_bounds","_transition_chrom_data","len","init_arcs","pie_layout","set_value","silent","zip","resolve","chroms_info","pie","value","sort","gap_per_chrom","new_endAngle","endAngle","chromArcTicks","startAngle","min_arc_len","CircsterQuantitativeTrackView","prototype","track_config","_update_min_max","v","k","visibleChroms","c","call","line","numbers","quantile","ascending","datum","click","ConfigSettingCollectionView","collection","linear","domain","range","radial","interpolate","area","labeledChroms","new_data","_data_bounds_ticks_fn","tick","render_in_modal","flatten","_quantile","chrom_chord_data","source_angle","_get_region_angle","CircsterBigWigTrackView","values","p","parseInt","chrom_angle_data","min","max","get_chroms_info","cur_chrom","target_angle","galaxy_config","app","viz_config","source","create_icon_buttons_menu","add_tracks","chord_data","concat","icon_class","Galaxy","modal","ajax","chord","url","error","position","show","chrom_layout","title","GalaxyApp","Genome","placement","vis","GenomeVisualization","add","key","type","Circster","hidden","dbkey","menu","on_click","select_datasets","root","body","dataType","id","vis_json","JSON","stringify","success","vis_info","hide","set","vis_id","buttons","Cancel","window","location","tooltip_config","tooltip"],"mappings":"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","file":"../../scripts/viz/circster.js","sourcesContent":["// load required libraries\nrequire([\n    'utils/utils',\n], function(mod_utils)\n{\n    // load css\n    mod_utils.cssLoadFile(\"static/style/circster.css\");\n});\n\ndefine([\n    \"libs/underscore\",\n    \"libs/d3\",\n    \"viz/visualization\",\n    \"utils/config\",\n    'mvc/ui/icon-button',\n    'libs/farbtastic'\n], function(_, d3, visualization, config, mod_icon_btn) {\n\n/**\n * Utility class for working with SVG.\n */\nvar SVGUtils = Backbone.Model.extend({\n\n    /**\n     * Returns true if element is visible.\n     */\n    is_visible: function(svg_elt, svg) {\n        var eltBRect = svg_elt.getBoundingClientRect(),\n            svgBRect = $('svg')[0].getBoundingClientRect();\n\n        if (// To the left of screen?\n            eltBRect.right < 0 ||\n            // To the right of screen?\n            eltBRect.left > svgBRect.right ||\n            // Above screen?\n            eltBRect.bottom < 0 ||\n            // Below screen?\n            eltBRect.top > svgBRect.bottom) {\n            return false;\n        }\n        return true;\n    }\n});\n\n/**\n * Mixin for using ticks.\n */\nvar UsesTicks = {\n    drawTicks: function(parent_elt, data, dataHandler, textTransform, horizontal) {\n        // Set up group elements for chroms and for each tick.\n        var ticks = parent_elt.append(\"g\")\n                        .selectAll(\"g\")\n                            .data(data)\n                        .enter().append(\"g\")\n                        .selectAll(\"g\")\n                            .data(dataHandler)\n                        .enter().append(\"g\")\n                            .attr(\"class\", \"tick\")\n                            .attr(\"transform\", function(d) {\n                                return \"rotate(\" + (d.angle * 180 / Math.PI - 90) + \")\" +\n                                        \"translate(\" + d.radius + \",0)\";\n                            });\n\n        // Add line + text for ticks.\n        var tick_coords = [],\n            text_coords = [],\n            text_anchor = function(d) {\n                return d.angle > Math.PI ? \"end\" : null;\n            };\n        if (horizontal) {\n            tick_coords = [0, 0, 0, -4];\n            text_coords = [4, 0, \"\", \".35em\"];\n            text_anchor = null;\n        }\n        else {\n            tick_coords = [1, 0, 4, 0];\n            text_coords = [0, 4, \".35em\", \"\"];\n\n        }\n\n        ticks.append(\"line\")\n             .attr(\"x1\", tick_coords[0])\n             .attr(\"y1\", tick_coords[1])\n             .attr(\"x2\", tick_coords[2])\n             .attr(\"y1\", tick_coords[3])\n             .style(\"stroke\", \"#000\");\n\n        return ticks.append(\"text\")\n                    .attr(\"x\", text_coords[0])\n                    .attr(\"y\", text_coords[1])\n                    .attr(\"dx\", text_coords[2])\n                    .attr(\"dy\", text_coords[3])\n                    .attr(\"text-anchor\", text_anchor)\n                    .attr(\"transform\", textTransform)\n                    .text(function(d) { return d.label; });\n    },\n\n    /**\n     * Format number for display at a tick.\n     */\n    formatNum: function(num, sigDigits) {\n        // Use default of 2 sig. digits.\n        if (sigDigits === undefined)\n            sigDigits = 2;\n\n        // Verify input number\n        if (num === null)\n            return null;\n\n        // Calculate return value\n        var rval = null;\n        if (Math.abs(num) < 1) {\n            rval = num.toPrecision(sigDigits);\n        }\n        else {\n            // Use round to turn string from toPrecision() back into a number.\n            var roundedNum = Math.round(num.toPrecision(sigDigits));\n\n            // Use abbreviations.\n            num = Math.abs(num);\n            if (num < 1000) {\n                rval = roundedNum;\n            }\n            else if (num < 1000000) {\n                // Use K.\n                rval = Math.round((roundedNum/1000).toPrecision(3)).toFixed(0) + 'K';\n            }\n            else if (num < 1000000000) {\n                // Use M.\n                rval = Math.round((roundedNum/1000000).toPrecision(3)).toFixed(0) + 'M';\n            }\n        }\n\n        return rval;\n    }\n};\n\n/**\n * A label track.\n */\nvar CircsterLabelTrack = Backbone.Model.extend({});\n\n/**\n * Renders a full circster visualization.\n */\nvar CircsterView = Backbone.View.extend({\n    className: 'circster',\n\n    initialize: function(options) {\n        this.genome = options.genome;\n        this.label_arc_height = 50;\n        this.scale = 1;\n        this.circular_views = null;\n        this.chords_views = null;\n\n        // When tracks added to/removed from model, update view.\n        this.model.get('drawables').on('add', this.add_track, this);\n        this.model.get('drawables').on('remove', this.remove_track, this);\n\n        // When config settings change, update view.\n        var vis_config = this.model.get('config');\n        vis_config.get('arc_dataset_height').on('change:value', this.update_track_bounds, this);\n        vis_config.get('track_gap').on('change:value', this.update_track_bounds, this);\n    },\n\n    // HACKs: using track_type for circular/chord distinction in the functions below for now.\n\n    /**\n     * Returns tracks to be rendered using circular view.\n     */\n    get_circular_tracks: function() {\n        return this.model.get('drawables').filter(function(track) {\n            return track.get('track_type') !== 'DiagonalHeatmapTrack';\n        });\n    },\n\n    /**\n     * Returns tracks to be rendered using chords view.\n     */\n    get_chord_tracks: function() {\n        return this.model.get('drawables').filter(function(track) {\n            return track.get('track_type') === 'DiagonalHeatmapTrack';\n        });\n    },\n\n    /**\n     * Returns a list of circular tracks' radius bounds.\n     */\n    get_tracks_bounds: function() {\n        var circular_tracks = this.get_circular_tracks(),\n            dataset_arc_height = this.model.get('config').get_value('arc_dataset_height'),\n            track_gap = this.model.get('config').get_value('track_gap'),\n            // Subtract 20 to make sure chrom labels are on screen.\n            min_dimension = Math.min(this.$el.width(), this.$el.height()) - 20,\n            // Compute radius start based on model, will be centered\n            // and fit entirely inside element by default.\n            radius_start = min_dimension / 2 -\n                            circular_tracks.length * (dataset_arc_height + track_gap) +\n                            // Add track_gap back in because no gap is needed for last track.\n                            track_gap -\n                            this.label_arc_height,\n\n            // Compute range of track starting radii.\n            tracks_start_radii = d3.range(radius_start, min_dimension / 2, dataset_arc_height + track_gap);\n\n        // Map from track start to bounds.\n        var self = this;\n        return _.map(tracks_start_radii, function(radius) {\n            return [radius, radius + dataset_arc_height];\n        });\n    },\n\n    /**\n     * Renders circular tracks, chord tracks, and label tracks.\n     */\n    render: function() {\n        var self = this,\n            width = self.$el.width(),\n            height = self.$el.height(),\n            circular_tracks = this.get_circular_tracks(),\n            chords_tracks = this.get_chord_tracks(),\n            total_gap = self.model.get('config').get_value('total_gap'),\n            tracks_bounds = this.get_tracks_bounds(),\n\n            // Set up SVG element.\n            svg = d3.select(self.$el[0])\n              .append(\"svg\")\n                .attr(\"width\", width)\n                .attr(\"height\", height)\n                .attr(\"pointer-events\", \"all\")\n              // Set up zooming, dragging.\n              .append('svg:g')\n                .call(d3.behavior.zoom().on('zoom', function() {\n                    // Do zoom, drag.\n                    var scale = d3.event.scale;\n                    svg.attr(\"transform\",\n                      \"translate(\" + d3.event.translate + \")\" +\n                      \" scale(\" + scale + \")\");\n\n                    // Propagate scale changes to views.\n                    if (self.scale !== scale) {\n                        // Use timeout to wait for zooming/dragging to stop before rendering more detail.\n                        if (self.zoom_drag_timeout) {\n                            clearTimeout(self.zoom_drag_timeout);\n                        }\n                        self.zoom_drag_timeout = setTimeout(function() {\n                            // Render more detail in tracks' visible elements.\n                            // FIXME: do not do this right now; it is not fully implemented--e.g. data bounds\n                            // are not updated when new data is fetched--and fetching more detailed quantitative\n                            // data is not that useful.\n                            /*\n                            _.each(self.circular_views, function(view) {\n                                view.update_scale(scale);\n                            });\n                            */\n                        }, 400);\n                    }\n                }))\n                .attr(\"transform\", \"translate(\" + width / 2 + \",\" + height / 2 + \")\")\n              .append('svg:g').attr('class', 'tracks');\n\n        // -- Render circular tracks. --\n\n        // Create a view for each track in the visualization and render.\n        this.circular_views = circular_tracks.map(function(track, index) {\n            var view = new CircsterBigWigTrackView({\n                    el: svg.append('g')[0],\n                    track: track,\n                    radius_bounds: tracks_bounds[index],\n                    genome: self.genome,\n                    total_gap: total_gap\n                });\n\n            view.render();\n\n            return view;\n        });\n\n        // -- Render chords tracks. --\n\n        this.chords_views = chords_tracks.map(function(track) {\n            var view = new CircsterChromInteractionsTrackView({\n                el: svg.append('g')[0],\n                track: track,\n                radius_bounds: tracks_bounds[0],\n                genome: self.genome,\n                total_gap: total_gap\n            });\n\n            view.render();\n\n            return view;\n        });\n\n        // -- Render label track. --\n\n        // Track bounds are:\n        // (a) outer radius of last circular track;\n        // (b)\n        var outermost_radius = this.circular_views[this.circular_views.length-1].radius_bounds[1],\n            track_bounds = [\n                outermost_radius,\n                outermost_radius + this.label_arc_height\n            ];\n        this.label_track_view = new CircsterChromLabelTrackView({\n            el: svg.append('g')[0],\n            track: new CircsterLabelTrack(),\n            radius_bounds: track_bounds,\n            genome: self.genome,\n            total_gap: total_gap\n        });\n\n        this.label_track_view.render();\n    },\n\n    /**\n     * Render a single track on the outside of the current visualization.\n     */\n    add_track: function(new_track) {\n        var total_gap = this.model.get('config').get_value('total_gap');\n\n        if (new_track.get('track_type') === 'DiagonalHeatmapTrack') {\n            // Added chords track.\n            var innermost_radius_bounds = this.circular_views[0].radius_bounds,\n                new_view = new CircsterChromInteractionsTrackView({\n                    el: d3.select('g.tracks').append('g')[0],\n                    track: new_track,\n                    radius_bounds: innermost_radius_bounds,\n                    genome: this.genome,\n                    total_gap: total_gap\n                });\n                new_view.render();\n                this.chords_views.push(new_view);\n        }\n        else {\n            // Added circular track.\n\n            // Recompute and update circular track bounds.\n            var new_track_bounds = this.get_tracks_bounds();\n            _.each(this.circular_views, function(track_view, i) {\n                track_view.update_radius_bounds(new_track_bounds[i]);\n            });\n\n            // Update chords tracks.\n            _.each(this.chords_views, function(track_view) {\n                track_view.update_radius_bounds(new_track_bounds[0]);\n            });\n\n            // Render new track.\n            var track_index = this.circular_views.length,\n                track_view = new CircsterBigWigTrackView({\n                    el: d3.select('g.tracks').append('g')[0],\n                    track: new_track,\n                    radius_bounds: new_track_bounds[track_index],\n                    genome: this.genome,\n                    total_gap: total_gap\n                });\n            track_view.render();\n            this.circular_views.push(track_view);\n\n            // Update label track.\n            /*\n            FIXME: should never have to update label track because vis always expands to fit area\n            within label track.\n            var track_bounds = new_track_bounds[ new_track_bounds.length-1 ];\n            track_bounds[1] = track_bounds[0];\n            this.label_track_view.update_radius_bounds(track_bounds);\n            */\n        }\n    },\n\n    /**\n     * Remove a track from the view.\n     */\n    remove_track: function(track, tracks, options) {\n        // -- Remove track from view. --\n        var track_view = this.circular_views[options.index];\n        this.circular_views.splice(options.index, 1);\n        track_view.$el.remove();\n\n        // Recompute and update track bounds.\n        var new_track_bounds = this.get_tracks_bounds();\n        _.each(this.circular_views, function(track_view, i) {\n            track_view.update_radius_bounds(new_track_bounds[i]);\n        });\n    },\n\n    update_track_bounds: function() {\n        // Recompute and update track bounds.\n        var new_track_bounds = this.get_tracks_bounds();\n        _.each(this.circular_views, function(track_view, i) {\n            track_view.update_radius_bounds(new_track_bounds[i]);\n        });\n\n        // Update chords tracks.\n        _.each(this.chords_views, function(track_view) {\n            track_view.update_radius_bounds(new_track_bounds[0]);\n        });\n\n    }\n});\n\n/**\n * Renders a track in a Circster visualization.\n */\nvar CircsterTrackView = Backbone.View.extend({\n    tagName: 'g',\n\n    /* ----------------------- Public Methods ------------------------- */\n\n    initialize: function(options) {\n        this.bg_stroke = '#ddd';\n        // Fill color when loading data.\n        this.loading_bg_fill = '#ffc';\n        // Fill color when data has been loaded.\n        this.bg_fill = '#ddd';\n        this.total_gap = options.total_gap;\n        this.track = options.track;\n        this.radius_bounds = options.radius_bounds;\n        this.genome = options.genome;\n        this.chroms_layout = this._chroms_layout();\n        this.data_bounds = [];\n        this.scale = 1;\n        this.parent_elt = d3.select(this.$el[0]);\n    },\n\n    /**\n     * Get fill color from config.\n     */\n    get_fill_color: function() {\n        var color = this.track.get('config').get_value('block_color');\n        if (!color) { color = this.track.get('config').get_value('color'); }\n        return color;\n    },\n\n    /**\n     * Render track's data by adding SVG elements to parent.\n     */\n    render: function() {\n        // -- Create track group element. --\n        var track_parent_elt = this.parent_elt;\n\n        // -- Render background arcs. --\n        var genome_arcs = this.chroms_layout,\n            arc_gen = d3.svg.arc()\n                        .innerRadius(this.radius_bounds[0])\n                        .outerRadius(this.radius_bounds[1]),\n\n            // Attach data to group element.\n            chroms_elts = track_parent_elt.selectAll('g')\n                .data(genome_arcs).enter().append('svg:g'),\n\n            // Draw chrom arcs/paths.\n            chroms_paths = chroms_elts.append('path')\n                .attr(\"d\", arc_gen)\n                .attr('class', 'chrom-background')\n                .style(\"stroke\", this.bg_stroke)\n                .style(\"fill\",  this.loading_bg_fill);\n\n            // Append titles to paths.\n            chroms_paths.append(\"title\").text(function(d) { return d.data.chrom; });\n\n        // -- Render track data and, when track data is rendered, apply preferences and update chrom_elts fill. --\n\n        var self = this,\n            data_manager = self.track.get('data_manager'),\n            // If track has a data manager, get deferred that resolves when data is ready.\n            data_ready_deferred = (data_manager ? data_manager.data_is_ready() : true );\n\n        // When data is ready, render track.\n        $.when(data_ready_deferred).then(function() {\n            $.when(self._render_data(track_parent_elt)).then(function() {\n                chroms_paths.style(\"fill\", self.bg_fill);\n\n                // Render labels after data is available so that data attributes are available.\n                self.render_labels();\n            });\n        });\n    },\n\n    /**\n     * Render track labels.\n     */\n    render_labels: function() {},\n\n    /**\n     * Update radius bounds.\n     */\n    update_radius_bounds: function(radius_bounds) {\n        // Update bounds.\n        this.radius_bounds = radius_bounds;\n\n        // -- Update background arcs. --\n        var new_d = d3.svg.arc()\n                        .innerRadius(this.radius_bounds[0])\n                        .outerRadius(this.radius_bounds[1]);\n\n        this.parent_elt.selectAll('g>path.chrom-background').transition().duration(1000).attr('d', new_d);\n\n        this._transition_chrom_data();\n\n        this._transition_labels();\n    },\n\n    /**\n     * Update view scale. This fetches more data if scale is increased.\n     */\n    update_scale: function(new_scale) {\n        // -- Update scale and return if new scale is less than old scale. --\n\n        var old_scale = this.scale;\n        this.scale = new_scale;\n        if (new_scale <= old_scale) {\n            return;\n        }\n\n        // -- Scale increased, so render visible data with more detail. --\n\n        var self = this,\n            utils = new SVGUtils();\n\n        // Select all chrom data and filter to operate on those that are visible.\n        this.parent_elt.selectAll('path.chrom-data').filter(function(d, i) {\n            return utils.is_visible(this);\n        }).each(function(d, i) {\n            // -- Now operating on a single path element representing chromosome data. --\n\n            var path_elt = d3.select(this),\n                chrom = path_elt.attr('chrom'),\n                chrom_region = self.genome.get_chrom_region(chrom),\n                data_manager = self.track.get('data_manager'),\n                data_deferred;\n\n            // If can't get more detailed data, return.\n            if (!data_manager.can_get_more_detailed_data(chrom_region)) {\n                return;\n            }\n\n            // -- Get more detailed data. --\n            data_deferred = self.track.get('data_manager').get_more_detailed_data(chrom_region, 'Coverage', 0, new_scale);\n\n            // When more data is available, use new data to redraw path.\n            $.when(data_deferred).then(function(data) {\n                // Remove current data path.\n                path_elt.remove();\n\n                // Update data bounds with new data.\n                self._update_data_bounds();\n\n                // Find chromosome arc to draw data on.\n                var chrom_arc = _.find(self.chroms_layout, function(layout) {\n                        return layout.data.chrom === chrom;\n                });\n\n                // Add new data path and apply preferences.\n                var color = self.get_fill_color();\n                self._render_chrom_data(self.parent_elt, chrom_arc, data).style('stroke', color).style('fill', color);\n            });\n        });\n\n        return self;\n    },\n\n    /* ----------------------- Internal Methods ------------------------- */\n\n    /**\n     * Transitions chrom data to new values (e.g new radius or data bounds).\n     */\n    _transition_chrom_data: function() {\n        var track = this.track,\n            chrom_arcs = this.chroms_layout,\n            chrom_data_paths = this.parent_elt.selectAll('g>path.chrom-data'),\n            num_paths = chrom_data_paths[0].length;\n\n        if (num_paths > 0) {\n            var self = this;\n            $.when(track.get('data_manager').get_genome_wide_data(this.genome)).then(function(genome_wide_data) {\n                // Map chrom data to path data, filtering out null values.\n                var path_data = _.reject( _.map(genome_wide_data, function(chrom_data, i) {\n                    var rval = null,\n                        path_fn = self._get_path_function(chrom_arcs[i], chrom_data);\n                    if (path_fn) {\n                        rval = path_fn(chrom_data.data);\n                    }\n                    return rval;\n                }), function(p_data) { return p_data === null; } );\n\n                // Transition each path for data and color.\n                var color = track.get('config').get_value('color');\n                chrom_data_paths.each(function(path, index) {\n                    d3.select(this).transition().duration(1000)\n                                   .style('stroke', color).style('fill', color)\n                                   .attr('d', path_data[index]);\n                });\n            });\n        }\n    },\n\n    /**\n     * Transition labels to new values (e.g new radius or data bounds).\n     */\n    _transition_labels: function() {},\n\n    /**\n     * Update data bounds. If there are new_bounds, use them; otherwise use\n     * default data bounds.\n     */\n    _update_data_bounds: function(new_bounds) {\n        var old_bounds = this.data_bounds;\n        this.data_bounds = new_bounds ||\n                           this.get_data_bounds(this.track.get('data_manager').get_genome_wide_data(this.genome));\n        this._transition_chrom_data();\n    },\n\n    /**\n     * Render data as elements attached to svg.\n     */\n    _render_data: function(svg) {\n        var self = this,\n            chrom_arcs = this.chroms_layout,\n            track = this.track,\n            rendered_deferred = $.Deferred();\n\n        // When genome-wide data is available, render data.\n        $.when(track.get('data_manager').get_genome_wide_data(this.genome)).then(function(genome_wide_data) {\n            // Set bounds.\n            self.data_bounds = self.get_data_bounds(genome_wide_data);\n\n            // Set min, max value in config so that they can be adjusted. Make this silent\n            // because these attributes are watched for changes and the viz is updated\n            // accordingly (set up in initialize). Because we are setting up, we don't want\n            // the watch to trigger events here.\n            track.get('config').set_value('min_value', self.data_bounds[0], {silent: true});\n            track.get('config').set_value('max_value', self.data_bounds[1], {silent: true});\n\n            // Merge chroms layout with data.\n            layout_and_data = _.zip(chrom_arcs, genome_wide_data),\n\n            // Render each chromosome's data.\n            chroms_data_layout = _.map(layout_and_data, function(chrom_info) {\n                var chrom_arc = chrom_info[0],\n                    data = chrom_info[1];\n                return self._render_chrom_data(svg, chrom_arc, data);\n            });\n\n            // Apply prefs to all track data.\n            var color = self.get_fill_color();\n            self.parent_elt.selectAll('path.chrom-data').style('stroke', color).style('fill', color);\n\n            rendered_deferred.resolve(svg);\n        });\n\n        return rendered_deferred;\n    },\n\n    /**\n     * Render a chromosome data and attach elements to svg.\n     */\n    _render_chrom_data: function(svg, chrom_arc, data) {},\n\n    /**\n     * Returns data for creating a path for the given data using chrom_arc and data bounds.\n     */\n    _get_path_function: function(chrom_arc, chrom_data) {},\n\n    /**\n     * Returns arc layouts for genome's chromosomes/contigs. Arcs are arranged in a circle\n     * separated by gaps.\n     */\n    _chroms_layout: function() {\n        // Setup chroms layout using pie.\n        var chroms_info = this.genome.get_chroms_info(),\n            pie_layout = d3.layout.pie().value(function(d) { return d.len; }).sort(null),\n            init_arcs = pie_layout(chroms_info),\n            gap_per_chrom = 2 * Math.PI * this.total_gap / chroms_info.length,\n            chrom_arcs = _.map(init_arcs, function(arc, index) {\n                // For short chroms, endAngle === startAngle.\n                var new_endAngle = arc.endAngle - gap_per_chrom;\n                arc.endAngle = (new_endAngle > arc.startAngle ? new_endAngle : arc.startAngle);\n                return arc;\n            });\n        return chrom_arcs;\n    }\n});\n\n/**\n * Render chromosome labels.\n */\nvar CircsterChromLabelTrackView = CircsterTrackView.extend({\n\n    initialize: function(options) {\n        CircsterTrackView.prototype.initialize.call(this, options);\n        // Use a single arc for rendering data.\n        this.innerRadius = this.radius_bounds[0];\n        this.radius_bounds[0] = this.radius_bounds[1];\n        this.bg_stroke = '#fff';\n        this.bg_fill = '#fff';\n\n        // Minimum arc distance for labels to be applied.\n        this.min_arc_len = 0.05;\n    },\n\n    /**\n     * Render labels.\n     */\n    _render_data: function(svg) {\n        // -- Add chromosome label where it will fit; an alternative labeling mechanism\n        // would be nice for small chromosomes. --\n        var self = this,\n            chrom_arcs = svg.selectAll('g');\n\n        chrom_arcs.selectAll('path')\n            .attr('id', function(d) { return 'label-' + d.data.chrom; });\n\n        chrom_arcs.append(\"svg:text\")\n            .filter(function(d) {\n                return d.endAngle - d.startAngle > self.min_arc_len;\n            })\n            .attr('text-anchor', 'middle')\n          .append(\"svg:textPath\")\n            .attr(\"class\", \"chrom-label\")\n            .attr(\"xlink:href\", function(d) { return \"#label-\" + d.data.chrom; })\n            .attr('startOffset', '25%')\n            .text(function(d) {\n                return d.data.chrom;\n            });\n\n        // -- Add ticks to denote chromosome length. --\n\n        /** Returns an array of tick angles and labels, given a chrom arc. */\n        var chromArcTicks = function(d) {\n            var k = (d.endAngle - d.startAngle) / d.value,\n                ticks = d3.range(0, d.value, 25000000).map(function(v, i) {\n                    return {\n                        radius: self.innerRadius,\n                        angle: v * k + d.startAngle,\n                        label: i === 0 ? 0 : (i % 3 ? null : self.formatNum(v))\n                    };\n                });\n\n            // If there are fewer that 4 ticks, label last tick so that at least one non-zero tick is labeled.\n            if (ticks.length < 4) {\n                ticks[ticks.length-1].label = self.formatNum(\n                    Math.round( ( ticks[ticks.length-1].angle - d.startAngle ) / k )\n                );\n            }\n\n            return ticks;\n        };\n\n        /** Rotate and move text as needed. */\n        var textTransform = function(d) {\n                return d.angle > Math.PI ? \"rotate(180)translate(-16)\" : null;\n        };\n\n        // Filter chroms for only those large enough for display.\n        var visibleChroms = _.filter(this.chroms_layout, function(c) { return c.endAngle - c.startAngle > self.min_arc_len; });\n\n        this.drawTicks(this.parent_elt, visibleChroms, chromArcTicks, textTransform);\n    }\n});\n_.extend(CircsterChromLabelTrackView.prototype, UsesTicks);\n\n/**\n * View for quantitative track in Circster.\n */\nvar CircsterQuantitativeTrackView = CircsterTrackView.extend({\n\n    initialize: function(options) {\n        CircsterTrackView.prototype.initialize.call(this, options);\n\n        // When config settings change, update view.\n        var track_config = this.track.get('config');\n        track_config.get('min_value').on('change:value', this._update_min_max, this);\n        track_config.get('max_value').on('change:value', this._update_min_max, this);\n        track_config.get('color').on('change:value', this._transition_chrom_data, this);\n    },\n\n    /**\n     * Update track when min and/or max are changed.\n     */\n    _update_min_max: function() {\n        var track_config = this.track.get('config'),\n            new_bounds = [track_config.get_value('min_value'), track_config.get_value('max_value')];\n        this._update_data_bounds(new_bounds);\n\n        // FIXME: this works to update tick/text bounds, but there's probably a better way to do this\n        // by updating the data itself.\n        this.parent_elt.selectAll('.min_max').text(function(d, i) {\n            return new_bounds[i];\n        });\n    },\n\n    /**\n     * Returns quantile for an array of numbers.\n     */\n    _quantile: function(numbers, quantile) {\n        numbers.sort(d3.ascending);\n        return d3.quantile(numbers, quantile);\n    },\n\n    /**\n     * Renders quantitative data with the form [x, value] and assumes data is equally spaced across\n     * chromosome. Attachs a dict with track and chrom name information to DOM element.\n     */\n    _render_chrom_data: function(svg, chrom_arc, chrom_data) {\n        var path_data = this._get_path_function(chrom_arc, chrom_data);\n\n        if (!path_data) { return null; }\n\n        // There is path data, so render as path.\n        var parent = svg.datum(chrom_data.data),\n            path = parent.append('path')\n                         .attr('class', 'chrom-data')\n                         .attr('chrom', chrom_arc.data.chrom)\n                         .attr('d', path_data);\n\n        return path;\n    },\n\n    /**\n     * Returns function for creating a path across the chrom arc.\n     */\n    _get_path_function: function(chrom_arc, chrom_data) {\n        // If no chrom data, return null.\n        if (typeof chrom_data === \"string\" || !chrom_data.data || chrom_data.data.length === 0) {\n            return null;\n        }\n\n        // Radius scaler.\n        var radius = d3.scale.linear()\n                       .domain(this.data_bounds)\n                       .range(this.radius_bounds)\n                       .clamp(true);\n\n        // Scaler for placing data points across arc.\n        var angle = d3.scale.linear()\n            .domain([0, chrom_data.data.length])\n            .range([chrom_arc.startAngle, chrom_arc.endAngle]);\n\n        // Use line generator to create area.\n        var line = d3.svg.line.radial()\n            .interpolate(\"linear\")\n            .radius(function(d) { return radius(d[1]); })\n            .angle(function(d, i) { return angle(i); });\n\n        return d3.svg.area.radial()\n            .interpolate(line.interpolate())\n            .innerRadius(radius(0))\n            .outerRadius(line.radius())\n            .angle(line.angle());\n    },\n\n    /**\n     * Render track min, max using ticks.\n     */\n    render_labels: function() {\n        var self = this,\n            // Keep counter of visible chroms.\n            textTransform = function() {\n                return \"rotate(90)\";\n            };\n\n        // FIXME:\n        // (1) using min_max class below is needed for _update_min_max, which could be improved.\n        // (2) showing config on tick click should be replaced by proper track config icon.\n\n        // Draw min, max on first chrom only.\n        var ticks = this.drawTicks(this.parent_elt, [ this.chroms_layout[0] ],\n                                   this._data_bounds_ticks_fn(), textTransform, true)\n                        .classed('min_max', true);\n\n        // Show config when ticks are clicked on.\n        _.each(ticks, function(tick) {\n            $(tick).click(function() {\n                var view = new config.ConfigSettingCollectionView({\n                    collection: self.track.get('config')\n                });\n                view.render_in_modal('Configure Track');\n            });\n        });\n\n\n\n        /*\n        // Filter for visible chroms, then for every third chrom so that labels attached to only every\n        // third chrom.\n        var visibleChroms = _.filter(this.chroms_layout, function(c) { return c.endAngle - c.startAngle > 0.08; }),\n            labeledChroms = _.filter(visibleChroms, function(c, i) { return i % 3 === 0; });\n        this.drawTicks(this.parent_elt, labeledChroms, this._data_bounds_ticks_fn(), textTransform, true);\n        */\n    },\n\n    /**\n     * Transition labels to new values (e.g new radius or data bounds).\n     */\n    _transition_labels: function() {\n        // FIXME: (a) pull out function for getting labeled chroms? and (b) function used in transition below\n        // is copied from UseTicks mixin, so pull out and make generally available.\n\n        // If there are no data bounds, nothing to transition.\n        if (this.data_bounds.length === 0) { return; }\n\n        // Transition labels to new radius bounds.\n        var self = this,\n            visibleChroms = _.filter(this.chroms_layout, function(c) { return c.endAngle - c.startAngle > 0.08; }),\n            labeledChroms = _.filter(visibleChroms, function(c, i) { return i % 3 === 0; }),\n            new_data = _.flatten( _.map(labeledChroms, function(c) {\n                return self._data_bounds_ticks_fn()(c);\n            }));\n        this.parent_elt.selectAll('g.tick').data(new_data).transition().attr(\"transform\", function(d) {\n            return \"rotate(\" + (d.angle * 180 / Math.PI - 90) + \")\" +\n                    \"translate(\" + d.radius + \",0)\";\n        });\n    },\n\n    /**\n     * Get function for locating data bounds ticks.\n     */\n    _data_bounds_ticks_fn: function() {\n        // Closure vars.\n        var self = this;\n            visibleChroms = 0;\n\n        // Return function for locating ticks based on chrom arc data.\n        return function(d) {\n            // Set up data to display min, max ticks.\n            return [\n                {\n                    radius: self.radius_bounds[0],\n                    angle: d.startAngle,\n                    label: self.formatNum(self.data_bounds[0])\n                },\n                {\n                    radius: self.radius_bounds[1],\n                    angle: d.startAngle,\n                    label: self.formatNum(self.data_bounds[1])\n                }\n            ];\n        };\n    },\n\n    /**\n     * Returns an array with two values denoting the minimum and maximum\n     * values for the track.\n     */\n    get_data_bounds: function(data) {}\n\n});\n_.extend(CircsterQuantitativeTrackView.prototype, UsesTicks);\n\n/**\n * Bigwig track view in Circster.\n */\nvar CircsterBigWigTrackView = CircsterQuantitativeTrackView.extend({\n\n    get_data_bounds: function(data) {\n        // Set max across dataset by extracting all values, flattening them into a\n        // single array, and getting third quartile.\n        var values = _.flatten( _.map(data, function(d) {\n            if (d) {\n                // Each data point has the form [position, value], so return all values.\n                return _.map(d.data, function(p) {\n                    // Null is used for a lack of data; resolve null to 0 for comparison.\n                    return parseInt(p[1], 10) || 0;\n                });\n            }\n            else {\n                return 0;\n            }\n        }) );\n\n        // For max, use 98% quantile in attempt to avoid very large values. However, this max may be 0\n        // for sparsely populated data, so use max in that case.\n        return [ _.min(values), this._quantile(values, 0.98) || _.max(values) ];\n    }\n});\n\n/**\n * Chromosome interactions track view in Circster.\n */\nvar CircsterChromInteractionsTrackView = CircsterTrackView.extend({\n\n    render: function() {\n        var self = this;\n\n        // When data is ready, render track.\n        $.when(self.track.get('data_manager').data_is_ready()).then(function() {\n            // When data has been fetched, render track.\n            $.when(self.track.get('data_manager').get_genome_wide_data(self.genome)).then(function(genome_wide_data) {\n                var chord_data = [],\n                    chroms_info = self.genome.get_chroms_info();\n                // Convert chromosome data into chord data.\n                _.each(genome_wide_data, function(chrom_data, index) {\n                    // Map each interaction into chord data.\n                    var cur_chrom = chroms_info[index].chrom;\n                    var chrom_chord_data = _.map(chrom_data.data, function(datum) {\n                        // Each datum is an interaction/chord.\n                        var source_angle = self._get_region_angle(cur_chrom, datum[1]),\n                            target_angle = self._get_region_angle(datum[3], datum[4]);\n                        return {\n                            source: {\n                                startAngle: source_angle,\n                                endAngle: source_angle + 0.01\n                            },\n                            target: {\n                                startAngle: target_angle,\n                                endAngle: target_angle + 0.01\n                            }\n                        };\n                    });\n\n                    chord_data = chord_data.concat(chrom_chord_data);\n                });\n\n                self.parent_elt.append(\"g\")\n                        .attr(\"class\", \"chord\")\n                    .selectAll(\"path\")\n                        .data(chord_data)\n                    .enter().append(\"path\")\n                        .style(\"fill\", self.get_fill_color())\n                        .attr(\"d\", d3.svg.chord().radius(self.radius_bounds[0]))\n                        .style(\"opacity\", 1);\n            });\n        });\n    },\n\n    update_radius_bounds: function(radius_bounds) {\n        this.radius_bounds = radius_bounds;\n        this.parent_elt.selectAll(\"path\").transition().attr(\"d\", d3.svg.chord().radius(this.radius_bounds[0]));\n    },\n\n    /**\n     * Returns radians for a genomic position.\n     */\n    _get_region_angle: function(chrom, position) {\n        // Find chrom angle data\n        var chrom_angle_data = _.find(this.chroms_layout, function(chrom_layout) {\n            return chrom_layout.data.chrom === chrom;\n        });\n\n        // Return angle at position.\n        return  chrom_angle_data.endAngle -\n                (\n                    (chrom_angle_data.endAngle - chrom_angle_data.startAngle) *\n                    (chrom_angle_data.data.len - position) / chrom_angle_data.data.len\n                );\n    }\n\n});\n\n// circster app loader\nvar Circster = Backbone.View.extend(\n{\n    initialize: function ()\n    {\n        // -- Configure visualization --\n        var genome = new visualization.Genome(galaxy_config.app.genome),\n            vis = new visualization.GenomeVisualization(galaxy_config.app.viz_config);\n\n        // Add Circster-specific config options.\n        vis.get('config').add([\n            { key: 'arc_dataset_height', label: 'Arc Dataset Height', type: 'int', value: 25, view: 'circster' },\n            { key: 'track_gap', label: 'Gap Between Tracks', type: 'int', value: 5, view: 'circster' },\n            { key: 'total_gap', label: 'Gap [0-1]', type: 'float', value: 0.4, view: 'circster', hidden: true }\n        ]);\n\n        var viz_view = new CircsterView(\n            {\n                // view pane\n                el                  : $('#center .unified-panel-body'),\n                genome              : genome,\n                model               : vis\n            });\n\n        // Render vizualization\n        viz_view.render();\n\n        // setup title\n        $('#center .unified-panel-header-inner').append(galaxy_config.app.viz_config.title + \" \" + galaxy_config.app.viz_config.dbkey);\n\n        // setup menu\n        var menu = mod_icon_btn.create_icon_buttons_menu([\n        {\n            icon_class: 'plus-button', title: 'Add tracks', on_click: function()\n            {\n                visualization.select_datasets(Galaxy.root + \"visualization/list_current_history_datasets\", Galaxy.root + \"api/datasets\", vis.get('dbkey'), function(tracks)\n                {\n                    vis.add_tracks(tracks);\n                });\n            }\n        },\n        {\n            icon_class: 'gear', title: 'Settings', on_click: function()\n            {\n                var view = new config.ConfigSettingCollectionView({\n                    collection: vis.get('config')\n                });\n                view.render_in_modal('Configure Visualization');\n            }\n        },\n        {\n            icon_class: 'disk--arrow', title: 'Save', on_click: function()\n            {\n                // show saving dialog box\n                Galaxy.modal.show({title: \"Saving...\", body: \"progress\" });\n\n                // send to server\n                $.ajax({\n                    url: Galaxy.root + \"visualization/save\",\n                    type: \"POST\",\n                    dataType: \"json\",\n                    data: {\n                        'id'        : vis.get('vis_id'),\n                        'title'     : vis.get('title'),\n                        'dbkey'     : vis.get('dbkey'),\n                        'type'      : 'trackster',\n                        'vis_json'  : JSON.stringify(vis)\n                    }\n                }).success(function(vis_info) {\n                    Galaxy.modal.hide();\n                    vis.set('vis_id', vis_info.vis_id);\n                }).error(function() {\n                    // show dialog\n                    Galaxy.modal.show({\n                        title   : \"Could Not Save\",\n                        body    : \"Could not save visualization. Please try again later.\",\n                        buttons : { \"Cancel\": function() { Galaxy.modal.hide(); } }\n                    });\n                });\n            }\n        },\n        {\n            icon_class: 'cross-circle', title: 'Close', on_click: function()\n            {\n                window.location = Galaxy.root + \"visualization/list\";\n            }\n        }], { tooltip_config: { placement: 'bottom' } });\n\n        // add menu\n        menu.$el.attr(\"style\", \"float: right\");\n        $(\"#center .unified-panel-header-inner\").append(menu.$el);\n\n        // manual tooltip config because default gravity is S and cannot be changed\n        $(\".menu-button\").tooltip( { placement: 'bottom' } );\n    }\n});\n\n// Module exports.\nreturn {\n    GalaxyApp: Circster\n};\n\n});\n"]}