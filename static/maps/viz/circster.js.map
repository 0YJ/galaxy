{"version":3,"sources":["viz/circster.js"],"names":["_","d3","_utils2","default","cssLoadFile","SVGUtils","Backbone","Model","extend","is_visible","svg_elt","svg","eltBRect","getBoundingClientRect","svgBRect","$","right","left","bottom","top","UsesTicks","drawTicks","parent_elt","data","dataHandler","textTransform","horizontal","ticks","append","selectAll","enter","attr","d","angle","Math","PI","radius","tick_coords","text_coords","text_anchor","style","label","formatNum","num","sigDigits","undefined","rval","toPrecision","round","abs","roundedNum","toFixed","CircsterLabelTrack","CircsterView","View","className","initialize","options","this","genome","label_arc_height","scale","circular_views","chords_views","model","get","on","add_track","remove_track","vis_config","update_track_bounds","get_circular_tracks","filter","track","get_chord_tracks","get_tracks_bounds","circular_tracks","min_dimension","dataset_arc_height","radius_start","get_value","track_gap","min","$el","width","height","length","tracks_start_radii","range","self","map","render","zoom_drag_timeout","clearTimeout","total_gap","tracks_bounds","select","call","behavior","zoom","event","view","translate","setTimeout","index","CircsterBigWigTrackView","el","outermost_radius","radius_bounds","track_bounds","chords_tracks","CircsterChromInteractionsTrackView","new_view","track_view","update_radius_bounds","each","label_track_view","new_track","innermost_radius_bounds","push","new_track_bounds","tracks","i","track_index","splice","chroms_layout","_chroms_layout","data_bounds","get_fill_color","color","CircsterTrackView","track_parent_elt","tagName","arc_gen","bg_stroke","chroms_elts","bg_fill","chroms_paths","chrom","data_ready_deferred","data_manager","genome_arcs","arc","innerRadius","outerRadius","_transition_labels","loading_bg_fill","update_scale","text","new_scale","data_is_ready","when","then","_render_data","render_labels","data_deferred","path_elt","remove","transition","duration","new_d","_transition_chrom_data","old_scale","num_paths","utils","chrom_region","p_data","get_chrom_region","chrom_data_paths","get_more_detailed_data","old_bounds","_update_data_bounds","chrom_arc","find","layout","rendered_deferred","_render_chrom_data","chrom_arcs","layout_and_data","genome_wide_data","path_data","reject","resolve","chrom_data","path_fn","_get_path_function","path","chroms_info","get_chroms_info","new_bounds","get_data_bounds","get_genome_wide_data","Deferred","set_value","silent","chrom_info","v","CircsterQuantitativeTrackView","CircsterChromLabelTrackView","pie","value","len","sort","init_arcs","track_config","endAngle","gap_per_chrom","startAngle","new_endAngle","_update_min_max","prototype","min_arc_len","parent","visibleChroms","c","k","collection","_quantile","numbers","quantile","ascending","new_data","linear","domain","values","line","radial","interpolate","area","_data_bounds_ticks_fn","classed","_config2","ConfigSettingCollectionView","target","_get_region_angle","chrom_angle_data","Circster","flatten","galaxy_config","vis","key","type","viz_view","on_click","modal","title","p","id","max","Galaxy","buttons","Cancel","chord_data","cur_chrom","icon_class","datum","source_angle","location","target_angle","source","concat","chrom_chord_data","chord","position","chrom_layout","_visualization2","Genome","app","GenomeVisualization","viz_config","add","hidden","dbkey","menu","_iconButton2","create_icon_buttons_menu","select_datasets","add_tracks","render_in_modal","show","body","ajax","url","root","dataType","vis_json","JSON","stringify","success","vis_info","hide","set","vis_id","error","window","tooltip_config","placement","tooltip","GalaxyApp"],"mappings":"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","file":"../../scripts/viz/circster.js","sourcesContent":["import * as _ from \"libs/underscore\";\nimport * as d3 from \"libs/d3\";\nimport visualization from \"viz/visualization\";\nimport mod_utils from \"utils/utils\";\nimport config from \"utils/config\";\nimport mod_icon_btn from \"mvc/ui/icon-button\";\nimport \"libs/farbtastic\";\n/**\n * Utility class for working with SVG.\n */\n// load css\nmod_utils.cssLoadFile(\"static/style/circster.css\");\n\nvar SVGUtils = Backbone.Model.extend({\n    /**\n     * Returns true if element is visible.\n     */\n    is_visible: function(svg_elt, svg) {\n        var eltBRect = svg_elt.getBoundingClientRect();\n        var svgBRect = $(\"svg\")[0].getBoundingClientRect();\n\n        if (\n            // To the left of screen?\n            eltBRect.right < 0 ||\n            // To the right of screen?\n            eltBRect.left > svgBRect.right ||\n            // Above screen?\n            eltBRect.bottom < 0 ||\n            // Below screen?\n            eltBRect.top > svgBRect.bottom\n        ) {\n            return false;\n        }\n        return true;\n    }\n});\n\n/**\n * Mixin for using ticks.\n */\nvar UsesTicks = {\n    drawTicks: function(\n        parent_elt,\n        data,\n        dataHandler,\n        textTransform,\n        horizontal\n    ) {\n        // Set up group elements for chroms and for each tick.\n        var ticks = parent_elt\n            .append(\"g\")\n            .selectAll(\"g\")\n            .data(data)\n            .enter()\n            .append(\"g\")\n            .selectAll(\"g\")\n            .data(dataHandler)\n            .enter()\n            .append(\"g\")\n            .attr(\"class\", \"tick\")\n            .attr(\n                \"transform\",\n                d =>\n                    `rotate(${d.angle * 180 / Math.PI -\n                        90})translate(${d.radius},0)`\n            );\n\n        // Add line + text for ticks.\n        var tick_coords = [];\n\n        var text_coords = [];\n\n        var text_anchor = d => (d.angle > Math.PI ? \"end\" : null);\n\n        if (horizontal) {\n            tick_coords = [0, 0, 0, -4];\n            text_coords = [4, 0, \"\", \".35em\"];\n            text_anchor = null;\n        } else {\n            tick_coords = [1, 0, 4, 0];\n            text_coords = [0, 4, \".35em\", \"\"];\n        }\n\n        ticks\n            .append(\"line\")\n            .attr(\"x1\", tick_coords[0])\n            .attr(\"y1\", tick_coords[1])\n            .attr(\"x2\", tick_coords[2])\n            .attr(\"y1\", tick_coords[3])\n            .style(\"stroke\", \"#000\");\n\n        return ticks\n            .append(\"text\")\n            .attr(\"x\", text_coords[0])\n            .attr(\"y\", text_coords[1])\n            .attr(\"dx\", text_coords[2])\n            .attr(\"dy\", text_coords[3])\n            .attr(\"text-anchor\", text_anchor)\n            .attr(\"transform\", textTransform)\n            .text(d => d.label);\n    },\n\n    /**\n     * Format number for display at a tick.\n     */\n    formatNum: function(num, sigDigits) {\n        // Use default of 2 sig. digits.\n        if (sigDigits === undefined) sigDigits = 2;\n\n        // Verify input number\n        if (num === null) return null;\n\n        // Calculate return value\n        var rval = null;\n        if (Math.abs(num) < 1) {\n            rval = num.toPrecision(sigDigits);\n        } else {\n            // Use round to turn string from toPrecision() back into a number.\n            var roundedNum = Math.round(num.toPrecision(sigDigits));\n\n            // Use abbreviations.\n            num = Math.abs(num);\n            if (num < 1000) {\n                rval = roundedNum;\n            } else if (num < 1000000) {\n                // Use K.\n                rval = `${Math.round(\n                    (roundedNum / 1000).toPrecision(3)\n                ).toFixed(0)}K`;\n            } else if (num < 1000000000) {\n                // Use M.\n                rval = `${Math.round(\n                    (roundedNum / 1000000).toPrecision(3)\n                ).toFixed(0)}M`;\n            }\n        }\n\n        return rval;\n    }\n};\n\n/**\n * A label track.\n */\nvar CircsterLabelTrack = Backbone.Model.extend({});\n\n/**\n * Renders a full circster visualization.\n */\nvar CircsterView = Backbone.View.extend({\n    className: \"circster\",\n\n    initialize: function(options) {\n        this.genome = options.genome;\n        this.label_arc_height = 50;\n        this.scale = 1;\n        this.circular_views = null;\n        this.chords_views = null;\n\n        // When tracks added to/removed from model, update view.\n        this.model.get(\"drawables\").on(\"add\", this.add_track, this);\n        this.model.get(\"drawables\").on(\"remove\", this.remove_track, this);\n\n        // When config settings change, update view.\n        var vis_config = this.model.get(\"config\");\n        vis_config\n            .get(\"arc_dataset_height\")\n            .on(\"change:value\", this.update_track_bounds, this);\n        vis_config\n            .get(\"track_gap\")\n            .on(\"change:value\", this.update_track_bounds, this);\n    },\n\n    // HACKs: using track_type for circular/chord distinction in the functions below for now.\n\n    /**\n     * Returns tracks to be rendered using circular view.\n     */\n    get_circular_tracks: function() {\n        return this.model\n            .get(\"drawables\")\n            .filter(\n                track => track.get(\"track_type\") !== \"DiagonalHeatmapTrack\"\n            );\n    },\n\n    /**\n     * Returns tracks to be rendered using chords view.\n     */\n    get_chord_tracks: function() {\n        return this.model\n            .get(\"drawables\")\n            .filter(\n                track => track.get(\"track_type\") === \"DiagonalHeatmapTrack\"\n            );\n    },\n\n    /**\n     * Returns a list of circular tracks' radius bounds.\n     */\n    get_tracks_bounds: function() {\n        var circular_tracks = this.get_circular_tracks();\n\n        var dataset_arc_height = this.model\n            .get(\"config\")\n            .get_value(\"arc_dataset_height\");\n\n        var track_gap = this.model.get(\"config\").get_value(\"track_gap\");\n\n        var // Subtract 20 to make sure chrom labels are on screen.\n        min_dimension = Math.min(this.$el.width(), this.$el.height()) - 20;\n\n        var // Compute radius start based on model, will be centered\n        // and fit entirely inside element by default.\n        radius_start =\n            min_dimension / 2 -\n            circular_tracks.length * (dataset_arc_height + track_gap) +\n            // Add track_gap back in because no gap is needed for last track.\n            track_gap -\n            this.label_arc_height;\n\n        var // Compute range of track starting radii.\n        tracks_start_radii = d3.range(\n            radius_start,\n            min_dimension / 2,\n            dataset_arc_height + track_gap\n        );\n\n        // Map from track start to bounds.\n        var self = this;\n        return _.map(tracks_start_radii, radius => [\n            radius,\n            radius + dataset_arc_height\n        ]);\n    },\n\n    /**\n     * Renders circular tracks, chord tracks, and label tracks.\n     */\n    render: function() {\n        var self = this;\n        var width = self.$el.width();\n        var height = self.$el.height();\n        var circular_tracks = this.get_circular_tracks();\n        var chords_tracks = this.get_chord_tracks();\n        var total_gap = self.model.get(\"config\").get_value(\"total_gap\");\n        var tracks_bounds = this.get_tracks_bounds();\n\n        var // Set up SVG element.\n        svg = d3\n            .select(self.$el[0])\n            .append(\"svg\")\n            .attr(\"width\", width)\n            .attr(\"height\", height)\n            .attr(\"pointer-events\", \"all\")\n            // Set up zooming, dragging.\n            .append(\"svg:g\")\n            .call(\n                d3.behavior.zoom().on(\"zoom\", () => {\n                    // Do zoom, drag.\n                    var scale = d3.event.scale;\n                    svg.attr(\n                        \"transform\",\n                        `translate(${d3.event.translate}) scale(${scale})`\n                    );\n\n                    // Propagate scale changes to views.\n                    if (self.scale !== scale) {\n                        // Use timeout to wait for zooming/dragging to stop before rendering more detail.\n                        if (self.zoom_drag_timeout) {\n                            clearTimeout(self.zoom_drag_timeout);\n                        }\n                        self.zoom_drag_timeout = setTimeout(() => {\n                            // Render more detail in tracks' visible elements.\n                            // FIXME: do not do this right now; it is not fully implemented--e.g. data bounds\n                            // are not updated when new data is fetched--and fetching more detailed quantitative\n                            // data is not that useful.\n                            /*\n                        _.each(self.circular_views, function(view) {\n                            view.update_scale(scale);\n                        });\n                        */\n                        }, 400);\n                    }\n                })\n            )\n            .attr(\"transform\", `translate(${width / 2},${height / 2})`)\n            .append(\"svg:g\")\n            .attr(\"class\", \"tracks\");\n\n        // -- Render circular tracks. --\n\n        // Create a view for each track in the visualization and render.\n        this.circular_views = circular_tracks.map((track, index) => {\n            var view = new CircsterBigWigTrackView({\n                el: svg.append(\"g\")[0],\n                track: track,\n                radius_bounds: tracks_bounds[index],\n                genome: self.genome,\n                total_gap: total_gap\n            });\n\n            view.render();\n\n            return view;\n        });\n\n        // -- Render chords tracks. --\n\n        this.chords_views = chords_tracks.map(track => {\n            var view = new CircsterChromInteractionsTrackView({\n                el: svg.append(\"g\")[0],\n                track: track,\n                radius_bounds: tracks_bounds[0],\n                genome: self.genome,\n                total_gap: total_gap\n            });\n\n            view.render();\n\n            return view;\n        });\n\n        // -- Render label track. --\n\n        // Track bounds are:\n        // (a) outer radius of last circular track;\n        // (b)\n        var outermost_radius = this.circular_views[\n            this.circular_views.length - 1\n        ].radius_bounds[1];\n\n        var track_bounds = [\n            outermost_radius,\n            outermost_radius + this.label_arc_height\n        ];\n\n        this.label_track_view = new CircsterChromLabelTrackView({\n            el: svg.append(\"g\")[0],\n            track: new CircsterLabelTrack(),\n            radius_bounds: track_bounds,\n            genome: self.genome,\n            total_gap: total_gap\n        });\n\n        this.label_track_view.render();\n    },\n\n    /**\n     * Render a single track on the outside of the current visualization.\n     */\n    add_track: function(new_track) {\n        var total_gap = this.model.get(\"config\").get_value(\"total_gap\");\n\n        if (new_track.get(\"track_type\") === \"DiagonalHeatmapTrack\") {\n            // Added chords track.\n            var innermost_radius_bounds = this.circular_views[0].radius_bounds;\n\n            var new_view = new CircsterChromInteractionsTrackView({\n                el: d3.select(\"g.tracks\").append(\"g\")[0],\n                track: new_track,\n                radius_bounds: innermost_radius_bounds,\n                genome: this.genome,\n                total_gap: total_gap\n            });\n\n            new_view.render();\n            this.chords_views.push(new_view);\n        } else {\n            // Added circular track.\n\n            // Recompute and update circular track bounds.\n            var new_track_bounds = this.get_tracks_bounds();\n            _.each(this.circular_views, (track_view, i) => {\n                track_view.update_radius_bounds(new_track_bounds[i]);\n            });\n\n            // Update chords tracks.\n            _.each(this.chords_views, track_view => {\n                track_view.update_radius_bounds(new_track_bounds[0]);\n            });\n\n            // Render new track.\n            var track_index = this.circular_views.length;\n\n            var track_view = new CircsterBigWigTrackView({\n                el: d3.select(\"g.tracks\").append(\"g\")[0],\n                track: new_track,\n                radius_bounds: new_track_bounds[track_index],\n                genome: this.genome,\n                total_gap: total_gap\n            });\n\n            track_view.render();\n            this.circular_views.push(track_view);\n\n            // Update label track.\n            /*\n            FIXME: should never have to update label track because vis always expands to fit area\n            within label track.\n            var track_bounds = new_track_bounds[ new_track_bounds.length-1 ];\n            track_bounds[1] = track_bounds[0];\n            this.label_track_view.update_radius_bounds(track_bounds);\n            */\n        }\n    },\n\n    /**\n     * Remove a track from the view.\n     */\n    remove_track: function(track, tracks, options) {\n        // -- Remove track from view. --\n        var track_view = this.circular_views[options.index];\n        this.circular_views.splice(options.index, 1);\n        track_view.$el.remove();\n\n        // Recompute and update track bounds.\n        var new_track_bounds = this.get_tracks_bounds();\n        _.each(this.circular_views, (track_view, i) => {\n            track_view.update_radius_bounds(new_track_bounds[i]);\n        });\n    },\n\n    update_track_bounds: function() {\n        // Recompute and update track bounds.\n        var new_track_bounds = this.get_tracks_bounds();\n        _.each(this.circular_views, (track_view, i) => {\n            track_view.update_radius_bounds(new_track_bounds[i]);\n        });\n\n        // Update chords tracks.\n        _.each(this.chords_views, track_view => {\n            track_view.update_radius_bounds(new_track_bounds[0]);\n        });\n    }\n});\n\n/**\n * Renders a track in a Circster visualization.\n */\nvar CircsterTrackView = Backbone.View.extend({\n    tagName: \"g\",\n\n    /* ----------------------- Public Methods ------------------------- */\n\n    initialize: function(options) {\n        this.bg_stroke = \"#ddd\";\n        // Fill color when loading data.\n        this.loading_bg_fill = \"#ffc\";\n        // Fill color when data has been loaded.\n        this.bg_fill = \"#ddd\";\n        this.total_gap = options.total_gap;\n        this.track = options.track;\n        this.radius_bounds = options.radius_bounds;\n        this.genome = options.genome;\n        this.chroms_layout = this._chroms_layout();\n        this.data_bounds = [];\n        this.scale = 1;\n        this.parent_elt = d3.select(this.$el[0]);\n    },\n\n    /**\n     * Get fill color from config.\n     */\n    get_fill_color: function() {\n        var color = this.track.get(\"config\").get_value(\"block_color\");\n        if (!color) {\n            color = this.track.get(\"config\").get_value(\"color\");\n        }\n        return color;\n    },\n\n    /**\n     * Render track's data by adding SVG elements to parent.\n     */\n    render: function() {\n        // -- Create track group element. --\n        var track_parent_elt = this.parent_elt;\n\n        // -- Render background arcs. --\n        var genome_arcs = this.chroms_layout;\n\n        var arc_gen = d3.svg\n            .arc()\n            .innerRadius(this.radius_bounds[0])\n            .outerRadius(this.radius_bounds[1]);\n\n        var // Attach data to group element.\n        chroms_elts = track_parent_elt\n            .selectAll(\"g\")\n            .data(genome_arcs)\n            .enter()\n            .append(\"svg:g\");\n\n        var // Draw chrom arcs/paths.\n        chroms_paths = chroms_elts\n            .append(\"path\")\n            .attr(\"d\", arc_gen)\n            .attr(\"class\", \"chrom-background\")\n            .style(\"stroke\", this.bg_stroke)\n            .style(\"fill\", this.loading_bg_fill);\n\n        // Append titles to paths.\n        chroms_paths.append(\"title\").text(d => d.data.chrom);\n\n        // -- Render track data and, when track data is rendered, apply preferences and update chrom_elts fill. --\n\n        var self = this;\n\n        var data_manager = self.track.get(\"data_manager\");\n\n        var // If track has a data manager, get deferred that resolves when data is ready.\n        data_ready_deferred = data_manager\n            ? data_manager.data_is_ready()\n            : true;\n\n        // When data is ready, render track.\n        $.when(data_ready_deferred).then(() => {\n            $.when(self._render_data(track_parent_elt)).then(() => {\n                chroms_paths.style(\"fill\", self.bg_fill);\n\n                // Render labels after data is available so that data attributes are available.\n                self.render_labels();\n            });\n        });\n    },\n\n    /**\n     * Render track labels.\n     */\n    render_labels: function() {},\n\n    /**\n     * Update radius bounds.\n     */\n    update_radius_bounds: function(radius_bounds) {\n        // Update bounds.\n        this.radius_bounds = radius_bounds;\n\n        // -- Update background arcs. --\n        var new_d = d3.svg\n            .arc()\n            .innerRadius(this.radius_bounds[0])\n            .outerRadius(this.radius_bounds[1]);\n\n        this.parent_elt\n            .selectAll(\"g>path.chrom-background\")\n            .transition()\n            .duration(1000)\n            .attr(\"d\", new_d);\n\n        this._transition_chrom_data();\n\n        this._transition_labels();\n    },\n\n    /**\n     * Update view scale. This fetches more data if scale is increased.\n     */\n    update_scale: function(new_scale) {\n        // -- Update scale and return if new scale is less than old scale. --\n\n        var old_scale = this.scale;\n        this.scale = new_scale;\n        if (new_scale <= old_scale) {\n            return;\n        }\n\n        // -- Scale increased, so render visible data with more detail. --\n\n        var self = this;\n\n        var utils = new SVGUtils();\n\n        // Select all chrom data and filter to operate on those that are visible.\n        this.parent_elt\n            .selectAll(\"path.chrom-data\")\n            .filter(function(d, i) {\n                return utils.is_visible(this);\n            })\n            .each(function(d, i) {\n                // -- Now operating on a single path element representing chromosome data. --\n\n                var path_elt = d3.select(this);\n\n                var chrom = path_elt.attr(\"chrom\");\n                var chrom_region = self.genome.get_chrom_region(chrom);\n                var data_manager = self.track.get(\"data_manager\");\n                var data_deferred;\n\n                // If can't get more detailed data, return.\n                if (!data_manager.can_get_more_detailed_data(chrom_region)) {\n                    return;\n                }\n\n                // -- Get more detailed data. --\n                data_deferred = self.track\n                    .get(\"data_manager\")\n                    .get_more_detailed_data(\n                        chrom_region,\n                        \"Coverage\",\n                        0,\n                        new_scale\n                    );\n\n                // When more data is available, use new data to redraw path.\n                $.when(data_deferred).then(data => {\n                    // Remove current data path.\n                    path_elt.remove();\n\n                    // Update data bounds with new data.\n                    self._update_data_bounds();\n\n                    // Find chromosome arc to draw data on.\n                    var chrom_arc = _.find(\n                        self.chroms_layout,\n                        layout => layout.data.chrom === chrom\n                    );\n\n                    // Add new data path and apply preferences.\n                    var color = self.get_fill_color();\n                    self\n                        ._render_chrom_data(self.parent_elt, chrom_arc, data)\n                        .style(\"stroke\", color)\n                        .style(\"fill\", color);\n                });\n            });\n\n        return self;\n    },\n\n    /* ----------------------- Internal Methods ------------------------- */\n\n    /**\n     * Transitions chrom data to new values (e.g new radius or data bounds).\n     */\n    _transition_chrom_data: function() {\n        var track = this.track;\n        var chrom_arcs = this.chroms_layout;\n        var chrom_data_paths = this.parent_elt.selectAll(\"g>path.chrom-data\");\n        var num_paths = chrom_data_paths[0].length;\n\n        if (num_paths > 0) {\n            var self = this;\n            $.when(\n                track.get(\"data_manager\").get_genome_wide_data(this.genome)\n            ).then(genome_wide_data => {\n                // Map chrom data to path data, filtering out null values.\n                var path_data = _.reject(\n                    _.map(genome_wide_data, (chrom_data, i) => {\n                        var rval = null;\n\n                        var path_fn = self._get_path_function(\n                            chrom_arcs[i],\n                            chrom_data\n                        );\n\n                        if (path_fn) {\n                            rval = path_fn(chrom_data.data);\n                        }\n                        return rval;\n                    }),\n                    p_data => p_data === null\n                );\n\n                // Transition each path for data and color.\n                var color = track.get(\"config\").get_value(\"color\");\n                chrom_data_paths.each(function(path, index) {\n                    d3\n                        .select(this)\n                        .transition()\n                        .duration(1000)\n                        .style(\"stroke\", color)\n                        .style(\"fill\", color)\n                        .attr(\"d\", path_data[index]);\n                });\n            });\n        }\n    },\n\n    /**\n     * Transition labels to new values (e.g new radius or data bounds).\n     */\n    _transition_labels: function() {},\n\n    /**\n     * Update data bounds. If there are new_bounds, use them; otherwise use\n     * default data bounds.\n     */\n    _update_data_bounds: function(new_bounds) {\n        var old_bounds = this.data_bounds;\n        this.data_bounds =\n            new_bounds ||\n            this.get_data_bounds(\n                this.track.get(\"data_manager\").get_genome_wide_data(this.genome)\n            );\n        this._transition_chrom_data();\n    },\n\n    /**\n     * Render data as elements attached to svg.\n     */\n    _render_data: function(svg) {\n        var self = this;\n        var chrom_arcs = this.chroms_layout;\n        var track = this.track;\n        var rendered_deferred = $.Deferred();\n\n        // When genome-wide data is available, render data.\n        $.when(\n            track.get(\"data_manager\").get_genome_wide_data(this.genome)\n        ).then(genome_wide_data => {\n            // Set bounds.\n            self.data_bounds = self.get_data_bounds(genome_wide_data);\n\n            // Set min, max value in config so that they can be adjusted. Make this silent\n            // because these attributes are watched for changes and the viz is updated\n            // accordingly (set up in initialize). Because we are setting up, we don't want\n            // the watch to trigger events here.\n            track.get(\"config\").set_value(\"min_value\", self.data_bounds[0], {\n                silent: true\n            });\n            track.get(\"config\").set_value(\"max_value\", self.data_bounds[1], {\n                silent: true\n            });\n\n            // Merge chroms layout with data.\n            var layout_and_data = _.zip(chrom_arcs, genome_wide_data);\n\n            // Render each chromosome's data.\n            _.each(layout_and_data, chrom_info => {\n                var chrom_arc = chrom_info[0];\n                var data = chrom_info[1];\n                return self._render_chrom_data(svg, chrom_arc, data);\n            });\n\n            // Apply prefs to all track data.\n            var color = self.get_fill_color();\n            self.parent_elt\n                .selectAll(\"path.chrom-data\")\n                .style(\"stroke\", color)\n                .style(\"fill\", color);\n\n            rendered_deferred.resolve(svg);\n        });\n\n        return rendered_deferred;\n    },\n\n    /**\n     * Render a chromosome data and attach elements to svg.\n     */\n    _render_chrom_data: function(svg, chrom_arc, data) {},\n\n    /**\n     * Returns data for creating a path for the given data using chrom_arc and data bounds.\n     */\n    _get_path_function: function(chrom_arc, chrom_data) {},\n\n    /**\n     * Returns arc layouts for genome's chromosomes/contigs. Arcs are arranged in a circle\n     * separated by gaps.\n     */\n    _chroms_layout: function() {\n        // Setup chroms layout using pie.\n        var chroms_info = this.genome.get_chroms_info();\n\n        var pie_layout = d3.layout\n            .pie()\n            .value(d => d.len)\n            .sort(null);\n\n        var init_arcs = pie_layout(chroms_info);\n        var gap_per_chrom = 2 * Math.PI * this.total_gap / chroms_info.length;\n\n        var chrom_arcs = _.map(init_arcs, (arc, index) => {\n            // For short chroms, endAngle === startAngle.\n            var new_endAngle = arc.endAngle - gap_per_chrom;\n            arc.endAngle =\n                new_endAngle > arc.startAngle ? new_endAngle : arc.startAngle;\n            return arc;\n        });\n\n        return chrom_arcs;\n    }\n});\n\n/**\n * Render chromosome labels.\n */\nvar CircsterChromLabelTrackView = CircsterTrackView.extend({\n    initialize: function(options) {\n        CircsterTrackView.prototype.initialize.call(this, options);\n        // Use a single arc for rendering data.\n        this.innerRadius = this.radius_bounds[0];\n        this.radius_bounds[0] = this.radius_bounds[1];\n        this.bg_stroke = \"#fff\";\n        this.bg_fill = \"#fff\";\n\n        // Minimum arc distance for labels to be applied.\n        this.min_arc_len = 0.05;\n    },\n\n    /**\n     * Render labels.\n     */\n    _render_data: function(svg) {\n        // -- Add chromosome label where it will fit; an alternative labeling mechanism\n        // would be nice for small chromosomes. --\n        var self = this;\n\n        var chrom_arcs = svg.selectAll(\"g\");\n\n        chrom_arcs.selectAll(\"path\").attr(\"id\", d => `label-${d.data.chrom}`);\n\n        chrom_arcs\n            .append(\"svg:text\")\n            .filter(d => d.endAngle - d.startAngle > self.min_arc_len)\n            .attr(\"text-anchor\", \"middle\")\n            .append(\"svg:textPath\")\n            .attr(\"class\", \"chrom-label\")\n            .attr(\"xlink:href\", d => `#label-${d.data.chrom}`)\n            .attr(\"startOffset\", \"25%\")\n            .text(d => d.data.chrom);\n\n        // -- Add ticks to denote chromosome length. --\n\n        /** Returns an array of tick angles and labels, given a chrom arc. */\n        var chromArcTicks = d => {\n            var k = (d.endAngle - d.startAngle) / d.value;\n\n            var ticks = d3.range(0, d.value, 25000000).map((v, i) => ({\n                radius: self.innerRadius,\n                angle: v * k + d.startAngle,\n                label: i === 0 ? 0 : i % 3 ? null : self.formatNum(v)\n            }));\n\n            // If there are fewer that 4 ticks, label last tick so that at least one non-zero tick is labeled.\n            if (ticks.length < 4) {\n                ticks[ticks.length - 1].label = self.formatNum(\n                    Math.round(\n                        (ticks[ticks.length - 1].angle - d.startAngle) / k\n                    )\n                );\n            }\n\n            return ticks;\n        };\n\n        /** Rotate and move text as needed. */\n        var textTransform = d =>\n            d.angle > Math.PI ? \"rotate(180)translate(-16)\" : null;\n\n        // Filter chroms for only those large enough for display.\n        var visibleChroms = _.filter(\n            this.chroms_layout,\n            c => c.endAngle - c.startAngle > self.min_arc_len\n        );\n\n        this.drawTicks(\n            this.parent_elt,\n            visibleChroms,\n            chromArcTicks,\n            textTransform\n        );\n    }\n});\n_.extend(CircsterChromLabelTrackView.prototype, UsesTicks);\n\n/**\n * View for quantitative track in Circster.\n */\nvar CircsterQuantitativeTrackView = CircsterTrackView.extend({\n    initialize: function(options) {\n        CircsterTrackView.prototype.initialize.call(this, options);\n\n        // When config settings change, update view.\n        var track_config = this.track.get(\"config\");\n        track_config\n            .get(\"min_value\")\n            .on(\"change:value\", this._update_min_max, this);\n        track_config\n            .get(\"max_value\")\n            .on(\"change:value\", this._update_min_max, this);\n        track_config\n            .get(\"color\")\n            .on(\"change:value\", this._transition_chrom_data, this);\n    },\n\n    /**\n     * Update track when min and/or max are changed.\n     */\n    _update_min_max: function() {\n        var track_config = this.track.get(\"config\");\n\n        var new_bounds = [\n            track_config.get_value(\"min_value\"),\n            track_config.get_value(\"max_value\")\n        ];\n\n        this._update_data_bounds(new_bounds);\n\n        // FIXME: this works to update tick/text bounds, but there's probably a better way to do this\n        // by updating the data itself.\n        this.parent_elt.selectAll(\".min_max\").text((d, i) => new_bounds[i]);\n    },\n\n    /**\n     * Returns quantile for an array of numbers.\n     */\n    _quantile: function(numbers, quantile) {\n        numbers.sort(d3.ascending);\n        return d3.quantile(numbers, quantile);\n    },\n\n    /**\n     * Renders quantitative data with the form [x, value] and assumes data is equally spaced across\n     * chromosome. Attachs a dict with track and chrom name information to DOM element.\n     */\n    _render_chrom_data: function(svg, chrom_arc, chrom_data) {\n        var path_data = this._get_path_function(chrom_arc, chrom_data);\n\n        if (!path_data) {\n            return null;\n        }\n\n        // There is path data, so render as path.\n        var parent = svg.datum(chrom_data.data);\n\n        var path = parent\n            .append(\"path\")\n            .attr(\"class\", \"chrom-data\")\n            .attr(\"chrom\", chrom_arc.data.chrom)\n            .attr(\"d\", path_data);\n\n        return path;\n    },\n\n    /**\n     * Returns function for creating a path across the chrom arc.\n     */\n    _get_path_function: function(chrom_arc, chrom_data) {\n        // If no chrom data, return null.\n        if (\n            typeof chrom_data === \"string\" ||\n            !chrom_data.data ||\n            chrom_data.data.length === 0\n        ) {\n            return null;\n        }\n\n        // Radius scaler.\n        var radius = d3.scale\n            .linear()\n            .domain(this.data_bounds)\n            .range(this.radius_bounds)\n            .clamp(true);\n\n        // Scaler for placing data points across arc.\n        var angle = d3.scale\n            .linear()\n            .domain([0, chrom_data.data.length])\n            .range([chrom_arc.startAngle, chrom_arc.endAngle]);\n\n        // Use line generator to create area.\n        var line = d3.svg.line\n            .radial()\n            .interpolate(\"linear\")\n            .radius(d => radius(d[1]))\n            .angle((d, i) => angle(i));\n\n        return d3.svg.area\n            .radial()\n            .interpolate(line.interpolate())\n            .innerRadius(radius(0))\n            .outerRadius(line.radius())\n            .angle(line.angle());\n    },\n\n    /**\n     * Render track min, max using ticks.\n     */\n    render_labels: function() {\n        var self = this;\n\n        var // Keep counter of visible chroms.\n        textTransform = () => \"rotate(90)\";\n\n        // FIXME:\n        // (1) using min_max class below is needed for _update_min_max, which could be improved.\n        // (2) showing config on tick click should be replaced by proper track config icon.\n\n        // Draw min, max on first chrom only.\n        var ticks = this.drawTicks(\n            this.parent_elt,\n            [this.chroms_layout[0]],\n            this._data_bounds_ticks_fn(),\n            textTransform,\n            true\n        ).classed(\"min_max\", true);\n\n        // Show config when ticks are clicked on.\n        _.each(ticks, tick => {\n            $(tick).click(() => {\n                var view = new config.ConfigSettingCollectionView({\n                    collection: self.track.get(\"config\")\n                });\n                view.render_in_modal(\"Configure Track\");\n            });\n        });\n\n        /*\n        // Filter for visible chroms, then for every third chrom so that labels attached to only every\n        // third chrom.\n        var visibleChroms = _.filter(this.chroms_layout, function(c) { return c.endAngle - c.startAngle > 0.08; }),\n            labeledChroms = _.filter(visibleChroms, function(c, i) { return i % 3 === 0; });\n        this.drawTicks(this.parent_elt, labeledChroms, this._data_bounds_ticks_fn(), textTransform, true);\n        */\n    },\n\n    /**\n     * Transition labels to new values (e.g new radius or data bounds).\n     */\n    _transition_labels: function() {\n        // FIXME: (a) pull out function for getting labeled chroms? and (b) function used in transition below\n        // is copied from UseTicks mixin, so pull out and make generally available.\n\n        // If there are no data bounds, nothing to transition.\n        if (this.data_bounds.length === 0) {\n            return;\n        }\n\n        // Transition labels to new radius bounds.\n        var self = this;\n\n        var visibleChroms = _.filter(\n            this.chroms_layout,\n            c => c.endAngle - c.startAngle > 0.08\n        );\n\n        var labeledChroms = _.filter(visibleChroms, (c, i) => i % 3 === 0);\n\n        var new_data = _.flatten(\n            _.map(labeledChroms, c => self._data_bounds_ticks_fn()(c))\n        );\n\n        this.parent_elt\n            .selectAll(\"g.tick\")\n            .data(new_data)\n            .transition()\n            .attr(\n                \"transform\",\n                d =>\n                    `rotate(${d.angle * 180 / Math.PI -\n                        90})translate(${d.radius},0)`\n            );\n    },\n\n    /**\n     * Get function for locating data bounds ticks.\n     */\n    _data_bounds_ticks_fn: function() {\n        // Closure vars.\n        var self = this;\n        visibleChroms = 0;\n\n        // Return function for locating ticks based on chrom arc data.\n        return (\n            d // Set up data to display min, max ticks.\n        ) => [\n            {\n                radius: self.radius_bounds[0],\n                angle: d.startAngle,\n                label: self.formatNum(self.data_bounds[0])\n            },\n            {\n                radius: self.radius_bounds[1],\n                angle: d.startAngle,\n                label: self.formatNum(self.data_bounds[1])\n            }\n        ];\n    },\n\n    /**\n     * Returns an array with two values denoting the minimum and maximum\n     * values for the track.\n     */\n    get_data_bounds: function(data) {}\n});\n_.extend(CircsterQuantitativeTrackView.prototype, UsesTicks);\n\n/**\n * Bigwig track view in Circster.\n */\nvar CircsterBigWigTrackView = CircsterQuantitativeTrackView.extend({\n    get_data_bounds: function(data) {\n        // Set max across dataset by extracting all values, flattening them into a\n        // single array, and getting third quartile.\n        var values = _.flatten(\n            _.map(data, d => {\n                if (d) {\n                    // Each data point has the form [position, value], so return all values.\n                    return _.map(\n                        d.data,\n                        (\n                            p // Null is used for a lack of data; resolve null to 0 for comparison.\n                        ) => parseInt(p[1], 10) || 0\n                    );\n                } else {\n                    return 0;\n                }\n            })\n        );\n\n        // For max, use 98% quantile in attempt to avoid very large values. However, this max may be 0\n        // for sparsely populated data, so use max in that case.\n        return [_.min(values), this._quantile(values, 0.98) || _.max(values)];\n    }\n});\n\n/**\n * Chromosome interactions track view in Circster.\n */\nvar CircsterChromInteractionsTrackView = CircsterTrackView.extend({\n    render: function() {\n        var self = this;\n\n        // When data is ready, render track.\n        $.when(self.track.get(\"data_manager\").data_is_ready()).then(() => {\n            // When data has been fetched, render track.\n            $.when(\n                self.track.get(\"data_manager\").get_genome_wide_data(self.genome)\n            ).then(genome_wide_data => {\n                var chord_data = [];\n                var chroms_info = self.genome.get_chroms_info();\n                // Convert chromosome data into chord data.\n                _.each(genome_wide_data, (chrom_data, index) => {\n                    // Map each interaction into chord data.\n                    var cur_chrom = chroms_info[index].chrom;\n                    var chrom_chord_data = _.map(chrom_data.data, datum => {\n                        // Each datum is an interaction/chord.\n                        var source_angle = self._get_region_angle(\n                            cur_chrom,\n                            datum[1]\n                        );\n\n                        var target_angle = self._get_region_angle(\n                            datum[3],\n                            datum[4]\n                        );\n\n                        return {\n                            source: {\n                                startAngle: source_angle,\n                                endAngle: source_angle + 0.01\n                            },\n                            target: {\n                                startAngle: target_angle,\n                                endAngle: target_angle + 0.01\n                            }\n                        };\n                    });\n\n                    chord_data = chord_data.concat(chrom_chord_data);\n                });\n\n                self.parent_elt\n                    .append(\"g\")\n                    .attr(\"class\", \"chord\")\n                    .selectAll(\"path\")\n                    .data(chord_data)\n                    .enter()\n                    .append(\"path\")\n                    .style(\"fill\", self.get_fill_color())\n                    .attr(\"d\", d3.svg.chord().radius(self.radius_bounds[0]))\n                    .style(\"opacity\", 1);\n            });\n        });\n    },\n\n    update_radius_bounds: function(radius_bounds) {\n        this.radius_bounds = radius_bounds;\n        this.parent_elt\n            .selectAll(\"path\")\n            .transition()\n            .attr(\"d\", d3.svg.chord().radius(this.radius_bounds[0]));\n    },\n\n    /**\n     * Returns radians for a genomic position.\n     */\n    _get_region_angle: function(chrom, position) {\n        // Find chrom angle data\n        var chrom_angle_data = _.find(\n            this.chroms_layout,\n            chrom_layout => chrom_layout.data.chrom === chrom\n        );\n\n        // Return angle at position.\n        return (\n            chrom_angle_data.endAngle -\n            (chrom_angle_data.endAngle - chrom_angle_data.startAngle) *\n                (chrom_angle_data.data.len - position) /\n                chrom_angle_data.data.len\n        );\n    }\n});\n\n// circster app loader\nvar Circster = Backbone.View.extend({\n    initialize: function() {\n        // -- Configure visualization --\n        var genome = new visualization.Genome(galaxy_config.app.genome);\n\n        var vis = new visualization.GenomeVisualization(\n            galaxy_config.app.viz_config\n        );\n\n        // Add Circster-specific config options.\n        vis.get(\"config\").add([\n            {\n                key: \"arc_dataset_height\",\n                label: \"Arc Dataset Height\",\n                type: \"int\",\n                value: 25,\n                view: \"circster\"\n            },\n            {\n                key: \"track_gap\",\n                label: \"Gap Between Tracks\",\n                type: \"int\",\n                value: 5,\n                view: \"circster\"\n            },\n            {\n                key: \"total_gap\",\n                label: \"Gap [0-1]\",\n                type: \"float\",\n                value: 0.4,\n                view: \"circster\",\n                hidden: true\n            }\n        ]);\n\n        var viz_view = new CircsterView({\n            // view pane\n            el: $(\"#center .unified-panel-body\"),\n            genome: genome,\n            model: vis\n        });\n\n        // Render vizualization\n        viz_view.render();\n\n        // setup title\n        $(\"#center .unified-panel-header-inner\").append(\n            `${galaxy_config.app.viz_config.title} ${galaxy_config.app\n                .viz_config.dbkey}`\n        );\n\n        // setup menu\n        var menu = mod_icon_btn.create_icon_buttons_menu(\n            [\n                {\n                    icon_class: \"plus-button\",\n                    title: \"Add tracks\",\n                    on_click: function() {\n                        visualization.select_datasets(\n                            { dbkey: vis.get(\"dbkey\") },\n                            tracks => {\n                                vis.add_tracks(tracks);\n                            }\n                        );\n                    }\n                },\n                {\n                    icon_class: \"gear\",\n                    title: \"Settings\",\n                    on_click: function() {\n                        var view = new config.ConfigSettingCollectionView({\n                            collection: vis.get(\"config\")\n                        });\n                        view.render_in_modal(\"Configure Visualization\");\n                    }\n                },\n                {\n                    icon_class: \"disk--arrow\",\n                    title: \"Save\",\n                    on_click: function() {\n                        // show saving dialog box\n                        Galaxy.modal.show({\n                            title: \"Saving...\",\n                            body: \"progress\"\n                        });\n\n                        // send to server\n                        $.ajax({\n                            url: `${Galaxy.root}visualization/save`,\n                            type: \"POST\",\n                            dataType: \"json\",\n                            data: {\n                                id: vis.get(\"vis_id\"),\n                                title: vis.get(\"title\"),\n                                dbkey: vis.get(\"dbkey\"),\n                                type: \"trackster\",\n                                vis_json: JSON.stringify(vis)\n                            }\n                        })\n                            .success(vis_info => {\n                                Galaxy.modal.hide();\n                                vis.set(\"vis_id\", vis_info.vis_id);\n                            })\n                            .error(() => {\n                                // show dialog\n                                Galaxy.modal.show({\n                                    title: \"Could Not Save\",\n                                    body:\n                                        \"Could not save visualization. Please try again later.\",\n                                    buttons: {\n                                        Cancel: function() {\n                                            Galaxy.modal.hide();\n                                        }\n                                    }\n                                });\n                            });\n                    }\n                },\n                {\n                    icon_class: \"cross-circle\",\n                    title: \"Close\",\n                    on_click: function() {\n                        window.location = `${Galaxy.root}visualizations/list`;\n                    }\n                }\n            ],\n            { tooltip_config: { placement: \"bottom\" } }\n        );\n\n        // add menu\n        menu.$el.attr(\"style\", \"float: right\");\n        $(\"#center .unified-panel-header-inner\").append(menu.$el);\n\n        // manual tooltip config because default gravity is S and cannot be changed\n        $(\".menu-button\").tooltip({ placement: \"bottom\" });\n    }\n});\n\n// Module exports.\nexport default {\n    GalaxyApp: Circster\n};\n"]}