{"version":3,"sources":["viz/circster.js"],"names":["_","d3","_utils2","default","cssLoadFile","SVGUtils","Backbone","Model","extend","is_visible","svg_elt","svg","eltBRect","getBoundingClientRect","svgBRect","$","right","left","bottom","top","UsesTicks","drawTicks","parent_elt","data","dataHandler","textTransform","horizontal","ticks","append","selectAll","enter","attr","d","angle","Math","PI","radius","tick_coords","text_anchor","text_coords","text","label","formatNum","num","sigDigits","undefined","rval","abs","roundedNum","toPrecision","round","toFixed","CircsterLabelTrack","genome","CircsterView","View","className","initialize","get","this","options","label_arc_height","scale","vis_config","model","on","add_track","remove_track","get_circular_tracks","update_track_bounds","filter","track","get_chord_tracks","track_gap","get_value","get_tracks_bounds","dataset_arc_height","tracks_start_radii","min_dimension","min","$el","width","height","radius_start","render","length","self","map","circular_tracks","chords_tracks","total_gap","tracks_bounds","select","call","behavior","zoom","CircsterBigWigTrackView","event","radius_bounds","translate","CircsterChromInteractionsTrackView","zoom_drag_timeout","setTimeout","outermost_radius","label_track_view","view","el","index","chords_views","new_view","new_track","circular_views","track_view","track_bounds","track_index","CircsterChromLabelTrackView","innermost_radius_bounds","push","new_track_bounds","each","i","update_radius_bounds","tracks","splice","remove","color","genome_arcs","chroms_layout","CircsterTrackView","tagName","bg_stroke","loading_bg_fill","bg_fill","data_manager","data_ready_deferred","_chroms_layout","when","chroms_paths","style","get_fill_color","render_labels","track_parent_elt","arc_gen","arc","innerRadius","outerRadius","_transition_labels","update_scale","new_scale","utils","chrom","path_elt","chrom_region","then","can_get_more_detailed_data","layout","transition","duration","new_d","_transition_chrom_data","old_scale","path_data","chrom_data_paths","data_deferred","get_chrom_region","get_more_detailed_data","rendered_deferred","Deferred","data_bounds","chrom_arc","find","set_value","silent","_render_chrom_data","layout_and_data","chrom_arcs","get_genome_wide_data","genome_wide_data","reject","chrom_data","path_fn","_get_path_function","p_data","init_arcs","path","new_endAngle","endAngle","_update_data_bounds","new_bounds","min_arc_len","get_data_bounds","_render_data","k","startAngle","value","zip","chrom_info","visibleChroms","prototype","track_config","chroms_info","get_chroms_info","pie","_update_min_max","sort","gap_per_chrom","line","c","range","v","CircsterQuantitativeTrackView","labeledChroms","new_data","flatten","_data_bounds_ticks_fn","_quantile","numbers","quantile","ascending","datum","linear","domain","cur_chrom","radial","interpolate","chrom_angle_data","classed","tick","Circster","_config2","ConfigSettingCollectionView","collection","render_in_modal","vis","viz_view","on_click","icon_class","title","Galaxy","modal","body","ajax","type","id","vis_json","stringify","success","vis_info","values","tooltip_config","p","parseInt","max","data_is_ready","chord_data","chrom_chord_data","source_angle","_get_region_angle","target_angle","source","target","concat","chord","position","chrom_layout","len","_visualization2","Genome","galaxy_config","app","GenomeVisualization","viz_config","add","key","hidden","dbkey","menu","_iconButton2","create_icon_buttons_menu","select_datasets","add_tracks","show","url","root","dataType","JSON","hide","set","vis_id","error","buttons","Cancel","window","location","placement","tooltip","GalaxyApp"],"mappings":"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","file":"../../scripts/viz/circster.js","sourcesContent":["import * as _ from \"libs/underscore\";\nimport * as d3 from \"libs/d3\";\nimport visualization from \"viz/visualization\";\nimport mod_utils from \"utils/utils\";\nimport config from \"utils/config\";\nimport mod_icon_btn from \"mvc/ui/icon-button\";\nimport \"libs/farbtastic\";\n/**\n * Utility class for working with SVG.\n */\n// load css\nmod_utils.cssLoadFile(\"static/style/circster.css\");\n\nvar SVGUtils = Backbone.Model.extend({\n    /**\n     * Returns true if element is visible.\n     */\n    is_visible: function(svg_elt, svg) {\n        var eltBRect = svg_elt.getBoundingClientRect();\n        var svgBRect = $(\"svg\")[0].getBoundingClientRect();\n\n        if (\n            // To the left of screen?\n            eltBRect.right < 0 ||\n            // To the right of screen?\n            eltBRect.left > svgBRect.right ||\n            // Above screen?\n            eltBRect.bottom < 0 ||\n            // Below screen?\n            eltBRect.top > svgBRect.bottom\n        ) {\n            return false;\n        }\n        return true;\n    }\n});\n\n/**\n * Mixin for using ticks.\n */\nvar UsesTicks = {\n    drawTicks: function(\n        parent_elt,\n        data,\n        dataHandler,\n        textTransform,\n        horizontal\n    ) {\n        // Set up group elements for chroms and for each tick.\n        var ticks = parent_elt\n            .append(\"g\")\n            .selectAll(\"g\")\n            .data(data)\n            .enter()\n            .append(\"g\")\n            .selectAll(\"g\")\n            .data(dataHandler)\n            .enter()\n            .append(\"g\")\n            .attr(\"class\", \"tick\")\n            .attr(\"transform\", function(d) {\n                return (\n                    \"rotate(\" +\n                    (d.angle * 180 / Math.PI - 90) +\n                    \")\" +\n                    \"translate(\" +\n                    d.radius +\n                    \",0)\"\n                );\n            });\n\n        // Add line + text for ticks.\n        var tick_coords = [];\n\n        var text_coords = [];\n\n        var text_anchor = function(d) {\n            return d.angle > Math.PI ? \"end\" : null;\n        };\n\n        if (horizontal) {\n            tick_coords = [0, 0, 0, -4];\n            text_coords = [4, 0, \"\", \".35em\"];\n            text_anchor = null;\n        } else {\n            tick_coords = [1, 0, 4, 0];\n            text_coords = [0, 4, \".35em\", \"\"];\n        }\n\n        ticks\n            .append(\"line\")\n            .attr(\"x1\", tick_coords[0])\n            .attr(\"y1\", tick_coords[1])\n            .attr(\"x2\", tick_coords[2])\n            .attr(\"y1\", tick_coords[3])\n            .style(\"stroke\", \"#000\");\n\n        return ticks\n            .append(\"text\")\n            .attr(\"x\", text_coords[0])\n            .attr(\"y\", text_coords[1])\n            .attr(\"dx\", text_coords[2])\n            .attr(\"dy\", text_coords[3])\n            .attr(\"text-anchor\", text_anchor)\n            .attr(\"transform\", textTransform)\n            .text(function(d) {\n                return d.label;\n            });\n    },\n\n    /**\n     * Format number for display at a tick.\n     */\n    formatNum: function(num, sigDigits) {\n        // Use default of 2 sig. digits.\n        if (sigDigits === undefined) sigDigits = 2;\n\n        // Verify input number\n        if (num === null) return null;\n\n        // Calculate return value\n        var rval = null;\n        if (Math.abs(num) < 1) {\n            rval = num.toPrecision(sigDigits);\n        } else {\n            // Use round to turn string from toPrecision() back into a number.\n            var roundedNum = Math.round(num.toPrecision(sigDigits));\n\n            // Use abbreviations.\n            num = Math.abs(num);\n            if (num < 1000) {\n                rval = roundedNum;\n            } else if (num < 1000000) {\n                // Use K.\n                rval =\n                    Math.round((roundedNum / 1000).toPrecision(3)).toFixed(0) +\n                    \"K\";\n            } else if (num < 1000000000) {\n                // Use M.\n                rval =\n                    Math.round((roundedNum / 1000000).toPrecision(3)).toFixed(\n                        0\n                    ) + \"M\";\n            }\n        }\n\n        return rval;\n    }\n};\n\n/**\n * A label track.\n */\nvar CircsterLabelTrack = Backbone.Model.extend({});\n\n/**\n * Renders a full circster visualization.\n */\nvar CircsterView = Backbone.View.extend({\n    className: \"circster\",\n\n    initialize: function(options) {\n        this.genome = options.genome;\n        this.label_arc_height = 50;\n        this.scale = 1;\n        this.circular_views = null;\n        this.chords_views = null;\n\n        // When tracks added to/removed from model, update view.\n        this.model.get(\"drawables\").on(\"add\", this.add_track, this);\n        this.model.get(\"drawables\").on(\"remove\", this.remove_track, this);\n\n        // When config settings change, update view.\n        var vis_config = this.model.get(\"config\");\n        vis_config\n            .get(\"arc_dataset_height\")\n            .on(\"change:value\", this.update_track_bounds, this);\n        vis_config\n            .get(\"track_gap\")\n            .on(\"change:value\", this.update_track_bounds, this);\n    },\n\n    // HACKs: using track_type for circular/chord distinction in the functions below for now.\n\n    /**\n     * Returns tracks to be rendered using circular view.\n     */\n    get_circular_tracks: function() {\n        return this.model.get(\"drawables\").filter(function(track) {\n            return track.get(\"track_type\") !== \"DiagonalHeatmapTrack\";\n        });\n    },\n\n    /**\n     * Returns tracks to be rendered using chords view.\n     */\n    get_chord_tracks: function() {\n        return this.model.get(\"drawables\").filter(function(track) {\n            return track.get(\"track_type\") === \"DiagonalHeatmapTrack\";\n        });\n    },\n\n    /**\n     * Returns a list of circular tracks' radius bounds.\n     */\n    get_tracks_bounds: function() {\n        var circular_tracks = this.get_circular_tracks();\n\n        var dataset_arc_height = this.model\n            .get(\"config\")\n            .get_value(\"arc_dataset_height\");\n\n        var track_gap = this.model.get(\"config\").get_value(\"track_gap\");\n\n        var // Subtract 20 to make sure chrom labels are on screen.\n        min_dimension = Math.min(this.$el.width(), this.$el.height()) - 20;\n\n        var // Compute radius start based on model, will be centered\n        // and fit entirely inside element by default.\n        radius_start =\n            min_dimension / 2 -\n            circular_tracks.length * (dataset_arc_height + track_gap) +\n            // Add track_gap back in because no gap is needed for last track.\n            track_gap -\n            this.label_arc_height;\n\n        var // Compute range of track starting radii.\n        tracks_start_radii = d3.range(\n            radius_start,\n            min_dimension / 2,\n            dataset_arc_height + track_gap\n        );\n\n        // Map from track start to bounds.\n        var self = this;\n        return _.map(tracks_start_radii, function(radius) {\n            return [radius, radius + dataset_arc_height];\n        });\n    },\n\n    /**\n     * Renders circular tracks, chord tracks, and label tracks.\n     */\n    render: function() {\n        var self = this;\n        var width = self.$el.width();\n        var height = self.$el.height();\n        var circular_tracks = this.get_circular_tracks();\n        var chords_tracks = this.get_chord_tracks();\n        var total_gap = self.model.get(\"config\").get_value(\"total_gap\");\n        var tracks_bounds = this.get_tracks_bounds();\n\n        var // Set up SVG element.\n        svg = d3\n            .select(self.$el[0])\n            .append(\"svg\")\n            .attr(\"width\", width)\n            .attr(\"height\", height)\n            .attr(\"pointer-events\", \"all\")\n            // Set up zooming, dragging.\n            .append(\"svg:g\")\n            .call(\n                d3.behavior.zoom().on(\"zoom\", function() {\n                    // Do zoom, drag.\n                    var scale = d3.event.scale;\n                    svg.attr(\n                        \"transform\",\n                        \"translate(\" +\n                            d3.event.translate +\n                            \")\" +\n                            \" scale(\" +\n                            scale +\n                            \")\"\n                    );\n\n                    // Propagate scale changes to views.\n                    if (self.scale !== scale) {\n                        // Use timeout to wait for zooming/dragging to stop before rendering more detail.\n                        if (self.zoom_drag_timeout) {\n                            clearTimeout(self.zoom_drag_timeout);\n                        }\n                        self.zoom_drag_timeout = setTimeout(function() {\n                            // Render more detail in tracks' visible elements.\n                            // FIXME: do not do this right now; it is not fully implemented--e.g. data bounds\n                            // are not updated when new data is fetched--and fetching more detailed quantitative\n                            // data is not that useful.\n                            /*\n                        _.each(self.circular_views, function(view) {\n                            view.update_scale(scale);\n                        });\n                        */\n                        }, 400);\n                    }\n                })\n            )\n            .attr(\n                \"transform\",\n                \"translate(\" + width / 2 + \",\" + height / 2 + \")\"\n            )\n            .append(\"svg:g\")\n            .attr(\"class\", \"tracks\");\n\n        // -- Render circular tracks. --\n\n        // Create a view for each track in the visualization and render.\n        this.circular_views = circular_tracks.map(function(track, index) {\n            var view = new CircsterBigWigTrackView({\n                el: svg.append(\"g\")[0],\n                track: track,\n                radius_bounds: tracks_bounds[index],\n                genome: self.genome,\n                total_gap: total_gap\n            });\n\n            view.render();\n\n            return view;\n        });\n\n        // -- Render chords tracks. --\n\n        this.chords_views = chords_tracks.map(function(track) {\n            var view = new CircsterChromInteractionsTrackView({\n                el: svg.append(\"g\")[0],\n                track: track,\n                radius_bounds: tracks_bounds[0],\n                genome: self.genome,\n                total_gap: total_gap\n            });\n\n            view.render();\n\n            return view;\n        });\n\n        // -- Render label track. --\n\n        // Track bounds are:\n        // (a) outer radius of last circular track;\n        // (b)\n        var outermost_radius = this.circular_views[\n            this.circular_views.length - 1\n        ].radius_bounds[1];\n\n        var track_bounds = [\n            outermost_radius,\n            outermost_radius + this.label_arc_height\n        ];\n\n        this.label_track_view = new CircsterChromLabelTrackView({\n            el: svg.append(\"g\")[0],\n            track: new CircsterLabelTrack(),\n            radius_bounds: track_bounds,\n            genome: self.genome,\n            total_gap: total_gap\n        });\n\n        this.label_track_view.render();\n    },\n\n    /**\n     * Render a single track on the outside of the current visualization.\n     */\n    add_track: function(new_track) {\n        var total_gap = this.model.get(\"config\").get_value(\"total_gap\");\n\n        if (new_track.get(\"track_type\") === \"DiagonalHeatmapTrack\") {\n            // Added chords track.\n            var innermost_radius_bounds = this.circular_views[0].radius_bounds;\n\n            var new_view = new CircsterChromInteractionsTrackView({\n                el: d3.select(\"g.tracks\").append(\"g\")[0],\n                track: new_track,\n                radius_bounds: innermost_radius_bounds,\n                genome: this.genome,\n                total_gap: total_gap\n            });\n\n            new_view.render();\n            this.chords_views.push(new_view);\n        } else {\n            // Added circular track.\n\n            // Recompute and update circular track bounds.\n            var new_track_bounds = this.get_tracks_bounds();\n            _.each(this.circular_views, function(track_view, i) {\n                track_view.update_radius_bounds(new_track_bounds[i]);\n            });\n\n            // Update chords tracks.\n            _.each(this.chords_views, function(track_view) {\n                track_view.update_radius_bounds(new_track_bounds[0]);\n            });\n\n            // Render new track.\n            var track_index = this.circular_views.length;\n\n            var track_view = new CircsterBigWigTrackView({\n                el: d3.select(\"g.tracks\").append(\"g\")[0],\n                track: new_track,\n                radius_bounds: new_track_bounds[track_index],\n                genome: this.genome,\n                total_gap: total_gap\n            });\n\n            track_view.render();\n            this.circular_views.push(track_view);\n\n            // Update label track.\n            /*\n            FIXME: should never have to update label track because vis always expands to fit area\n            within label track.\n            var track_bounds = new_track_bounds[ new_track_bounds.length-1 ];\n            track_bounds[1] = track_bounds[0];\n            this.label_track_view.update_radius_bounds(track_bounds);\n            */\n        }\n    },\n\n    /**\n     * Remove a track from the view.\n     */\n    remove_track: function(track, tracks, options) {\n        // -- Remove track from view. --\n        var track_view = this.circular_views[options.index];\n        this.circular_views.splice(options.index, 1);\n        track_view.$el.remove();\n\n        // Recompute and update track bounds.\n        var new_track_bounds = this.get_tracks_bounds();\n        _.each(this.circular_views, function(track_view, i) {\n            track_view.update_radius_bounds(new_track_bounds[i]);\n        });\n    },\n\n    update_track_bounds: function() {\n        // Recompute and update track bounds.\n        var new_track_bounds = this.get_tracks_bounds();\n        _.each(this.circular_views, function(track_view, i) {\n            track_view.update_radius_bounds(new_track_bounds[i]);\n        });\n\n        // Update chords tracks.\n        _.each(this.chords_views, function(track_view) {\n            track_view.update_radius_bounds(new_track_bounds[0]);\n        });\n    }\n});\n\n/**\n * Renders a track in a Circster visualization.\n */\nvar CircsterTrackView = Backbone.View.extend({\n    tagName: \"g\",\n\n    /* ----------------------- Public Methods ------------------------- */\n\n    initialize: function(options) {\n        this.bg_stroke = \"#ddd\";\n        // Fill color when loading data.\n        this.loading_bg_fill = \"#ffc\";\n        // Fill color when data has been loaded.\n        this.bg_fill = \"#ddd\";\n        this.total_gap = options.total_gap;\n        this.track = options.track;\n        this.radius_bounds = options.radius_bounds;\n        this.genome = options.genome;\n        this.chroms_layout = this._chroms_layout();\n        this.data_bounds = [];\n        this.scale = 1;\n        this.parent_elt = d3.select(this.$el[0]);\n    },\n\n    /**\n     * Get fill color from config.\n     */\n    get_fill_color: function() {\n        var color = this.track.get(\"config\").get_value(\"block_color\");\n        if (!color) {\n            color = this.track.get(\"config\").get_value(\"color\");\n        }\n        return color;\n    },\n\n    /**\n     * Render track's data by adding SVG elements to parent.\n     */\n    render: function() {\n        // -- Create track group element. --\n        var track_parent_elt = this.parent_elt;\n\n        // -- Render background arcs. --\n        var genome_arcs = this.chroms_layout;\n\n        var arc_gen = d3.svg\n            .arc()\n            .innerRadius(this.radius_bounds[0])\n            .outerRadius(this.radius_bounds[1]);\n\n        var // Attach data to group element.\n        chroms_elts = track_parent_elt\n            .selectAll(\"g\")\n            .data(genome_arcs)\n            .enter()\n            .append(\"svg:g\");\n\n        var // Draw chrom arcs/paths.\n        chroms_paths = chroms_elts\n            .append(\"path\")\n            .attr(\"d\", arc_gen)\n            .attr(\"class\", \"chrom-background\")\n            .style(\"stroke\", this.bg_stroke)\n            .style(\"fill\", this.loading_bg_fill);\n\n        // Append titles to paths.\n        chroms_paths.append(\"title\").text(function(d) {\n            return d.data.chrom;\n        });\n\n        // -- Render track data and, when track data is rendered, apply preferences and update chrom_elts fill. --\n\n        var self = this;\n\n        var data_manager = self.track.get(\"data_manager\");\n\n        var // If track has a data manager, get deferred that resolves when data is ready.\n        data_ready_deferred = data_manager\n            ? data_manager.data_is_ready()\n            : true;\n\n        // When data is ready, render track.\n        $.when(data_ready_deferred).then(function() {\n            $.when(self._render_data(track_parent_elt)).then(function() {\n                chroms_paths.style(\"fill\", self.bg_fill);\n\n                // Render labels after data is available so that data attributes are available.\n                self.render_labels();\n            });\n        });\n    },\n\n    /**\n     * Render track labels.\n     */\n    render_labels: function() {},\n\n    /**\n     * Update radius bounds.\n     */\n    update_radius_bounds: function(radius_bounds) {\n        // Update bounds.\n        this.radius_bounds = radius_bounds;\n\n        // -- Update background arcs. --\n        var new_d = d3.svg\n            .arc()\n            .innerRadius(this.radius_bounds[0])\n            .outerRadius(this.radius_bounds[1]);\n\n        this.parent_elt\n            .selectAll(\"g>path.chrom-background\")\n            .transition()\n            .duration(1000)\n            .attr(\"d\", new_d);\n\n        this._transition_chrom_data();\n\n        this._transition_labels();\n    },\n\n    /**\n     * Update view scale. This fetches more data if scale is increased.\n     */\n    update_scale: function(new_scale) {\n        // -- Update scale and return if new scale is less than old scale. --\n\n        var old_scale = this.scale;\n        this.scale = new_scale;\n        if (new_scale <= old_scale) {\n            return;\n        }\n\n        // -- Scale increased, so render visible data with more detail. --\n\n        var self = this;\n\n        var utils = new SVGUtils();\n\n        // Select all chrom data and filter to operate on those that are visible.\n        this.parent_elt\n            .selectAll(\"path.chrom-data\")\n            .filter(function(d, i) {\n                return utils.is_visible(this);\n            })\n            .each(function(d, i) {\n                // -- Now operating on a single path element representing chromosome data. --\n\n                var path_elt = d3.select(this);\n\n                var chrom = path_elt.attr(\"chrom\");\n                var chrom_region = self.genome.get_chrom_region(chrom);\n                var data_manager = self.track.get(\"data_manager\");\n                var data_deferred;\n\n                // If can't get more detailed data, return.\n                if (!data_manager.can_get_more_detailed_data(chrom_region)) {\n                    return;\n                }\n\n                // -- Get more detailed data. --\n                data_deferred = self.track\n                    .get(\"data_manager\")\n                    .get_more_detailed_data(\n                        chrom_region,\n                        \"Coverage\",\n                        0,\n                        new_scale\n                    );\n\n                // When more data is available, use new data to redraw path.\n                $.when(data_deferred).then(function(data) {\n                    // Remove current data path.\n                    path_elt.remove();\n\n                    // Update data bounds with new data.\n                    self._update_data_bounds();\n\n                    // Find chromosome arc to draw data on.\n                    var chrom_arc = _.find(self.chroms_layout, function(\n                        layout\n                    ) {\n                        return layout.data.chrom === chrom;\n                    });\n\n                    // Add new data path and apply preferences.\n                    var color = self.get_fill_color();\n                    self\n                        ._render_chrom_data(self.parent_elt, chrom_arc, data)\n                        .style(\"stroke\", color)\n                        .style(\"fill\", color);\n                });\n            });\n\n        return self;\n    },\n\n    /* ----------------------- Internal Methods ------------------------- */\n\n    /**\n     * Transitions chrom data to new values (e.g new radius or data bounds).\n     */\n    _transition_chrom_data: function() {\n        var track = this.track;\n        var chrom_arcs = this.chroms_layout;\n        var chrom_data_paths = this.parent_elt.selectAll(\"g>path.chrom-data\");\n        var num_paths = chrom_data_paths[0].length;\n\n        if (num_paths > 0) {\n            var self = this;\n            $.when(\n                track.get(\"data_manager\").get_genome_wide_data(this.genome)\n            ).then(function(genome_wide_data) {\n                // Map chrom data to path data, filtering out null values.\n                var path_data = _.reject(\n                    _.map(genome_wide_data, function(chrom_data, i) {\n                        var rval = null;\n\n                        var path_fn = self._get_path_function(\n                            chrom_arcs[i],\n                            chrom_data\n                        );\n\n                        if (path_fn) {\n                            rval = path_fn(chrom_data.data);\n                        }\n                        return rval;\n                    }),\n                    function(p_data) {\n                        return p_data === null;\n                    }\n                );\n\n                // Transition each path for data and color.\n                var color = track.get(\"config\").get_value(\"color\");\n                chrom_data_paths.each(function(path, index) {\n                    d3\n                        .select(this)\n                        .transition()\n                        .duration(1000)\n                        .style(\"stroke\", color)\n                        .style(\"fill\", color)\n                        .attr(\"d\", path_data[index]);\n                });\n            });\n        }\n    },\n\n    /**\n     * Transition labels to new values (e.g new radius or data bounds).\n     */\n    _transition_labels: function() {},\n\n    /**\n     * Update data bounds. If there are new_bounds, use them; otherwise use\n     * default data bounds.\n     */\n    _update_data_bounds: function(new_bounds) {\n        var old_bounds = this.data_bounds;\n        this.data_bounds =\n            new_bounds ||\n            this.get_data_bounds(\n                this.track.get(\"data_manager\").get_genome_wide_data(this.genome)\n            );\n        this._transition_chrom_data();\n    },\n\n    /**\n     * Render data as elements attached to svg.\n     */\n    _render_data: function(svg) {\n        var self = this;\n        var chrom_arcs = this.chroms_layout;\n        var track = this.track;\n        var rendered_deferred = $.Deferred();\n\n        // When genome-wide data is available, render data.\n        $.when(\n            track.get(\"data_manager\").get_genome_wide_data(this.genome)\n        ).then(function(genome_wide_data) {\n            // Set bounds.\n            self.data_bounds = self.get_data_bounds(genome_wide_data);\n\n            // Set min, max value in config so that they can be adjusted. Make this silent\n            // because these attributes are watched for changes and the viz is updated\n            // accordingly (set up in initialize). Because we are setting up, we don't want\n            // the watch to trigger events here.\n            track.get(\"config\").set_value(\"min_value\", self.data_bounds[0], {\n                silent: true\n            });\n            track.get(\"config\").set_value(\"max_value\", self.data_bounds[1], {\n                silent: true\n            });\n\n            // Merge chroms layout with data.\n            var layout_and_data = _.zip(chrom_arcs, genome_wide_data);\n\n            // Render each chromosome's data.\n            _.each(layout_and_data, function(chrom_info) {\n                var chrom_arc = chrom_info[0];\n                var data = chrom_info[1];\n                return self._render_chrom_data(svg, chrom_arc, data);\n            });\n\n            // Apply prefs to all track data.\n            var color = self.get_fill_color();\n            self.parent_elt\n                .selectAll(\"path.chrom-data\")\n                .style(\"stroke\", color)\n                .style(\"fill\", color);\n\n            rendered_deferred.resolve(svg);\n        });\n\n        return rendered_deferred;\n    },\n\n    /**\n     * Render a chromosome data and attach elements to svg.\n     */\n    _render_chrom_data: function(svg, chrom_arc, data) {},\n\n    /**\n     * Returns data for creating a path for the given data using chrom_arc and data bounds.\n     */\n    _get_path_function: function(chrom_arc, chrom_data) {},\n\n    /**\n     * Returns arc layouts for genome's chromosomes/contigs. Arcs are arranged in a circle\n     * separated by gaps.\n     */\n    _chroms_layout: function() {\n        // Setup chroms layout using pie.\n        var chroms_info = this.genome.get_chroms_info();\n\n        var pie_layout = d3.layout\n            .pie()\n            .value(function(d) {\n                return d.len;\n            })\n            .sort(null);\n\n        var init_arcs = pie_layout(chroms_info);\n        var gap_per_chrom = 2 * Math.PI * this.total_gap / chroms_info.length;\n\n        var chrom_arcs = _.map(init_arcs, function(arc, index) {\n            // For short chroms, endAngle === startAngle.\n            var new_endAngle = arc.endAngle - gap_per_chrom;\n            arc.endAngle =\n                new_endAngle > arc.startAngle ? new_endAngle : arc.startAngle;\n            return arc;\n        });\n\n        return chrom_arcs;\n    }\n});\n\n/**\n * Render chromosome labels.\n */\nvar CircsterChromLabelTrackView = CircsterTrackView.extend({\n    initialize: function(options) {\n        CircsterTrackView.prototype.initialize.call(this, options);\n        // Use a single arc for rendering data.\n        this.innerRadius = this.radius_bounds[0];\n        this.radius_bounds[0] = this.radius_bounds[1];\n        this.bg_stroke = \"#fff\";\n        this.bg_fill = \"#fff\";\n\n        // Minimum arc distance for labels to be applied.\n        this.min_arc_len = 0.05;\n    },\n\n    /**\n     * Render labels.\n     */\n    _render_data: function(svg) {\n        // -- Add chromosome label where it will fit; an alternative labeling mechanism\n        // would be nice for small chromosomes. --\n        var self = this;\n\n        var chrom_arcs = svg.selectAll(\"g\");\n\n        chrom_arcs.selectAll(\"path\").attr(\"id\", function(d) {\n            return \"label-\" + d.data.chrom;\n        });\n\n        chrom_arcs\n            .append(\"svg:text\")\n            .filter(function(d) {\n                return d.endAngle - d.startAngle > self.min_arc_len;\n            })\n            .attr(\"text-anchor\", \"middle\")\n            .append(\"svg:textPath\")\n            .attr(\"class\", \"chrom-label\")\n            .attr(\"xlink:href\", function(d) {\n                return \"#label-\" + d.data.chrom;\n            })\n            .attr(\"startOffset\", \"25%\")\n            .text(function(d) {\n                return d.data.chrom;\n            });\n\n        // -- Add ticks to denote chromosome length. --\n\n        /** Returns an array of tick angles and labels, given a chrom arc. */\n        var chromArcTicks = function(d) {\n            var k = (d.endAngle - d.startAngle) / d.value;\n\n            var ticks = d3.range(0, d.value, 25000000).map(function(v, i) {\n                return {\n                    radius: self.innerRadius,\n                    angle: v * k + d.startAngle,\n                    label: i === 0 ? 0 : i % 3 ? null : self.formatNum(v)\n                };\n            });\n\n            // If there are fewer that 4 ticks, label last tick so that at least one non-zero tick is labeled.\n            if (ticks.length < 4) {\n                ticks[ticks.length - 1].label = self.formatNum(\n                    Math.round(\n                        (ticks[ticks.length - 1].angle - d.startAngle) / k\n                    )\n                );\n            }\n\n            return ticks;\n        };\n\n        /** Rotate and move text as needed. */\n        var textTransform = function(d) {\n            return d.angle > Math.PI ? \"rotate(180)translate(-16)\" : null;\n        };\n\n        // Filter chroms for only those large enough for display.\n        var visibleChroms = _.filter(this.chroms_layout, function(c) {\n            return c.endAngle - c.startAngle > self.min_arc_len;\n        });\n\n        this.drawTicks(\n            this.parent_elt,\n            visibleChroms,\n            chromArcTicks,\n            textTransform\n        );\n    }\n});\n_.extend(CircsterChromLabelTrackView.prototype, UsesTicks);\n\n/**\n * View for quantitative track in Circster.\n */\nvar CircsterQuantitativeTrackView = CircsterTrackView.extend({\n    initialize: function(options) {\n        CircsterTrackView.prototype.initialize.call(this, options);\n\n        // When config settings change, update view.\n        var track_config = this.track.get(\"config\");\n        track_config\n            .get(\"min_value\")\n            .on(\"change:value\", this._update_min_max, this);\n        track_config\n            .get(\"max_value\")\n            .on(\"change:value\", this._update_min_max, this);\n        track_config\n            .get(\"color\")\n            .on(\"change:value\", this._transition_chrom_data, this);\n    },\n\n    /**\n     * Update track when min and/or max are changed.\n     */\n    _update_min_max: function() {\n        var track_config = this.track.get(\"config\");\n\n        var new_bounds = [\n            track_config.get_value(\"min_value\"),\n            track_config.get_value(\"max_value\")\n        ];\n\n        this._update_data_bounds(new_bounds);\n\n        // FIXME: this works to update tick/text bounds, but there's probably a better way to do this\n        // by updating the data itself.\n        this.parent_elt.selectAll(\".min_max\").text(function(d, i) {\n            return new_bounds[i];\n        });\n    },\n\n    /**\n     * Returns quantile for an array of numbers.\n     */\n    _quantile: function(numbers, quantile) {\n        numbers.sort(d3.ascending);\n        return d3.quantile(numbers, quantile);\n    },\n\n    /**\n     * Renders quantitative data with the form [x, value] and assumes data is equally spaced across\n     * chromosome. Attachs a dict with track and chrom name information to DOM element.\n     */\n    _render_chrom_data: function(svg, chrom_arc, chrom_data) {\n        var path_data = this._get_path_function(chrom_arc, chrom_data);\n\n        if (!path_data) {\n            return null;\n        }\n\n        // There is path data, so render as path.\n        var parent = svg.datum(chrom_data.data);\n\n        var path = parent\n            .append(\"path\")\n            .attr(\"class\", \"chrom-data\")\n            .attr(\"chrom\", chrom_arc.data.chrom)\n            .attr(\"d\", path_data);\n\n        return path;\n    },\n\n    /**\n     * Returns function for creating a path across the chrom arc.\n     */\n    _get_path_function: function(chrom_arc, chrom_data) {\n        // If no chrom data, return null.\n        if (\n            typeof chrom_data === \"string\" ||\n            !chrom_data.data ||\n            chrom_data.data.length === 0\n        ) {\n            return null;\n        }\n\n        // Radius scaler.\n        var radius = d3.scale\n            .linear()\n            .domain(this.data_bounds)\n            .range(this.radius_bounds)\n            .clamp(true);\n\n        // Scaler for placing data points across arc.\n        var angle = d3.scale\n            .linear()\n            .domain([0, chrom_data.data.length])\n            .range([chrom_arc.startAngle, chrom_arc.endAngle]);\n\n        // Use line generator to create area.\n        var line = d3.svg.line\n            .radial()\n            .interpolate(\"linear\")\n            .radius(function(d) {\n                return radius(d[1]);\n            })\n            .angle(function(d, i) {\n                return angle(i);\n            });\n\n        return d3.svg.area\n            .radial()\n            .interpolate(line.interpolate())\n            .innerRadius(radius(0))\n            .outerRadius(line.radius())\n            .angle(line.angle());\n    },\n\n    /**\n     * Render track min, max using ticks.\n     */\n    render_labels: function() {\n        var self = this;\n\n        var // Keep counter of visible chroms.\n        textTransform = function() {\n            return \"rotate(90)\";\n        };\n\n        // FIXME:\n        // (1) using min_max class below is needed for _update_min_max, which could be improved.\n        // (2) showing config on tick click should be replaced by proper track config icon.\n\n        // Draw min, max on first chrom only.\n        var ticks = this.drawTicks(\n            this.parent_elt,\n            [this.chroms_layout[0]],\n            this._data_bounds_ticks_fn(),\n            textTransform,\n            true\n        ).classed(\"min_max\", true);\n\n        // Show config when ticks are clicked on.\n        _.each(ticks, function(tick) {\n            $(tick).click(function() {\n                var view = new config.ConfigSettingCollectionView({\n                    collection: self.track.get(\"config\")\n                });\n                view.render_in_modal(\"Configure Track\");\n            });\n        });\n\n        /*\n        // Filter for visible chroms, then for every third chrom so that labels attached to only every\n        // third chrom.\n        var visibleChroms = _.filter(this.chroms_layout, function(c) { return c.endAngle - c.startAngle > 0.08; }),\n            labeledChroms = _.filter(visibleChroms, function(c, i) { return i % 3 === 0; });\n        this.drawTicks(this.parent_elt, labeledChroms, this._data_bounds_ticks_fn(), textTransform, true);\n        */\n    },\n\n    /**\n     * Transition labels to new values (e.g new radius or data bounds).\n     */\n    _transition_labels: function() {\n        // FIXME: (a) pull out function for getting labeled chroms? and (b) function used in transition below\n        // is copied from UseTicks mixin, so pull out and make generally available.\n\n        // If there are no data bounds, nothing to transition.\n        if (this.data_bounds.length === 0) {\n            return;\n        }\n\n        // Transition labels to new radius bounds.\n        var self = this;\n\n        var visibleChroms = _.filter(this.chroms_layout, function(c) {\n            return c.endAngle - c.startAngle > 0.08;\n        });\n\n        var labeledChroms = _.filter(visibleChroms, function(c, i) {\n            return i % 3 === 0;\n        });\n\n        var new_data = _.flatten(\n            _.map(labeledChroms, function(c) {\n                return self._data_bounds_ticks_fn()(c);\n            })\n        );\n\n        this.parent_elt\n            .selectAll(\"g.tick\")\n            .data(new_data)\n            .transition()\n            .attr(\"transform\", function(d) {\n                return (\n                    \"rotate(\" +\n                    (d.angle * 180 / Math.PI - 90) +\n                    \")\" +\n                    \"translate(\" +\n                    d.radius +\n                    \",0)\"\n                );\n            });\n    },\n\n    /**\n     * Get function for locating data bounds ticks.\n     */\n    _data_bounds_ticks_fn: function() {\n        // Closure vars.\n        var self = this;\n        visibleChroms = 0;\n\n        // Return function for locating ticks based on chrom arc data.\n        return function(d) {\n            // Set up data to display min, max ticks.\n            return [\n                {\n                    radius: self.radius_bounds[0],\n                    angle: d.startAngle,\n                    label: self.formatNum(self.data_bounds[0])\n                },\n                {\n                    radius: self.radius_bounds[1],\n                    angle: d.startAngle,\n                    label: self.formatNum(self.data_bounds[1])\n                }\n            ];\n        };\n    },\n\n    /**\n     * Returns an array with two values denoting the minimum and maximum\n     * values for the track.\n     */\n    get_data_bounds: function(data) {}\n});\n_.extend(CircsterQuantitativeTrackView.prototype, UsesTicks);\n\n/**\n * Bigwig track view in Circster.\n */\nvar CircsterBigWigTrackView = CircsterQuantitativeTrackView.extend({\n    get_data_bounds: function(data) {\n        // Set max across dataset by extracting all values, flattening them into a\n        // single array, and getting third quartile.\n        var values = _.flatten(\n            _.map(data, function(d) {\n                if (d) {\n                    // Each data point has the form [position, value], so return all values.\n                    return _.map(d.data, function(p) {\n                        // Null is used for a lack of data; resolve null to 0 for comparison.\n                        return parseInt(p[1], 10) || 0;\n                    });\n                } else {\n                    return 0;\n                }\n            })\n        );\n\n        // For max, use 98% quantile in attempt to avoid very large values. However, this max may be 0\n        // for sparsely populated data, so use max in that case.\n        return [_.min(values), this._quantile(values, 0.98) || _.max(values)];\n    }\n});\n\n/**\n * Chromosome interactions track view in Circster.\n */\nvar CircsterChromInteractionsTrackView = CircsterTrackView.extend({\n    render: function() {\n        var self = this;\n\n        // When data is ready, render track.\n        $.when(self.track.get(\"data_manager\").data_is_ready()).then(function() {\n            // When data has been fetched, render track.\n            $.when(\n                self.track.get(\"data_manager\").get_genome_wide_data(self.genome)\n            ).then(function(genome_wide_data) {\n                var chord_data = [];\n                var chroms_info = self.genome.get_chroms_info();\n                // Convert chromosome data into chord data.\n                _.each(genome_wide_data, function(chrom_data, index) {\n                    // Map each interaction into chord data.\n                    var cur_chrom = chroms_info[index].chrom;\n                    var chrom_chord_data = _.map(chrom_data.data, function(\n                        datum\n                    ) {\n                        // Each datum is an interaction/chord.\n                        var source_angle = self._get_region_angle(\n                            cur_chrom,\n                            datum[1]\n                        );\n\n                        var target_angle = self._get_region_angle(\n                            datum[3],\n                            datum[4]\n                        );\n\n                        return {\n                            source: {\n                                startAngle: source_angle,\n                                endAngle: source_angle + 0.01\n                            },\n                            target: {\n                                startAngle: target_angle,\n                                endAngle: target_angle + 0.01\n                            }\n                        };\n                    });\n\n                    chord_data = chord_data.concat(chrom_chord_data);\n                });\n\n                self.parent_elt\n                    .append(\"g\")\n                    .attr(\"class\", \"chord\")\n                    .selectAll(\"path\")\n                    .data(chord_data)\n                    .enter()\n                    .append(\"path\")\n                    .style(\"fill\", self.get_fill_color())\n                    .attr(\"d\", d3.svg.chord().radius(self.radius_bounds[0]))\n                    .style(\"opacity\", 1);\n            });\n        });\n    },\n\n    update_radius_bounds: function(radius_bounds) {\n        this.radius_bounds = radius_bounds;\n        this.parent_elt\n            .selectAll(\"path\")\n            .transition()\n            .attr(\"d\", d3.svg.chord().radius(this.radius_bounds[0]));\n    },\n\n    /**\n     * Returns radians for a genomic position.\n     */\n    _get_region_angle: function(chrom, position) {\n        // Find chrom angle data\n        var chrom_angle_data = _.find(this.chroms_layout, function(\n            chrom_layout\n        ) {\n            return chrom_layout.data.chrom === chrom;\n        });\n\n        // Return angle at position.\n        return (\n            chrom_angle_data.endAngle -\n            (chrom_angle_data.endAngle - chrom_angle_data.startAngle) *\n                (chrom_angle_data.data.len - position) /\n                chrom_angle_data.data.len\n        );\n    }\n});\n\n// circster app loader\nvar Circster = Backbone.View.extend({\n    initialize: function() {\n        // -- Configure visualization --\n        var genome = new visualization.Genome(galaxy_config.app.genome);\n\n        var vis = new visualization.GenomeVisualization(\n            galaxy_config.app.viz_config\n        );\n\n        // Add Circster-specific config options.\n        vis.get(\"config\").add([\n            {\n                key: \"arc_dataset_height\",\n                label: \"Arc Dataset Height\",\n                type: \"int\",\n                value: 25,\n                view: \"circster\"\n            },\n            {\n                key: \"track_gap\",\n                label: \"Gap Between Tracks\",\n                type: \"int\",\n                value: 5,\n                view: \"circster\"\n            },\n            {\n                key: \"total_gap\",\n                label: \"Gap [0-1]\",\n                type: \"float\",\n                value: 0.4,\n                view: \"circster\",\n                hidden: true\n            }\n        ]);\n\n        var viz_view = new CircsterView({\n            // view pane\n            el: $(\"#center .unified-panel-body\"),\n            genome: genome,\n            model: vis\n        });\n\n        // Render vizualization\n        viz_view.render();\n\n        // setup title\n        $(\"#center .unified-panel-header-inner\").append(\n            galaxy_config.app.viz_config.title +\n                \" \" +\n                galaxy_config.app.viz_config.dbkey\n        );\n\n        // setup menu\n        var menu = mod_icon_btn.create_icon_buttons_menu(\n            [\n                {\n                    icon_class: \"plus-button\",\n                    title: \"Add tracks\",\n                    on_click: function() {\n                        visualization.select_datasets(\n                            { dbkey: vis.get(\"dbkey\") },\n                            function(tracks) {\n                                vis.add_tracks(tracks);\n                            }\n                        );\n                    }\n                },\n                {\n                    icon_class: \"gear\",\n                    title: \"Settings\",\n                    on_click: function() {\n                        var view = new config.ConfigSettingCollectionView({\n                            collection: vis.get(\"config\")\n                        });\n                        view.render_in_modal(\"Configure Visualization\");\n                    }\n                },\n                {\n                    icon_class: \"disk--arrow\",\n                    title: \"Save\",\n                    on_click: function() {\n                        // show saving dialog box\n                        Galaxy.modal.show({\n                            title: \"Saving...\",\n                            body: \"progress\"\n                        });\n\n                        // send to server\n                        $.ajax({\n                            url: Galaxy.root + \"visualization/save\",\n                            type: \"POST\",\n                            dataType: \"json\",\n                            data: {\n                                id: vis.get(\"vis_id\"),\n                                title: vis.get(\"title\"),\n                                dbkey: vis.get(\"dbkey\"),\n                                type: \"trackster\",\n                                vis_json: JSON.stringify(vis)\n                            }\n                        })\n                            .success(function(vis_info) {\n                                Galaxy.modal.hide();\n                                vis.set(\"vis_id\", vis_info.vis_id);\n                            })\n                            .error(function() {\n                                // show dialog\n                                Galaxy.modal.show({\n                                    title: \"Could Not Save\",\n                                    body:\n                                        \"Could not save visualization. Please try again later.\",\n                                    buttons: {\n                                        Cancel: function() {\n                                            Galaxy.modal.hide();\n                                        }\n                                    }\n                                });\n                            });\n                    }\n                },\n                {\n                    icon_class: \"cross-circle\",\n                    title: \"Close\",\n                    on_click: function() {\n                        window.location = Galaxy.root + \"visualizations/list\";\n                    }\n                }\n            ],\n            { tooltip_config: { placement: \"bottom\" } }\n        );\n\n        // add menu\n        menu.$el.attr(\"style\", \"float: right\");\n        $(\"#center .unified-panel-header-inner\").append(menu.$el);\n\n        // manual tooltip config because default gravity is S and cannot be changed\n        $(\".menu-button\").tooltip({ placement: \"bottom\" });\n    }\n});\n\n// Module exports.\nexport default {\n    GalaxyApp: Circster\n};\n"]}