{"version":3,"sources":["viz/visualization.js"],"names":["define","_","data_mod","util_mod","config_mod","GridView","Tabs","Ui","toJSON","json","this","each","constructor","to_json_keys","k","val","self","get","to_json_mappers","CanvasManager","patterns","default_font","Image","src","onload","dummy_canvas","new_canvas","dummy_context","getContext","get_pattern","font","char_width_px","measureText","width","load_pattern","defaults","num_elements","extend","prototype","key","path","initialize","image","Galaxy","root","createPattern","index","indexOf","canvas","$","manager","Cache","Backbone","Model","obj_cache","key_ary","options","get_elt","attributes","length","key_str","toString","deleted_key","move_key_to_end","push","stale","value","set_elt","GenomeDataManager","most_recently_added","shift","data_type","data_mode_compatible","splice","clear","size","entries","init_data","min_region_size","filters_manager","entry","mode","data_is_ready","dataset","ajax_settings","url","call","query_type","initial_entries","dataType","ss_deferred","ready_deferred","search_features","region","Deferred","ServerStateDeferred","chrom","hda_ldda","resolution","interval","extra_params","success_fn","response","when","filters","resolve","filter_names","result","set_data","params","query","getJSON","load_data","low","high","entry_region","is_subregion","is_deferred","filter_cols","JSON","stringify","subset_entry","get_data","last_request","i","contains","DEEP_DATA_REQ","_mark_stale","cur_data","start_val","req_type","BROAD_DATA_REQ","copy","new_data_request","new_data_available","data","set","genome","trim","console","num_samples","detail_multiplier","query_low","max_high","get_genome_wide_data","chrom_info","start","end","all_data_available","chrom_data","then","concat","gw_data","max_low","message","deferred","replace","add_data","genome_wide_data","data_manager","bigwig","filter","refseq","subregion","seq_start","slice","subregion_data","dataset_placeholder","dataset_type","log","chroms_info","get_chrom_region","len","GenomeRegion","str_val","data_point","same","subset_fns","GenomeReferenceDataManager","first_chrom","a_region","data_url","first_start","second_end","first_end","second_start","Genome","name","overlap","id","dbkey","get_chroms_info","chr_name","find","chrom_len","get_chrom_len","overlap_results","DIF_CHROMS","BEFORE","GenomeRegionCollection","Collection","note","from_str","pieces","split","start_end","parseInt","BrowserBookmark","on","default_value","type","label","ConfigSettingCollection","preloaded_data","p","color","second_chrom","OVERLAP_START","CONTAINS","AFTER","CONTAINED_BY","OVERLAP_END","GenomeVisualization","drawables","models","compute_overlap","view","intersection","obj_type","content_visible","TrackBrowserRouter","model","navigate","new_loc","Visualization","CustomToJSON","Dataset","from_models_and_saved_values","prefs","d","BackboneTrackCollection","BackboneTrack","title","urlRoot","save","ajax","vis_json","bookmarks","viewport","tracks","unset","add_tracks","add","dummy","Router","route","change_location","go_to","BrowserBookmarkCollection","select_datasets","history_grid","library_grid","url_base","dict_format","embedded","tabs","View","$el","append","body","closing_events","modal","show","Add","window","requests","apply","track_defs","arguments","current","Array","arg","hide"],"mappings":"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","file":"../../scripts/viz/visualization.js","sourcesContent":["define(\n    [\n        \"libs/underscore\",\n        \"mvc/dataset/data\",\n        \"viz/trackster/util\",\n        \"utils/config\",\n        \"mvc/grid/grid-view\",\n        \"mvc/ui/ui-tabs\",\n        \"mvc/ui/ui-misc\"\n    ],\n    function(_, data_mod, util_mod, config_mod, GridView, Tabs, Ui) {\n        /**\n * Mixin for returning custom JSON representation from toJSON. Class attribute to_json_keys defines a set of attributes\n * to include in the representation; to_json_mappers defines mappers for returned objects.\n */\n        var CustomToJSON = {\n            /**\n     * Returns JSON representation of object using to_json_keys and to_json_mappers.\n     */\n            toJSON: function() {\n                var self = this,\n                    json = {};\n                _.each(self.constructor.to_json_keys, function(k) {\n                    var val = self.get(k);\n                    if (k in self.constructor.to_json_mappers) {\n                        val = self.constructor.to_json_mappers[k](val, self);\n                    }\n                    json[k] = val;\n                });\n                return json;\n            }\n        };\n\n        /**\n * Model, view, and controller objects for Galaxy visualization framework.\n *\n * Models have no references to views, instead using events to indicate state\n * changes; this is advantageous because multiple views can use the same object\n * and models can be used without views.\n */\n\n        /**\n * Use a popup grid to select datasets from histories or libraries. After datasets are selected,\n * track definitions are obtained from the server and the success_fn is called with the list of\n * definitions for selected datasets.\n */\n        var select_datasets = function(filters, success_fn) {\n            // history dataset selection tab\n            var history_grid = new GridView({\n                url_base: Galaxy.root + \"visualization/list_history_datasets\",\n                filters: filters,\n                dict_format: true,\n                embedded: true\n            });\n\n            // library dataset selection tab\n            var library_grid = new GridView({\n                url_base: Galaxy.root + \"visualization/list_library_datasets\",\n                dict_format: true,\n                embedded: true\n            });\n\n            // build tabs\n            var tabs = new Tabs.View();\n            tabs.add({\n                id: \"histories\",\n                title: \"Histories\",\n                $el: $(\"<div/>\").append(history_grid.$el)\n            });\n            tabs.add({\n                id: \"libraries\",\n                title: \"Libraries\",\n                $el: $(\"<div/>\").append(library_grid.$el)\n            });\n\n            // modal\n            Galaxy.modal.show({\n                title: \"Select datasets for new tracks\",\n                body: tabs.$el,\n                closing_events: true,\n                buttons: {\n                    Cancel: function() {\n                        Galaxy.modal.hide();\n                    },\n                    Add: function() {\n                        var requests = [];\n                        tabs\n                            .$(\n                                \"input.grid-row-select-checkbox[name=id]:checked\"\n                            )\n                            .each(function() {\n                                window.console.log($(this).val());\n                                requests[requests.length] = $.ajax({\n                                    url:\n                                        Galaxy.root +\n                                        \"api/datasets/\" +\n                                        $(this).val(),\n                                    dataType: \"json\",\n                                    data: {\n                                        data_type: \"track_config\",\n                                        hda_ldda:\n                                            tabs.current() == \"histories\"\n                                                ? \"hda\"\n                                                : \"ldda\"\n                                    }\n                                });\n                            });\n                        // To preserve order, wait until there are definitions for all tracks and then add\n                        // them sequentially.\n                        $.when.apply($, requests).then(function() {\n                            // jQuery always returns an Array for arguments, so need to look at first element\n                            // to determine whether multiple requests were made and consequently how to\n                            // map arguments to track definitions.\n                            var track_defs =\n                                arguments[0] instanceof Array\n                                    ? $.map(arguments, function(arg) {\n                                          return arg[0];\n                                      })\n                                    : [arguments[0]];\n                            success_fn(track_defs);\n                        });\n                        Galaxy.modal.hide();\n                    }\n                }\n            });\n        };\n\n        // --------- Models ---------\n\n        /**\n * Canvas manager is used to create canvases for browsers as well as providing a pattern cache\n */\n        var CanvasManager = function(default_font) {\n            this.default_font =\n                default_font !== undefined\n                    ? default_font\n                    : \"9px Monaco, Lucida Console, monospace\";\n\n            this.dummy_canvas = this.new_canvas();\n            this.dummy_context = this.dummy_canvas.getContext(\"2d\");\n            this.dummy_context.font = this.default_font;\n\n            this.char_width_px = this.dummy_context.measureText(\"A\").width;\n\n            this.patterns = {};\n\n            // FIXME: move somewhere to make this more general\n            this.load_pattern(\n                \"right_strand\",\n                \"/visualization/strand_right.png\"\n            );\n            this.load_pattern(\"left_strand\", \"/visualization/strand_left.png\");\n            this.load_pattern(\n                \"right_strand_inv\",\n                \"/visualization/strand_right_inv.png\"\n            );\n            this.load_pattern(\n                \"left_strand_inv\",\n                \"/visualization/strand_left_inv.png\"\n            );\n        };\n\n        _.extend(CanvasManager.prototype, {\n            load_pattern: function(key, path) {\n                var patterns = this.patterns,\n                    dummy_context = this.dummy_context,\n                    image = new Image();\n                image.src = Galaxy.root + \"static/images\" + path;\n                image.onload = function() {\n                    patterns[key] = dummy_context.createPattern(\n                        image,\n                        \"repeat\"\n                    );\n                };\n            },\n            get_pattern: function(key) {\n                return this.patterns[key];\n            },\n            new_canvas: function() {\n                var canvas = $(\"<canvas/>\")[0];\n                // Keep a reference back to the manager\n                canvas.manager = this;\n                return canvas;\n            }\n        });\n\n        /**\n * Generic cache that handles key/value pairs. Keys can be any object that can be\n * converted to a String and compared.\n */\n        var Cache = Backbone.Model.extend({\n            defaults: {\n                num_elements: 20,\n                // Objects in cache; indexes into cache are strings of keys.\n                obj_cache: null,\n                // key_ary contains keys for objects in cache.\n                key_ary: null\n            },\n\n            initialize: function(options) {\n                this.clear();\n            },\n\n            /**\n     * Get an element from the cache using its key.\n     */\n            get_elt: function(key) {\n                var obj_cache = this.attributes.obj_cache,\n                    key_ary = this.attributes.key_ary,\n                    key_str = key.toString(),\n                    index = _.indexOf(key_ary, function(k) {\n                        return k.toString() === key_str;\n                    });\n\n                // Update cache.\n                if (index !== -1) {\n                    // Object is in cache, so update it.\n                    if (obj_cache[key_str].stale) {\n                        // Object is stale: remove key and object.\n                        key_ary.splice(index, 1);\n                        delete obj_cache[key_str];\n                    } else {\n                        // Move key to back because it is most recently used.\n                        this.move_key_to_end(key, index);\n                    }\n                }\n\n                return obj_cache[key_str];\n            },\n\n            /**\n     * Put an element into the cache.\n     */\n            set_elt: function(key, value) {\n                var obj_cache = this.attributes.obj_cache,\n                    key_ary = this.attributes.key_ary,\n                    key_str = key.toString(),\n                    num_elements = this.attributes.num_elements;\n\n                // Update keys, objects.\n                if (!obj_cache[key_str]) {\n                    // Add object to cache.\n\n                    if (key_ary.length >= num_elements) {\n                        // Cache full, so remove first element.\n                        var deleted_key = key_ary.shift();\n                        delete obj_cache[deleted_key.toString()];\n                    }\n\n                    // Add key.\n                    key_ary.push(key);\n                }\n\n                // Add object.\n                obj_cache[key_str] = value;\n                return value;\n            },\n\n            /**\n     * Move key to end of cache. Keys are removed from the front, so moving a key to the end\n     * delays the key's removal.\n     */\n            move_key_to_end: function(key, index) {\n                this.attributes.key_ary.splice(index, 1);\n                this.attributes.key_ary.push(key);\n            },\n\n            /**\n     * Clear all elements from the cache.\n     */\n            clear: function() {\n                this.attributes.obj_cache = {};\n                this.attributes.key_ary = [];\n            },\n\n            /** Returns the number of elements in the cache. */\n            size: function() {\n                return this.attributes.key_ary.length;\n            },\n\n            /** Returns key most recently added to cache. */\n            most_recently_added: function() {\n                return this.size() === 0\n                    ? null\n                    : // Most recent key is at the end of key array.\n                      this.attributes.key_ary[\n                          this.attributes.key_ary.length - 1\n                      ];\n            }\n        });\n\n        /**\n * Data manager for genomic data. Data is connected to and queryable by genomic regions.\n */\n        var GenomeDataManager = Cache.extend({\n            defaults: _.extend({}, Cache.prototype.defaults, {\n                dataset: null,\n                genome: null,\n                init_data: null,\n                min_region_size: 200,\n                filters_manager: null,\n                data_type: \"data\",\n                data_mode_compatible: function(entry, mode) {\n                    return true;\n                },\n                can_subset: function(entry) {\n                    return false;\n                }\n            }),\n\n            /**\n     * Initialization.\n     */\n            initialize: function(options) {\n                Cache.prototype.initialize.call(this);\n\n                // Set initial entries in data manager.\n                var initial_entries = this.get(\"init_data\");\n                if (initial_entries) {\n                    this.add_data(initial_entries);\n                }\n            },\n\n            /**\n     * Add data entries to manager; each entry should be a dict with attributes region (key), data, and data_type.\n     * If necessary, manager size is increased to hold all data.\n     */\n            add_data: function(entries) {\n                // Increase size to accomodate all entries.\n                if (this.get(\"num_elements\") < entries.length) {\n                    this.set(\"num_elements\", entries.length);\n                }\n\n                // Put data into manager.\n                var self = this;\n                _.each(entries, function(entry) {\n                    self.set_data(entry.region, entry);\n                });\n            },\n\n            /**\n     * Returns deferred that resolves to true when dataset is ready (or false if dataset\n     * cannot be used).\n     */\n            data_is_ready: function() {\n                var dataset = this.get(\"dataset\"),\n                    ready_deferred = $.Deferred(),\n                    // If requesting raw data, query dataset state; if requesting (converted) data,\n                    // need to query converted datasets state.\n                    query_type =\n                        this.get(\"data_type\") === \"raw_data\"\n                            ? \"state\"\n                            : this.get(\"data_type\") === \"data\"\n                              ? \"converted_datasets_state\"\n                              : \"error\",\n                    ss_deferred = new util_mod.ServerStateDeferred({\n                        ajax_settings: {\n                            url: this.get(\"dataset\").url(),\n                            data: {\n                                hda_ldda: dataset.get(\"hda_ldda\"),\n                                data_type: query_type\n                            },\n                            dataType: \"json\"\n                        },\n                        interval: 5000,\n                        success_fn: function(response) {\n                            return response !== \"pending\";\n                        }\n                    });\n\n                $.when(ss_deferred.go()).then(function(response) {\n                    ready_deferred.resolve(\n                        response === \"ok\" || response === \"data\"\n                    );\n                });\n                return ready_deferred;\n            },\n\n            /**\n     * Perform a feature search from server; returns Deferred object that resolves when data is available.\n     */\n            search_features: function(query) {\n                var dataset = this.get(\"dataset\"),\n                    params = {\n                        query: query,\n                        hda_ldda: dataset.get(\"hda_ldda\"),\n                        data_type: \"features\"\n                    };\n                return $.getJSON(dataset.url(), params);\n            },\n\n            /**\n     * Load data from server and manages data entries. Adds a Deferred to manager\n     * for region; when data becomes available, replaces Deferred with data.\n     * Returns the Deferred that resolves when data is available.\n     */\n            load_data: function(region, mode, resolution, extra_params) {\n                // Setup data request params.\n                var dataset = this.get(\"dataset\"),\n                    params = {\n                        data_type: this.get(\"data_type\"),\n                        chrom: region.get(\"chrom\"),\n                        low: region.get(\"start\"),\n                        high: region.get(\"end\"),\n                        mode: mode,\n                        resolution: resolution,\n                        hda_ldda: dataset.get(\"hda_ldda\")\n                    };\n\n                $.extend(params, extra_params);\n\n                // Add track filters to params.\n                var filters_manager = this.get(\"filters_manager\");\n                if (filters_manager) {\n                    var filter_names = [];\n                    var filters = filters_manager.filters;\n                    for (var i = 0; i < filters.length; i++) {\n                        filter_names.push(filters[i].name);\n                    }\n                    params.filter_cols = JSON.stringify(filter_names);\n                }\n\n                // Do request.\n                var manager = this,\n                    entry = $.getJSON(dataset.url(), params, function(result) {\n                        // Add region to the result.\n                        result.region = region;\n                        manager.set_data(region, result);\n                    });\n\n                this.set_data(region, entry);\n                return entry;\n            },\n\n            /**\n     * Get data from dataset.\n     */\n            get_data: function(region, mode, resolution, extra_params) {\n                // Look for entry and return if it's a deferred or if data available is compatible with mode.\n                var entry = this.get_elt(region);\n                if (\n                    entry &&\n                    (util_mod.is_deferred(entry) ||\n                        this.get(\"data_mode_compatible\")(entry, mode))\n                ) {\n                    return entry;\n                }\n\n                //\n                // Look in cache for data that can be used.\n                // TODO: this logic could be improved if the visualization knew whether\n                // the data was \"index\" or \"data.\"\n                //\n                var key_ary = this.get(\"key_ary\"),\n                    obj_cache = this.get(\"obj_cache\"),\n                    entry_region,\n                    is_subregion;\n                for (var i = 0; i < key_ary.length; i++) {\n                    entry_region = key_ary[i];\n\n                    if (entry_region.contains(region)) {\n                        is_subregion = true;\n\n                        // This entry has data in the requested range. Return if data\n                        // is compatible and can be subsetted.\n                        entry = obj_cache[entry_region.toString()];\n                        if (\n                            util_mod.is_deferred(entry) ||\n                            (this.get(\"data_mode_compatible\")(entry, mode) &&\n                                this.get(\"can_subset\")(entry))\n                        ) {\n                            this.move_key_to_end(entry_region, i);\n\n                            // If there's data, subset it.\n                            if (!util_mod.is_deferred(entry)) {\n                                var subset_entry = this.subset_entry(\n                                    entry,\n                                    region\n                                );\n                                this.set_data(region, subset_entry);\n                                entry = subset_entry;\n                            }\n\n                            return entry;\n                        }\n                    }\n                }\n\n                // FIXME: There _may_ be instances where region is a subregion of another entry but cannot be\n                // subsetted. For these cases, do not increase length because region will never be found (and\n                // an infinite loop will occur.)\n                // If needed, extend region to make it minimum size.\n                if (\n                    !is_subregion &&\n                    region.length() < this.attributes.min_region_size\n                ) {\n                    // IDEA: alternative heuristic is to find adjacent cache entry to region and use that to extend.\n                    // This would prevent bad extensions when zooming in/out while still preserving the behavior\n                    // below.\n\n                    // Use copy of region to avoid changing actual region.\n                    region = region.copy();\n\n                    // Use heuristic to extend region: extend relative to last data request.\n                    var last_request = this.most_recently_added();\n                    if (\n                        !last_request ||\n                        region.get(\"start\") > last_request.get(\"start\")\n                    ) {\n                        // This request is after the last request, so extend right.\n                        region.set(\n                            \"end\",\n                            region.get(\"start\") +\n                                this.attributes.min_region_size\n                        );\n                    } else {\n                        // This request is after the last request, so extend left.\n                        region.set(\n                            \"start\",\n                            region.get(\"end\") - this.attributes.min_region_size\n                        );\n                    }\n\n                    // Trim region to avoid invalid coordinates.\n                    region.set(\"genome\", this.attributes.genome);\n                    region.trim();\n                }\n\n                return this.load_data(region, mode, resolution, extra_params);\n            },\n\n            /**\n     * Alias for set_elt for readbility.\n     */\n            set_data: function(region, entry) {\n                this.set_elt(region, entry);\n            },\n\n            /** \"Deep\" data request; used as a parameter for DataManager.get_more_data() */\n            DEEP_DATA_REQ: \"deep\",\n\n            /** \"Broad\" data request; used as a parameter for DataManager.get_more_data() */\n            BROAD_DATA_REQ: \"breadth\",\n\n            /**\n     * Gets more data for a region using either a depth-first or a breadth-first approach.\n     */\n            get_more_data: function(\n                region,\n                mode,\n                resolution,\n                extra_params,\n                req_type\n            ) {\n                var cur_data = this._mark_stale(region);\n                if (\n                    !(\n                        cur_data &&\n                        this.get(\"data_mode_compatible\")(cur_data, mode)\n                    )\n                ) {\n                    console.log(\n                        \"ERROR: problem with getting more data: current data is not compatible\"\n                    );\n                    return;\n                }\n\n                //\n                // Set parameters based on request type.\n                //\n                var query_low = region.get(\"start\");\n                if (req_type === this.DEEP_DATA_REQ) {\n                    // Use same interval but set start_val to skip data that's already in cur_data.\n                    $.extend(extra_params, {\n                        start_val: cur_data.data.length + 1\n                    });\n                } else if (req_type === this.BROAD_DATA_REQ) {\n                    // To get past an area of extreme feature depth, set query low to be after either\n                    // (a) the maximum high or HACK/FIXME (b) the end of the last feature returned.\n                    query_low =\n                        (cur_data.max_high\n                            ? cur_data.max_high\n                            : cur_data.data[cur_data.data.length - 1][2]) + 1;\n                }\n                var query_region = region.copy().set(\"start\", query_low);\n\n                //\n                // Get additional data, append to current data, and set new data. Use a custom deferred object\n                // to signal when new data is available.\n                //\n                var data_manager = this,\n                    new_data_request = this.load_data(\n                        query_region,\n                        mode,\n                        resolution,\n                        extra_params\n                    ),\n                    new_data_available = $.Deferred();\n                // load_data sets cache to new_data_request, but use custom deferred object so that signal and data\n                // is all data, not just new data.\n                this.set_data(region, new_data_available);\n                $.when(new_data_request).then(function(result) {\n                    // Update data and message.\n                    if (result.data) {\n                        result.data = cur_data.data.concat(result.data);\n                        if (result.max_low) {\n                            result.max_low = cur_data.max_low;\n                        }\n                        if (result.message) {\n                            // HACK: replace number in message with current data length. Works but is ugly.\n                            result.message = result.message.replace(\n                                /[0-9]+/,\n                                result.data.length\n                            );\n                        }\n                    }\n                    data_manager.set_data(region, result);\n                    new_data_available.resolve(result);\n                });\n                return new_data_available;\n            },\n\n            /**\n     * Returns true if more detailed data can be obtained for entry.\n     */\n            can_get_more_detailed_data: function(region) {\n                var cur_data = this.get_elt(region);\n\n                // Can only get more detailed data for bigwig data that has less than 8000 data points.\n                // Summary tree returns *way* too much data, and 8000 data points ~ 500KB.\n                return (\n                    cur_data.dataset_type === \"bigwig\" &&\n                    cur_data.data.length < 8000\n                );\n            },\n\n            /**\n     * Returns more detailed data for an entry.\n     */\n            get_more_detailed_data: function(\n                region,\n                mode,\n                resolution,\n                detail_multiplier,\n                extra_params\n            ) {\n                // Mark current entry as stale.\n                var cur_data = this._mark_stale(region);\n                if (!cur_data) {\n                    console.log(\n                        \"ERROR getting more detailed data: no current data\"\n                    );\n                    return;\n                }\n\n                if (!extra_params) {\n                    extra_params = {};\n                }\n\n                // Use additional parameters to get more detailed data.\n                if (cur_data.dataset_type === \"bigwig\") {\n                    // FIXME: constant should go somewhere.\n                    extra_params.num_samples = 1000 * detail_multiplier;\n                }\n\n                return this.load_data(region, mode, resolution, extra_params);\n            },\n\n            /**\n     * Marks cache data as stale.\n     */\n            _mark_stale: function(region) {\n                var entry = this.get_elt(region);\n                if (!entry) {\n                    console.log(\n                        \"ERROR: no data to mark as stale: \",\n                        this.get(\"dataset\"),\n                        region.toString()\n                    );\n                }\n                entry.stale = true;\n                return entry;\n            },\n\n            /**\n     * Returns an array of data with each entry representing one chromosome/contig\n     * of data or, if data is not available, returns a Deferred that resolves to the\n     * data when it becomes available.\n     */\n            get_genome_wide_data: function(genome) {\n                // -- Get all data. --\n\n                var self = this,\n                    all_data_available = true,\n                    //  Map chromosome info into genome data.\n                    gw_data = _.map(\n                        genome.get(\"chroms_info\").chrom_info,\n                        function(chrom_info) {\n                            var chrom_data = self.get_elt(\n                                new GenomeRegion({\n                                    chrom: chrom_info.chrom,\n                                    start: 0,\n                                    end: chrom_info.len\n                                })\n                            );\n\n                            // Set flag if data is not available.\n                            if (!chrom_data) {\n                                all_data_available = false;\n                            }\n\n                            return chrom_data;\n                        }\n                    );\n\n                // -- If all data is available, return it. --\n                if (all_data_available) {\n                    return gw_data;\n                }\n\n                // -- All data is not available, so load from server. --\n\n                var deferred = $.Deferred();\n                $.getJSON(\n                    this.get(\"dataset\").url(),\n                    { data_type: \"genome_data\" },\n                    function(genome_wide_data) {\n                        self.add_data(genome_wide_data.data);\n                        deferred.resolve(genome_wide_data.data);\n                    }\n                );\n\n                return deferred;\n            },\n\n            /**\n     * Returns entry with only data in the subregion.\n     */\n            subset_entry: function(entry, subregion) {\n                // Dictionary from entry type to function for subsetting data.\n                var subset_fns = {\n                    bigwig: function(data, subregion) {\n                        return _.filter(data, function(data_point) {\n                            return (\n                                data_point[0] >= subregion.get(\"start\") &&\n                                data_point[0] <= subregion.get(\"end\")\n                            );\n                        });\n                    },\n                    refseq: function(data, subregion) {\n                        var seq_start =\n                            subregion.get(\"start\") - entry.region.get(\"start\");\n                        return entry.data.slice(\n                            seq_start,\n                            seq_start + subregion.length()\n                        );\n                    }\n                };\n\n                // Subset entry if there is a function for subsetting and regions are not the same.\n                var subregion_data = entry.data;\n                if (\n                    !entry.region.same(subregion) &&\n                    entry.dataset_type in subset_fns\n                ) {\n                    subregion_data = subset_fns[entry.dataset_type](\n                        entry.data,\n                        subregion\n                    );\n                }\n\n                // Return entry with subregion's data.\n                return {\n                    region: subregion,\n                    data: subregion_data,\n                    dataset_type: entry.dataset_type\n                };\n            }\n        });\n\n        var GenomeReferenceDataManager = GenomeDataManager.extend({\n            initialize: function(options) {\n                // Use generic object in place of dataset and set urlRoot to fetch data.\n                var dataset_placeholder = new Backbone.Model();\n                dataset_placeholder.urlRoot = options.data_url;\n                this.set(\"dataset\", dataset_placeholder);\n            },\n\n            load_data: function(region, mode, resolution, extra_params) {\n                // Fetch data if region is not too large.\n                return region.length() <= 100000\n                    ? GenomeDataManager.prototype.load_data.call(\n                          this,\n                          region,\n                          mode,\n                          resolution,\n                          extra_params\n                      )\n                    : { data: null, region: region };\n            }\n        });\n\n        /**\n * A genome build.\n */\n        var Genome = Backbone.Model.extend({\n            defaults: {\n                name: null,\n                key: null,\n                chroms_info: null\n            },\n\n            initialize: function(options) {\n                this.id = options.dbkey;\n            },\n\n            /**\n     * Shorthand for getting to chromosome information.\n     */\n            get_chroms_info: function() {\n                return this.attributes.chroms_info.chrom_info;\n            },\n\n            /**\n     * Returns a GenomeRegion object denoting a complete chromosome.\n     */\n            get_chrom_region: function(chr_name) {\n                // FIXME: use findWhere in underscore 1.4\n                var chrom_info = _.find(this.get_chroms_info(), function(\n                    chrom_info\n                ) {\n                    return chrom_info.chrom === chr_name;\n                });\n                return new GenomeRegion({\n                    chrom: chrom_info.chrom,\n                    end: chrom_info.len\n                });\n            },\n\n            /** Returns the length of a chromosome. */\n            get_chrom_len: function(chr_name) {\n                // FIXME: use findWhere in underscore 1.4\n                return _.find(this.get_chroms_info(), function(chrom_info) {\n                    return chrom_info.chrom === chr_name;\n                }).len;\n            }\n        });\n\n        /**\n * A genomic region.\n */\n        var GenomeRegion = Backbone.Model.extend(\n            {\n                defaults: {\n                    chrom: null,\n                    start: 0,\n                    end: 0,\n                    str_val: null,\n                    genome: null\n                },\n\n                /**\n     * Returns true if this region is the same as a given region.\n     * It does not test the genome right now.\n     */\n                same: function(region) {\n                    return (\n                        this.attributes.chrom === region.get(\"chrom\") &&\n                        this.attributes.start === region.get(\"start\") &&\n                        this.attributes.end === region.get(\"end\")\n                    );\n                },\n\n                /**\n     * If from_str specified, use it to initialize attributes.\n     */\n                initialize: function(options) {\n                    if (options.from_str) {\n                        var pieces = options.from_str.split(\":\"),\n                            chrom = pieces[0],\n                            start_end = pieces[1].split(\"-\");\n                        this.set({\n                            chrom: chrom,\n                            start: parseInt(start_end[0], 10),\n                            end: parseInt(start_end[1], 10)\n                        });\n                    }\n\n                    // Keep a copy of region's string value for fast lookup.\n                    this.attributes.str_val =\n                        this.get(\"chrom\") +\n                        \":\" +\n                        this.get(\"start\") +\n                        \"-\" +\n                        this.get(\"end\");\n\n                    // Set str_val on attribute change.\n                    this.on(\n                        \"change\",\n                        function() {\n                            this.attributes.str_val =\n                                this.get(\"chrom\") +\n                                \":\" +\n                                this.get(\"start\") +\n                                \"-\" +\n                                this.get(\"end\");\n                        },\n                        this\n                    );\n                },\n\n                copy: function() {\n                    return new GenomeRegion({\n                        chrom: this.get(\"chrom\"),\n                        start: this.get(\"start\"),\n                        end: this.get(\"end\")\n                    });\n                },\n\n                length: function() {\n                    return this.get(\"end\") - this.get(\"start\");\n                },\n\n                /** Returns region in canonical form chrom:start-end */\n                toString: function() {\n                    return this.attributes.str_val;\n                },\n\n                toJSON: function() {\n                    return {\n                        chrom: this.get(\"chrom\"),\n                        start: this.get(\"start\"),\n                        end: this.get(\"end\")\n                    };\n                },\n\n                /**\n     * Compute the type of overlap between this region and another region. The overlap is computed relative to the given/second region;\n     * hence, OVERLAP_START indicates that the first region overlaps the start (but not the end) of the second region.\n     */\n                compute_overlap: function(a_region) {\n                    var first_chrom = this.get(\"chrom\"),\n                        second_chrom = a_region.get(\"chrom\"),\n                        first_start = this.get(\"start\"),\n                        second_start = a_region.get(\"start\"),\n                        first_end = this.get(\"end\"),\n                        second_end = a_region.get(\"end\"),\n                        overlap;\n\n                    // Compare chroms.\n                    if (\n                        first_chrom &&\n                        second_chrom &&\n                        first_chrom !== second_chrom\n                    ) {\n                        return GenomeRegion.overlap_results.DIF_CHROMS;\n                    }\n\n                    // Compare regions.\n                    if (first_start < second_start) {\n                        if (first_end < second_start) {\n                            overlap = GenomeRegion.overlap_results.BEFORE;\n                        } else if (first_end < second_end) {\n                            overlap =\n                                GenomeRegion.overlap_results.OVERLAP_START;\n                        } else {\n                            // first_end >= second_end\n                            overlap = GenomeRegion.overlap_results.CONTAINS;\n                        }\n                    } else if (first_start > second_start) {\n                        if (first_start > second_end) {\n                            overlap = GenomeRegion.overlap_results.AFTER;\n                        } else if (first_end <= second_end) {\n                            overlap = GenomeRegion.overlap_results.CONTAINED_BY;\n                        } else {\n                            overlap = GenomeRegion.overlap_results.OVERLAP_END;\n                        }\n                    } else {\n                        // first_start === second_start\n                        overlap =\n                            first_end >= second_end\n                                ? GenomeRegion.overlap_results.CONTAINS\n                                : GenomeRegion.overlap_results.CONTAINED_BY;\n                    }\n\n                    return overlap;\n                },\n\n                /**\n     * Trim a region to match genome's constraints.\n     */\n                trim: function(genome) {\n                    // Assume that all chromosome/contigs start at 0.\n                    if (this.attributes.start < 0) {\n                        this.attributes.start = 0;\n                    }\n\n                    // Only try to trim the end if genome is set.\n                    if (this.attributes.genome) {\n                        var chrom_len = this.attributes.genome.get_chrom_len(\n                            this.attributes.chrom\n                        );\n                        if (this.attributes.end > chrom_len) {\n                            this.attributes.end = chrom_len - 1;\n                        }\n                    }\n\n                    return this;\n                },\n\n                /**\n     * Returns true if this region contains a given region.\n     */\n                contains: function(a_region) {\n                    return (\n                        this.compute_overlap(a_region) ===\n                        GenomeRegion.overlap_results.CONTAINS\n                    );\n                },\n\n                /**\n     * Returns true if regions overlap.\n     */\n                overlaps: function(a_region) {\n                    return (\n                        _.intersection(\n                            [this.compute_overlap(a_region)],\n                            [\n                                GenomeRegion.overlap_results.DIF_CHROMS,\n                                GenomeRegion.overlap_results.BEFORE,\n                                GenomeRegion.overlap_results.AFTER\n                            ]\n                        ).length === 0\n                    );\n                }\n            },\n            {\n                overlap_results: {\n                    DIF_CHROMS: 1000,\n                    BEFORE: 1001,\n                    CONTAINS: 1002,\n                    OVERLAP_START: 1003,\n                    OVERLAP_END: 1004,\n                    CONTAINED_BY: 1005,\n                    AFTER: 1006\n                }\n            }\n        );\n\n        var GenomeRegionCollection = Backbone.Collection.extend({\n            model: GenomeRegion\n        });\n\n        /**\n * A genome browser bookmark.\n */\n        var BrowserBookmark = Backbone.Model.extend({\n            defaults: {\n                region: null,\n                note: \"\"\n            },\n\n            initialize: function(options) {\n                this.set(\"region\", new GenomeRegion(options.region));\n            }\n        });\n\n        /**\n * Bookmarks collection.\n */\n        var BrowserBookmarkCollection = Backbone.Collection.extend({\n            model: BrowserBookmark\n        });\n\n        /**\n * A track of data in a genome visualization.\n */\n        // TODO: rename to Track and merge with Trackster's Track object.\n        var BackboneTrack = Backbone.Model.extend(CustomToJSON).extend(\n            {\n                defaults: {\n                    mode: \"Auto\"\n                },\n\n                initialize: function(options) {\n                    this.set(\"dataset\", new data_mod.Dataset(options.dataset));\n\n                    // -- Set up config settings. --\n                    var models = [\n                        {\n                            key: \"name\",\n                            default_value: this.get(\"dataset\").get(\"name\")\n                        },\n                        { key: \"color\" },\n                        {\n                            key: \"min_value\",\n                            label: \"Min Value\",\n                            type: \"float\",\n                            default_value: 0\n                        },\n                        {\n                            key: \"max_value\",\n                            label: \"Max Value\",\n                            type: \"float\",\n                            default_value: 1\n                        }\n                    ];\n\n                    this.set(\n                        \"config\",\n                        config_mod.ConfigSettingCollection.from_models_and_saved_values(\n                            models,\n                            options.prefs\n                        )\n                    );\n\n                    // -- Set up data manager. --\n                    var preloaded_data = this.get(\"preloaded_data\");\n                    if (preloaded_data) {\n                        preloaded_data = preloaded_data.data;\n                    } else {\n                        preloaded_data = [];\n                    }\n                    this.set(\n                        \"data_manager\",\n                        new GenomeDataManager({\n                            dataset: this.get(\"dataset\"),\n                            init_data: preloaded_data\n                        })\n                    );\n                }\n            },\n            {\n                // This definition matches that produced by to_dict() methods in tracks.js\n                to_json_keys: [\n                    \"track_type\",\n                    \"dataset\",\n                    \"prefs\",\n                    \"mode\",\n                    \"filters\",\n                    \"tool_state\"\n                ],\n                to_json_mappers: {\n                    prefs: function(p, self) {\n                        if (_.size(p) === 0) {\n                            p = {\n                                name: self\n                                    .get(\"config\")\n                                    .get(\"name\")\n                                    .get(\"value\"),\n                                color: self\n                                    .get(\"config\")\n                                    .get(\"color\")\n                                    .get(\"value\")\n                            };\n                        }\n                        return p;\n                    },\n                    dataset: function(d) {\n                        return {\n                            id: d.id,\n                            hda_ldda: d.get(\"hda_ldda\")\n                        };\n                    }\n                }\n            }\n        );\n\n        var BackboneTrackCollection = Backbone.Collection.extend({\n            model: BackboneTrack\n        });\n\n        /**\n * A visualization.\n */\n        var Visualization = Backbone.Model.extend({\n            defaults: {\n                title: \"\",\n                type: \"\"\n            },\n\n            urlRoot: Galaxy.root + \"api/visualizations\",\n\n            /**\n     * POSTs visualization's JSON to its URL using the parameter 'vis_json'\n     * Note: This is necessary because (a) Galaxy requires keyword args and\n     * (b) Galaxy does not handle PUT now.\n     */\n            save: function() {\n                return $.ajax({\n                    url: this.url(),\n                    type: \"POST\",\n                    dataType: \"json\",\n                    data: {\n                        vis_json: JSON.stringify(this)\n                    }\n                });\n            }\n        });\n\n        /**\n * A visualization of genome data.\n */\n        var GenomeVisualization = Visualization.extend(CustomToJSON).extend(\n            {\n                defaults: _.extend({}, Visualization.prototype.defaults, {\n                    dbkey: \"\",\n                    drawables: null,\n                    bookmarks: null,\n                    viewport: null\n                }),\n\n                initialize: function(options) {\n                    // Replace drawables with tracks.\n                    this.set(\n                        \"drawables\",\n                        new BackboneTrackCollection(options.tracks)\n                    );\n\n                    var models = [];\n                    this.set(\n                        \"config\",\n                        config_mod.ConfigSettingCollection.from_models_and_saved_values(\n                            models,\n                            options.prefs\n                        )\n                    );\n\n                    // Clear track and data definitions to avoid storing large objects.\n                    this.unset(\"tracks\");\n                    this.get(\"drawables\").each(function(d) {\n                        d.unset(\"preloaded_data\");\n                    });\n                },\n\n                /**\n     * Add a track or array of tracks to the visualization.\n     */\n                add_tracks: function(tracks) {\n                    this.get(\"drawables\").add(tracks);\n                }\n            },\n            {\n                // This definition matches that produced by to_dict() methods in tracks.js\n                to_json_keys: [\"view\", \"viewport\", \"bookmarks\"],\n\n                to_json_mappers: {\n                    view: function(dummy, self) {\n                        return {\n                            obj_type: \"View\",\n                            prefs: {\n                                name: self.get(\"title\"),\n                                content_visible: true\n                            },\n                            drawables: self.get(\"drawables\")\n                        };\n                    }\n                }\n            }\n        );\n\n        /**\n * -- Routers --\n */\n\n        /**\n * Router for track browser.\n */\n        var TrackBrowserRouter = Backbone.Router.extend({\n            initialize: function(options) {\n                this.view = options.view;\n\n                // Can't put regular expression in routes dictionary.\n                // NOTE: parentheses are used to denote parameters returned to callback.\n                this.route(/([\\w]+)$/, \"change_location\");\n                this.route(/([\\w\\+]+\\:[\\d,]+-[\\d,]+)$/, \"change_location\");\n\n                // Handle navigate events from view.\n                var self = this;\n                self.view.on(\"navigate\", function(new_loc) {\n                    self.navigate(new_loc);\n                });\n            },\n\n            change_location: function(new_loc) {\n                this.view.go_to(new_loc);\n            }\n        });\n\n        return {\n            BackboneTrack: BackboneTrack,\n            BrowserBookmark: BrowserBookmark,\n            BrowserBookmarkCollection: BrowserBookmarkCollection,\n            Cache: Cache,\n            CanvasManager: CanvasManager,\n            Genome: Genome,\n            GenomeDataManager: GenomeDataManager,\n            GenomeRegion: GenomeRegion,\n            GenomeRegionCollection: GenomeRegionCollection,\n            GenomeVisualization: GenomeVisualization,\n            GenomeReferenceDataManager: GenomeReferenceDataManager,\n            TrackBrowserRouter: TrackBrowserRouter,\n            Visualization: Visualization,\n            select_datasets: select_datasets\n        };\n    }\n);\n"]}