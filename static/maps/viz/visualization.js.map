{"version":3,"sources":["viz/visualization.js"],"names":["CustomToJSON","toJSON","self","this","json","_underscore2","default","each","constructor","to_json_keys","k","val","get","to_json_mappers","CanvasManager","default_font","Galaxy","undefined","dummy_canvas","new_canvas","dummy_context","getContext","font","char_width_px","measureText","width","load_pattern","extend","key","path","patterns","image","Image","src","root","onload","createPattern","get_pattern","canvas","$","Cache","Backbone","Model","defaults","num_elements","obj_cache","initialize","options","get_elt","attributes","key_ary","key_str","toString","index","indexOf","stale","splice","set_elt","shift","push","value","move_key_to_end","clear","length","most_recently_added","size","GenomeDataManager","prototype","dataset","genome","init_data","entry","mode","min_region_size","data_type","data_mode_compatible","call","add_data","initial_entries","entries","set","set_data","region","data_is_ready","ready_deferred","Deferred","query_type","ss_deferred","_util2","ServerStateDeferred","ajax_settings","url","data","hda_ldda","dataType","interval","success_fn","response","when","then","resolve","search_features","query","params","getJSON","load_data","extra_params","chrom","low","high","resolution","filters_manager","filter_names","filters","i","filter_cols","JSON","stringify","manager","result","get_data","is_deferred","is_subregion","entry_region","contains","subset_entry","last_request","copy","DEEP_DATA_REQ","trim","cur_data","_mark_stale","BROAD_DATA_REQ","get_more_data","req_type","query_region","query_low","new_data_available","new_data_request","concat","max_low","max_high","data_manager","can_get_more_detailed_data","dataset_type","get_more_detailed_data","message","replace","console","log","get_genome_wide_data","detail_multiplier","end","all_data_available","num_samples","gw_data","deferred","refseq","map","slice","chrom_info","seq_start","chrom_data","GenomeRegion","subregion_data","same","subset_fns","Genome","genome_wide_data","subregion","bigwig","filter","data_point","get_chrom_region","len","str_val","urlRoot","data_url","dataset_placeholder","start","chroms_info","id","dbkey","get_chroms_info","chr_name","find","get_chrom_len","compute_overlap","first_start","second_start","first_end","second_end","overlap","overlap_results","pieces","start_end","split","parseInt","on","chrom_len","CONTAINS","OVERLAP_START","OVERLAP_END","CONTAINED_BY","AFTER","a_region","first_chrom","second_chrom","BrowserBookmark","note","DIF_CHROMS","BrowserBookmarkCollection","BackboneTrack","default_value","preloaded_data","p","name","color","intersection","BEFORE","BackboneTrackCollection","Visualization","title","type","GenomeRegionCollection","Collection","save","vis_json","viewport","model","ConfigSettingCollection","unset","_data2","Dataset","models","add","tracks","label","dummy","prefs","content_visible","_config2","from_models_and_saved_values","TrackBrowserRouter","route","change_location","GenomeVisualization","GenomeReferenceDataManager","select_datasets","d","ajax","drawables","bookmarks","add_tracks","view","obj_type","Router","new_loc","navigate","go_to","history_grid","_gridView2","url_base","dict_format","embedded","library_grid","tabs","_uiTabs2","View","$el","append","modal","buttons","Cancel","hide","requests","window","current","Add","apply","Array","arg","track_defs"],"mappings":"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","file":"../../scripts/viz/visualization.js","sourcesContent":["import _ from \"libs/underscore\";\nimport data_mod from \"mvc/dataset/data\";\nimport util_mod from \"viz/trackster/util\";\nimport config_mod from \"utils/config\";\nimport GridView from \"mvc/grid/grid-view\";\nimport Tabs from \"mvc/ui/ui-tabs\";\nimport Ui from \"mvc/ui/ui-misc\";\n/**\n * Mixin for returning custom JSON representation from toJSON. Class attribute to_json_keys defines a set of attributes\n * to include in the representation; to_json_mappers defines mappers for returned objects.\n */\nvar CustomToJSON = {\n    /**\n     * Returns JSON representation of object using to_json_keys and to_json_mappers.\n     */\n    toJSON: function() {\n        var self = this,\n            json = {};\n        _.each(self.constructor.to_json_keys, function(k) {\n            var val = self.get(k);\n            if (k in self.constructor.to_json_mappers) {\n                val = self.constructor.to_json_mappers[k](val, self);\n            }\n            json[k] = val;\n        });\n        return json;\n    }\n};\n\n/**\n * Model, view, and controller objects for Galaxy visualization framework.\n *\n * Models have no references to views, instead using events to indicate state\n * changes; this is advantageous because multiple views can use the same object\n * and models can be used without views.\n */\n\n/**\n * Use a popup grid to select datasets from histories or libraries. After datasets are selected,\n * track definitions are obtained from the server and the success_fn is called with the list of\n * definitions for selected datasets.\n */\nvar select_datasets = function(filters, success_fn) {\n    // history dataset selection tab\n    var history_grid = new GridView({\n        url_base: Galaxy.root + \"visualization/list_history_datasets\",\n        filters: filters,\n        dict_format: true,\n        embedded: true\n    });\n\n    // library dataset selection tab\n    var library_grid = new GridView({\n        url_base: Galaxy.root + \"visualization/list_library_datasets\",\n        dict_format: true,\n        embedded: true\n    });\n\n    // build tabs\n    var tabs = new Tabs.View();\n    tabs.add({\n        id: \"histories\",\n        title: \"Histories\",\n        $el: $(\"<div/>\").append(history_grid.$el)\n    });\n    tabs.add({\n        id: \"libraries\",\n        title: \"Libraries\",\n        $el: $(\"<div/>\").append(library_grid.$el)\n    });\n\n    // modal\n    Galaxy.modal.show({\n        title: \"Select datasets for new tracks\",\n        body: tabs.$el,\n        closing_events: true,\n        buttons: {\n            Cancel: function() {\n                Galaxy.modal.hide();\n            },\n            Add: function() {\n                var requests = [];\n                tabs\n                    .$(\"input.grid-row-select-checkbox[name=id]:checked\")\n                    .each(function() {\n                        window.console.log($(this).val());\n                        requests[requests.length] = $.ajax({\n                            url: Galaxy.root + \"api/datasets/\" + $(this).val(),\n                            dataType: \"json\",\n                            data: {\n                                data_type: \"track_config\",\n                                hda_ldda:\n                                    tabs.current() == \"histories\"\n                                        ? \"hda\"\n                                        : \"ldda\"\n                            }\n                        });\n                    });\n                // To preserve order, wait until there are definitions for all tracks and then add\n                // them sequentially.\n                $.when.apply($, requests).then(function() {\n                    // jQuery always returns an Array for arguments, so need to look at first element\n                    // to determine whether multiple requests were made and consequently how to\n                    // map arguments to track definitions.\n                    var track_defs =\n                        arguments[0] instanceof Array\n                            ? $.map(arguments, function(arg) {\n                                  return arg[0];\n                              })\n                            : [arguments[0]];\n                    success_fn(track_defs);\n                });\n                Galaxy.modal.hide();\n            }\n        }\n    });\n};\n\n// --------- Models ---------\n\n/**\n * Canvas manager is used to create canvases for browsers as well as providing a pattern cache\n */\nvar CanvasManager = function(default_font) {\n    this.default_font =\n        default_font !== undefined\n            ? default_font\n            : \"9px Monaco, Lucida Console, monospace\";\n\n    this.dummy_canvas = this.new_canvas();\n    this.dummy_context = this.dummy_canvas.getContext(\"2d\");\n    this.dummy_context.font = this.default_font;\n\n    this.char_width_px = this.dummy_context.measureText(\"A\").width;\n\n    this.patterns = {};\n\n    // FIXME: move somewhere to make this more general\n    this.load_pattern(\"right_strand\", \"/visualization/strand_right.png\");\n    this.load_pattern(\"left_strand\", \"/visualization/strand_left.png\");\n    this.load_pattern(\n        \"right_strand_inv\",\n        \"/visualization/strand_right_inv.png\"\n    );\n    this.load_pattern(\"left_strand_inv\", \"/visualization/strand_left_inv.png\");\n};\n\n_.extend(CanvasManager.prototype, {\n    load_pattern: function(key, path) {\n        var patterns = this.patterns,\n            dummy_context = this.dummy_context,\n            image = new Image();\n        image.src = Galaxy.root + \"static/images\" + path;\n        image.onload = function() {\n            patterns[key] = dummy_context.createPattern(image, \"repeat\");\n        };\n    },\n    get_pattern: function(key) {\n        return this.patterns[key];\n    },\n    new_canvas: function() {\n        var canvas = $(\"<canvas/>\")[0];\n        // Keep a reference back to the manager\n        canvas.manager = this;\n        return canvas;\n    }\n});\n\n/**\n * Generic cache that handles key/value pairs. Keys can be any object that can be\n * converted to a String and compared.\n */\nvar Cache = Backbone.Model.extend({\n    defaults: {\n        num_elements: 20,\n        // Objects in cache; indexes into cache are strings of keys.\n        obj_cache: null,\n        // key_ary contains keys for objects in cache.\n        key_ary: null\n    },\n\n    initialize: function(options) {\n        this.clear();\n    },\n\n    /**\n     * Get an element from the cache using its key.\n     */\n    get_elt: function(key) {\n        var obj_cache = this.attributes.obj_cache,\n            key_ary = this.attributes.key_ary,\n            key_str = key.toString(),\n            index = _.indexOf(key_ary, function(k) {\n                return k.toString() === key_str;\n            });\n\n        // Update cache.\n        if (index !== -1) {\n            // Object is in cache, so update it.\n            if (obj_cache[key_str].stale) {\n                // Object is stale: remove key and object.\n                key_ary.splice(index, 1);\n                delete obj_cache[key_str];\n            } else {\n                // Move key to back because it is most recently used.\n                this.move_key_to_end(key, index);\n            }\n        }\n\n        return obj_cache[key_str];\n    },\n\n    /**\n     * Put an element into the cache.\n     */\n    set_elt: function(key, value) {\n        var obj_cache = this.attributes.obj_cache,\n            key_ary = this.attributes.key_ary,\n            key_str = key.toString(),\n            num_elements = this.attributes.num_elements;\n\n        // Update keys, objects.\n        if (!obj_cache[key_str]) {\n            // Add object to cache.\n\n            if (key_ary.length >= num_elements) {\n                // Cache full, so remove first element.\n                var deleted_key = key_ary.shift();\n                delete obj_cache[deleted_key.toString()];\n            }\n\n            // Add key.\n            key_ary.push(key);\n        }\n\n        // Add object.\n        obj_cache[key_str] = value;\n        return value;\n    },\n\n    /**\n     * Move key to end of cache. Keys are removed from the front, so moving a key to the end\n     * delays the key's removal.\n     */\n    move_key_to_end: function(key, index) {\n        this.attributes.key_ary.splice(index, 1);\n        this.attributes.key_ary.push(key);\n    },\n\n    /**\n     * Clear all elements from the cache.\n     */\n    clear: function() {\n        this.attributes.obj_cache = {};\n        this.attributes.key_ary = [];\n    },\n\n    /** Returns the number of elements in the cache. */\n    size: function() {\n        return this.attributes.key_ary.length;\n    },\n\n    /** Returns key most recently added to cache. */\n    most_recently_added: function() {\n        return this.size() === 0\n            ? null\n            : // Most recent key is at the end of key array.\n              this.attributes.key_ary[this.attributes.key_ary.length - 1];\n    }\n});\n\n/**\n * Data manager for genomic data. Data is connected to and queryable by genomic regions.\n */\nvar GenomeDataManager = Cache.extend({\n    defaults: _.extend({}, Cache.prototype.defaults, {\n        dataset: null,\n        genome: null,\n        init_data: null,\n        min_region_size: 200,\n        filters_manager: null,\n        data_type: \"data\",\n        data_mode_compatible: function(entry, mode) {\n            return true;\n        },\n        can_subset: function(entry) {\n            return false;\n        }\n    }),\n\n    /**\n     * Initialization.\n     */\n    initialize: function(options) {\n        Cache.prototype.initialize.call(this);\n\n        // Set initial entries in data manager.\n        var initial_entries = this.get(\"init_data\");\n        if (initial_entries) {\n            this.add_data(initial_entries);\n        }\n    },\n\n    /**\n     * Add data entries to manager; each entry should be a dict with attributes region (key), data, and data_type.\n     * If necessary, manager size is increased to hold all data.\n     */\n    add_data: function(entries) {\n        // Increase size to accomodate all entries.\n        if (this.get(\"num_elements\") < entries.length) {\n            this.set(\"num_elements\", entries.length);\n        }\n\n        // Put data into manager.\n        var self = this;\n        _.each(entries, function(entry) {\n            self.set_data(entry.region, entry);\n        });\n    },\n\n    /**\n     * Returns deferred that resolves to true when dataset is ready (or false if dataset\n     * cannot be used).\n     */\n    data_is_ready: function() {\n        var dataset = this.get(\"dataset\"),\n            ready_deferred = $.Deferred(),\n            // If requesting raw data, query dataset state; if requesting (converted) data,\n            // need to query converted datasets state.\n            query_type =\n                this.get(\"data_type\") === \"raw_data\"\n                    ? \"state\"\n                    : this.get(\"data_type\") === \"data\"\n                      ? \"converted_datasets_state\"\n                      : \"error\",\n            ss_deferred = new util_mod.ServerStateDeferred({\n                ajax_settings: {\n                    url: this.get(\"dataset\").url(),\n                    data: {\n                        hda_ldda: dataset.get(\"hda_ldda\"),\n                        data_type: query_type\n                    },\n                    dataType: \"json\"\n                },\n                interval: 5000,\n                success_fn: function(response) {\n                    return response !== \"pending\";\n                }\n            });\n\n        $.when(ss_deferred.go()).then(function(response) {\n            ready_deferred.resolve(response === \"ok\" || response === \"data\");\n        });\n        return ready_deferred;\n    },\n\n    /**\n     * Perform a feature search from server; returns Deferred object that resolves when data is available.\n     */\n    search_features: function(query) {\n        var dataset = this.get(\"dataset\"),\n            params = {\n                query: query,\n                hda_ldda: dataset.get(\"hda_ldda\"),\n                data_type: \"features\"\n            };\n        return $.getJSON(dataset.url(), params);\n    },\n\n    /**\n     * Load data from server and manages data entries. Adds a Deferred to manager\n     * for region; when data becomes available, replaces Deferred with data.\n     * Returns the Deferred that resolves when data is available.\n     */\n    load_data: function(region, mode, resolution, extra_params) {\n        // Setup data request params.\n        var dataset = this.get(\"dataset\"),\n            params = {\n                data_type: this.get(\"data_type\"),\n                chrom: region.get(\"chrom\"),\n                low: region.get(\"start\"),\n                high: region.get(\"end\"),\n                mode: mode,\n                resolution: resolution,\n                hda_ldda: dataset.get(\"hda_ldda\")\n            };\n\n        $.extend(params, extra_params);\n\n        // Add track filters to params.\n        var filters_manager = this.get(\"filters_manager\");\n        if (filters_manager) {\n            var filter_names = [];\n            var filters = filters_manager.filters;\n            for (var i = 0; i < filters.length; i++) {\n                filter_names.push(filters[i].name);\n            }\n            params.filter_cols = JSON.stringify(filter_names);\n        }\n\n        // Do request.\n        var manager = this,\n            entry = $.getJSON(dataset.url(), params, function(result) {\n                // Add region to the result.\n                result.region = region;\n                manager.set_data(region, result);\n            });\n\n        this.set_data(region, entry);\n        return entry;\n    },\n\n    /**\n     * Get data from dataset.\n     */\n    get_data: function(region, mode, resolution, extra_params) {\n        // Look for entry and return if it's a deferred or if data available is compatible with mode.\n        var entry = this.get_elt(region);\n        if (\n            entry &&\n            (util_mod.is_deferred(entry) ||\n                this.get(\"data_mode_compatible\")(entry, mode))\n        ) {\n            return entry;\n        }\n\n        //\n        // Look in cache for data that can be used.\n        // TODO: this logic could be improved if the visualization knew whether\n        // the data was \"index\" or \"data.\"\n        //\n        var key_ary = this.get(\"key_ary\"),\n            obj_cache = this.get(\"obj_cache\"),\n            entry_region,\n            is_subregion;\n        for (var i = 0; i < key_ary.length; i++) {\n            entry_region = key_ary[i];\n\n            if (entry_region.contains(region)) {\n                is_subregion = true;\n\n                // This entry has data in the requested range. Return if data\n                // is compatible and can be subsetted.\n                entry = obj_cache[entry_region.toString()];\n                if (\n                    util_mod.is_deferred(entry) ||\n                    (this.get(\"data_mode_compatible\")(entry, mode) &&\n                        this.get(\"can_subset\")(entry))\n                ) {\n                    this.move_key_to_end(entry_region, i);\n\n                    // If there's data, subset it.\n                    if (!util_mod.is_deferred(entry)) {\n                        var subset_entry = this.subset_entry(entry, region);\n                        this.set_data(region, subset_entry);\n                        entry = subset_entry;\n                    }\n\n                    return entry;\n                }\n            }\n        }\n\n        // FIXME: There _may_ be instances where region is a subregion of another entry but cannot be\n        // subsetted. For these cases, do not increase length because region will never be found (and\n        // an infinite loop will occur.)\n        // If needed, extend region to make it minimum size.\n        if (\n            !is_subregion &&\n            region.length() < this.attributes.min_region_size\n        ) {\n            // IDEA: alternative heuristic is to find adjacent cache entry to region and use that to extend.\n            // This would prevent bad extensions when zooming in/out while still preserving the behavior\n            // below.\n\n            // Use copy of region to avoid changing actual region.\n            region = region.copy();\n\n            // Use heuristic to extend region: extend relative to last data request.\n            var last_request = this.most_recently_added();\n            if (\n                !last_request ||\n                region.get(\"start\") > last_request.get(\"start\")\n            ) {\n                // This request is after the last request, so extend right.\n                region.set(\n                    \"end\",\n                    region.get(\"start\") + this.attributes.min_region_size\n                );\n            } else {\n                // This request is after the last request, so extend left.\n                region.set(\n                    \"start\",\n                    region.get(\"end\") - this.attributes.min_region_size\n                );\n            }\n\n            // Trim region to avoid invalid coordinates.\n            region.set(\"genome\", this.attributes.genome);\n            region.trim();\n        }\n\n        return this.load_data(region, mode, resolution, extra_params);\n    },\n\n    /**\n     * Alias for set_elt for readbility.\n     */\n    set_data: function(region, entry) {\n        this.set_elt(region, entry);\n    },\n\n    /** \"Deep\" data request; used as a parameter for DataManager.get_more_data() */\n    DEEP_DATA_REQ: \"deep\",\n\n    /** \"Broad\" data request; used as a parameter for DataManager.get_more_data() */\n    BROAD_DATA_REQ: \"breadth\",\n\n    /**\n     * Gets more data for a region using either a depth-first or a breadth-first approach.\n     */\n    get_more_data: function(region, mode, resolution, extra_params, req_type) {\n        var cur_data = this._mark_stale(region);\n        if (!(cur_data && this.get(\"data_mode_compatible\")(cur_data, mode))) {\n            console.log(\n                \"ERROR: problem with getting more data: current data is not compatible\"\n            );\n            return;\n        }\n\n        //\n        // Set parameters based on request type.\n        //\n        var query_low = region.get(\"start\");\n        if (req_type === this.DEEP_DATA_REQ) {\n            // Use same interval but set start_val to skip data that's already in cur_data.\n            $.extend(extra_params, {\n                start_val: cur_data.data.length + 1\n            });\n        } else if (req_type === this.BROAD_DATA_REQ) {\n            // To get past an area of extreme feature depth, set query low to be after either\n            // (a) the maximum high or HACK/FIXME (b) the end of the last feature returned.\n            query_low =\n                (cur_data.max_high\n                    ? cur_data.max_high\n                    : cur_data.data[cur_data.data.length - 1][2]) + 1;\n        }\n        var query_region = region.copy().set(\"start\", query_low);\n\n        //\n        // Get additional data, append to current data, and set new data. Use a custom deferred object\n        // to signal when new data is available.\n        //\n        var data_manager = this,\n            new_data_request = this.load_data(\n                query_region,\n                mode,\n                resolution,\n                extra_params\n            ),\n            new_data_available = $.Deferred();\n        // load_data sets cache to new_data_request, but use custom deferred object so that signal and data\n        // is all data, not just new data.\n        this.set_data(region, new_data_available);\n        $.when(new_data_request).then(function(result) {\n            // Update data and message.\n            if (result.data) {\n                result.data = cur_data.data.concat(result.data);\n                if (result.max_low) {\n                    result.max_low = cur_data.max_low;\n                }\n                if (result.message) {\n                    // HACK: replace number in message with current data length. Works but is ugly.\n                    result.message = result.message.replace(\n                        /[0-9]+/,\n                        result.data.length\n                    );\n                }\n            }\n            data_manager.set_data(region, result);\n            new_data_available.resolve(result);\n        });\n        return new_data_available;\n    },\n\n    /**\n     * Returns true if more detailed data can be obtained for entry.\n     */\n    can_get_more_detailed_data: function(region) {\n        var cur_data = this.get_elt(region);\n\n        // Can only get more detailed data for bigwig data that has less than 8000 data points.\n        // Summary tree returns *way* too much data, and 8000 data points ~ 500KB.\n        return (\n            cur_data.dataset_type === \"bigwig\" && cur_data.data.length < 8000\n        );\n    },\n\n    /**\n     * Returns more detailed data for an entry.\n     */\n    get_more_detailed_data: function(\n        region,\n        mode,\n        resolution,\n        detail_multiplier,\n        extra_params\n    ) {\n        // Mark current entry as stale.\n        var cur_data = this._mark_stale(region);\n        if (!cur_data) {\n            console.log(\"ERROR getting more detailed data: no current data\");\n            return;\n        }\n\n        if (!extra_params) {\n            extra_params = {};\n        }\n\n        // Use additional parameters to get more detailed data.\n        if (cur_data.dataset_type === \"bigwig\") {\n            // FIXME: constant should go somewhere.\n            extra_params.num_samples = 1000 * detail_multiplier;\n        }\n\n        return this.load_data(region, mode, resolution, extra_params);\n    },\n\n    /**\n     * Marks cache data as stale.\n     */\n    _mark_stale: function(region) {\n        var entry = this.get_elt(region);\n        if (!entry) {\n            console.log(\n                \"ERROR: no data to mark as stale: \",\n                this.get(\"dataset\"),\n                region.toString()\n            );\n        }\n        entry.stale = true;\n        return entry;\n    },\n\n    /**\n     * Returns an array of data with each entry representing one chromosome/contig\n     * of data or, if data is not available, returns a Deferred that resolves to the\n     * data when it becomes available.\n     */\n    get_genome_wide_data: function(genome) {\n        // -- Get all data. --\n\n        var self = this,\n            all_data_available = true,\n            //  Map chromosome info into genome data.\n            gw_data = _.map(genome.get(\"chroms_info\").chrom_info, function(\n                chrom_info\n            ) {\n                var chrom_data = self.get_elt(\n                    new GenomeRegion({\n                        chrom: chrom_info.chrom,\n                        start: 0,\n                        end: chrom_info.len\n                    })\n                );\n\n                // Set flag if data is not available.\n                if (!chrom_data) {\n                    all_data_available = false;\n                }\n\n                return chrom_data;\n            });\n\n        // -- If all data is available, return it. --\n        if (all_data_available) {\n            return gw_data;\n        }\n\n        // -- All data is not available, so load from server. --\n\n        var deferred = $.Deferred();\n        $.getJSON(\n            this.get(\"dataset\").url(),\n            { data_type: \"genome_data\" },\n            function(genome_wide_data) {\n                self.add_data(genome_wide_data.data);\n                deferred.resolve(genome_wide_data.data);\n            }\n        );\n\n        return deferred;\n    },\n\n    /**\n     * Returns entry with only data in the subregion.\n     */\n    subset_entry: function(entry, subregion) {\n        // Dictionary from entry type to function for subsetting data.\n        var subset_fns = {\n            bigwig: function(data, subregion) {\n                return _.filter(data, function(data_point) {\n                    return (\n                        data_point[0] >= subregion.get(\"start\") &&\n                        data_point[0] <= subregion.get(\"end\")\n                    );\n                });\n            },\n            refseq: function(data, subregion) {\n                var seq_start =\n                    subregion.get(\"start\") - entry.region.get(\"start\");\n                return entry.data.slice(\n                    seq_start,\n                    seq_start + subregion.length()\n                );\n            }\n        };\n\n        // Subset entry if there is a function for subsetting and regions are not the same.\n        var subregion_data = entry.data;\n        if (!entry.region.same(subregion) && entry.dataset_type in subset_fns) {\n            subregion_data = subset_fns[entry.dataset_type](\n                entry.data,\n                subregion\n            );\n        }\n\n        // Return entry with subregion's data.\n        return {\n            region: subregion,\n            data: subregion_data,\n            dataset_type: entry.dataset_type\n        };\n    }\n});\n\nvar GenomeReferenceDataManager = GenomeDataManager.extend({\n    initialize: function(options) {\n        // Use generic object in place of dataset and set urlRoot to fetch data.\n        var dataset_placeholder = new Backbone.Model();\n        dataset_placeholder.urlRoot = options.data_url;\n        this.set(\"dataset\", dataset_placeholder);\n    },\n\n    load_data: function(region, mode, resolution, extra_params) {\n        // Fetch data if region is not too large.\n        return region.length() <= 100000\n            ? GenomeDataManager.prototype.load_data.call(\n                  this,\n                  region,\n                  mode,\n                  resolution,\n                  extra_params\n              )\n            : { data: null, region: region };\n    }\n});\n\n/**\n * A genome build.\n */\nvar Genome = Backbone.Model.extend({\n    defaults: {\n        name: null,\n        key: null,\n        chroms_info: null\n    },\n\n    initialize: function(options) {\n        this.id = options.dbkey;\n    },\n\n    /**\n     * Shorthand for getting to chromosome information.\n     */\n    get_chroms_info: function() {\n        return this.attributes.chroms_info.chrom_info;\n    },\n\n    /**\n     * Returns a GenomeRegion object denoting a complete chromosome.\n     */\n    get_chrom_region: function(chr_name) {\n        // FIXME: use findWhere in underscore 1.4\n        var chrom_info = _.find(this.get_chroms_info(), function(chrom_info) {\n            return chrom_info.chrom === chr_name;\n        });\n        return new GenomeRegion({\n            chrom: chrom_info.chrom,\n            end: chrom_info.len\n        });\n    },\n\n    /** Returns the length of a chromosome. */\n    get_chrom_len: function(chr_name) {\n        // FIXME: use findWhere in underscore 1.4\n        return _.find(this.get_chroms_info(), function(chrom_info) {\n            return chrom_info.chrom === chr_name;\n        }).len;\n    }\n});\n\n/**\n * A genomic region.\n */\nvar GenomeRegion = Backbone.Model.extend(\n    {\n        defaults: {\n            chrom: null,\n            start: 0,\n            end: 0,\n            str_val: null,\n            genome: null\n        },\n\n        /**\n     * Returns true if this region is the same as a given region.\n     * It does not test the genome right now.\n     */\n        same: function(region) {\n            return (\n                this.attributes.chrom === region.get(\"chrom\") &&\n                this.attributes.start === region.get(\"start\") &&\n                this.attributes.end === region.get(\"end\")\n            );\n        },\n\n        /**\n     * If from_str specified, use it to initialize attributes.\n     */\n        initialize: function(options) {\n            if (options.from_str) {\n                var pieces = options.from_str.split(\":\"),\n                    chrom = pieces[0],\n                    start_end = pieces[1].split(\"-\");\n                this.set({\n                    chrom: chrom,\n                    start: parseInt(start_end[0], 10),\n                    end: parseInt(start_end[1], 10)\n                });\n            }\n\n            // Keep a copy of region's string value for fast lookup.\n            this.attributes.str_val =\n                this.get(\"chrom\") +\n                \":\" +\n                this.get(\"start\") +\n                \"-\" +\n                this.get(\"end\");\n\n            // Set str_val on attribute change.\n            this.on(\n                \"change\",\n                function() {\n                    this.attributes.str_val =\n                        this.get(\"chrom\") +\n                        \":\" +\n                        this.get(\"start\") +\n                        \"-\" +\n                        this.get(\"end\");\n                },\n                this\n            );\n        },\n\n        copy: function() {\n            return new GenomeRegion({\n                chrom: this.get(\"chrom\"),\n                start: this.get(\"start\"),\n                end: this.get(\"end\")\n            });\n        },\n\n        length: function() {\n            return this.get(\"end\") - this.get(\"start\");\n        },\n\n        /** Returns region in canonical form chrom:start-end */\n        toString: function() {\n            return this.attributes.str_val;\n        },\n\n        toJSON: function() {\n            return {\n                chrom: this.get(\"chrom\"),\n                start: this.get(\"start\"),\n                end: this.get(\"end\")\n            };\n        },\n\n        /**\n     * Compute the type of overlap between this region and another region. The overlap is computed relative to the given/second region;\n     * hence, OVERLAP_START indicates that the first region overlaps the start (but not the end) of the second region.\n     */\n        compute_overlap: function(a_region) {\n            var first_chrom = this.get(\"chrom\"),\n                second_chrom = a_region.get(\"chrom\"),\n                first_start = this.get(\"start\"),\n                second_start = a_region.get(\"start\"),\n                first_end = this.get(\"end\"),\n                second_end = a_region.get(\"end\"),\n                overlap;\n\n            // Compare chroms.\n            if (first_chrom && second_chrom && first_chrom !== second_chrom) {\n                return GenomeRegion.overlap_results.DIF_CHROMS;\n            }\n\n            // Compare regions.\n            if (first_start < second_start) {\n                if (first_end < second_start) {\n                    overlap = GenomeRegion.overlap_results.BEFORE;\n                } else if (first_end < second_end) {\n                    overlap = GenomeRegion.overlap_results.OVERLAP_START;\n                } else {\n                    // first_end >= second_end\n                    overlap = GenomeRegion.overlap_results.CONTAINS;\n                }\n            } else if (first_start > second_start) {\n                if (first_start > second_end) {\n                    overlap = GenomeRegion.overlap_results.AFTER;\n                } else if (first_end <= second_end) {\n                    overlap = GenomeRegion.overlap_results.CONTAINED_BY;\n                } else {\n                    overlap = GenomeRegion.overlap_results.OVERLAP_END;\n                }\n            } else {\n                // first_start === second_start\n                overlap =\n                    first_end >= second_end\n                        ? GenomeRegion.overlap_results.CONTAINS\n                        : GenomeRegion.overlap_results.CONTAINED_BY;\n            }\n\n            return overlap;\n        },\n\n        /**\n     * Trim a region to match genome's constraints.\n     */\n        trim: function(genome) {\n            // Assume that all chromosome/contigs start at 0.\n            if (this.attributes.start < 0) {\n                this.attributes.start = 0;\n            }\n\n            // Only try to trim the end if genome is set.\n            if (this.attributes.genome) {\n                var chrom_len = this.attributes.genome.get_chrom_len(\n                    this.attributes.chrom\n                );\n                if (this.attributes.end > chrom_len) {\n                    this.attributes.end = chrom_len - 1;\n                }\n            }\n\n            return this;\n        },\n\n        /**\n     * Returns true if this region contains a given region.\n     */\n        contains: function(a_region) {\n            return (\n                this.compute_overlap(a_region) ===\n                GenomeRegion.overlap_results.CONTAINS\n            );\n        },\n\n        /**\n     * Returns true if regions overlap.\n     */\n        overlaps: function(a_region) {\n            return (\n                _.intersection(\n                    [this.compute_overlap(a_region)],\n                    [\n                        GenomeRegion.overlap_results.DIF_CHROMS,\n                        GenomeRegion.overlap_results.BEFORE,\n                        GenomeRegion.overlap_results.AFTER\n                    ]\n                ).length === 0\n            );\n        }\n    },\n    {\n        overlap_results: {\n            DIF_CHROMS: 1000,\n            BEFORE: 1001,\n            CONTAINS: 1002,\n            OVERLAP_START: 1003,\n            OVERLAP_END: 1004,\n            CONTAINED_BY: 1005,\n            AFTER: 1006\n        }\n    }\n);\n\nvar GenomeRegionCollection = Backbone.Collection.extend({\n    model: GenomeRegion\n});\n\n/**\n * A genome browser bookmark.\n */\nvar BrowserBookmark = Backbone.Model.extend({\n    defaults: {\n        region: null,\n        note: \"\"\n    },\n\n    initialize: function(options) {\n        this.set(\"region\", new GenomeRegion(options.region));\n    }\n});\n\n/**\n * Bookmarks collection.\n */\nvar BrowserBookmarkCollection = Backbone.Collection.extend({\n    model: BrowserBookmark\n});\n\n/**\n * A track of data in a genome visualization.\n */\n// TODO: rename to Track and merge with Trackster's Track object.\nvar BackboneTrack = Backbone.Model.extend(CustomToJSON).extend(\n    {\n        defaults: {\n            mode: \"Auto\"\n        },\n\n        initialize: function(options) {\n            this.set(\"dataset\", new data_mod.Dataset(options.dataset));\n\n            // -- Set up config settings. --\n            var models = [\n                {\n                    key: \"name\",\n                    default_value: this.get(\"dataset\").get(\"name\")\n                },\n                { key: \"color\" },\n                {\n                    key: \"min_value\",\n                    label: \"Min Value\",\n                    type: \"float\",\n                    default_value: 0\n                },\n                {\n                    key: \"max_value\",\n                    label: \"Max Value\",\n                    type: \"float\",\n                    default_value: 1\n                }\n            ];\n\n            this.set(\n                \"config\",\n                config_mod.ConfigSettingCollection.from_models_and_saved_values(\n                    models,\n                    options.prefs\n                )\n            );\n\n            // -- Set up data manager. --\n            var preloaded_data = this.get(\"preloaded_data\");\n            if (preloaded_data) {\n                preloaded_data = preloaded_data.data;\n            } else {\n                preloaded_data = [];\n            }\n            this.set(\n                \"data_manager\",\n                new GenomeDataManager({\n                    dataset: this.get(\"dataset\"),\n                    init_data: preloaded_data\n                })\n            );\n        }\n    },\n    {\n        // This definition matches that produced by to_dict() methods in tracks.js\n        to_json_keys: [\n            \"track_type\",\n            \"dataset\",\n            \"prefs\",\n            \"mode\",\n            \"filters\",\n            \"tool_state\"\n        ],\n        to_json_mappers: {\n            prefs: function(p, self) {\n                if (_.size(p) === 0) {\n                    p = {\n                        name: self\n                            .get(\"config\")\n                            .get(\"name\")\n                            .get(\"value\"),\n                        color: self\n                            .get(\"config\")\n                            .get(\"color\")\n                            .get(\"value\")\n                    };\n                }\n                return p;\n            },\n            dataset: function(d) {\n                return {\n                    id: d.id,\n                    hda_ldda: d.get(\"hda_ldda\")\n                };\n            }\n        }\n    }\n);\n\nvar BackboneTrackCollection = Backbone.Collection.extend({\n    model: BackboneTrack\n});\n\n/**\n * A visualization.\n */\nvar Visualization = Backbone.Model.extend({\n    defaults: {\n        title: \"\",\n        type: \"\"\n    },\n\n    urlRoot: Galaxy.root + \"api/visualizations\",\n\n    /**\n     * POSTs visualization's JSON to its URL using the parameter 'vis_json'\n     * Note: This is necessary because (a) Galaxy requires keyword args and\n     * (b) Galaxy does not handle PUT now.\n     */\n    save: function() {\n        return $.ajax({\n            url: this.url(),\n            type: \"POST\",\n            dataType: \"json\",\n            data: {\n                vis_json: JSON.stringify(this)\n            }\n        });\n    }\n});\n\n/**\n * A visualization of genome data.\n */\nvar GenomeVisualization = Visualization.extend(CustomToJSON).extend(\n    {\n        defaults: _.extend({}, Visualization.prototype.defaults, {\n            dbkey: \"\",\n            drawables: null,\n            bookmarks: null,\n            viewport: null\n        }),\n\n        initialize: function(options) {\n            // Replace drawables with tracks.\n            this.set(\"drawables\", new BackboneTrackCollection(options.tracks));\n\n            var models = [];\n            this.set(\n                \"config\",\n                config_mod.ConfigSettingCollection.from_models_and_saved_values(\n                    models,\n                    options.prefs\n                )\n            );\n\n            // Clear track and data definitions to avoid storing large objects.\n            this.unset(\"tracks\");\n            this.get(\"drawables\").each(function(d) {\n                d.unset(\"preloaded_data\");\n            });\n        },\n\n        /**\n     * Add a track or array of tracks to the visualization.\n     */\n        add_tracks: function(tracks) {\n            this.get(\"drawables\").add(tracks);\n        }\n    },\n    {\n        // This definition matches that produced by to_dict() methods in tracks.js\n        to_json_keys: [\"view\", \"viewport\", \"bookmarks\"],\n\n        to_json_mappers: {\n            view: function(dummy, self) {\n                return {\n                    obj_type: \"View\",\n                    prefs: {\n                        name: self.get(\"title\"),\n                        content_visible: true\n                    },\n                    drawables: self.get(\"drawables\")\n                };\n            }\n        }\n    }\n);\n\n/**\n * -- Routers --\n */\n\n/**\n * Router for track browser.\n */\nvar TrackBrowserRouter = Backbone.Router.extend({\n    initialize: function(options) {\n        this.view = options.view;\n\n        // Can't put regular expression in routes dictionary.\n        // NOTE: parentheses are used to denote parameters returned to callback.\n        this.route(/([\\w]+)$/, \"change_location\");\n        this.route(/([\\w\\+]+\\:[\\d,]+-[\\d,]+)$/, \"change_location\");\n\n        // Handle navigate events from view.\n        var self = this;\n        self.view.on(\"navigate\", function(new_loc) {\n            self.navigate(new_loc);\n        });\n    },\n\n    change_location: function(new_loc) {\n        this.view.go_to(new_loc);\n    }\n});\n\nexport default {\n    BackboneTrack: BackboneTrack,\n    BrowserBookmark: BrowserBookmark,\n    BrowserBookmarkCollection: BrowserBookmarkCollection,\n    Cache: Cache,\n    CanvasManager: CanvasManager,\n    Genome: Genome,\n    GenomeDataManager: GenomeDataManager,\n    GenomeRegion: GenomeRegion,\n    GenomeRegionCollection: GenomeRegionCollection,\n    GenomeVisualization: GenomeVisualization,\n    GenomeReferenceDataManager: GenomeReferenceDataManager,\n    TrackBrowserRouter: TrackBrowserRouter,\n    Visualization: Visualization,\n    select_datasets: select_datasets\n};\n"]}