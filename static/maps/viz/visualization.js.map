{"version":3,"sources":["viz/visualization.js"],"names":["define","_","data_mod","util_mod","config_mod","GridView","Tabs","Ui","CustomToJSON","toJSON","self","this","json","each","to_json_keys","k","get","constructor","val","to_json_mappers","CanvasManager","default_font","undefined","dummy_canvas","dummy_context","getContext","new_canvas","char_width_px","font","width","patterns","load_pattern","extend","prototype","key","path","image","src","onload","Galaxy","createPattern","get_pattern","canvas","$","manager","Cache","Backbone","Model","defaults","num_elements","obj_cache","initialize","options","clear","get_elt","attributes","key_ary","key_str","index","stale","move_key_to_end","set_elt","value","toString","length","shift","push","splice","size","most_recently_added","GenomeDataManager","dataset","genome","init_data","min_region_size","filters_manager","data_type","entry","mode","data_mode_compatible","call","initial_entries","add_data","entries","set","set_data","region","data_is_ready","ready_deferred","Deferred","ss_deferred","ajax_settings","url","data","query_type","hda_ldda","when","go","then","response","interval","resolve","search_features","query","params","load_data","resolution","extra_params","chrom","low","high","filter_names","filters","i","name","stringify","result","filter_cols","get_data","is_deferred","entry_region","is_subregion","contains","last_request","copy","BROAD_DATA_REQ","req_type","cur_data","_mark_stale","query_low","DEEP_DATA_REQ","start_val","query_region","data_manager","new_data_request","new_data_available","max_low","message","console","log","can_get_more_detailed_data","get_more_detailed_data","detail_multiplier","dataset_type","get_genome_wide_data","all_data_available","gw_data","map","chrom_info","chrom_data","GenomeRegion","start","end","len","deferred","getJSON","genome_wide_data","subset_entry","subregion","subset_fns","bigwig","filter","data_point","refseq","seq_start","subregion_data","same","dataset_placeholder","urlRoot","data_url","Genome","chroms_info","dbkey","get_chroms_info","get_chrom_region","chr_name","find","get_chrom_len","from_str","start_end","pieces","str_val","on","compute_overlap","a_region","first_chrom","second_chrom","second_start","first_end","second_end","DIF_CHROMS","first_start","overlap_results","BEFORE","OVERLAP_START","CONTAINS","overlap","AFTER","OVERLAP_END","CONTAINED_BY","trim","chrom_len","overlaps","intersection","GenomeRegionCollection","Collection","model","note","BrowserBookmarkCollection","BrowserBookmark","BackboneTrack","models","default_value","preloaded_data","label","type","ConfigSettingCollection","from_models_and_saved_values","prefs","p","id","BackboneTrackCollection","color","d","title","dataType","vis_json","root","drawables","bookmarks","viewport","JSON","GenomeVisualization","Visualization","add_tracks","tracks","unset","obj_type","add","view","route","TrackBrowserRouter","new_loc","select_datasets","change_location","go_to","GenomeReferenceDataManager","success_fn","url_base","history_grid","library_grid","dict_format","tabs","View","$el","append","modal","show","body","closing_events","buttons","hide","requests","window","ajax","current","apply","track_defs","arguments","Array","arg"],"mappings":"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","file":"../../scripts/viz/visualization.js","sourcesContent":["define( [\"libs/underscore\", \"mvc/dataset/data\", \"viz/trackster/util\", \"utils/config\", \"mvc/grid/grid-view\", \"mvc/ui/ui-tabs\", \"mvc/ui/ui-misc\"], function(_, data_mod, util_mod, config_mod, GridView, Tabs, Ui) {\n\n/**\n * Mixin for returning custom JSON representation from toJSON. Class attribute to_json_keys defines a set of attributes\n * to include in the representation; to_json_mappers defines mappers for returned objects.\n */\nvar CustomToJSON = {\n    /**\n     * Returns JSON representation of object using to_json_keys and to_json_mappers.\n     */\n    toJSON: function() {\n        var self = this,\n            json = {};\n        _.each(self.constructor.to_json_keys, function(k) {\n            var val = self.get(k);\n            if (k in self.constructor.to_json_mappers) {\n                val = self.constructor.to_json_mappers[k](val, self);\n            }\n            json[k] = val;\n        });\n        return json;\n    }\n};\n\n/**\n * Model, view, and controller objects for Galaxy visualization framework.\n *\n * Models have no references to views, instead using events to indicate state\n * changes; this is advantageous because multiple views can use the same object\n * and models can be used without views.\n */\n\n/**\n * Use a popup grid to select datasets from histories or libraries. After datasets are selected,\n * track definitions are obtained from the server and the success_fn is called with the list of\n * definitions for selected datasets.\n */\nvar select_datasets = function(filters, success_fn) {\n    // history dataset selection tab\n    var history_grid = new GridView({\n        url_base    : Galaxy.root + 'visualization/list_history_datasets',\n        filters     : filters,\n        dict_format : true,\n        embedded    : true\n    });\n\n    // library dataset selection tab\n    var library_grid = new GridView( {\n        url_base    : Galaxy.root + 'visualization/list_library_datasets',\n        dict_format : true,\n        embedded    : true\n    });\n\n    // build tabs\n    var tabs = new Tabs.View();\n    tabs.add({  id      : 'histories',\n                title   : 'Histories',\n                $el     : $( '<div/>' ).append( history_grid.$el )\n    });\n    tabs.add({  id      : 'libraries',\n                title   : 'Libraries',\n                $el     : $( '<div/>' ).append( library_grid.$el )\n    });\n\n    // modal\n    Galaxy.modal.show({\n        title           : 'Select datasets for new tracks',\n        body            : tabs.$el,\n        closing_events  : true,\n        buttons         : {\n            'Cancel': function() {\n                Galaxy.modal.hide();\n            },\n            'Add': function() {\n                var requests = [];\n                tabs.$('input.grid-row-select-checkbox[name=id]:checked').each(function() {\n                    window.console.log( $(this).val() );\n                    requests[requests.length] = $.ajax({\n                        url      : Galaxy.root + 'api/datasets/' + $(this).val(),\n                        dataType : 'json',\n                        data     : {\n                            data_type : 'track_config',\n                            hda_ldda  : tabs.current() == 'histories' ? 'hda' : 'ldda'\n                        }\n                    });\n                });\n                // To preserve order, wait until there are definitions for all tracks and then add\n                // them sequentially.\n                $.when.apply($, requests).then(function() {\n                    // jQuery always returns an Array for arguments, so need to look at first element\n                    // to determine whether multiple requests were made and consequently how to\n                    // map arguments to track definitions.\n                    var track_defs = ( arguments[0] instanceof Array ?\n                                       $.map(arguments, function(arg) { return arg[0]; }) :\n                                       [ arguments[0] ] );\n                    success_fn(track_defs);\n                });\n                Galaxy.modal.hide();\n            }\n        }\n    });\n};\n\n// --------- Models ---------\n\n/**\n * Canvas manager is used to create canvases for browsers as well as providing a pattern cache\n */\nvar CanvasManager = function(default_font) {\n    this.default_font = default_font !== undefined ? default_font : \"9px Monaco, Lucida Console, monospace\";\n\n    this.dummy_canvas = this.new_canvas();\n    this.dummy_context = this.dummy_canvas.getContext('2d');\n    this.dummy_context.font = this.default_font;\n\n    this.char_width_px = this.dummy_context.measureText(\"A\").width;\n\n    this.patterns = {};\n\n    // FIXME: move somewhere to make this more general\n    this.load_pattern( 'right_strand', \"/visualization/strand_right.png\" );\n    this.load_pattern( 'left_strand', \"/visualization/strand_left.png\" );\n    this.load_pattern( 'right_strand_inv', \"/visualization/strand_right_inv.png\" );\n    this.load_pattern( 'left_strand_inv', \"/visualization/strand_left_inv.png\" );\n};\n\n_.extend( CanvasManager.prototype, {\n    load_pattern: function( key, path ) {\n        var patterns = this.patterns,\n            dummy_context = this.dummy_context,\n            image = new Image();\n        image.src = Galaxy.root + \"static/images\" + path;\n        image.onload = function() {\n            patterns[key] = dummy_context.createPattern( image, \"repeat\" );\n        };\n    },\n    get_pattern: function( key ) {\n        return this.patterns[key];\n    },\n    new_canvas: function() {\n        var canvas = $(\"<canvas/>\")[0];\n        // Keep a reference back to the manager\n        canvas.manager = this;\n        return canvas;\n    }\n});\n\n/**\n * Generic cache that handles key/value pairs. Keys can be any object that can be\n * converted to a String and compared.\n */\nvar Cache = Backbone.Model.extend({\n    defaults: {\n        num_elements: 20,\n        // Objects in cache; indexes into cache are strings of keys.\n        obj_cache: null,\n        // key_ary contains keys for objects in cache.\n        key_ary: null\n    },\n\n    initialize: function(options) {\n        this.clear();\n    },\n\n    /**\n     * Get an element from the cache using its key.\n     */\n    get_elt: function(key) {\n        var obj_cache = this.attributes.obj_cache,\n            key_ary = this.attributes.key_ary,\n            key_str = key.toString(),\n            index = _.indexOf(key_ary, function(k) {\n                return k.toString() === key_str;\n            });\n\n        // Update cache.\n        if (index !== -1) {\n            // Object is in cache, so update it.\n            if (obj_cache[key_str].stale) {\n                // Object is stale: remove key and object.\n                key_ary.splice(index, 1);\n                delete obj_cache[key_str];\n            }\n            else {\n                // Move key to back because it is most recently used.\n                this.move_key_to_end(key, index);\n            }\n        }\n\n        return obj_cache[key_str];\n    },\n\n    /**\n     * Put an element into the cache.\n     */\n    set_elt: function(key, value) {\n        var obj_cache = this.attributes.obj_cache,\n            key_ary = this.attributes.key_ary,\n            key_str = key.toString(),\n            num_elements = this.attributes.num_elements;\n\n        // Update keys, objects.\n        if (!obj_cache[key_str]) {\n            // Add object to cache.\n\n            if (key_ary.length >= num_elements) {\n                // Cache full, so remove first element.\n                var deleted_key = key_ary.shift();\n                delete obj_cache[deleted_key.toString()];\n            }\n\n            // Add key.\n            key_ary.push(key);\n        }\n\n        // Add object.\n        obj_cache[key_str] = value;\n        return value;\n    },\n\n    /**\n     * Move key to end of cache. Keys are removed from the front, so moving a key to the end\n     * delays the key's removal.\n     */\n    move_key_to_end: function(key, index) {\n        this.attributes.key_ary.splice(index, 1);\n        this.attributes.key_ary.push(key);\n    },\n\n    /**\n     * Clear all elements from the cache.\n     */\n    clear: function() {\n        this.attributes.obj_cache = {};\n        this.attributes.key_ary = [];\n    },\n\n    /** Returns the number of elements in the cache. */\n    size: function() {\n        return this.attributes.key_ary.length;\n    },\n\n    /** Returns key most recently added to cache. */\n    most_recently_added: function() {\n        return this.size() === 0 ? null :\n               // Most recent key is at the end of key array.\n               this.attributes.key_ary[this.attributes.key_ary.length - 1];\n    }\n});\n\n/**\n * Data manager for genomic data. Data is connected to and queryable by genomic regions.\n */\nvar GenomeDataManager = Cache.extend({\n    defaults: _.extend({}, Cache.prototype.defaults, {\n        dataset: null,\n        genome: null,\n        init_data: null,\n        min_region_size: 200,\n        filters_manager: null,\n        data_type: \"data\",\n        data_mode_compatible: function(entry, mode) { return true; },\n        can_subset: function(entry) { return false; }\n    }),\n\n    /**\n     * Initialization.\n     */\n    initialize: function(options) {\n        Cache.prototype.initialize.call(this);\n\n        // Set initial entries in data manager.\n        var initial_entries = this.get('init_data');\n        if (initial_entries) {\n            this.add_data(initial_entries);\n        }\n    },\n\n    /**\n     * Add data entries to manager; each entry should be a dict with attributes region (key), data, and data_type.\n     * If necessary, manager size is increased to hold all data.\n     */\n    add_data: function(entries) {\n        // Increase size to accomodate all entries.\n        if (this.get('num_elements') < entries.length) {\n            this.set('num_elements', entries.length);\n        }\n\n        // Put data into manager.\n        var self = this;\n        _.each(entries, function(entry) {\n            self.set_data(entry.region, entry);\n        });\n    },\n\n    /**\n     * Returns deferred that resolves to true when dataset is ready (or false if dataset\n     * cannot be used).\n     */\n    data_is_ready: function() {\n        var dataset = this.get('dataset'),\n            ready_deferred = $.Deferred(),\n            // If requesting raw data, query dataset state; if requesting (converted) data,\n            // need to query converted datasets state.\n            query_type = (this.get('data_type') === 'raw_data' ? 'state' :\n                          this.get('data_type') === 'data' ? 'converted_datasets_state' : \"error\" ),\n            ss_deferred = new util_mod.ServerStateDeferred({\n                ajax_settings: {\n                    url: this.get('dataset').url(),\n                    data: {\n                        hda_ldda: dataset.get('hda_ldda'),\n                        data_type: query_type\n                    },\n                    dataType: \"json\"\n                },\n                interval: 5000,\n                success_fn: function(response) { return response !== \"pending\"; }\n            });\n\n        $.when(ss_deferred.go()).then(function(response) {\n            ready_deferred.resolve(response === \"ok\" || response === \"data\" );\n        });\n        return ready_deferred;\n    },\n\n    /**\n     * Perform a feature search from server; returns Deferred object that resolves when data is available.\n     */\n    search_features: function(query) {\n        var dataset = this.get('dataset'),\n            params = {\n                query: query,\n                hda_ldda: dataset.get('hda_ldda'),\n                data_type: 'features'\n            };\n        return $.getJSON(dataset.url(), params);\n    },\n\n    /**\n     * Load data from server and manages data entries. Adds a Deferred to manager\n     * for region; when data becomes available, replaces Deferred with data.\n     * Returns the Deferred that resolves when data is available.\n     */\n    load_data: function(region, mode, resolution, extra_params) {\n        // Setup data request params.\n        var dataset = this.get('dataset'),\n            params = {\n                        \"data_type\": this.get('data_type'),\n                        \"chrom\": region.get('chrom'),\n                        \"low\": region.get('start'),\n                        \"high\": region.get('end'),\n                        \"mode\": mode,\n                        \"resolution\": resolution,\n                        \"hda_ldda\": dataset.get('hda_ldda')\n                     };\n\n        $.extend(params, extra_params);\n\n        // Add track filters to params.\n        var filters_manager = this.get('filters_manager');\n        if (filters_manager) {\n            var filter_names = [];\n            var filters = filters_manager.filters;\n            for (var i = 0; i < filters.length; i++) {\n                filter_names.push(filters[i].name);\n            }\n            params.filter_cols = JSON.stringify(filter_names);\n        }\n\n        // Do request.\n        var manager = this,\n            entry = $.getJSON(dataset.url(), params, function (result) {\n                // Add region to the result.\n                result.region = region;\n                manager.set_data(region, result);\n            });\n\n        this.set_data(region, entry);\n        return entry;\n    },\n\n    /**\n     * Get data from dataset.\n     */\n    get_data: function(region, mode, resolution, extra_params) {\n        // Look for entry and return if it's a deferred or if data available is compatible with mode.\n        var entry = this.get_elt(region);\n        if ( entry &&\n             ( util_mod.is_deferred(entry) || this.get('data_mode_compatible')(entry, mode) ) ) {\n            return entry;\n        }\n\n        //\n        // Look in cache for data that can be used.\n        // TODO: this logic could be improved if the visualization knew whether\n        // the data was \"index\" or \"data.\"\n        //\n        var key_ary = this.get('key_ary'),\n            obj_cache = this.get('obj_cache'),\n            entry_region, is_subregion;\n        for (var i = 0; i < key_ary.length; i++) {\n            entry_region = key_ary[i];\n\n            if (entry_region.contains(region)) {\n                is_subregion = true;\n\n                // This entry has data in the requested range. Return if data\n                // is compatible and can be subsetted.\n                entry = obj_cache[entry_region.toString()];\n                if ( util_mod.is_deferred(entry) ||\n                    ( this.get('data_mode_compatible')(entry, mode) && this.get('can_subset')(entry) ) ) {\n                    this.move_key_to_end(entry_region, i);\n\n                    // If there's data, subset it.\n                    if ( !util_mod.is_deferred(entry) ) {\n                        var subset_entry = this.subset_entry(entry, region);\n                        this.set_data(region, subset_entry);\n                        entry = subset_entry;\n                    }\n\n                    return entry;\n                }\n            }\n        }\n\n        // FIXME: There _may_ be instances where region is a subregion of another entry but cannot be\n        // subsetted. For these cases, do not increase length because region will never be found (and\n        // an infinite loop will occur.)\n        // If needed, extend region to make it minimum size.\n        if (!is_subregion && region.length() < this.attributes.min_region_size) {\n            // IDEA: alternative heuristic is to find adjacent cache entry to region and use that to extend.\n            // This would prevent bad extensions when zooming in/out while still preserving the behavior\n            // below.\n\n            // Use copy of region to avoid changing actual region.\n            region = region.copy();\n\n            // Use heuristic to extend region: extend relative to last data request.\n            var last_request = this.most_recently_added();\n            if (!last_request || (region.get('start') > last_request.get('start'))) {\n                // This request is after the last request, so extend right.\n                region.set('end', region.get('start') + this.attributes.min_region_size);\n            }\n            else {\n                // This request is after the last request, so extend left.\n                region.set('start', region.get('end') - this.attributes.min_region_size);\n            }\n\n            // Trim region to avoid invalid coordinates.\n            region.set('genome', this.attributes.genome);\n            region.trim();\n        }\n\n        return this.load_data(region, mode, resolution, extra_params);\n    },\n\n    /**\n     * Alias for set_elt for readbility.\n     */\n    set_data: function(region, entry) {\n        this.set_elt(region, entry);\n    },\n\n    /** \"Deep\" data request; used as a parameter for DataManager.get_more_data() */\n    DEEP_DATA_REQ: \"deep\",\n\n    /** \"Broad\" data request; used as a parameter for DataManager.get_more_data() */\n    BROAD_DATA_REQ: \"breadth\",\n\n    /**\n     * Gets more data for a region using either a depth-first or a breadth-first approach.\n     */\n    get_more_data: function(region, mode, resolution, extra_params, req_type) {\n        var cur_data = this._mark_stale(region);\n        if (!(cur_data && this.get('data_mode_compatible')(cur_data, mode))) {\n            console.log('ERROR: problem with getting more data: current data is not compatible');\n            return;\n        }\n\n        //\n        // Set parameters based on request type.\n        //\n        var query_low = region.get('start');\n        if (req_type === this.DEEP_DATA_REQ) {\n            // Use same interval but set start_val to skip data that's already in cur_data.\n            $.extend(extra_params, {start_val: cur_data.data.length + 1});\n        }\n        else if (req_type === this.BROAD_DATA_REQ) {\n            // To get past an area of extreme feature depth, set query low to be after either\n            // (a) the maximum high or HACK/FIXME (b) the end of the last feature returned.\n            query_low = (cur_data.max_high ? cur_data.max_high : cur_data.data[cur_data.data.length - 1][2]) + 1;\n        }\n        var query_region = region.copy().set('start', query_low);\n\n        //\n        // Get additional data, append to current data, and set new data. Use a custom deferred object\n        // to signal when new data is available.\n        //\n        var data_manager = this,\n            new_data_request = this.load_data(query_region, mode, resolution, extra_params),\n            new_data_available = $.Deferred();\n        // load_data sets cache to new_data_request, but use custom deferred object so that signal and data\n        // is all data, not just new data.\n        this.set_data(region, new_data_available);\n        $.when(new_data_request).then(function(result) {\n            // Update data and message.\n            if (result.data) {\n                result.data = cur_data.data.concat(result.data);\n                if (result.max_low) {\n                    result.max_low = cur_data.max_low;\n                }\n                if (result.message) {\n                    // HACK: replace number in message with current data length. Works but is ugly.\n                    result.message = result.message.replace(/[0-9]+/, result.data.length);\n                }\n            }\n            data_manager.set_data(region, result);\n            new_data_available.resolve(result);\n        });\n        return new_data_available;\n    },\n\n    /**\n     * Returns true if more detailed data can be obtained for entry.\n     */\n    can_get_more_detailed_data: function(region) {\n        var cur_data = this.get_elt(region);\n\n        // Can only get more detailed data for bigwig data that has less than 8000 data points.\n        // Summary tree returns *way* too much data, and 8000 data points ~ 500KB.\n        return (cur_data.dataset_type === 'bigwig' && cur_data.data.length < 8000);\n    },\n\n    /**\n     * Returns more detailed data for an entry.\n     */\n    get_more_detailed_data: function(region, mode, resolution, detail_multiplier, extra_params) {\n        // Mark current entry as stale.\n        var cur_data = this._mark_stale(region);\n        if (!cur_data) {\n            console.log(\"ERROR getting more detailed data: no current data\");\n            return;\n        }\n\n        if (!extra_params) { extra_params = {}; }\n\n        // Use additional parameters to get more detailed data.\n        if (cur_data.dataset_type === 'bigwig') {\n            // FIXME: constant should go somewhere.\n            extra_params.num_samples = 1000 * detail_multiplier;\n        }\n\n        return this.load_data(region, mode, resolution, extra_params);\n    },\n\n    /**\n     * Marks cache data as stale.\n     */\n    _mark_stale: function(region) {\n        var entry = this.get_elt(region);\n        if (!entry) {\n            console.log(\"ERROR: no data to mark as stale: \", this.get('dataset'), region.toString());\n        }\n        entry.stale = true;\n        return entry;\n    },\n\n    /**\n     * Returns an array of data with each entry representing one chromosome/contig\n     * of data or, if data is not available, returns a Deferred that resolves to the\n     * data when it becomes available.\n     */\n    get_genome_wide_data: function(genome) {\n        // -- Get all data. --\n\n        var self = this,\n            all_data_available = true,\n\n            //  Map chromosome info into genome data.\n            gw_data = _.map(genome.get('chroms_info').chrom_info, function(chrom_info) {\n                var chrom_data = self.get_elt(\n                    new GenomeRegion({\n                        chrom: chrom_info.chrom,\n                        start: 0,\n                        end: chrom_info.len\n                    })\n                );\n\n                // Set flag if data is not available.\n                if (!chrom_data) { all_data_available = false; }\n\n                return chrom_data;\n            });\n\n        // -- If all data is available, return it. --\n        if (all_data_available) {\n            return gw_data;\n        }\n\n        // -- All data is not available, so load from server. --\n\n        var deferred = $.Deferred();\n        $.getJSON(this.get('dataset').url(), { data_type: 'genome_data' }, function(genome_wide_data) {\n            self.add_data(genome_wide_data.data);\n            deferred.resolve(genome_wide_data.data);\n        });\n\n        return deferred;\n    },\n\n    /**\n     * Returns entry with only data in the subregion.\n     */\n    subset_entry: function(entry, subregion) {\n        // Dictionary from entry type to function for subsetting data.\n        var subset_fns = {\n            bigwig: function(data, subregion) {\n                return _.filter(data, function(data_point) {\n                    return data_point[0] >= subregion.get('start') &&\n                           data_point[0] <= subregion.get('end');\n                });\n            },\n            refseq: function(data, subregion) {\n                var seq_start = subregion.get('start') - entry.region.get('start');\n                return entry.data.slice(seq_start, seq_start + subregion.length());\n            }\n        };\n\n        // Subset entry if there is a function for subsetting and regions are not the same.\n        var subregion_data = entry.data;\n        if (!entry.region.same(subregion) && entry.dataset_type in subset_fns) {\n            subregion_data = subset_fns[entry.dataset_type](entry.data, subregion);\n        }\n\n        // Return entry with subregion's data.\n        return {\n            region: subregion,\n            data: subregion_data,\n            dataset_type: entry.dataset_type\n        };\n    }\n});\n\nvar GenomeReferenceDataManager = GenomeDataManager.extend({\n    initialize: function(options) {\n        // Use generic object in place of dataset and set urlRoot to fetch data.\n        var dataset_placeholder = new Backbone.Model();\n        dataset_placeholder.urlRoot = options.data_url;\n        this.set('dataset', dataset_placeholder);\n    },\n\n    load_data: function(region, mode, resolution, extra_params) {\n        // Fetch data if region is not too large.\n        return ( region.length() <= 100000 ?\n                 GenomeDataManager.prototype.load_data.call(this, region, mode, resolution, extra_params) :\n                 { data: null, region: region } );\n    }\n});\n\n/**\n * A genome build.\n */\nvar Genome = Backbone.Model.extend({\n    defaults: {\n        name: null,\n        key: null,\n        chroms_info: null\n    },\n\n    initialize: function(options) {\n        this.id = options.dbkey;\n    },\n\n    /**\n     * Shorthand for getting to chromosome information.\n     */\n    get_chroms_info: function() {\n        return this.attributes.chroms_info.chrom_info;\n    },\n\n    /**\n     * Returns a GenomeRegion object denoting a complete chromosome.\n     */\n    get_chrom_region: function(chr_name) {\n        // FIXME: use findWhere in underscore 1.4\n        var chrom_info = _.find(this.get_chroms_info(), function(chrom_info) {\n            return chrom_info.chrom === chr_name;\n        });\n        return new GenomeRegion({\n            chrom: chrom_info.chrom,\n            end: chrom_info.len\n        });\n    },\n\n    /** Returns the length of a chromosome. */\n    get_chrom_len: function(chr_name) {\n        // FIXME: use findWhere in underscore 1.4\n        return _.find(this.get_chroms_info(), function(chrom_info) {\n            return chrom_info.chrom === chr_name;\n        }).len;\n    }\n});\n\n/**\n * A genomic region.\n */\nvar GenomeRegion = Backbone.Model.extend({\n    defaults: {\n        chrom: null,\n        start: 0,\n        end: 0,\n        str_val: null,\n        genome: null\n    },\n\n    /**\n     * Returns true if this region is the same as a given region.\n     * It does not test the genome right now.\n     */\n    same: function(region) {\n        return this.attributes.chrom === region.get('chrom') &&\n               this.attributes.start === region.get('start') &&\n               this.attributes.end === region.get('end');\n    },\n\n    /**\n     * If from_str specified, use it to initialize attributes.\n     */\n    initialize: function(options) {\n        if (options.from_str) {\n            var pieces = options.from_str.split(':'),\n                chrom = pieces[0],\n                start_end = pieces[1].split('-');\n            this.set({\n                chrom: chrom,\n                start: parseInt(start_end[0], 10),\n                end: parseInt(start_end[1], 10)\n            });\n        }\n\n        // Keep a copy of region's string value for fast lookup.\n        this.attributes.str_val = this.get('chrom') + \":\" + this.get('start') + \"-\" + this.get('end');\n\n        // Set str_val on attribute change.\n        this.on('change', function() {\n            this.attributes.str_val = this.get('chrom') + \":\" + this.get('start') + \"-\" + this.get('end');\n        }, this);\n    },\n\n    copy: function() {\n        return new GenomeRegion({\n            chrom: this.get('chrom'),\n            start: this.get('start'),\n            end: this.get('end')\n        });\n    },\n\n    length: function() {\n        return this.get('end') - this.get('start');\n    },\n\n    /** Returns region in canonical form chrom:start-end */\n    toString: function() {\n        return this.attributes.str_val;\n    },\n\n    toJSON: function() {\n        return {\n            chrom: this.get('chrom'),\n            start: this.get('start'),\n            end: this.get('end')\n        };\n    },\n\n    /**\n     * Compute the type of overlap between this region and another region. The overlap is computed relative to the given/second region;\n     * hence, OVERLAP_START indicates that the first region overlaps the start (but not the end) of the second region.\n     */\n    compute_overlap: function(a_region) {\n        var first_chrom = this.get('chrom'), second_chrom = a_region.get('chrom'),\n            first_start = this.get('start'), second_start = a_region.get('start'),\n            first_end = this.get('end'), second_end = a_region.get('end'),\n            overlap;\n\n        // Compare chroms.\n        if (first_chrom && second_chrom && first_chrom !== second_chrom) {\n            return GenomeRegion.overlap_results.DIF_CHROMS;\n        }\n\n        // Compare regions.\n        if (first_start < second_start) {\n            if (first_end < second_start) {\n                overlap = GenomeRegion.overlap_results.BEFORE;\n            }\n            else if (first_end < second_end) {\n                overlap = GenomeRegion.overlap_results.OVERLAP_START;\n            }\n            else { // first_end >= second_end\n                overlap = GenomeRegion.overlap_results.CONTAINS;\n            }\n        }\n        else if (first_start > second_start) {\n            if (first_start > second_end) {\n                overlap = GenomeRegion.overlap_results.AFTER;\n            }\n            else if (first_end <= second_end) {\n                overlap = GenomeRegion.overlap_results.CONTAINED_BY;\n            }\n            else {\n                overlap = GenomeRegion.overlap_results.OVERLAP_END;\n            }\n        }\n        else { // first_start === second_start\n            overlap = (first_end >= second_end ?\n                       GenomeRegion.overlap_results.CONTAINS :\n                       GenomeRegion.overlap_results.CONTAINED_BY);\n        }\n\n        return overlap;\n    },\n\n    /**\n     * Trim a region to match genome's constraints.\n     */\n    trim: function(genome) {\n        // Assume that all chromosome/contigs start at 0.\n        if (this.attributes.start < 0) {\n            this.attributes.start = 0;\n        }\n\n        // Only try to trim the end if genome is set.\n        if (this.attributes.genome) {\n            var chrom_len = this.attributes.genome.get_chrom_len(this.attributes.chrom);\n            if (this.attributes.end > chrom_len) {\n                this.attributes.end = chrom_len - 1;\n            }\n        }\n\n        return this;\n    },\n\n    /**\n     * Returns true if this region contains a given region.\n     */\n    contains: function(a_region) {\n        return this.compute_overlap(a_region) === GenomeRegion.overlap_results.CONTAINS;\n    },\n\n    /**\n     * Returns true if regions overlap.\n     */\n    overlaps: function(a_region) {\n        return _.intersection( [this.compute_overlap(a_region)],\n                               [GenomeRegion.overlap_results.DIF_CHROMS, GenomeRegion.overlap_results.BEFORE, GenomeRegion.overlap_results.AFTER] ).length === 0;\n    }\n},\n{\n    overlap_results: {\n        DIF_CHROMS: 1000,\n        BEFORE: 1001,\n        CONTAINS: 1002,\n        OVERLAP_START: 1003,\n        OVERLAP_END: 1004,\n        CONTAINED_BY: 1005,\n        AFTER: 1006\n    }\n});\n\nvar GenomeRegionCollection = Backbone.Collection.extend({\n    model: GenomeRegion\n});\n\n/**\n * A genome browser bookmark.\n */\nvar BrowserBookmark = Backbone.Model.extend({\n    defaults: {\n        region: null,\n        note: ''\n    },\n\n    initialize: function(options) {\n        this.set('region', new GenomeRegion(options.region));\n    }\n});\n\n/**\n * Bookmarks collection.\n */\nvar BrowserBookmarkCollection = Backbone.Collection.extend({\n    model: BrowserBookmark\n});\n\n/**\n * A track of data in a genome visualization.\n */\n// TODO: rename to Track and merge with Trackster's Track object.\nvar BackboneTrack = Backbone.Model.extend(CustomToJSON).extend({\n    defaults: {\n        mode: 'Auto'\n    },\n\n    initialize: function(options) {\n        this.set('dataset', new data_mod.Dataset(options.dataset));\n\n        // -- Set up config settings. --\n        var models =  [\n            { key: 'name', default_value: this.get('dataset').get('name') },\n            { key: 'color' },\n            { key: 'min_value', label: 'Min Value', type: 'float', default_value: 0 },\n            { key: 'max_value', label: 'Max Value', type: 'float', default_value: 1 }\n        ];\n\n        this.set('config', config_mod.ConfigSettingCollection.from_models_and_saved_values(models, options.prefs));\n\n        // -- Set up data manager. --\n        var preloaded_data = this.get('preloaded_data');\n        if (preloaded_data) {\n            preloaded_data = preloaded_data.data;\n        }\n        else {\n            preloaded_data = [];\n        }\n        this.set('data_manager', new GenomeDataManager({\n            dataset: this.get('dataset'),\n            init_data: preloaded_data\n        }));\n    }\n},\n{\n    // This definition matches that produced by to_dict() methods in tracks.js\n    to_json_keys: [\n        'track_type',\n        'dataset',\n        'prefs',\n        'mode',\n        'filters',\n        'tool_state'\n    ],\n    to_json_mappers: {\n        prefs: function(p, self) {\n            if (_.size(p) === 0) {\n                p = {\n                    name: self.get('config').get('name').get('value'),\n                    color: self.get('config').get('color').get('value')\n                };\n            }\n            return p;\n        },\n        dataset: function(d) {\n            return {\n                id: d.id,\n                hda_ldda: d.get('hda_ldda')\n            };\n        }\n    }\n});\n\nvar BackboneTrackCollection = Backbone.Collection.extend({\n    model: BackboneTrack\n});\n\n/**\n * A visualization.\n */\nvar Visualization = Backbone.Model.extend({\n    defaults: {\n        title: '',\n        type: ''\n    },\n\n    urlRoot: Galaxy.root + \"api/visualizations\",\n\n    /**\n     * POSTs visualization's JSON to its URL using the parameter 'vis_json'\n     * Note: This is necessary because (a) Galaxy requires keyword args and\n     * (b) Galaxy does not handle PUT now.\n     */\n    save: function() {\n        return $.ajax({\n            url: this.url(),\n            type: \"POST\",\n            dataType: \"json\",\n            data: {\n                vis_json: JSON.stringify(this)\n            }\n        });\n    }\n});\n\n/**\n * A visualization of genome data.\n */\nvar GenomeVisualization = Visualization.extend(CustomToJSON).extend({\n    defaults: _.extend({}, Visualization.prototype.defaults, {\n        dbkey: '',\n        drawables: null,\n        bookmarks: null,\n        viewport: null\n    }),\n\n    initialize: function(options) {\n        // Replace drawables with tracks.\n        this.set('drawables', new BackboneTrackCollection(options.tracks));\n\n        var models = [];\n        this.set('config', config_mod.ConfigSettingCollection.from_models_and_saved_values(models, options.prefs));\n\n        // Clear track and data definitions to avoid storing large objects.\n        this.unset('tracks');\n        this.get('drawables').each(function(d) {\n            d.unset('preloaded_data');\n        });\n    },\n\n    /**\n     * Add a track or array of tracks to the visualization.\n     */\n    add_tracks: function(tracks) {\n        this.get('drawables').add(tracks);\n    }\n},\n{\n    // This definition matches that produced by to_dict() methods in tracks.js\n    to_json_keys: [\n        'view',\n        'viewport',\n        'bookmarks'\n    ],\n\n    to_json_mappers: {\n        'view': function(dummy, self) {\n            return {\n                obj_type: 'View',\n                prefs: {\n                    name: self.get('title'),\n                    content_visible: true\n                },\n                drawables: self.get('drawables')\n            };\n        }\n    }\n}\n);\n\n/**\n * -- Routers --\n */\n\n/**\n * Router for track browser.\n */\nvar TrackBrowserRouter = Backbone.Router.extend({\n    initialize: function(options) {\n        this.view = options.view;\n\n        // Can't put regular expression in routes dictionary.\n        // NOTE: parentheses are used to denote parameters returned to callback.\n        this.route(/([\\w]+)$/, 'change_location');\n        this.route(/([\\w\\+]+\\:[\\d,]+-[\\d,]+)$/, 'change_location');\n\n        // Handle navigate events from view.\n        var self = this;\n        self.view.on(\"navigate\", function(new_loc) {\n            self.navigate(new_loc);\n        });\n    },\n\n    change_location: function(new_loc) {\n        this.view.go_to(new_loc);\n    }\n});\n\nreturn {\n    BackboneTrack: BackboneTrack,\n    BrowserBookmark: BrowserBookmark,\n    BrowserBookmarkCollection: BrowserBookmarkCollection,\n    Cache: Cache,\n    CanvasManager: CanvasManager,\n    Genome: Genome,\n    GenomeDataManager: GenomeDataManager,\n    GenomeRegion: GenomeRegion,\n    GenomeRegionCollection: GenomeRegionCollection,\n    GenomeVisualization: GenomeVisualization,\n    GenomeReferenceDataManager: GenomeReferenceDataManager,\n    TrackBrowserRouter: TrackBrowserRouter,\n    Visualization: Visualization,\n    select_datasets: select_datasets\n};\n\n});"]}