{"version":3,"sources":["viz/visualization.js"],"names":["_","CustomToJSON","toJSON","self","this","json","each","constructor","to_json_keys","k","val","get","to_json_mappers","requests","url","dataType","data","data_type","dummy_canvas","new_canvas","dummy_context","getContext","font","default_font","char_width_px","measureText","width","patterns","load_pattern","track_defs","arg","success_fn","extend","CanvasManager","prototype","key","path","image","Image","src","Galaxy","root","onload","get_pattern","canvas","Backbone","num_elements","obj_cache","initialize","options","manager","attributes","key_ary","key_str","toString","index","indexOf","defaults","stale","splice","move_key_to_end","set_elt","length","shift","push","value","clear","deleted_key","size","GenomeDataManager","Cache","dataset","genome","init_data","filters_manager","data_mode_compatible","entry","mode","call","initial_entries","entries","can_subset","set_data","region","data_is_ready","ready_deferred","$","Deferred","query_type","ss_deferred","_util2","default","ServerStateDeferred","ajax_settings","interval","response","when","go","then","resolve","hda_ldda","query","getJSON","params","load_data","resolution","extra_params","chrom","filter_names","i","filters","name","JSON","stringify","high","result","get_data","get_elt","entry_region","contains","is_subregion","is_deferred","subset_entry","min_region_size","copy","last_request","set","DEEP_DATA_REQ","BROAD_DATA_REQ","get_more_data","cur_data","_mark_stale","query_low","start_val","req_type","max_high","query_region","data_manager","new_data_request","new_data_available","max_low","message","replace","can_get_more_detailed_data","dataset_type","console","detail_multiplier","num_samples","gw_data","map","all_data_available","start","end","chrom_info","chrom_data","get_genome_wide_data","deferred","genome_wide_data","GenomeRegion","len","subset_fns","subregion_data","add_data","subregion","dataset_placeholder","bigwig","filter","data_point","refseq","seq_start","slice","dbkey","GenomeReferenceDataManager","chr_name","Model","get_chroms_info","str_val","chroms_info","same","parseInt","get_chrom_len","find","second_end","a_region","overlap","from_str","pieces","split","first_chrom","second_chrom","start_end","overlap_results","OVERLAP_START","on","first_end","trim","compute_overlap","first_start","second_start","overlaps","DIF_CHROMS","OVERLAP_END","CONTAINED_BY","BEFORE","AFTER","CONTAINS","chrom_len","label","type","default_value","preloaded_data","intersection","prefs","p","color","Collection","model","BackboneTrack","note","Visualization","BrowserBookmarkCollection","BrowserBookmark","vis_json","_data2","Dataset","models","GenomeVisualization","drawables","viewport","d","_config2","ConfigSettingCollection","from_models_and_saved_values","view","obj_type","TrackBrowserRouter","change_location","go_to","select_datasets","urlRoot","save","ajax","bookmarks","BackboneTrackCollection","tracks","unset","add_tracks","add","dummy","content_visible","Router","route","new_loc","navigate","Genome","GenomeRegionCollection","history_grid","_gridView2","url_base","dict_format","tabs","_uiTabs2","View","id","title","$el","append","library_grid","modal","show","body","closing_events","buttons","Cancel","hide","Add","window","log","current","apply","arguments"],"mappings":"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","file":"../../scripts/viz/visualization.js","sourcesContent":["import * as _ from \"libs/underscore\";\nimport data_mod from \"mvc/dataset/data\";\nimport util_mod from \"viz/trackster/util\";\nimport config_mod from \"utils/config\";\nimport GridView from \"mvc/grid/grid-view\";\nimport Tabs from \"mvc/ui/ui-tabs\";\nimport Ui from \"mvc/ui/ui-misc\";\n/**\n * Mixin for returning custom JSON representation from toJSON. Class attribute to_json_keys defines a set of attributes\n * to include in the representation; to_json_mappers defines mappers for returned objects.\n */\nvar CustomToJSON = {\n    /**\n     * Returns JSON representation of object using to_json_keys and to_json_mappers.\n     */\n    toJSON: function() {\n        var self = this;\n        var json = {};\n        _.each(self.constructor.to_json_keys, k => {\n            var val = self.get(k);\n            if (k in self.constructor.to_json_mappers) {\n                val = self.constructor.to_json_mappers[k](val, self);\n            }\n            json[k] = val;\n        });\n        return json;\n    }\n};\n\n/**\n * Model, view, and controller objects for Galaxy visualization framework.\n *\n * Models have no references to views, instead using events to indicate state\n * changes; this is advantageous because multiple views can use the same object\n * and models can be used without views.\n */\n\n/**\n * Use a popup grid to select datasets from histories or libraries. After datasets are selected,\n * track definitions are obtained from the server and the success_fn is called with the list of\n * definitions for selected datasets.\n */\nvar select_datasets = (filters, success_fn) => {\n    // history dataset selection tab\n    var history_grid = new GridView({\n        url_base: `${Galaxy.root}visualization/list_history_datasets`,\n        filters: filters,\n        dict_format: true,\n        embedded: true\n    });\n\n    // library dataset selection tab\n    var library_grid = new GridView({\n        url_base: `${Galaxy.root}visualization/list_library_datasets`,\n        dict_format: true,\n        embedded: true\n    });\n\n    // build tabs\n    var tabs = new Tabs.View();\n    tabs.add({\n        id: \"histories\",\n        title: \"Histories\",\n        $el: $(\"<div/>\").append(history_grid.$el)\n    });\n    tabs.add({\n        id: \"libraries\",\n        title: \"Libraries\",\n        $el: $(\"<div/>\").append(library_grid.$el)\n    });\n\n    // modal\n    Galaxy.modal.show({\n        title: \"Select datasets for new tracks\",\n        body: tabs.$el,\n        closing_events: true,\n        buttons: {\n            Cancel: function() {\n                Galaxy.modal.hide();\n            },\n            Add: function() {\n                var requests = [];\n                tabs\n                    .$(\"input.grid-row-select-checkbox[name=id]:checked\")\n                    .each(function() {\n                        window.console.log($(this).val());\n                        requests[requests.length] = $.ajax({\n                            url: `${Galaxy.root}api/datasets/${$(this).val()}`,\n                            dataType: \"json\",\n                            data: {\n                                data_type: \"track_config\",\n                                hda_ldda:\n                                    tabs.current() == \"histories\"\n                                        ? \"hda\"\n                                        : \"ldda\"\n                            }\n                        });\n                    });\n                // To preserve order, wait until there are definitions for all tracks and then add\n                // them sequentially.\n                $.when.apply($, requests).then(function() {\n                    // jQuery always returns an Array for arguments, so need to look at first element\n                    // to determine whether multiple requests were made and consequently how to\n                    // map arguments to track definitions.\n                    var track_defs =\n                        arguments[0] instanceof Array\n                            ? $.map(arguments, arg => arg[0])\n                            : [arguments[0]];\n                    success_fn(track_defs);\n                });\n                Galaxy.modal.hide();\n            }\n        }\n    });\n};\n\n// --------- Models ---------\n\n/**\n * Canvas manager is used to create canvases for browsers as well as providing a pattern cache\n */\nvar CanvasManager = function(default_font) {\n    this.default_font =\n        default_font !== undefined\n            ? default_font\n            : \"9px Monaco, Lucida Console, monospace\";\n\n    this.dummy_canvas = this.new_canvas();\n    this.dummy_context = this.dummy_canvas.getContext(\"2d\");\n    this.dummy_context.font = this.default_font;\n\n    this.char_width_px = this.dummy_context.measureText(\"A\").width;\n\n    this.patterns = {};\n\n    // FIXME: move somewhere to make this more general\n    this.load_pattern(\"right_strand\", \"/visualization/strand_right.png\");\n    this.load_pattern(\"left_strand\", \"/visualization/strand_left.png\");\n    this.load_pattern(\n        \"right_strand_inv\",\n        \"/visualization/strand_right_inv.png\"\n    );\n    this.load_pattern(\"left_strand_inv\", \"/visualization/strand_left_inv.png\");\n};\n\n_.extend(CanvasManager.prototype, {\n    load_pattern: function(key, path) {\n        var patterns = this.patterns;\n        var dummy_context = this.dummy_context;\n        var image = new Image();\n        image.src = `${Galaxy.root}static/images${path}`;\n        image.onload = () => {\n            patterns[key] = dummy_context.createPattern(image, \"repeat\");\n        };\n    },\n    get_pattern: function(key) {\n        return this.patterns[key];\n    },\n    new_canvas: function() {\n        var canvas = $(\"<canvas/>\")[0];\n        // Keep a reference back to the manager\n        canvas.manager = this;\n        return canvas;\n    }\n});\n\n/**\n * Generic cache that handles key/value pairs. Keys can be any object that can be\n * converted to a String and compared.\n */\nvar Cache = Backbone.Model.extend({\n    defaults: {\n        num_elements: 20,\n        // Objects in cache; indexes into cache are strings of keys.\n        obj_cache: null,\n        // key_ary contains keys for objects in cache.\n        key_ary: null\n    },\n\n    initialize: function(options) {\n        this.clear();\n    },\n\n    /**\n     * Get an element from the cache using its key.\n     */\n    get_elt: function(key) {\n        var obj_cache = this.attributes.obj_cache;\n        var key_ary = this.attributes.key_ary;\n        var key_str = key.toString();\n\n        var index = _.indexOf(key_ary, k => k.toString() === key_str);\n\n        // Update cache.\n        if (index !== -1) {\n            // Object is in cache, so update it.\n            if (obj_cache[key_str].stale) {\n                // Object is stale: remove key and object.\n                key_ary.splice(index, 1);\n                delete obj_cache[key_str];\n            } else {\n                // Move key to back because it is most recently used.\n                this.move_key_to_end(key, index);\n            }\n        }\n\n        return obj_cache[key_str];\n    },\n\n    /**\n     * Put an element into the cache.\n     */\n    set_elt: function(key, value) {\n        var obj_cache = this.attributes.obj_cache;\n        var key_ary = this.attributes.key_ary;\n        var key_str = key.toString();\n        var num_elements = this.attributes.num_elements;\n\n        // Update keys, objects.\n        if (!obj_cache[key_str]) {\n            // Add object to cache.\n\n            if (key_ary.length >= num_elements) {\n                // Cache full, so remove first element.\n                var deleted_key = key_ary.shift();\n                delete obj_cache[deleted_key.toString()];\n            }\n\n            // Add key.\n            key_ary.push(key);\n        }\n\n        // Add object.\n        obj_cache[key_str] = value;\n        return value;\n    },\n\n    /**\n     * Move key to end of cache. Keys are removed from the front, so moving a key to the end\n     * delays the key's removal.\n     */\n    move_key_to_end: function(key, index) {\n        this.attributes.key_ary.splice(index, 1);\n        this.attributes.key_ary.push(key);\n    },\n\n    /**\n     * Clear all elements from the cache.\n     */\n    clear: function() {\n        this.attributes.obj_cache = {};\n        this.attributes.key_ary = [];\n    },\n\n    /** Returns the number of elements in the cache. */\n    size: function() {\n        return this.attributes.key_ary.length;\n    },\n\n    /** Returns key most recently added to cache. */\n    most_recently_added: function() {\n        return this.size() === 0\n            ? null\n            : // Most recent key is at the end of key array.\n              this.attributes.key_ary[this.attributes.key_ary.length - 1];\n    }\n});\n\n/**\n * Data manager for genomic data. Data is connected to and queryable by genomic regions.\n */\nvar GenomeDataManager = Cache.extend({\n    defaults: _.extend({}, Cache.prototype.defaults, {\n        dataset: null,\n        genome: null,\n        init_data: null,\n        min_region_size: 200,\n        filters_manager: null,\n        data_type: \"data\",\n        data_mode_compatible: function(entry, mode) {\n            return true;\n        },\n        can_subset: function(entry) {\n            return false;\n        }\n    }),\n\n    /**\n     * Initialization.\n     */\n    initialize: function(options) {\n        Cache.prototype.initialize.call(this);\n\n        // Set initial entries in data manager.\n        var initial_entries = this.get(\"init_data\");\n        if (initial_entries) {\n            this.add_data(initial_entries);\n        }\n    },\n\n    /**\n     * Add data entries to manager; each entry should be a dict with attributes region (key), data, and data_type.\n     * If necessary, manager size is increased to hold all data.\n     */\n    add_data: function(entries) {\n        // Increase size to accomodate all entries.\n        if (this.get(\"num_elements\") < entries.length) {\n            this.set(\"num_elements\", entries.length);\n        }\n\n        // Put data into manager.\n        var self = this;\n        _.each(entries, entry => {\n            self.set_data(entry.region, entry);\n        });\n    },\n\n    /**\n     * Returns deferred that resolves to true when dataset is ready (or false if dataset\n     * cannot be used).\n     */\n    data_is_ready: function() {\n        var dataset = this.get(\"dataset\");\n        var ready_deferred = $.Deferred();\n\n        var // If requesting raw data, query dataset state; if requesting (converted) data,\n        // need to query converted datasets state.\n        query_type =\n            this.get(\"data_type\") === \"raw_data\"\n                ? \"state\"\n                : this.get(\"data_type\") === \"data\"\n                  ? \"converted_datasets_state\"\n                  : \"error\";\n\n        var ss_deferred = new util_mod.ServerStateDeferred({\n            ajax_settings: {\n                url: this.get(\"dataset\").url(),\n                data: {\n                    hda_ldda: dataset.get(\"hda_ldda\"),\n                    data_type: query_type\n                },\n                dataType: \"json\"\n            },\n            interval: 5000,\n            success_fn: function(response) {\n                return response !== \"pending\";\n            }\n        });\n\n        $.when(ss_deferred.go()).then(response => {\n            ready_deferred.resolve(response === \"ok\" || response === \"data\");\n        });\n        return ready_deferred;\n    },\n\n    /**\n     * Perform a feature search from server; returns Deferred object that resolves when data is available.\n     */\n    search_features: function(query) {\n        var dataset = this.get(\"dataset\");\n\n        var params = {\n            query: query,\n            hda_ldda: dataset.get(\"hda_ldda\"),\n            data_type: \"features\"\n        };\n\n        return $.getJSON(dataset.url(), params);\n    },\n\n    /**\n     * Load data from server and manages data entries. Adds a Deferred to manager\n     * for region; when data becomes available, replaces Deferred with data.\n     * Returns the Deferred that resolves when data is available.\n     */\n    load_data: function(region, mode, resolution, extra_params) {\n        // Setup data request params.\n        var dataset = this.get(\"dataset\");\n\n        var params = {\n            data_type: this.get(\"data_type\"),\n            chrom: region.get(\"chrom\"),\n            low: region.get(\"start\"),\n            high: region.get(\"end\"),\n            mode: mode,\n            resolution: resolution,\n            hda_ldda: dataset.get(\"hda_ldda\")\n        };\n\n        $.extend(params, extra_params);\n\n        // Add track filters to params.\n        var filters_manager = this.get(\"filters_manager\");\n        if (filters_manager) {\n            var filter_names = [];\n            var filters = filters_manager.filters;\n            for (var i = 0; i < filters.length; i++) {\n                filter_names.push(filters[i].name);\n            }\n            params.filter_cols = JSON.stringify(filter_names);\n        }\n\n        // Do request.\n        var manager = this;\n\n        var entry = $.getJSON(dataset.url(), params, result => {\n            // Add region to the result.\n            result.region = region;\n            manager.set_data(region, result);\n        });\n\n        this.set_data(region, entry);\n        return entry;\n    },\n\n    /**\n     * Get data from dataset.\n     */\n    get_data: function(region, mode, resolution, extra_params) {\n        // Look for entry and return if it's a deferred or if data available is compatible with mode.\n        var entry = this.get_elt(region);\n        if (\n            entry &&\n            (util_mod.is_deferred(entry) ||\n                this.get(\"data_mode_compatible\")(entry, mode))\n        ) {\n            return entry;\n        }\n\n        //\n        // Look in cache for data that can be used.\n        // TODO: this logic could be improved if the visualization knew whether\n        // the data was \"index\" or \"data.\"\n        //\n        var key_ary = this.get(\"key_ary\");\n\n        var obj_cache = this.get(\"obj_cache\");\n        var entry_region;\n        var is_subregion;\n        for (var i = 0; i < key_ary.length; i++) {\n            entry_region = key_ary[i];\n\n            if (entry_region.contains(region)) {\n                is_subregion = true;\n\n                // This entry has data in the requested range. Return if data\n                // is compatible and can be subsetted.\n                entry = obj_cache[entry_region.toString()];\n                if (\n                    util_mod.is_deferred(entry) ||\n                    (this.get(\"data_mode_compatible\")(entry, mode) &&\n                        this.get(\"can_subset\")(entry))\n                ) {\n                    this.move_key_to_end(entry_region, i);\n\n                    // If there's data, subset it.\n                    if (!util_mod.is_deferred(entry)) {\n                        var subset_entry = this.subset_entry(entry, region);\n                        this.set_data(region, subset_entry);\n                        entry = subset_entry;\n                    }\n\n                    return entry;\n                }\n            }\n        }\n\n        // FIXME: There _may_ be instances where region is a subregion of another entry but cannot be\n        // subsetted. For these cases, do not increase length because region will never be found (and\n        // an infinite loop will occur.)\n        // If needed, extend region to make it minimum size.\n        if (\n            !is_subregion &&\n            region.length() < this.attributes.min_region_size\n        ) {\n            // IDEA: alternative heuristic is to find adjacent cache entry to region and use that to extend.\n            // This would prevent bad extensions when zooming in/out while still preserving the behavior\n            // below.\n\n            // Use copy of region to avoid changing actual region.\n            region = region.copy();\n\n            // Use heuristic to extend region: extend relative to last data request.\n            var last_request = this.most_recently_added();\n            if (\n                !last_request ||\n                region.get(\"start\") > last_request.get(\"start\")\n            ) {\n                // This request is after the last request, so extend right.\n                region.set(\n                    \"end\",\n                    region.get(\"start\") + this.attributes.min_region_size\n                );\n            } else {\n                // This request is after the last request, so extend left.\n                region.set(\n                    \"start\",\n                    region.get(\"end\") - this.attributes.min_region_size\n                );\n            }\n\n            // Trim region to avoid invalid coordinates.\n            region.set(\"genome\", this.attributes.genome);\n            region.trim();\n        }\n\n        return this.load_data(region, mode, resolution, extra_params);\n    },\n\n    /**\n     * Alias for set_elt for readbility.\n     */\n    set_data: function(region, entry) {\n        this.set_elt(region, entry);\n    },\n\n    /** \"Deep\" data request; used as a parameter for DataManager.get_more_data() */\n    DEEP_DATA_REQ: \"deep\",\n\n    /** \"Broad\" data request; used as a parameter for DataManager.get_more_data() */\n    BROAD_DATA_REQ: \"breadth\",\n\n    /**\n     * Gets more data for a region using either a depth-first or a breadth-first approach.\n     */\n    get_more_data: function(region, mode, resolution, extra_params, req_type) {\n        var cur_data = this._mark_stale(region);\n        if (!(cur_data && this.get(\"data_mode_compatible\")(cur_data, mode))) {\n            console.log(\n                \"ERROR: problem with getting more data: current data is not compatible\"\n            );\n            return;\n        }\n\n        //\n        // Set parameters based on request type.\n        //\n        var query_low = region.get(\"start\");\n        if (req_type === this.DEEP_DATA_REQ) {\n            // Use same interval but set start_val to skip data that's already in cur_data.\n            $.extend(extra_params, {\n                start_val: cur_data.data.length + 1\n            });\n        } else if (req_type === this.BROAD_DATA_REQ) {\n            // To get past an area of extreme feature depth, set query low to be after either\n            // (a) the maximum high or HACK/FIXME (b) the end of the last feature returned.\n            query_low =\n                (cur_data.max_high\n                    ? cur_data.max_high\n                    : cur_data.data[cur_data.data.length - 1][2]) + 1;\n        }\n        var query_region = region.copy().set(\"start\", query_low);\n\n        //\n        // Get additional data, append to current data, and set new data. Use a custom deferred object\n        // to signal when new data is available.\n        //\n        var data_manager = this;\n\n        var new_data_request = this.load_data(\n            query_region,\n            mode,\n            resolution,\n            extra_params\n        );\n\n        var new_data_available = $.Deferred();\n        // load_data sets cache to new_data_request, but use custom deferred object so that signal and data\n        // is all data, not just new data.\n        this.set_data(region, new_data_available);\n        $.when(new_data_request).then(result => {\n            // Update data and message.\n            if (result.data) {\n                result.data = cur_data.data.concat(result.data);\n                if (result.max_low) {\n                    result.max_low = cur_data.max_low;\n                }\n                if (result.message) {\n                    // HACK: replace number in message with current data length. Works but is ugly.\n                    result.message = result.message.replace(\n                        /[0-9]+/,\n                        result.data.length\n                    );\n                }\n            }\n            data_manager.set_data(region, result);\n            new_data_available.resolve(result);\n        });\n        return new_data_available;\n    },\n\n    /**\n     * Returns true if more detailed data can be obtained for entry.\n     */\n    can_get_more_detailed_data: function(region) {\n        var cur_data = this.get_elt(region);\n\n        // Can only get more detailed data for bigwig data that has less than 8000 data points.\n        // Summary tree returns *way* too much data, and 8000 data points ~ 500KB.\n        return (\n            cur_data.dataset_type === \"bigwig\" && cur_data.data.length < 8000\n        );\n    },\n\n    /**\n     * Returns more detailed data for an entry.\n     */\n    get_more_detailed_data: function(\n        region,\n        mode,\n        resolution,\n        detail_multiplier,\n        extra_params\n    ) {\n        // Mark current entry as stale.\n        var cur_data = this._mark_stale(region);\n        if (!cur_data) {\n            console.log(\"ERROR getting more detailed data: no current data\");\n            return;\n        }\n\n        if (!extra_params) {\n            extra_params = {};\n        }\n\n        // Use additional parameters to get more detailed data.\n        if (cur_data.dataset_type === \"bigwig\") {\n            // FIXME: constant should go somewhere.\n            extra_params.num_samples = 1000 * detail_multiplier;\n        }\n\n        return this.load_data(region, mode, resolution, extra_params);\n    },\n\n    /**\n     * Marks cache data as stale.\n     */\n    _mark_stale: function(region) {\n        var entry = this.get_elt(region);\n        if (!entry) {\n            console.log(\n                \"ERROR: no data to mark as stale: \",\n                this.get(\"dataset\"),\n                region.toString()\n            );\n        }\n        entry.stale = true;\n        return entry;\n    },\n\n    /**\n     * Returns an array of data with each entry representing one chromosome/contig\n     * of data or, if data is not available, returns a Deferred that resolves to the\n     * data when it becomes available.\n     */\n    get_genome_wide_data: function(genome) {\n        // -- Get all data. --\n\n        var self = this;\n\n        var all_data_available = true;\n\n        var //  Map chromosome info into genome data.\n        gw_data = _.map(genome.get(\"chroms_info\").chrom_info, chrom_info => {\n            var chrom_data = self.get_elt(\n                new GenomeRegion({\n                    chrom: chrom_info.chrom,\n                    start: 0,\n                    end: chrom_info.len\n                })\n            );\n\n            // Set flag if data is not available.\n            if (!chrom_data) {\n                all_data_available = false;\n            }\n\n            return chrom_data;\n        });\n\n        // -- If all data is available, return it. --\n        if (all_data_available) {\n            return gw_data;\n        }\n\n        // -- All data is not available, so load from server. --\n\n        var deferred = $.Deferred();\n        $.getJSON(\n            this.get(\"dataset\").url(),\n            { data_type: \"genome_data\" },\n            genome_wide_data => {\n                self.add_data(genome_wide_data.data);\n                deferred.resolve(genome_wide_data.data);\n            }\n        );\n\n        return deferred;\n    },\n\n    /**\n     * Returns entry with only data in the subregion.\n     */\n    subset_entry: function(entry, subregion) {\n        // Dictionary from entry type to function for subsetting data.\n        var subset_fns = {\n            bigwig: function(data, subregion) {\n                return _.filter(\n                    data,\n                    data_point =>\n                        data_point[0] >= subregion.get(\"start\") &&\n                        data_point[0] <= subregion.get(\"end\")\n                );\n            },\n            refseq: function(data, subregion) {\n                var seq_start =\n                    subregion.get(\"start\") - entry.region.get(\"start\");\n                return entry.data.slice(\n                    seq_start,\n                    seq_start + subregion.length()\n                );\n            }\n        };\n\n        // Subset entry if there is a function for subsetting and regions are not the same.\n        var subregion_data = entry.data;\n        if (!entry.region.same(subregion) && entry.dataset_type in subset_fns) {\n            subregion_data = subset_fns[entry.dataset_type](\n                entry.data,\n                subregion\n            );\n        }\n\n        // Return entry with subregion's data.\n        return {\n            region: subregion,\n            data: subregion_data,\n            dataset_type: entry.dataset_type\n        };\n    }\n});\n\nvar GenomeReferenceDataManager = GenomeDataManager.extend({\n    initialize: function(options) {\n        // Use generic object in place of dataset and set urlRoot to fetch data.\n        var dataset_placeholder = new Backbone.Model();\n        dataset_placeholder.urlRoot = options.data_url;\n        this.set(\"dataset\", dataset_placeholder);\n    },\n\n    load_data: function(region, mode, resolution, extra_params) {\n        // Fetch data if region is not too large.\n        return region.length() <= 100000\n            ? GenomeDataManager.prototype.load_data.call(\n                  this,\n                  region,\n                  mode,\n                  resolution,\n                  extra_params\n              )\n            : { data: null, region: region };\n    }\n});\n\n/**\n * A genome build.\n */\nvar Genome = Backbone.Model.extend({\n    defaults: {\n        name: null,\n        key: null,\n        chroms_info: null\n    },\n\n    initialize: function(options) {\n        this.id = options.dbkey;\n    },\n\n    /**\n     * Shorthand for getting to chromosome information.\n     */\n    get_chroms_info: function() {\n        return this.attributes.chroms_info.chrom_info;\n    },\n\n    /**\n     * Returns a GenomeRegion object denoting a complete chromosome.\n     */\n    get_chrom_region: function(chr_name) {\n        // FIXME: use findWhere in underscore 1.4\n        var chrom_info = _.find(\n            this.get_chroms_info(),\n            chrom_info => chrom_info.chrom === chr_name\n        );\n        return new GenomeRegion({\n            chrom: chrom_info.chrom,\n            end: chrom_info.len\n        });\n    },\n\n    /** Returns the length of a chromosome. */\n    get_chrom_len: function(chr_name) {\n        // FIXME: use findWhere in underscore 1.4\n        return _.find(\n            this.get_chroms_info(),\n            chrom_info => chrom_info.chrom === chr_name\n        ).len;\n    }\n});\n\n/**\n * A genomic region.\n */\nvar GenomeRegion = Backbone.Model.extend(\n    {\n        defaults: {\n            chrom: null,\n            start: 0,\n            end: 0,\n            str_val: null,\n            genome: null\n        },\n\n        /**\n     * Returns true if this region is the same as a given region.\n     * It does not test the genome right now.\n     */\n        same: function(region) {\n            return (\n                this.attributes.chrom === region.get(\"chrom\") &&\n                this.attributes.start === region.get(\"start\") &&\n                this.attributes.end === region.get(\"end\")\n            );\n        },\n\n        /**\n     * If from_str specified, use it to initialize attributes.\n     */\n        initialize: function(options) {\n            if (options.from_str) {\n                var pieces = options.from_str.split(\":\");\n                var chrom = pieces[0];\n                var start_end = pieces[1].split(\"-\");\n                this.set({\n                    chrom: chrom,\n                    start: parseInt(start_end[0], 10),\n                    end: parseInt(start_end[1], 10)\n                });\n            }\n\n            // Keep a copy of region's string value for fast lookup.\n            this.attributes.str_val = `${this.get(\"chrom\")}:${this.get(\n                \"start\"\n            )}-${this.get(\"end\")}`;\n\n            // Set str_val on attribute change.\n            this.on(\n                \"change\",\n                function() {\n                    this.attributes.str_val = `${this.get(\"chrom\")}:${this.get(\n                        \"start\"\n                    )}-${this.get(\"end\")}`;\n                },\n                this\n            );\n        },\n\n        copy: function() {\n            return new GenomeRegion({\n                chrom: this.get(\"chrom\"),\n                start: this.get(\"start\"),\n                end: this.get(\"end\")\n            });\n        },\n\n        length: function() {\n            return this.get(\"end\") - this.get(\"start\");\n        },\n\n        /** Returns region in canonical form chrom:start-end */\n        toString: function() {\n            return this.attributes.str_val;\n        },\n\n        toJSON: function() {\n            return {\n                chrom: this.get(\"chrom\"),\n                start: this.get(\"start\"),\n                end: this.get(\"end\")\n            };\n        },\n\n        /**\n     * Compute the type of overlap between this region and another region. The overlap is computed relative to the given/second region;\n     * hence, OVERLAP_START indicates that the first region overlaps the start (but not the end) of the second region.\n     */\n        compute_overlap: function(a_region) {\n            var first_chrom = this.get(\"chrom\");\n            var second_chrom = a_region.get(\"chrom\");\n            var first_start = this.get(\"start\");\n            var second_start = a_region.get(\"start\");\n            var first_end = this.get(\"end\");\n            var second_end = a_region.get(\"end\");\n            var overlap;\n\n            // Compare chroms.\n            if (first_chrom && second_chrom && first_chrom !== second_chrom) {\n                return GenomeRegion.overlap_results.DIF_CHROMS;\n            }\n\n            // Compare regions.\n            if (first_start < second_start) {\n                if (first_end < second_start) {\n                    overlap = GenomeRegion.overlap_results.BEFORE;\n                } else if (first_end < second_end) {\n                    overlap = GenomeRegion.overlap_results.OVERLAP_START;\n                } else {\n                    // first_end >= second_end\n                    overlap = GenomeRegion.overlap_results.CONTAINS;\n                }\n            } else if (first_start > second_start) {\n                if (first_start > second_end) {\n                    overlap = GenomeRegion.overlap_results.AFTER;\n                } else if (first_end <= second_end) {\n                    overlap = GenomeRegion.overlap_results.CONTAINED_BY;\n                } else {\n                    overlap = GenomeRegion.overlap_results.OVERLAP_END;\n                }\n            } else {\n                // first_start === second_start\n                overlap =\n                    first_end >= second_end\n                        ? GenomeRegion.overlap_results.CONTAINS\n                        : GenomeRegion.overlap_results.CONTAINED_BY;\n            }\n\n            return overlap;\n        },\n\n        /**\n     * Trim a region to match genome's constraints.\n     */\n        trim: function(genome) {\n            // Assume that all chromosome/contigs start at 0.\n            if (this.attributes.start < 0) {\n                this.attributes.start = 0;\n            }\n\n            // Only try to trim the end if genome is set.\n            if (this.attributes.genome) {\n                var chrom_len = this.attributes.genome.get_chrom_len(\n                    this.attributes.chrom\n                );\n                if (this.attributes.end > chrom_len) {\n                    this.attributes.end = chrom_len - 1;\n                }\n            }\n\n            return this;\n        },\n\n        /**\n     * Returns true if this region contains a given region.\n     */\n        contains: function(a_region) {\n            return (\n                this.compute_overlap(a_region) ===\n                GenomeRegion.overlap_results.CONTAINS\n            );\n        },\n\n        /**\n     * Returns true if regions overlap.\n     */\n        overlaps: function(a_region) {\n            return (\n                _.intersection(\n                    [this.compute_overlap(a_region)],\n                    [\n                        GenomeRegion.overlap_results.DIF_CHROMS,\n                        GenomeRegion.overlap_results.BEFORE,\n                        GenomeRegion.overlap_results.AFTER\n                    ]\n                ).length === 0\n            );\n        }\n    },\n    {\n        overlap_results: {\n            DIF_CHROMS: 1000,\n            BEFORE: 1001,\n            CONTAINS: 1002,\n            OVERLAP_START: 1003,\n            OVERLAP_END: 1004,\n            CONTAINED_BY: 1005,\n            AFTER: 1006\n        }\n    }\n);\n\nvar GenomeRegionCollection = Backbone.Collection.extend({\n    model: GenomeRegion\n});\n\n/**\n * A genome browser bookmark.\n */\nvar BrowserBookmark = Backbone.Model.extend({\n    defaults: {\n        region: null,\n        note: \"\"\n    },\n\n    initialize: function(options) {\n        this.set(\"region\", new GenomeRegion(options.region));\n    }\n});\n\n/**\n * Bookmarks collection.\n */\nvar BrowserBookmarkCollection = Backbone.Collection.extend({\n    model: BrowserBookmark\n});\n\n/**\n * A track of data in a genome visualization.\n */\n// TODO: rename to Track and merge with Trackster's Track object.\nvar BackboneTrack = Backbone.Model.extend(CustomToJSON).extend(\n    {\n        defaults: {\n            mode: \"Auto\"\n        },\n\n        initialize: function(options) {\n            this.set(\"dataset\", new data_mod.Dataset(options.dataset));\n\n            // -- Set up config settings. --\n            var models = [\n                {\n                    key: \"name\",\n                    default_value: this.get(\"dataset\").get(\"name\")\n                },\n                { key: \"color\" },\n                {\n                    key: \"min_value\",\n                    label: \"Min Value\",\n                    type: \"float\",\n                    default_value: 0\n                },\n                {\n                    key: \"max_value\",\n                    label: \"Max Value\",\n                    type: \"float\",\n                    default_value: 1\n                }\n            ];\n\n            this.set(\n                \"config\",\n                config_mod.ConfigSettingCollection.from_models_and_saved_values(\n                    models,\n                    options.prefs\n                )\n            );\n\n            // -- Set up data manager. --\n            var preloaded_data = this.get(\"preloaded_data\");\n            if (preloaded_data) {\n                preloaded_data = preloaded_data.data;\n            } else {\n                preloaded_data = [];\n            }\n            this.set(\n                \"data_manager\",\n                new GenomeDataManager({\n                    dataset: this.get(\"dataset\"),\n                    init_data: preloaded_data\n                })\n            );\n        }\n    },\n    {\n        // This definition matches that produced by to_dict() methods in tracks.js\n        to_json_keys: [\n            \"track_type\",\n            \"dataset\",\n            \"prefs\",\n            \"mode\",\n            \"filters\",\n            \"tool_state\"\n        ],\n        to_json_mappers: {\n            prefs: function(p, self) {\n                if (_.size(p) === 0) {\n                    p = {\n                        name: self\n                            .get(\"config\")\n                            .get(\"name\")\n                            .get(\"value\"),\n                        color: self\n                            .get(\"config\")\n                            .get(\"color\")\n                            .get(\"value\")\n                    };\n                }\n                return p;\n            },\n            dataset: function(d) {\n                return {\n                    id: d.id,\n                    hda_ldda: d.get(\"hda_ldda\")\n                };\n            }\n        }\n    }\n);\n\nvar BackboneTrackCollection = Backbone.Collection.extend({\n    model: BackboneTrack\n});\n\n/**\n * A visualization.\n */\nvar Visualization = Backbone.Model.extend({\n    defaults: {\n        title: \"\",\n        type: \"\"\n    },\n\n    urlRoot: `${Galaxy.root}api/visualizations`,\n\n    /**\n     * POSTs visualization's JSON to its URL using the parameter 'vis_json'\n     * Note: This is necessary because (a) Galaxy requires keyword args and\n     * (b) Galaxy does not handle PUT now.\n     */\n    save: function() {\n        return $.ajax({\n            url: this.url(),\n            type: \"POST\",\n            dataType: \"json\",\n            data: {\n                vis_json: JSON.stringify(this)\n            }\n        });\n    }\n});\n\n/**\n * A visualization of genome data.\n */\nvar GenomeVisualization = Visualization.extend(CustomToJSON).extend(\n    {\n        defaults: _.extend({}, Visualization.prototype.defaults, {\n            dbkey: \"\",\n            drawables: null,\n            bookmarks: null,\n            viewport: null\n        }),\n\n        initialize: function(options) {\n            // Replace drawables with tracks.\n            this.set(\"drawables\", new BackboneTrackCollection(options.tracks));\n\n            var models = [];\n            this.set(\n                \"config\",\n                config_mod.ConfigSettingCollection.from_models_and_saved_values(\n                    models,\n                    options.prefs\n                )\n            );\n\n            // Clear track and data definitions to avoid storing large objects.\n            this.unset(\"tracks\");\n            this.get(\"drawables\").each(d => {\n                d.unset(\"preloaded_data\");\n            });\n        },\n\n        /**\n     * Add a track or array of tracks to the visualization.\n     */\n        add_tracks: function(tracks) {\n            this.get(\"drawables\").add(tracks);\n        }\n    },\n    {\n        // This definition matches that produced by to_dict() methods in tracks.js\n        to_json_keys: [\"view\", \"viewport\", \"bookmarks\"],\n\n        to_json_mappers: {\n            view: function(dummy, self) {\n                return {\n                    obj_type: \"View\",\n                    prefs: {\n                        name: self.get(\"title\"),\n                        content_visible: true\n                    },\n                    drawables: self.get(\"drawables\")\n                };\n            }\n        }\n    }\n);\n\n/**\n * -- Routers --\n */\n\n/**\n * Router for track browser.\n */\nvar TrackBrowserRouter = Backbone.Router.extend({\n    initialize: function(options) {\n        this.view = options.view;\n\n        // Can't put regular expression in routes dictionary.\n        // NOTE: parentheses are used to denote parameters returned to callback.\n        this.route(/([\\w]+)$/, \"change_location\");\n        this.route(/([\\w\\+]+\\:[\\d,]+-[\\d,]+)$/, \"change_location\");\n\n        // Handle navigate events from view.\n        var self = this;\n        self.view.on(\"navigate\", new_loc => {\n            self.navigate(new_loc);\n        });\n    },\n\n    change_location: function(new_loc) {\n        this.view.go_to(new_loc);\n    }\n});\n\nexport default {\n    BackboneTrack: BackboneTrack,\n    BrowserBookmark: BrowserBookmark,\n    BrowserBookmarkCollection: BrowserBookmarkCollection,\n    Cache: Cache,\n    CanvasManager: CanvasManager,\n    Genome: Genome,\n    GenomeDataManager: GenomeDataManager,\n    GenomeRegion: GenomeRegion,\n    GenomeRegionCollection: GenomeRegionCollection,\n    GenomeVisualization: GenomeVisualization,\n    GenomeReferenceDataManager: GenomeReferenceDataManager,\n    TrackBrowserRouter: TrackBrowserRouter,\n    Visualization: Visualization,\n    select_datasets: select_datasets\n};\n"]}