{"version":3,"sources":["mvc/form/form-data.js"],"names":["define","Utils","Manager","Backbone","Model","extend","initialize","app","checksum","sum","this","$el","find","each","self","$","attr","field","field_list","id","value","collapsed","create","result_dict","input_id","input_value","flat_dict","flat_id","element_list","convert","identifier","head","index","input","node","name","type","block_indices","section_label","block_prefix","indexOf","block_label","pos","push","parseInt","substr","sort","a","b","i","add","test_param","selectedCase","matchCase","undefined","ignore","collapsible_value","p_id","payload","dict","_iterate","section","match","matchModel","model","callback","visitInputs","inputs","matchResponse","response","search","result","separator","Array","new_id","parent","children","child","input_list","truevalue","falsevalue","cases","prefix","context","_","key","cache","j","Galaxy","emit","debug"],"mappings":"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","file":"../../../scripts/mvc/form/form-data.js","sourcesContent":["/* This class maps the form dom to an api compatible javascript dictionary. */\ndefine([ 'utils/utils' ], function( Utils ) {\n    var Manager = Backbone.Model.extend({\n        initialize: function( app ) {\n            this.app = app;\n        },\n\n        /** Creates a checksum. */\n        checksum: function() {\n            var sum = '';\n            var self = this;\n            this.app.section.$el.find( '.section-row' ).each( function() {\n                var id = $(this).attr( 'id' );\n                var field = self.app.field_list[ id ];\n                if ( field ) {\n                    sum += id + ':' + JSON.stringify( field.value && field.value() ) + ':' + field.collapsed + ';';\n                }\n            });\n            return sum;\n        },\n\n        /** Convert dom into a dictionary of flat id/value pairs used e.g. on job submission. */\n        create: function() {\n            var self = this;\n\n            // get raw dictionary from dom\n            var dict = {};\n            this._iterate( this.app.section.$el, dict );\n\n            // add to result dictionary, label elements\n            var result_dict = {};\n            this.flat_dict = {};\n            function add( flat_id, input_id, input_value ) {\n                self.flat_dict[ flat_id ] = input_id;\n                result_dict[ flat_id ] = input_value;\n                self.app.element_list[ input_id ] && self.app.element_list[ input_id ].$el.attr( 'tour_id', flat_id );\n            }\n            // converter between raw dictionary and job dictionary\n            function convert( identifier, head ) {\n                for ( var index in head ) {\n                    var node = head[ index ];\n                    if ( node.input ) {\n                        var input = node.input;\n                        var flat_id = identifier;\n                        if ( identifier != '' ) {\n                            flat_id += '|';\n                        }\n                        flat_id += input.name;\n                        switch ( input.type ) {\n                            case 'repeat':\n                                var section_label = 'section-';\n                                var block_indices = [];\n                                var block_prefix = null;\n                                for ( var block_label in node ) {\n                                    var pos = block_label.indexOf( section_label );\n                                    if ( pos != -1 ) {\n                                        pos += section_label.length;\n                                        block_indices.push( parseInt( block_label.substr( pos ) ));\n                                        if ( !block_prefix ) {\n                                            block_prefix = block_label.substr( 0, pos );\n                                        }\n                                    }\n                                }\n                                block_indices.sort( function( a, b ) { return a - b; });\n                                var index = 0;\n                                for ( var i in block_indices ) {\n                                    convert( flat_id + '_' + index++, node[ block_prefix + block_indices[ i ] ]);\n                                }\n                                break;\n                            case 'conditional':\n                                var value = self.app.field_list[ input.id ].value();\n                                add( flat_id + '|' + input.test_param.name, input.id, value );\n                                var selectedCase = matchCase( input, value );\n                                if ( selectedCase != -1 ) {\n                                    convert( flat_id, head[ input.id + '-section-' + selectedCase ] );\n                                }\n                                break;\n                            case 'section':\n                                convert( !input.flat && flat_id || '', node );\n                                break;\n                            default:\n                                var field = self.app.field_list[ input.id ];\n                                if ( field && field.value ) {\n                                    var value = field.value();\n                                    if ( input.ignore === undefined || input.ignore != value ) {\n                                        if ( field.collapsed && input.collapsible_value ) {\n                                            value = input.collapsible_value;\n                                        }\n                                        add( flat_id, input.id, value );\n                                        if ( input.payload ) {\n                                            for ( var p_id in input.payload ) {\n                                                add( p_id, input.id, input.payload[ p_id ] );\n                                            }\n                                        }\n                                    }\n                                }\n                        }\n                    }\n                }\n            }\n            convert( '', dict );\n            return result_dict;\n        },\n\n        /** Matches flat ids to corresponding input element\n         * @param{string} flat_id - Flat input id to be looked up.\n         */\n        match: function ( flat_id ) {\n            return this.flat_dict && this.flat_dict[ flat_id ];\n        },\n\n        /** Match conditional values to selected cases\n        */\n        matchCase: function( input, value ) {\n            return matchCase( input, value );\n        },\n\n        /** Matches a new tool model to the current input elements e.g. used to update dynamic options\n        */\n        matchModel: function( model, callback ) {\n            var self = this;\n            visitInputs( model.inputs, function( input, name ) {\n                self.flat_dict[ name ] && callback ( input, self.flat_dict[ name ] );\n            });\n        },\n\n        /** Matches identifier from api response to input elements e.g. used to display validation errors\n        */\n        matchResponse: function( response ) {\n            var result = {};\n            var self = this;\n            function search ( id, head ) {\n                if ( typeof head === 'string' ) {\n                    var input_id = self.flat_dict[ id ];\n                    input_id && ( result[ input_id ] = head );\n                } else {\n                    for ( var i in head ) {\n                        var new_id = i;\n                        if ( id !== '' ) {\n                            var separator = '|';\n                            if ( head instanceof Array ) {\n                                separator = '_';\n                            }\n                            new_id = id + separator + new_id;\n                        }\n                        search ( new_id, head[ i ] );\n                    }\n                }\n            }\n            search( '', response );\n            return result;\n        },\n\n        /** Map dom tree to dictionary tree with input elements.\n        */\n        _iterate: function( parent, dict ) {\n            var self = this;\n            var children = $( parent ).children();\n            children.each( function() {\n                var child = this;\n                var id = $( child ).attr( 'id' );\n                if ( $( child ).hasClass( 'section-row' ) ) {\n                    var input = self.app.input_list[ id ];\n                    dict[ id ] = ( input && { input : input } ) || {};\n                    self._iterate( child, dict[ id ] );\n                } else {\n                    self._iterate( child, dict );\n                }\n            });\n        }\n    });\n\n    /** Match conditional values to selected cases\n     * @param{dict}   input     - Definition of conditional input parameter\n     * @param{dict}   value     - Current value\n     */\n    var matchCase = function( input, value ) {\n        if ( input.test_param.type == 'boolean' ) {\n            if ( value == 'true' ) {\n                value = input.test_param.truevalue || 'true';\n            } else {\n                value = input.test_param.falsevalue || 'false';\n            }\n        }\n        for ( var i in input.cases ) {\n            if ( input.cases[ i ].value == value ) {\n                return i;\n            }\n        }\n        return -1;\n    };\n\n    /** Visits tool inputs\n     * @param{dict}   inputs    - Nested dictionary of input elements\n     * @param{dict}   callback  - Called with the mapped dictionary object and corresponding model node\n     */\n    var visitInputs = function( inputs, callback, prefix, context ) {\n        context = $.extend( true, {}, context );\n        _.each( inputs, function ( input ) {\n            if ( input && input.type && input.name ) {\n                context[ input.name ] = input;\n            }\n        });\n        for ( var key in inputs ) {\n            var node = inputs[ key ];\n            node.name = node.name || key;\n            var name = prefix ? prefix + '|' + node.name : node.name;\n            switch ( node.type ) {\n                case 'repeat':\n                    _.each( node.cache, function( cache, j ) {\n                        visitInputs( cache, callback, name + '_' + j, context );\n                    });\n                    break;\n                case 'conditional':\n                    if ( node.test_param ) {\n                        callback( node.test_param, name + '|' + node.test_param.name, context );\n                        var selectedCase = matchCase( node, node.test_param.value );\n                        if ( selectedCase != -1 ) {\n                            visitInputs( node.cases[ selectedCase ].inputs, callback, name, context );\n                        } else {\n                            Galaxy.emit.debug( 'form-data::visitInputs() - Invalid case for ' + name + '.' );\n                        }\n                    } else {\n                        Galaxy.emit.debug( 'form-data::visitInputs() - Conditional test parameter missing for ' + name  + '.' );\n                    }\n                    break;\n                case 'section':\n                    visitInputs( node.inputs, callback, name, context )\n                    break;\n                default:\n                    callback( node, name, context );\n            }\n        }\n    };\n\n    return {\n        Manager         : Manager,\n        visitInputs     : visitInputs\n    }\n});"]}