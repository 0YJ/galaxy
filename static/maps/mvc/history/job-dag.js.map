{"version":3,"sources":["mvc/history/job-dag.js"],"names":["define","GRAPH","addLogging","_super","Graph","JobDAG","options","self","this","filters","_jobsData","_historyContentsMap","_toolMap","_outputIdToJobMap","noInputJobs","noOutputJobs","filteredSetMetadata","filteredErroredJobs","dataKeys","call","_","pick","omit","prototype","constructor","init","defaults","excludeSetMetadata","_initFilters","push","jobData","job","tool_id","id","excludeErroredJobs","state","isArray","concat","debug","length","read","data","has","preprocessHistoryContents","historyContents","preprocessTools","tools","preprocessJobs","jobs","createGraph","_filterJobs","info","forEach","content","i","clone","each","tool","sort","map","preprocessJob","cmpCreate","a","b","create_time","index","inputs","_processInputs","size","outputs","_processOutputs","inputMap","input","nameInJob","_validateInputOutput","name","inputOutput","Error","JSON","stringify","src","outputMap","output","filter","j","_filterJob","jobsData","createVertex","targetId","inputId","sourceId","createJobLessVertex","createEdge","directed","dataset","toVerticesAndEdges","contentId","mangledId","weakComponentGraphArray","dag","weakComponents","component","vertices","aCreateTime","bCreateTime","_jobsDataMap","jobsDataMap"],"mappings":"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","file":"../../../scripts/mvc/history/job-dag.js","sourcesContent":["define([\n    'utils/graph',\n    'utils/add-logging'\n],function( GRAPH, addLogging ){\n\n'use strict';\n\n// ============================================================================\nvar _super = GRAPH.Graph;\n/** A Directed acyclic Graph built from a history's job data.\n *      Reads in job json, filters and process that json, and builds a graph\n *      using the connections between job inputs and outputs.\n */\nvar JobDAG = function( options ){\n    options = options || {};\n    var self = this;\n    //this.logger = console;\n\n    self.filters = [];\n\n    // instance vars\n//TODO: needed?\n    self._jobsData = [];\n    self._historyContentsMap = {};\n    self._toolMap = {};\n\n    self._outputIdToJobMap = {};\n    self.noInputJobs = [];\n    self.noOutputJobs = [];\n\n//TODO: save these?\n    self.filteredSetMetadata = [];\n    self.filteredErroredJobs = [];\n\n    self.dataKeys = [ 'jobs', 'historyContents', 'tools' ];\n    _super.call( self, true,\n        _.pick( options, self.dataKeys ),\n        _.omit( options, self.dataKeys )\n    );\n};\nJobDAG.prototype = new GRAPH.Graph();\nJobDAG.prototype.constructor = JobDAG;\n\n// add logging ability - turn off/on using the this.logger statement above\naddLogging( JobDAG );\n\n\n// ----------------------------------------------------------------------------\n/** process jobs, options, filters, and any history data, then create the graph */\nJobDAG.prototype.init = function _init( options ){\n    options = options || {};\n\n    var self = this;\n    self.options = _.defaults( options, {\n        excludeSetMetadata : false\n    });\n    self.filters = self._initFilters();\n\n    _super.prototype.init.call( self, options );\n    return self;\n};\n\n/** add job filters based on options */\nJobDAG.prototype._initFilters = function __initFilters(){\n    var self = this,\n        filters = [];\n\n    if( self.options.excludeSetMetadata ){\n        self.filteredSetMetadata = [];\n        filters.push( function filterSetMetadata( jobData ){\n            if( jobData.job.tool_id !== '__SET_METADATA__' ){ return true; }\n            self.filteredSetMetadata.push( jobData.job.id );\n            return false;\n        });\n    }\n\n    if( self.options.excludeErroredJobs ){\n        self.filteredErroredJobs = [];\n        filters.push( function filterErrored( jobData ){\n            if( jobData.job.state !== 'error' ){ return true; }\n            self.filteredErroredJobs.push( jobData.job.id );\n            return false;\n        });\n    }\n\n    // all outputs deleted\n    // all outputs hidden\n\n    if( _.isArray( self.options.filters ) ){\n        filters = filters.concat( self.options.filters );\n    }\n    self.debug( 'filters len:', filters.length );\n    return filters;\n};\n\n/**  */\nJobDAG.prototype.read = function _read( data ){\n    var self = this;\n    if( _.has( data, 'historyContents' ) && _.has( data, 'jobs' ) && _.has( data, 'tools' ) ){\n        // a job dag is composed of these three elements:\n        //  clone the 3 data sources into the DAG, processing the jobs finally using the history and tools\n        self.preprocessHistoryContents( data.historyContents || [] )\n            .preprocessTools( data.tools || {} )\n            .preprocessJobs( data.jobs || [] );\n\n        // filter jobs and create the vertices and edges of the job DAG\n        self.createGraph( self._filterJobs() );\n        return self;\n    }\n    return _super.prototype.read.call( this, data );\n};\n\n/**  */\nJobDAG.prototype.preprocessHistoryContents = function _preprocessHistoryContents( historyContents ){\n    this.info( 'processing history' );\n    var self = this;\n    self._historyContentsMap = {};\n\n    historyContents.forEach( function( content, i ){\n        self._historyContentsMap[ content.id ] = _.clone( content );\n    });\n    return self;\n};\n\n/**  */\nJobDAG.prototype.preprocessTools = function _preprocessTools( tools ){\n    this.info( 'processing tools' );\n    var self = this;\n    self._toolMap = {};\n\n    _.each( tools, function( tool, id ){\n        self._toolMap[ id ] = _.clone( tool );\n    });\n    return self;\n};\n\n/** sort the cloned jobs, decorate with tool and history contents info, and store in prop array */\nJobDAG.prototype.preprocessJobs = function _preprocessJobs( jobs ){\n    this.info( 'processing jobs' );\n    var self = this;\n    self._outputIdToJobMap = {};\n\n    self._jobsData = self.sort( jobs ).map( function( job ){\n        return self.preprocessJob( _.clone( job ) );\n    });\n//console.debug( JSON.stringify( self._jobsData, null, '    ' ) );\n//console.debug( JSON.stringify( self._outputIdToJobMap, null, '    ' ) );\n    return self;\n};\n\n/** sort the jobs based on update time */\nJobDAG.prototype.sort = function _sort( jobs ){\n    function cmpCreate( a, b ){\n        if( a.create_time > b.create_time ){ return 1; }\n        if( a.create_time < b.create_time ){ return -1; }\n        return 0;\n    }\n    return jobs.sort( cmpCreate );\n};\n\n/** decorate with input/output datasets and tool */\nJobDAG.prototype.preprocessJob = function _preprocessJob( job, index ){\n    //this.info( 'preprocessJob', job, index );\n    var self = this,\n        jobData = { job: job };\n\n    jobData.inputs = self._processInputs( job );\n    if( _.size( jobData.inputs ) === 0 ){\n        self.noInputJobs.push( job.id );\n    }\n    jobData.outputs = self._processOutputs( job );\n    if( _.size( jobData.outputs ) === 0 ){\n        self.noOutputJobs.push( job.id );\n    }\n\n    jobData.tool = self._toolMap[ job.tool_id ];\n\n    //self.info( '\\t jobData:', jobData );\n    return jobData;\n};\n\n/**\n */\nJobDAG.prototype._processInputs = function __processInputs( job ){\n    var self = this,\n        inputs = job.inputs,\n        inputMap = {};\n    _.each( inputs, function( input, nameInJob ){\n        input = _.clone( self._validateInputOutput( input ) );\n        input.name = nameInJob;\n        // since this is a DAG and we're processing in order of create time,\n        //  the inputs for this job will already be listed in _outputIdToJobMap\n        //  TODO: we can possibly exploit this\n        //console.debug( 'input in _outputIdToJobMap', self._outputIdToJobMap[ input.id ] );\n        input.content = self._historyContentsMap[ input.id ];\n        inputMap[ input.id ] = input;\n    });\n    return inputMap;\n};\n\n/**\n */\nJobDAG.prototype._validateInputOutput = function __validateInputOutput( inputOutput ){\n    if( !inputOutput.id ){\n        throw new Error( 'No id on job input/output: ', JSON.stringify( inputOutput ) );\n    }\n    if( !inputOutput.src || inputOutput.src !== 'hda' ){\n        throw new Error( 'Bad src on job input/output: ', JSON.stringify( inputOutput ) );\n    }\n    return inputOutput;\n};\n\n/**\n */\nJobDAG.prototype._processOutputs = function __processOutputs( job ){\n    var self = this,\n        outputs = job.outputs,\n        outputMap = {};\n    _.each( outputs, function( output, nameInJob ){\n        output = _.clone( self._validateInputOutput( output ) );\n        output.name = nameInJob;\n        // add dataset content to jobData\n        output.content = self._historyContentsMap[ output.id ];\n        outputMap[ output.id ] = output;\n\n        self._outputIdToJobMap[ output.id ] = job.id;\n    });\n    return outputMap;\n};\n\n/**  */\nJobDAG.prototype._filterJobs = function __filterJobs(){\n    var self = this;\n    return self._jobsData.filter( function( j, i ){ return self._filterJob( j, i ); });\n};\n\n/**\n */\nJobDAG.prototype._filterJob = function _filterJob( jobData, index ){\n    // apply filters after processing job allowing access to the additional data above inside the filters\n    var self = this;\n    for( var i=0; i<self.filters.length; i++ ){\n        if( !self.filters[i].call( self, jobData ) ){\n            self.debug( '\\t job', jobData.job.id, ' has been filtered out by function:\\n', self.filters[i] );\n            return false;\n        }\n    }\n    return true;\n};\n\n/** Walk all the jobs (vertices), attempting to find connections\n *  between datasets used as both inputs and outputs (edges)\n */\nJobDAG.prototype.createGraph = function _createGraph( jobsData ){\n    var self = this;\n    self.debug( 'connections:' );\n    //console.debug( jobsData );\n\n    _.each( jobsData, function( jobData ){\n        var id = jobData.job.id;\n        self.debug( '\\t', id, jobData );\n        self.createVertex( id, jobData );\n    });\n    _.each( jobsData, function( jobData ){\n        var targetId = jobData.job.id;\n        _.each( jobData.inputs, function( input, inputId ){\n            //console.debug( '\\t\\t target input:', inputId, input );\n            var sourceId = self._outputIdToJobMap[ inputId ];\n            //console.debug( '\\t\\t source job id:', sourceId );\n            if( !sourceId ){\n                var joblessVertex = self.createJobLessVertex( inputId );\n                sourceId = joblessVertex.name;\n            }\n//TODO:?? no checking here whether sourceId is actually in the vertex map\n            //console.debug( '\\t\\t creating edge, source:', sourceId, self.vertices[ sourceId ] );\n            //console.debug( '\\t\\t creating edge, target:', targetId, self.vertices[ targetId ] );\n            self.createEdge( sourceId, targetId, self.directed, {\n                dataset : inputId\n            });\n        });\n    });\n    //console.debug( self.toVerticesAndEdges().edges );\n\n    self.debug( 'final graph: ', JSON.stringify( self.toVerticesAndEdges(), null, '  ' ) );\n    return self;\n};\n\n/** Return a 'mangled' version of history contents id to prevent contents <-> job id collision */\nJobDAG.prototype.createJobLessVertex = function _createJobLessVertex( contentId ){\n    // currently, copied contents are the only history contents without jobs (that I know of)\n    //note: following needed to prevent id collision btwn content and jobs in vertex map\n    var JOBLESS_ID_MANGLER = 'copy-',\n        mangledId = JOBLESS_ID_MANGLER + contentId;\n    return this.createVertex( mangledId, this._historyContentsMap[ contentId ] );\n};\n\n/** Override to re-sort (ugh) jobs in each component by update time */\nJobDAG.prototype.weakComponentGraphArray = function(){\n    var dag = this;\n    return this.weakComponents().map( function( component ){\n//TODO: this seems to belong above (in sort) - why isn't it preserved?\n        // note: using create_time (as opposed to update_time)\n        //  since update_time for jobless/copied datasets is changes more often\n        component.vertices.sort( function cmpCreate( a, b ){\n            var aCreateTime = a.data.job? a.data.job.create_time : a.data.create_time,\n                bCreateTime = b.data.job? b.data.job.create_time : b.data.create_time;\n            if( aCreateTime > bCreateTime ){ return 1; }\n            if( aCreateTime < bCreateTime ){ return -1; }\n            return 0;\n        });\n        return new Graph( dag.directed, component );\n    });\n};\n\nJobDAG.prototype._jobsDataMap = function(){\n    var jobsDataMap = {};\n    this._jobsData.forEach( function( jobData ){\n        jobsDataMap[ jobData.job.id ] = jobData;\n    });\n    return jobsDataMap;\n};\n\n\n// ============================================================================\n    return JobDAG;\n});\n"]}