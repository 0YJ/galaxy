{"version":3,"sources":["mvc/history/job-dag.js"],"names":["_graph","require","_addLogging","_super","_graph2","default","Graph","JobDAG","options","self","this","filters","_jobsData","_historyContentsMap","_toolMap","filteredErroredJobs","dataKeys","_","pick","_outputIdToJobMap","prototype","constructor","_addLogging2","init","defaults","excludeSetMetadata","_initFilters","call","filteredSetMetadata","push","jobData","job","tool_id","id","concat","debug","length","read","data","has","preprocessHistoryContents","preprocessTools","tools","preprocessJobs","jobs","createGraph","_filterJobs","content","i","clone","tool","preprocessJob","cmpCreate","sort","create_time","b","a","index","size","inputs","noInputJobs","outputs","noOutputJobs","_processInputs","inputMap","each","input","_validateInputOutput","name","nameInJob","inputOutput","src","Error","stringify","outputMap","output","__filterJobs","j","_filterJob","filter","jobsData","sourceId","inputId","createVertex","dataset","targetId","createJobLessVertex","createEdge","directed","JOBLESS_ID_MANGLER","dag","JSON","weakComponents","component","bCreateTime","contentId","mangledId","weakComponentGraphArray","map","vertices","jobsDataMap","aCreateTime","_jobsDataMap","forEach"],"mappings":"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","file":"../../../scripts/mvc/history/job-dag.js","sourcesContent":["import GRAPH from \"utils/graph\";\nimport addLogging from \"utils/add-logging\";\n\n// ============================================================================\nvar _super = GRAPH.Graph;\n/** A Directed acyclic Graph built from a history's job data.\n *      Reads in job json, filters and process that json, and builds a graph\n *      using the connections between job inputs and outputs.\n */\nvar JobDAG = function(options) {\n    options = options || {};\n    var self = this;\n    //this.logger = console;\n\n    self.filters = [];\n\n    // instance vars\n    //TODO: needed?\n    self._jobsData = [];\n    self._historyContentsMap = {};\n    self._toolMap = {};\n\n    self._outputIdToJobMap = {};\n    self.noInputJobs = [];\n    self.noOutputJobs = [];\n\n    //TODO: save these?\n    self.filteredSetMetadata = [];\n    self.filteredErroredJobs = [];\n\n    self.dataKeys = [\"jobs\", \"historyContents\", \"tools\"];\n    _super.call(\n        self,\n        true,\n        _.pick(options, self.dataKeys),\n        _.omit(options, self.dataKeys)\n    );\n};\nJobDAG.prototype = new GRAPH.Graph();\nJobDAG.prototype.constructor = JobDAG;\n\n// add logging ability - turn off/on using the this.logger statement above\naddLogging(JobDAG);\n\n// ----------------------------------------------------------------------------\n/** process jobs, options, filters, and any history data, then create the graph */\nJobDAG.prototype.init = function _init(options) {\n    options = options || {};\n\n    var self = this;\n    self.options = _.defaults(options, {\n        excludeSetMetadata: false\n    });\n    self.filters = self._initFilters();\n\n    _super.prototype.init.call(self, options);\n    return self;\n};\n\n/** add job filters based on options */\nJobDAG.prototype._initFilters = function __initFilters() {\n    var self = this,\n        filters = [];\n\n    if (self.options.excludeSetMetadata) {\n        self.filteredSetMetadata = [];\n        filters.push(function filterSetMetadata(jobData) {\n            if (jobData.job.tool_id !== \"__SET_METADATA__\") {\n                return true;\n            }\n            self.filteredSetMetadata.push(jobData.job.id);\n            return false;\n        });\n    }\n\n    if (self.options.excludeErroredJobs) {\n        self.filteredErroredJobs = [];\n        filters.push(function filterErrored(jobData) {\n            if (jobData.job.state !== \"error\") {\n                return true;\n            }\n            self.filteredErroredJobs.push(jobData.job.id);\n            return false;\n        });\n    }\n\n    // all outputs deleted\n    // all outputs hidden\n\n    if (_.isArray(self.options.filters)) {\n        filters = filters.concat(self.options.filters);\n    }\n    self.debug(\"filters len:\", filters.length);\n    return filters;\n};\n\n/**  */\nJobDAG.prototype.read = function _read(data) {\n    var self = this;\n    if (\n        _.has(data, \"historyContents\") &&\n        _.has(data, \"jobs\") &&\n        _.has(data, \"tools\")\n    ) {\n        // a job dag is composed of these three elements:\n        //  clone the 3 data sources into the DAG, processing the jobs finally using the history and tools\n        self\n            .preprocessHistoryContents(data.historyContents || [])\n            .preprocessTools(data.tools || {})\n            .preprocessJobs(data.jobs || []);\n\n        // filter jobs and create the vertices and edges of the job DAG\n        self.createGraph(self._filterJobs());\n        return self;\n    }\n    return _super.prototype.read.call(this, data);\n};\n\n/**  */\nJobDAG.prototype.preprocessHistoryContents = function _preprocessHistoryContents(\n    historyContents\n) {\n    this.info(\"processing history\");\n    var self = this;\n    self._historyContentsMap = {};\n\n    historyContents.forEach(function(content, i) {\n        self._historyContentsMap[content.id] = _.clone(content);\n    });\n    return self;\n};\n\n/**  */\nJobDAG.prototype.preprocessTools = function _preprocessTools(tools) {\n    this.info(\"processing tools\");\n    var self = this;\n    self._toolMap = {};\n\n    _.each(tools, function(tool, id) {\n        self._toolMap[id] = _.clone(tool);\n    });\n    return self;\n};\n\n/** sort the cloned jobs, decorate with tool and history contents info, and store in prop array */\nJobDAG.prototype.preprocessJobs = function _preprocessJobs(jobs) {\n    this.info(\"processing jobs\");\n    var self = this;\n    self._outputIdToJobMap = {};\n\n    self._jobsData = self.sort(jobs).map(function(job) {\n        return self.preprocessJob(_.clone(job));\n    });\n    //console.debug( JSON.stringify( self._jobsData, null, '    ' ) );\n    //console.debug( JSON.stringify( self._outputIdToJobMap, null, '    ' ) );\n    return self;\n};\n\n/** sort the jobs based on update time */\nJobDAG.prototype.sort = function _sort(jobs) {\n    function cmpCreate(a, b) {\n        if (a.create_time > b.create_time) {\n            return 1;\n        }\n        if (a.create_time < b.create_time) {\n            return -1;\n        }\n        return 0;\n    }\n    return jobs.sort(cmpCreate);\n};\n\n/** decorate with input/output datasets and tool */\nJobDAG.prototype.preprocessJob = function _preprocessJob(job, index) {\n    //this.info( 'preprocessJob', job, index );\n    var self = this,\n        jobData = { job: job };\n\n    jobData.inputs = self._processInputs(job);\n    if (_.size(jobData.inputs) === 0) {\n        self.noInputJobs.push(job.id);\n    }\n    jobData.outputs = self._processOutputs(job);\n    if (_.size(jobData.outputs) === 0) {\n        self.noOutputJobs.push(job.id);\n    }\n\n    jobData.tool = self._toolMap[job.tool_id];\n\n    //self.info( '\\t jobData:', jobData );\n    return jobData;\n};\n\n/**\n */\nJobDAG.prototype._processInputs = function __processInputs(job) {\n    var self = this,\n        inputs = job.inputs,\n        inputMap = {};\n    _.each(inputs, function(input, nameInJob) {\n        input = _.clone(self._validateInputOutput(input));\n        input.name = nameInJob;\n        // since this is a DAG and we're processing in order of create time,\n        //  the inputs for this job will already be listed in _outputIdToJobMap\n        //  TODO: we can possibly exploit this\n        //console.debug( 'input in _outputIdToJobMap', self._outputIdToJobMap[ input.id ] );\n        input.content = self._historyContentsMap[input.id];\n        inputMap[input.id] = input;\n    });\n    return inputMap;\n};\n\n/**\n */\nJobDAG.prototype._validateInputOutput = function __validateInputOutput(\n    inputOutput\n) {\n    if (!inputOutput.id) {\n        throw new Error(\n            \"No id on job input/output: \",\n            JSON.stringify(inputOutput)\n        );\n    }\n    if (!inputOutput.src || inputOutput.src !== \"hda\") {\n        throw new Error(\n            \"Bad src on job input/output: \",\n            JSON.stringify(inputOutput)\n        );\n    }\n    return inputOutput;\n};\n\n/**\n */\nJobDAG.prototype._processOutputs = function __processOutputs(job) {\n    var self = this,\n        outputs = job.outputs,\n        outputMap = {};\n    _.each(outputs, function(output, nameInJob) {\n        output = _.clone(self._validateInputOutput(output));\n        output.name = nameInJob;\n        // add dataset content to jobData\n        output.content = self._historyContentsMap[output.id];\n        outputMap[output.id] = output;\n\n        self._outputIdToJobMap[output.id] = job.id;\n    });\n    return outputMap;\n};\n\n/**  */\nJobDAG.prototype._filterJobs = function __filterJobs() {\n    var self = this;\n    return self._jobsData.filter(function(j, i) {\n        return self._filterJob(j, i);\n    });\n};\n\n/**\n */\nJobDAG.prototype._filterJob = function _filterJob(jobData, index) {\n    // apply filters after processing job allowing access to the additional data above inside the filters\n    var self = this;\n    for (var i = 0; i < self.filters.length; i++) {\n        if (!self.filters[i].call(self, jobData)) {\n            self.debug(\n                \"\\t job\",\n                jobData.job.id,\n                \" has been filtered out by function:\\n\",\n                self.filters[i]\n            );\n            return false;\n        }\n    }\n    return true;\n};\n\n/** Walk all the jobs (vertices), attempting to find connections\n *  between datasets used as both inputs and outputs (edges)\n */\nJobDAG.prototype.createGraph = function _createGraph(jobsData) {\n    var self = this;\n    self.debug(\"connections:\");\n    //console.debug( jobsData );\n\n    _.each(jobsData, function(jobData) {\n        var id = jobData.job.id;\n        self.debug(\"\\t\", id, jobData);\n        self.createVertex(id, jobData);\n    });\n    _.each(jobsData, function(jobData) {\n        var targetId = jobData.job.id;\n        _.each(jobData.inputs, function(input, inputId) {\n            //console.debug( '\\t\\t target input:', inputId, input );\n            var sourceId = self._outputIdToJobMap[inputId];\n            //console.debug( '\\t\\t source job id:', sourceId );\n            if (!sourceId) {\n                var joblessVertex = self.createJobLessVertex(inputId);\n                sourceId = joblessVertex.name;\n            }\n            //TODO:?? no checking here whether sourceId is actually in the vertex map\n            //console.debug( '\\t\\t creating edge, source:', sourceId, self.vertices[ sourceId ] );\n            //console.debug( '\\t\\t creating edge, target:', targetId, self.vertices[ targetId ] );\n            self.createEdge(sourceId, targetId, self.directed, {\n                dataset: inputId\n            });\n        });\n    });\n    //console.debug( self.toVerticesAndEdges().edges );\n\n    self.debug(\n        \"final graph: \",\n        JSON.stringify(self.toVerticesAndEdges(), null, \"  \")\n    );\n    return self;\n};\n\n/** Return a 'mangled' version of history contents id to prevent contents <-> job id collision */\nJobDAG.prototype.createJobLessVertex = function _createJobLessVertex(\n    contentId\n) {\n    // currently, copied contents are the only history contents without jobs (that I know of)\n    //note: following needed to prevent id collision btwn content and jobs in vertex map\n    var JOBLESS_ID_MANGLER = \"copy-\",\n        mangledId = JOBLESS_ID_MANGLER + contentId;\n    return this.createVertex(mangledId, this._historyContentsMap[contentId]);\n};\n\n/** Override to re-sort (ugh) jobs in each component by update time */\nJobDAG.prototype.weakComponentGraphArray = function() {\n    var dag = this;\n    return this.weakComponents().map(function(component) {\n        //TODO: this seems to belong above (in sort) - why isn't it preserved?\n        // note: using create_time (as opposed to update_time)\n        //  since update_time for jobless/copied datasets is changes more often\n        component.vertices.sort(function cmpCreate(a, b) {\n            var aCreateTime = a.data.job\n                    ? a.data.job.create_time\n                    : a.data.create_time,\n                bCreateTime = b.data.job\n                    ? b.data.job.create_time\n                    : b.data.create_time;\n            if (aCreateTime > bCreateTime) {\n                return 1;\n            }\n            if (aCreateTime < bCreateTime) {\n                return -1;\n            }\n            return 0;\n        });\n        return new Graph(dag.directed, component);\n    });\n};\n\nJobDAG.prototype._jobsDataMap = function() {\n    var jobsDataMap = {};\n    this._jobsData.forEach(function(jobData) {\n        jobsDataMap[jobData.job.id] = jobData;\n    });\n    return jobsDataMap;\n};\n\n// ============================================================================\nexport default JobDAG;\n"]}