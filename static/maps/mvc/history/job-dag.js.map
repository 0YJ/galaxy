{"version":3,"sources":["mvc/history/job-dag.js"],"names":["define","GRAPH","addLogging","_super","JobDAG","options","self","call","_","pick","dataKeys","prototype","Graph","excludeSetMetadata","filters","defaults","_initFilters","init","filteredSetMetadata","jobData","job","tool_id","push","id","filteredErroredJobs","state","isArray","concat","debug","read","_read","has","data","preprocessHistoryContents","preprocessTools","tools","preprocessJobs","jobs","createGraph","_filterJobs","this","historyContents","_historyContentsMap","forEach","content","i","clone","_toolMap","each","tool","_outputIdToJobMap","_jobsData","sort","map","preprocessJob","a","create_time","b","index","size","inputs","_processInputs","noInputJobs","outputs","_processOutputs","inputMap","nameInJob","input","_validateInputOutput","name","inputOutput","__validateInputOutput","src","Error","JSON","stringify","outputMap","output","__filterJobs","_filterJob","j","length","jobsData","createVertex","inputId","sourceId","createJobLessVertex","createEdge","targetId","directed","dataset","toVerticesAndEdges","contentId","mangledId","weakComponentGraphArray","dag","weakComponents","component","vertices","aCreateTime","bCreateTime","cmpCreate","_jobsDataMap","jobsDataMap"],"mappings":"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","file":"../../../scripts/mvc/history/job-dag.js","sourcesContent":["define([\n    'utils/graph',\n    'utils/add-logging'\n],function( GRAPH, addLogging ){\n\n'use strict';\n\n// ============================================================================\nvar _super = GRAPH.Graph;\n/** A Directed acyclic Graph built from a history's job data.\n *      Reads in job json, filters and process that json, and builds a graph\n *      using the connections between job inputs and outputs.\n */\nvar JobDAG = function( options ){\n    options = options || {};\n    var self = this;\n    //this.logger = console;\n\n    self.filters = [];\n\n    // instance vars\n//TODO: needed?\n    self._jobsData = [];\n    self._historyContentsMap = {};\n    self._toolMap = {};\n\n    self._outputIdToJobMap = {};\n    self.noInputJobs = [];\n    self.noOutputJobs = [];\n\n//TODO: save these?\n    self.filteredSetMetadata = [];\n    self.filteredErroredJobs = [];\n\n    self.dataKeys = [ 'jobs', 'historyContents', 'tools' ];\n    _super.call( self, true,\n        _.pick( options, self.dataKeys ),\n        _.omit( options, self.dataKeys )\n    );\n};\nJobDAG.prototype = new GRAPH.Graph();\nJobDAG.prototype.constructor = JobDAG;\n\n// add logging ability - turn off/on using the this.logger statement above\naddLogging( JobDAG );\n\n\n// ----------------------------------------------------------------------------\n/** process jobs, options, filters, and any history data, then create the graph */\nJobDAG.prototype.init = function _init( options ){\n    options = options || {};\n\n    var self = this;\n    self.options = _.defaults( options, {\n        excludeSetMetadata : false\n    });\n    self.filters = self._initFilters();\n\n    _super.prototype.init.call( self, options );\n    return self;\n};\n\n/** add job filters based on options */\nJobDAG.prototype._initFilters = function __initFilters(){\n    var self = this,\n        filters = [];\n\n    if( self.options.excludeSetMetadata ){\n        self.filteredSetMetadata = [];\n        filters.push( function filterSetMetadata( jobData ){\n            if( jobData.job.tool_id !== '__SET_METADATA__' ){ return true; }\n            self.filteredSetMetadata.push( jobData.job.id );\n            return false;\n        });\n    }\n\n    if( self.options.excludeErroredJobs ){\n        self.filteredErroredJobs = [];\n        filters.push( function filterErrored( jobData ){\n            if( jobData.job.state !== 'error' ){ return true; }\n            self.filteredErroredJobs.push( jobData.job.id );\n            return false;\n        });\n    }\n\n    // all outputs deleted\n    // all outputs hidden\n\n    if( _.isArray( self.options.filters ) ){\n        filters = filters.concat( self.options.filters );\n    }\n    self.debug( 'filters len:', filters.length );\n    return filters;\n};\n\n/**  */\nJobDAG.prototype.read = function _read( data ){\n    var self = this;\n    if( _.has( data, 'historyContents' ) && _.has( data, 'jobs' ) && _.has( data, 'tools' ) ){\n        // a job dag is composed of these three elements:\n        //  clone the 3 data sources into the DAG, processing the jobs finally using the history and tools\n        self.preprocessHistoryContents( data.historyContents || [] )\n            .preprocessTools( data.tools || {} )\n            .preprocessJobs( data.jobs || [] );\n\n        // filter jobs and create the vertices and edges of the job DAG\n        self.createGraph( self._filterJobs() );\n        return self;\n    }\n    return _super.prototype.read.call( this, data );\n};\n\n/**  */\nJobDAG.prototype.preprocessHistoryContents = function _preprocessHistoryContents( historyContents ){\n    this.info( 'processing history' );\n    var self = this;\n    self._historyContentsMap = {};\n\n    historyContents.forEach( function( content, i ){\n        self._historyContentsMap[ content.id ] = _.clone( content );\n    });\n    return self;\n};\n\n/**  */\nJobDAG.prototype.preprocessTools = function _preprocessTools( tools ){\n    this.info( 'processing tools' );\n    var self = this;\n    self._toolMap = {};\n\n    _.each( tools, function( tool, id ){\n        self._toolMap[ id ] = _.clone( tool );\n    });\n    return self;\n};\n\n/** sort the cloned jobs, decorate with tool and history contents info, and store in prop array */\nJobDAG.prototype.preprocessJobs = function _preprocessJobs( jobs ){\n    this.info( 'processing jobs' );\n    var self = this;\n    self._outputIdToJobMap = {};\n\n    self._jobsData = self.sort( jobs ).map( function( job ){\n        return self.preprocessJob( _.clone( job ) );\n    });\n//console.debug( JSON.stringify( self._jobsData, null, '    ' ) );\n//console.debug( JSON.stringify( self._outputIdToJobMap, null, '    ' ) );\n    return self;\n};\n\n/** sort the jobs based on update time */\nJobDAG.prototype.sort = function _sort( jobs ){\n    function cmpCreate( a, b ){\n        if( a.create_time > b.create_time ){ return 1; }\n        if( a.create_time < b.create_time ){ return -1; }\n        return 0;\n    }\n    return jobs.sort( cmpCreate );\n};\n\n/** decorate with input/output datasets and tool */\nJobDAG.prototype.preprocessJob = function _preprocessJob( job, index ){\n    //this.info( 'preprocessJob', job, index );\n    var self = this,\n        jobData = { job: job };\n\n    jobData.inputs = self._processInputs( job );\n    if( _.size( jobData.inputs ) === 0 ){\n        self.noInputJobs.push( job.id );\n    }\n    jobData.outputs = self._processOutputs( job );\n    if( _.size( jobData.outputs ) === 0 ){\n        self.noOutputJobs.push( job.id );\n    }\n\n    jobData.tool = self._toolMap[ job.tool_id ];\n\n    //self.info( '\\t jobData:', jobData );\n    return jobData;\n};\n\n/**\n */\nJobDAG.prototype._processInputs = function __processInputs( job ){\n    var self = this,\n        inputs = job.inputs,\n        inputMap = {};\n    _.each( inputs, function( input, nameInJob ){\n        input = _.clone( self._validateInputOutput( input ) );\n        input.name = nameInJob;\n        // since this is a DAG and we're processing in order of create time,\n        //  the inputs for this job will already be listed in _outputIdToJobMap\n        //  TODO: we can possibly exploit this\n        //console.debug( 'input in _outputIdToJobMap', self._outputIdToJobMap[ input.id ] );\n        input.content = self._historyContentsMap[ input.id ];\n        inputMap[ input.id ] = input;\n    });\n    return inputMap;\n};\n\n/**\n */\nJobDAG.prototype._validateInputOutput = function __validateInputOutput( inputOutput ){\n    if( !inputOutput.id ){\n        throw new Error( 'No id on job input/output: ', JSON.stringify( inputOutput ) );\n    }\n    if( !inputOutput.src || inputOutput.src !== 'hda' ){\n        throw new Error( 'Bad src on job input/output: ', JSON.stringify( inputOutput ) );\n    }\n    return inputOutput;\n};\n\n/**\n */\nJobDAG.prototype._processOutputs = function __processOutputs( job ){\n    var self = this,\n        outputs = job.outputs,\n        outputMap = {};\n    _.each( outputs, function( output, nameInJob ){\n        output = _.clone( self._validateInputOutput( output ) );\n        output.name = nameInJob;\n        // add dataset content to jobData\n        output.content = self._historyContentsMap[ output.id ];\n        outputMap[ output.id ] = output;\n\n        self._outputIdToJobMap[ output.id ] = job.id;\n    });\n    return outputMap;\n};\n\n/**  */\nJobDAG.prototype._filterJobs = function __filterJobs(){\n    var self = this;\n    return self._jobsData.filter( function( j, i ){ return self._filterJob( j, i ); });\n};\n\n/**\n */\nJobDAG.prototype._filterJob = function _filterJob( jobData, index ){\n    // apply filters after processing job allowing access to the additional data above inside the filters\n    var self = this;\n    for( var i=0; i<self.filters.length; i++ ){\n        if( !self.filters[i].call( self, jobData ) ){\n            self.debug( '\\t job', jobData.job.id, ' has been filtered out by function:\\n', self.filters[i] );\n            return false;\n        }\n    }\n    return true;\n};\n\n/** Walk all the jobs (vertices), attempting to find connections\n *  between datasets used as both inputs and outputs (edges)\n */\nJobDAG.prototype.createGraph = function _createGraph( jobsData ){\n    var self = this;\n    self.debug( 'connections:' );\n    //console.debug( jobsData );\n\n    _.each( jobsData, function( jobData ){\n        var id = jobData.job.id;\n        self.debug( '\\t', id, jobData );\n        self.createVertex( id, jobData );\n    });\n    _.each( jobsData, function( jobData ){\n        var targetId = jobData.job.id;\n        _.each( jobData.inputs, function( input, inputId ){\n            //console.debug( '\\t\\t target input:', inputId, input );\n            var sourceId = self._outputIdToJobMap[ inputId ];\n            //console.debug( '\\t\\t source job id:', sourceId );\n            if( !sourceId ){\n                var joblessVertex = self.createJobLessVertex( inputId );\n                sourceId = joblessVertex.name;\n            }\n//TODO:?? no checking here whether sourceId is actually in the vertex map\n            //console.debug( '\\t\\t creating edge, source:', sourceId, self.vertices[ sourceId ] );\n            //console.debug( '\\t\\t creating edge, target:', targetId, self.vertices[ targetId ] );\n            self.createEdge( sourceId, targetId, self.directed, {\n                dataset : inputId\n            });\n        });\n    });\n    //console.debug( self.toVerticesAndEdges().edges );\n\n    self.debug( 'final graph: ', JSON.stringify( self.toVerticesAndEdges(), null, '  ' ) );\n    return self;\n};\n\n/** Return a 'mangled' version of history contents id to prevent contents <-> job id collision */\nJobDAG.prototype.createJobLessVertex = function _createJobLessVertex( contentId ){\n    // currently, copied contents are the only history contents without jobs (that I know of)\n    //note: following needed to prevent id collision btwn content and jobs in vertex map\n    var JOBLESS_ID_MANGLER = 'copy-',\n        mangledId = JOBLESS_ID_MANGLER + contentId;\n    return this.createVertex( mangledId, this._historyContentsMap[ contentId ] );\n};\n\n/** Override to re-sort (ugh) jobs in each component by update time */\nJobDAG.prototype.weakComponentGraphArray = function(){\n    var dag = this;\n    return this.weakComponents().map( function( component ){\n//TODO: this seems to belong above (in sort) - why isn't it preserved?\n        // note: using create_time (as opposed to update_time)\n        //  since update_time for jobless/copied datasets is changes more often\n        component.vertices.sort( function cmpCreate( a, b ){\n            var aCreateTime = a.data.job? a.data.job.create_time : a.data.create_time,\n                bCreateTime = b.data.job? b.data.job.create_time : b.data.create_time;\n            if( aCreateTime > bCreateTime ){ return 1; }\n            if( aCreateTime < bCreateTime ){ return -1; }\n            return 0;\n        });\n        return new Graph( dag.directed, component );\n    });\n};\n\nJobDAG.prototype._jobsDataMap = function(){\n    var jobsDataMap = {};\n    this._jobsData.forEach( function( jobData ){\n        jobsDataMap[ jobData.job.id ] = jobData;\n    });\n    return jobsDataMap;\n};\n\n\n// ============================================================================\n    return JobDAG;\n});\n"]}