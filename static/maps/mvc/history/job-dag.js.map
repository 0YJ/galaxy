{"version":3,"sources":["mvc/history/job-dag.js"],"names":["define","GRAPH","addLogging","_super","JobDAG","options","self","call","_","pick","dataKeys","prototype","Graph","excludeSetMetadata","filters","defaults","_initFilters","init","filteredSetMetadata","jobData","job","tool_id","push","id","filteredErroredJobs","state","isArray","concat","debug","read","_read","has","data","preprocessHistoryContents","preprocessTools","tools","preprocessJobs","jobs","createGraph","_filterJobs","this","historyContents","_historyContentsMap","forEach","content","i","clone","_toolMap","each","tool","_outputIdToJobMap","_jobsData","sort","map","preprocessJob","a","create_time","cmpCreate","b","index","size","inputs","_processInputs","noInputJobs","outputs","_processOutputs","inputMap","nameInJob","input","_validateInputOutput","name","inputOutput","__validateInputOutput","src","Error","JSON","stringify","outputMap","output","__filterJobs","_filterJob","j","length","jobsData","createVertex","inputId","sourceId","createJobLessVertex","createEdge","targetId","directed","dataset","toVerticesAndEdges","contentId","mangledId","weakComponentGraphArray","dag","weakComponents","component","vertices","aCreateTime","bCreateTime","_jobsDataMap","jobsDataMap"],"mappings":"YAAAA,SACI,cADJA,qBAGE,SAAUC,EAAOC,GAKnB,GAAAC,GAAIA,EAASF,MAKbG,EAAIA,SAASC,GACTA,EAAAA,KACA,IAAAC,GAAIA,IAGJA,GAAAA,WAIAA,EAAAA,aACAA,EAAAA,uBACAA,EAAAA,YAEAA,EAAAA,qBACAA,EAAAA,eACAA,EAAAA,gBAGAA,EAAAA,uBACAA,EAAAA,uBAEAA,EAAAA,UAAA,OAAkB,kBAAQ,SAC1BH,EAAAA,KAAOI,GAAMD,EAtBjBE,EAAAC,KAAAJ,EAAAC,EAAAI,UA2BAN,EAAAA,KAAOO,EAAYL,EAAIL,WAoRnB,OAjRJG,GAAAO,UAAA,GAAAV,GAAAW,MACAV,EAAAA,UAAYE,YAAZA,EAIAF,EAAAE,GAKIE,EAAAA,UAAKD,KAAUG,SAAYH,GACvBQ,EAAAA,KAEJP,IAAAA,GAAKQ,IAOTV,OAVIE,GAAKD,QAAUG,EAAEO,SAAUV,GAK3BF,oBAAA,IAEHG,EAXDQ,QAAAR,EAAAU,eAaAb,EAAAQ,UAAAM,KAAAV,KAAAD,EAAAD,GACOM,GAIHP,EAAAO,UAASN,aAAQQ,WACbP,GAAAA,GAAAA,KACAQ,IAuBJ,OAtB0DR,GAAAD,QAAAQ,qBAAcP,EAAAY,uBAChEZ,EAAAA,KAAKY,SAA0BC,GAC/B,MAAA,qBAAAA,EAAOC,IAAPC,UACHf,EAJDY,oBAAAI,KAAAH,EAAAC,IAAAG,KAKH,MAIGT,EAAAA,QAAQQ,qBACJhB,EAAAkB,uBAAqCV,EAAAQ,KAAA,SAAAH,GAAc,MAAA,UAAAA,EAAAC,IAAAK,QACnDnB,EAAAA,oBAAKkB,KAAoBF,EAAMH,IAAQC,KACvC,MAORZ,EAAAkB,QAAMA,EAASpB,QAAKD,WAChBS,EAAAA,EAAUA,OAAQa,EAAQrB,QAAKD,UAEnCC,EAAAA,MAAKsB,eAAOd,EAAgBA,QAC5BA,GAIJV,EAAAA,UAAOO,KAAUkB,SAAgBC,GAC7B,GAAAxB,GAAIA,IACJ,OAAAE,GAAAuB,IAAMA,EAAKC,oBAAPxB,EAAoCA,IAAAwB,EAAA,SAAyBxB,EAAEuB,IAAKC,EAAM,UAG1E1B,EAAAA,0BAAK2B,EAA2BD,qBAC3BE,gBAAiBF,EAAKG,WAG3BC,eAAAJ,EAAAK,UAGH/B,EAAAgC,YAAAhC,EAAAiC,eACMpC,GAAAA,EAAOQ,UAAUkB,KAAKtB,KAAMiC,KAAMR,IAMzC5B,EAAAO,UAAIL,0BAAJ,SAAAmC,GACAnC,KAAAA,KAAKoC,qBADL,IAAIpC,GAAOkC,IAMX,OAHAC,GAAAA,uBAECA,EAFDE,QAAA,SAAAC,EAAAC,GAGAvC,EAAAoC,oBAAAE,EAAArB,IAAAf,EAAAsC,MAAAF,KAAOtC,GAMPF,EAAAO,UAAIL,gBAAJ,SAAA6B,GACA7B,KAAAA,KAAKyC,mBADL,IAAIzC,GAAOkC,IAMX,OAHAhC,GAAAA,YAECA,EAAAwC,KAFDb,EAAA,SAAAc,EAAA1B,GAGAjB,EAAAyC,SAAAxB,GAAAf,EAAAsC,MAAAG,KAAO3C,GAMPF,EAAAO,UAAIL,eAAJ,SAAA+B,GACA/B,KAAAA,KAAK4C,kBADL,IAAI5C,GAAOkC,IAQX,OALAlC,GAAAA,qBAECA,EAFgB6C,UAAjB7C,EAAA8C,KAAAf,GAAAgB,IAAA,SAAAjC,GAGJ,MAAAd,GAAAgD,cAAA9C,EAAAsC,MAAA1B,MAEWd,GAMHF,EAAAO,UAAI4C,KAAEC,SAAgBA,GAAe,QAAAC,GAAAF,EAAAG,GAAW,MAAAH,GAAAC,YAAAE,EAAAF,YAAA,EAChDD,EAAAC,YAAMA,EAAFA,aAA+B,EAAE,EACrC,MAAAnB,GAAAe,KAAAK,IAMRrD,EAAOO,UAAU2C,cAAgB,SAAyBlC,EAAKuC,GAA/DvD,GAAAA,GAAOO,KACHQ,GAAAC,IAAAA,EAgBA,OAfAD,GACIA,OAAAA,EAAYC,eADhBA,GAIiC,IAA7BZ,EAAEoD,KAAMzC,EAAQ0C,SADpB1C,EAAAA,YAAiBb,KAAKwD,EAAAA,IAElBxD,EAAAA,QAAKyD,EAAAA,gBAAL3C,GACH,IAAAZ,EAAAoD,KAAAzC,EAAA6C,UACD7C,EAAAA,aAAkBb,KAAK2D,EAAAA,IAGtB9C,EAAA8B,KAAA3C,EAAAyC,SAAA3B,EAAAC,SAKMF,GAGXf,EAAAO,UAAAmD,eAAA,SAAA1C,GAGI,GAAId,GAAOkC,KADfpC,EAAOO,EAAUmD,OACbI,IAWIA,OAXJ1D,GAAAwC,KACIa,EAAAA,SAAaA,EADjBM,GAAAC,EAEIF,EAAAA,MAFJ5D,EAAA+D,qBAAAD,IAGA5D,EAAA8D,KAAAH,EAKIC,EAAAxB,QAAAtC,EAAAoC,oBAAA0B,EAAA7C,IACA2C,EAAAE,EAAA7C,IAAA6C,IAEAF,GAKR9D,EAAAO,UAAA0D,qBAAA,SAAAE,GAGI,IAAKA,EAAYhD,GADrBnB,KAAOO,IAAAA,OAAU0D,8BAAgCG,KAAAA,UAAAA,GAEzC,KAAAD,EAAME,KAAW,QAAAF,EAAAE,IACpB,KAAA,IAAAC,OAAA,gCAAAC,KAAAC,UAAAL,GAEG,OAAAA,IAKRnE,EAAAO,UAAAsD,gBAAA,SAAA7C,GAGI,GAAId,GAAOkC,KADfpC,EAAOO,EAAUsD,QACbY,IAUIvE,OAVJE,GAAAwC,KACIgB,EAAAA,SAAcA,EADlBG,GAAAW,EAEID,EAAAA,MAFJvE,EAAA+D,qBAAAS,IAGAtE,EAAQwD,KAARG,EAEIW,EAAAA,QAAAxE,EAAc6D,oBAAdW,EAAAvD,IACAsD,EAAAC,EAAAvD,IAAAuD,EAEAD,EAAAA,kBAAAC,EAAyBA,IAAzB1D,EAAAG,KAEAjB,GAMRF,EAAOO,UAAU4B,YAAc,WAD/B,GAAAjC,GAAAkC,IACApC,OAAOO,GAAAA,UAAU4B,OAAjB,SAAwCwC,EAAAA,GAAAA,MAAczE,GAAA0E,WAAAC,EAAApC,MAGrDzC,EAHDO,UAAAqE,WAAA,SAAA7D,EAAAwC,GAUI,IAAK,GALTrD,GAAAkC,KAKaK,EAAE,EAAGA,EAAEvC,EAAKQ,QAAQoE,OAAQrC,IAHzCzC,IAAOO,EAAAA,QAAUqE,GAAAA,KAAa1E,EAAAa,GAEtBb,MADJA,GAAAsB,MAAA,SAAAT,EAAAC,IAAAG,GAAA,wCAAAjB,EAAAQ,QAAA+B,KACW,CAGHvC,QAAAA,GAUZF,EAAOO,UAAU2B,YAAc,SAAuB6C,GAHtD,GAAA7E,GAAAkC,IA8BK,OAzBDlC,GAAKsB,MAAO,gBADZpB,EAAAwC,KAAI1C,EAAO,SAAXa,GACAb,GAAAA,GAAKsB,EAAOR,IAAAG,EACZjB,GAAAsB,MAAA,KAAAL,EAAAJ,GAKIb,EAAK8E,aAAc7D,EAAIJ,KAFvBX,EAAAwC,KAAAmC,EAAShE,SAAAA,GACTb,GAAAA,GAAYa,EAAZC,IAAsBD,EACtBb,GAAAA,KAAAA,EAAK8E,OAAL,SAAAhB,EAAAiB,GAEFrC,GAAMmC,GAAU7E,EAAA4C,kBAAmBmC,EAEjC7E,KAAEwC,EAAca,CAEZyB,EADAhF,EAAAiF,oBAAAF,GACoBnC,KAKnB5C,EAAAkF,WAAAF,EAAAG,EAAAnF,EAAAoF,UACbC,QAAAN,QAMS/E,EAAAsB,MAdD,gBAAA+C,KAAAC,UAAAtE,EAAAsF,qBAAA,KAAA,OAFJtF,GAqBAF,EAAAO,UAAOL,oBAAP,SAAAuF,GAGJ,GACAzF,GADA,QACAyF,CACI,OAAArD,MAAA4C,aAAAU,EAAAtD,KAAAE,oBAAAmD,KAIAzF,EAAAO,UAAOoF,wBAAA,WACV,GANDC,GAAAxD,IAWI,OAAOA,MAAKyD,iBAAiB5C,IAAK,SAAU6C,GAOpC,MAPRA,GAAOC,SAAKF,KAAAA,SAAgCC,EAAAA,GAChD,GAAAE,GAAA7C,EAAAvB,KAAAZ,IAAAmC,EAAAvB,KAAAZ,IAAAoC,YAAAD,EAAAvB,KAAAwB,YACQ6C,EAAA3C,EAAA1B,KAAAZ,IAAAsC,EAAA1B,KAAAZ,IAAAoC,YAAAE,EAAA1B,KAAAwB,WACA,OAAA4C,GAAAC,EAAA,EACAH,EAAAG,GAAkC5C,EAC9B,IAEA,GAAA7C,OAAIwF,EAAAA,SAAcC,MACejG,EAAAO,UAAA2F,aAAA,WAAY,GAAAC,KAIpD,OAHO/D,MAAAW,UAAAR,QAAA,SAAAxB,GACHoF,EANDpF,EAAAC,IAAAG,IAAAJ,IAJJoF,GAiBAnG","file":"../../../scripts/mvc/history/job-dag.js","sourcesContent":["define([\n    'utils/graph',\n    'utils/add-logging'\n],function( GRAPH, addLogging ){\n\n'use strict';\n\n// ============================================================================\nvar _super = GRAPH.Graph;\n/** A Directed acyclic Graph built from a history's job data.\n *      Reads in job json, filters and process that json, and builds a graph\n *      using the connections between job inputs and outputs.\n */\nvar JobDAG = function( options ){\n    options = options || {};\n    var self = this;\n    //this.logger = console;\n\n    self.filters = [];\n\n    // instance vars\n//TODO: needed?\n    self._jobsData = [];\n    self._historyContentsMap = {};\n    self._toolMap = {};\n\n    self._outputIdToJobMap = {};\n    self.noInputJobs = [];\n    self.noOutputJobs = [];\n\n//TODO: save these?\n    self.filteredSetMetadata = [];\n    self.filteredErroredJobs = [];\n\n    self.dataKeys = [ 'jobs', 'historyContents', 'tools' ];\n    _super.call( self, true,\n        _.pick( options, self.dataKeys ),\n        _.omit( options, self.dataKeys )\n    );\n};\nJobDAG.prototype = new GRAPH.Graph();\nJobDAG.prototype.constructor = JobDAG;\n\n// add logging ability - turn off/on using the this.logger statement above\naddLogging( JobDAG );\n\n\n// ----------------------------------------------------------------------------\n/** process jobs, options, filters, and any history data, then create the graph */\nJobDAG.prototype.init = function _init( options ){\n    options = options || {};\n\n    var self = this;\n    self.options = _.defaults( options, {\n        excludeSetMetadata : false\n    });\n    self.filters = self._initFilters();\n\n    _super.prototype.init.call( self, options );\n    return self;\n};\n\n/** add job filters based on options */\nJobDAG.prototype._initFilters = function __initFilters(){\n    var self = this,\n        filters = [];\n\n    if( self.options.excludeSetMetadata ){\n        self.filteredSetMetadata = [];\n        filters.push( function filterSetMetadata( jobData ){\n            if( jobData.job.tool_id !== '__SET_METADATA__' ){ return true; }\n            self.filteredSetMetadata.push( jobData.job.id );\n            return false;\n        });\n    }\n\n    if( self.options.excludeErroredJobs ){\n        self.filteredErroredJobs = [];\n        filters.push( function filterErrored( jobData ){\n            if( jobData.job.state !== 'error' ){ return true; }\n            self.filteredErroredJobs.push( jobData.job.id );\n            return false;\n        });\n    }\n\n    // all outputs deleted\n    // all outputs hidden\n\n    if( _.isArray( self.options.filters ) ){\n        filters = filters.concat( self.options.filters );\n    }\n    self.debug( 'filters len:', filters.length );\n    return filters;\n};\n\n/**  */\nJobDAG.prototype.read = function _read( data ){\n    var self = this;\n    if( _.has( data, 'historyContents' ) && _.has( data, 'jobs' ) && _.has( data, 'tools' ) ){\n        // a job dag is composed of these three elements:\n        //  clone the 3 data sources into the DAG, processing the jobs finally using the history and tools\n        self.preprocessHistoryContents( data.historyContents || [] )\n            .preprocessTools( data.tools || {} )\n            .preprocessJobs( data.jobs || [] );\n\n        // filter jobs and create the vertices and edges of the job DAG\n        self.createGraph( self._filterJobs() );\n        return self;\n    }\n    return _super.prototype.read.call( this, data );\n};\n\n/**  */\nJobDAG.prototype.preprocessHistoryContents = function _preprocessHistoryContents( historyContents ){\n    this.info( 'processing history' );\n    var self = this;\n    self._historyContentsMap = {};\n\n    historyContents.forEach( function( content, i ){\n        self._historyContentsMap[ content.id ] = _.clone( content );\n    });\n    return self;\n};\n\n/**  */\nJobDAG.prototype.preprocessTools = function _preprocessTools( tools ){\n    this.info( 'processing tools' );\n    var self = this;\n    self._toolMap = {};\n\n    _.each( tools, function( tool, id ){\n        self._toolMap[ id ] = _.clone( tool );\n    });\n    return self;\n};\n\n/** sort the cloned jobs, decorate with tool and history contents info, and store in prop array */\nJobDAG.prototype.preprocessJobs = function _preprocessJobs( jobs ){\n    this.info( 'processing jobs' );\n    var self = this;\n    self._outputIdToJobMap = {};\n\n    self._jobsData = self.sort( jobs ).map( function( job ){\n        return self.preprocessJob( _.clone( job ) );\n    });\n//console.debug( JSON.stringify( self._jobsData, null, '    ' ) );\n//console.debug( JSON.stringify( self._outputIdToJobMap, null, '    ' ) );\n    return self;\n};\n\n/** sort the jobs based on update time */\nJobDAG.prototype.sort = function _sort( jobs ){\n    function cmpCreate( a, b ){\n        if( a.create_time > b.create_time ){ return 1; }\n        if( a.create_time < b.create_time ){ return -1; }\n        return 0;\n    }\n    return jobs.sort( cmpCreate );\n};\n\n/** decorate with input/output datasets and tool */\nJobDAG.prototype.preprocessJob = function _preprocessJob( job, index ){\n    //this.info( 'preprocessJob', job, index );\n    var self = this,\n        jobData = { job: job };\n\n    jobData.inputs = self._processInputs( job );\n    if( _.size( jobData.inputs ) === 0 ){\n        self.noInputJobs.push( job.id );\n    }\n    jobData.outputs = self._processOutputs( job );\n    if( _.size( jobData.outputs ) === 0 ){\n        self.noOutputJobs.push( job.id );\n    }\n\n    jobData.tool = self._toolMap[ job.tool_id ];\n\n    //self.info( '\\t jobData:', jobData );\n    return jobData;\n};\n\n/**\n */\nJobDAG.prototype._processInputs = function __processInputs( job ){\n    var self = this,\n        inputs = job.inputs,\n        inputMap = {};\n    _.each( inputs, function( input, nameInJob ){\n        input = _.clone( self._validateInputOutput( input ) );\n        input.name = nameInJob;\n        // since this is a DAG and we're processing in order of create time,\n        //  the inputs for this job will already be listed in _outputIdToJobMap\n        //  TODO: we can possibly exploit this\n        //console.debug( 'input in _outputIdToJobMap', self._outputIdToJobMap[ input.id ] );\n        input.content = self._historyContentsMap[ input.id ];\n        inputMap[ input.id ] = input;\n    });\n    return inputMap;\n};\n\n/**\n */\nJobDAG.prototype._validateInputOutput = function __validateInputOutput( inputOutput ){\n    if( !inputOutput.id ){\n        throw new Error( 'No id on job input/output: ', JSON.stringify( inputOutput ) );\n    }\n    if( !inputOutput.src || inputOutput.src !== 'hda' ){\n        throw new Error( 'Bad src on job input/output: ', JSON.stringify( inputOutput ) );\n    }\n    return inputOutput;\n};\n\n/**\n */\nJobDAG.prototype._processOutputs = function __processOutputs( job ){\n    var self = this,\n        outputs = job.outputs,\n        outputMap = {};\n    _.each( outputs, function( output, nameInJob ){\n        output = _.clone( self._validateInputOutput( output ) );\n        output.name = nameInJob;\n        // add dataset content to jobData\n        output.content = self._historyContentsMap[ output.id ];\n        outputMap[ output.id ] = output;\n\n        self._outputIdToJobMap[ output.id ] = job.id;\n    });\n    return outputMap;\n};\n\n/**  */\nJobDAG.prototype._filterJobs = function __filterJobs(){\n    var self = this;\n    return self._jobsData.filter( function( j, i ){ return self._filterJob( j, i ); });\n};\n\n/**\n */\nJobDAG.prototype._filterJob = function _filterJob( jobData, index ){\n    // apply filters after processing job allowing access to the additional data above inside the filters\n    var self = this;\n    for( var i=0; i<self.filters.length; i++ ){\n        if( !self.filters[i].call( self, jobData ) ){\n            self.debug( '\\t job', jobData.job.id, ' has been filtered out by function:\\n', self.filters[i] );\n            return false;\n        }\n    }\n    return true;\n};\n\n/** Walk all the jobs (vertices), attempting to find connections\n *  between datasets used as both inputs and outputs (edges)\n */\nJobDAG.prototype.createGraph = function _createGraph( jobsData ){\n    var self = this;\n    self.debug( 'connections:' );\n    //console.debug( jobsData );\n\n    _.each( jobsData, function( jobData ){\n        var id = jobData.job.id;\n        self.debug( '\\t', id, jobData );\n        self.createVertex( id, jobData );\n    });\n    _.each( jobsData, function( jobData ){\n        var targetId = jobData.job.id;\n        _.each( jobData.inputs, function( input, inputId ){\n            //console.debug( '\\t\\t target input:', inputId, input );\n            var sourceId = self._outputIdToJobMap[ inputId ];\n            //console.debug( '\\t\\t source job id:', sourceId );\n            if( !sourceId ){\n                var joblessVertex = self.createJobLessVertex( inputId );\n                sourceId = joblessVertex.name;\n            }\n//TODO:?? no checking here whether sourceId is actually in the vertex map\n            //console.debug( '\\t\\t creating edge, source:', sourceId, self.vertices[ sourceId ] );\n            //console.debug( '\\t\\t creating edge, target:', targetId, self.vertices[ targetId ] );\n            self.createEdge( sourceId, targetId, self.directed, {\n                dataset : inputId\n            });\n        });\n    });\n    //console.debug( self.toVerticesAndEdges().edges );\n\n    self.debug( 'final graph: ', JSON.stringify( self.toVerticesAndEdges(), null, '  ' ) );\n    return self;\n};\n\n/** Return a 'mangled' version of history contents id to prevent contents <-> job id collision */\nJobDAG.prototype.createJobLessVertex = function _createJobLessVertex( contentId ){\n    // currently, copied contents are the only history contents without jobs (that I know of)\n    //note: following needed to prevent id collision btwn content and jobs in vertex map\n    var JOBLESS_ID_MANGLER = 'copy-',\n        mangledId = JOBLESS_ID_MANGLER + contentId;\n    return this.createVertex( mangledId, this._historyContentsMap[ contentId ] );\n};\n\n/** Override to re-sort (ugh) jobs in each component by update time */\nJobDAG.prototype.weakComponentGraphArray = function(){\n    var dag = this;\n    return this.weakComponents().map( function( component ){\n//TODO: this seems to belong above (in sort) - why isn't it preserved?\n        // note: using create_time (as opposed to update_time)\n        //  since update_time for jobless/copied datasets is changes more often\n        component.vertices.sort( function cmpCreate( a, b ){\n            var aCreateTime = a.data.job? a.data.job.create_time : a.data.create_time,\n                bCreateTime = b.data.job? b.data.job.create_time : b.data.create_time;\n            if( aCreateTime > bCreateTime ){ return 1; }\n            if( aCreateTime < bCreateTime ){ return -1; }\n            return 0;\n        });\n        return new Graph( dag.directed, component );\n    });\n};\n\nJobDAG.prototype._jobsDataMap = function(){\n    var jobsDataMap = {};\n    this._jobsData.forEach( function( jobData ){\n        jobsDataMap[ jobData.job.id ] = jobData;\n    });\n    return jobsDataMap;\n};\n\n\n// ============================================================================\n    return JobDAG;\n});\n"]}