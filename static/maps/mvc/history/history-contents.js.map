{"version":3,"sources":["mvc/history/history-contents.js"],"names":["define","_super","CONTROLLED_FETCH_COLLECTION","PaginatedCollection","HISTORY_PREFS","BASE_MVC","AJAX_QUEUE","HistoryContents","extend","LoggableMixin","model","attrs","history_content_type","HDA_MODEL","HistoryDatasetAssociation","HistoryListDatasetCollection","HistoryPairDatasetCollection","collection_type","HDCA_MODEL","options","HistoryListPairedDatasetCollection","HistoryListOfListsDatasetCollection","msg","console","warn","validationError","limitPerPage","limitPerProgressiveFetch","order","urlRoot","Galaxy","root","initialize","this","historyId","setHistoryId","prototype","includeDeleted","history","includeHidden","idAttribute","_setUpWebStorage","newId","storage","trigger","HistoryPrefs","id","historyStorageKey","on","include-deleted","newVal","include-hidden","comparators","_","buildComparator","ascending","name","name-dsc","hid","hid-asc","running","filter","c","inReadyState","runningAndActive","get","getByHid","findWhere","haveDetails","all","hasDetails","hidden","deleted","visibleAndUndeleted","setIncludeDeleted","setting","isBoolean","result","setIncludeHidden","fetch","details","prefs","toJSON","isEmpty","expandedIds","values","join","call","_buildFetchData","v","_fetchParams","concat","_buildFetchFilters","superFilters","filters","purged","defaults","getTotalItemCount","visible","fetchUpdated","since","contentsShown","remove","update_time-ge","toISOString","self","undefined","fetchHidden","always","data","detailsFlag","fetchCollectionCounts","fetchAllDetails","updateWhat","updateArgs","filterParams","then","fetched","reduce","modelArray","currJson","i","_filterAndUpdate","ajaxQueue","collection","AjaxQueue","slice","reverse","map","content","fn","apply","args","deferred","_recursivelyFetch","offset","progressivelyFetchDetails","clone","detailKeys","limit","searchAttributes","_options","view","reject","keys","response","notify","length","resolve","isString","isCopyable","contentsJSON","copyableModelClasses","isObject","contains","model_class","copy","json","type","contentType","method","xhr","jQuery","stringify","add","parse","message","fail","source","createHDCA","elementIdentifiers","collectionType","hideSourceItems","hdca","history_id","hide_source_items","element_identifiers","save","haveSearchDetails","allFetched","has","attributes","matches","matchesWhat","Backbone","Collection","toString"],"mappings":"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","file":"../../../scripts/mvc/history/history-contents.js","sourcesContent":["define([\n    \"mvc/base/controlled-fetch-collection\",\n    \"mvc/history/hda-model\",\n    \"mvc/history/hdca-model\",\n    \"mvc/history/history-preferences\",\n    \"mvc/base-mvc\",\n    \"utils/ajax-queue\"\n], function( CONTROLLED_FETCH_COLLECTION, HDA_MODEL, HDCA_MODEL, HISTORY_PREFS, BASE_MVC, AJAX_QUEUE ){\n'use strict';\n\n//==============================================================================\nvar _super = CONTROLLED_FETCH_COLLECTION.PaginatedCollection;\n/** @class Backbone collection for history content.\n *      NOTE: history content seems like a dataset collection, but differs in that it is mixed:\n *          each element can be either an HDA (dataset) or a DatasetCollection and co-exist on\n *          the same level.\n *      Dataset collections on the other hand are not mixed and (so far) can only contain either\n *          HDAs or child dataset collections on one level.\n *      This is why this does not inherit from any of the DatasetCollections (currently).\n */\nvar HistoryContents = _super.extend( BASE_MVC.LoggableMixin ).extend({\n    _logNamespace : 'history',\n\n    // ........................................................................ composite collection\n    /** since history content is a mix, override model fn into a factory, creating based on history_content_type */\n    model : function( attrs, options ) {\n        if( attrs.history_content_type === \"dataset\" ) {\n            return new HDA_MODEL.HistoryDatasetAssociation( attrs, options );\n\n        } else if( attrs.history_content_type === \"dataset_collection\" ) {\n            switch( attrs.collection_type ){\n                case 'list':\n                    return new HDCA_MODEL.HistoryListDatasetCollection( attrs, options );\n                case 'paired':\n                    return new HDCA_MODEL.HistoryPairDatasetCollection( attrs, options );\n                case 'list:paired':\n                    return new HDCA_MODEL.HistoryListPairedDatasetCollection( attrs, options );\n                case 'list:list':\n                    return new HDCA_MODEL.HistoryListOfListsDatasetCollection( attrs, options );\n            }\n            // This is a hack inside a hack:\n            // Raise a plain object with validationError to fake a model.validationError\n            // (since we don't have a model to use validate with)\n            // (the outer hack being the mixed content/model function in this collection)\n            var msg = 'Unknown collection_type: ' + attrs.collection_type;\n            console.warn( msg, attrs );\n            return { validationError : msg };\n        }\n        return { validationError : 'Unknown history_content_type: ' + attrs.history_content_type };\n    },\n\n    // ........................................................................ set up\n    limitPerPage : 500,\n\n    /** @type {Integer} how many contents per call to fetch when using progressivelyFetchDetails */\n    limitPerProgressiveFetch : 500,\n\n    /** @type {String} order used here and when fetching from server */\n    order : 'hid',\n\n    /** root api url */\n    urlRoot : Galaxy.root + 'api/histories',\n\n    /** complete api url */\n    url : function(){\n        return this.urlRoot + '/' + this.historyId + '/contents';\n    },\n\n    /** Set up */\n    initialize : function( models, options ){\n        options = options || {};\n        _super.prototype.initialize.call( this, models, options );\n\n        this.history = options.history || null;\n        this.setHistoryId( options.historyId || null );\n        /** @type {Boolean} does this collection contain and fetch deleted elements */\n        this.includeDeleted = options.includeDeleted || this.includeDeleted;\n        /** @type {Boolean} does this collection contain and fetch non-visible elements */\n        this.includeHidden = options.includeHidden || this.includeHidden;\n\n        // backbonejs uses collection.model.prototype.idAttribute to determine if a model is *already* in a collection\n        //  and either merged or replaced. In this case, our 'model' is a function so we need to add idAttribute\n        //  manually here - if we don't, contents will not merge but be replaced/swapped.\n        this.model.prototype.idAttribute = 'type_id';\n    },\n\n    setHistoryId : function( newId ){\n        this.historyId = newId;\n        this._setUpWebStorage();\n    },\n\n    /** Set up client side storage. Currently PersistanStorage keyed under 'history:<id>' */\n    _setUpWebStorage : function( initialSettings ){\n        // TODO: use initialSettings\n        if( !this.historyId ){ return; }\n        this.storage = new HISTORY_PREFS.HistoryPrefs({\n            id: HISTORY_PREFS.HistoryPrefs.historyStorageKey( this.historyId )\n        });\n        this.trigger( 'new-storage', this.storage, this );\n\n        this.on({\n            'include-deleted' : function( newVal ){\n                this.storage.includeDeleted( newVal );\n            },\n            'include-hidden' : function( newVal ){\n                this.storage.includeHidden( newVal );\n            }\n        });\n\n        this.includeDeleted = this.storage.includeDeleted() || false;\n        this.includeHidden  = this.storage.includeHidden()  || false;\n        return this;\n    },\n\n    // ........................................................................ common queries\n    /** @type {Object} map of collection available sorting orders containing comparator fns */\n    comparators : _.extend( _.clone( _super.prototype.comparators ), {\n        'name'       : BASE_MVC.buildComparator( 'name', { ascending: true }),\n        'name-dsc'   : BASE_MVC.buildComparator( 'name', { ascending: false }),\n        'hid'        : BASE_MVC.buildComparator( 'hid',  { ascending: false }),\n        'hid-asc'    : BASE_MVC.buildComparator( 'hid',  { ascending: true }),\n    }),\n\n    /** Get every model in this collection not in a 'ready' state (running). */\n    running : function(){\n        return this.filter( function( c ){ return !c.inReadyState(); });\n    },\n\n    /** return contents that are not ready and not deleted/hidden */\n    runningAndActive : function(){\n        return this.filter( function( c ){\n            return ( !c.inReadyState() )\n                && (  c.get( 'visible' ) )\n                // TODO: deletedOrPurged?\n                && ( !c.get( 'deleted' ) );\n        });\n    },\n\n    /** Get the model with the given hid\n     *  @param {Int} hid the hid to search for\n     *  @returns {HistoryDatasetAssociation} the model with the given hid or undefined if not found\n     */\n    getByHid : function( hid ){\n        // note: there *can* be more than one content with a given hid, this finds the first based on order\n        return this.findWhere({ hid: hid });\n    },\n\n    /** return true if all contents have details */\n    haveDetails : function(){\n        return this.all( function( c ){ return c.hasDetails(); });\n    },\n\n    // ........................................................................ hidden / deleted\n    /** return a new contents collection of only hidden items */\n    hidden : function(){\n        return this.filter( function( c ){ return c.hidden(); });\n    },\n\n    /** return a new contents collection of only hidden items */\n    deleted : function(){\n        return this.filter( function( c ){ return c.get( 'deleted' ); });\n    },\n\n    /** return a new contents collection of only hidden items */\n    visibleAndUndeleted : function(){\n        return this.filter( function( c ){\n            return (  c.get( 'visible' ) )\n                // TODO: deletedOrPurged?\n                && ( !c.get( 'deleted' ) );\n        });\n    },\n\n    /** create a setter in order to publish the change */\n    setIncludeDeleted : function( setting, options ){\n        if( _.isBoolean( setting ) && setting !== this.includeDeleted ){\n            this.includeDeleted = setting;\n            if( _.result( options, 'silent' ) ){ return; }\n            this.trigger( 'include-deleted', setting, this );\n        }\n    },\n\n    /** create a setter in order to publish the change */\n    setIncludeHidden : function( setting, options ){\n        if( _.isBoolean( setting ) && setting !== this.includeHidden ){\n            this.includeHidden = setting;\n            options = options || {};\n            if( _.result( options, 'silent' ) ){ return; }\n            this.trigger( 'include-hidden', setting, this );\n        }\n    },\n\n    // ........................................................................ ajax\n    // ............ controlled fetch collection\n    /** override to get expanded ids from sessionStorage and pass to API as details */\n    fetch : function( options ){\n        options = options || {};\n        if( this.historyId && !options.details ){\n            var prefs = HISTORY_PREFS.HistoryPrefs.get( this.historyId ).toJSON();\n            if( !_.isEmpty( prefs.expandedIds ) ){\n                options.details = _.values( prefs.expandedIds ).join( ',' );\n            }\n        }\n        return _super.prototype.fetch.call( this, options );\n    },\n\n    // ............. ControlledFetch stuff\n    /** override to include the API versioning flag */\n    _buildFetchData : function( options ){\n        return _.extend( _super.prototype._buildFetchData.call( this, options ), {\n            v : 'dev'\n        });\n    },\n\n    /** Extend to include details and version */\n    _fetchParams : _super.prototype._fetchParams.concat([\n        // TODO: remove (the need for) both\n        /** version */\n        'v',\n        /** dataset ids to get full details of */\n        'details',\n    ]),\n\n    /** override to add deleted/hidden filters */\n    _buildFetchFilters : function( options ){\n        var superFilters = _super.prototype._buildFetchFilters.call( this, options ) || {};\n        var filters = {};\n        if( !this.includeDeleted ){\n            filters.deleted = false;\n            filters.purged = false;\n        }\n        if( !this.includeHidden ){\n            filters.visible = true;\n        }\n        return _.defaults( superFilters, filters );\n    },\n\n    // ............ paginated collection\n    getTotalItemCount : function(){\n        return this.history.contentsShown();\n    },\n\n    // ............ history contents specific ajax\n    /** override to filter requested contents to those updated after the Date 'since' */\n    fetchUpdated : function( since, options ){\n        if( since ){\n            options = options || { filters: {} };\n            options.remove = false;\n            options.filters = {\n                'update_time-ge' : since.toISOString(),\n                // workflows will produce hidden datasets (non-output datasets) that still\n                // need to be updated in the collection or they'll update forever\n                // we can remove the default visible filter by using an 'empty' value\n                visible          : ''\n            };\n        }\n        return this.fetch( options );\n    },\n\n    /** fetch all the deleted==true contents of this collection */\n    fetchDeleted : function( options ){\n        options = options || {};\n        var self = this;\n        options.filters = _.extend( options.filters, {\n            // all deleted, purged or not\n            deleted : true,\n            purged  : undefined\n        });\n        options.remove = false;\n\n        self.trigger( 'fetching-deleted', self );\n        return self.fetch( options )\n            .always( function(){ self.trigger( 'fetching-deleted-done', self ); });\n    },\n\n    /** fetch all the visible==false contents of this collection */\n    fetchHidden : function( options ){\n        options = options || {};\n        var self = this;\n        options.filters = _.extend( options.filters, {\n            visible : false\n        });\n        options.remove = false;\n\n        self.trigger( 'fetching-hidden', self );\n        return self.fetch( options )\n            .always( function(){ self.trigger( 'fetching-hidden-done', self ); });\n    },\n\n    /** fetch detailed model data for all contents in this collection */\n    fetchAllDetails : function( options ){\n        options = options || {};\n        var detailsFlag = { details: 'all' };\n        options.data = _.extend( options.data || {}, detailsFlag );\n        return this.fetch( options );\n    },\n\n    /** specialty fetch method for retrieving the element_counts of all hdcas in the history */\n    fetchCollectionCounts : function( options ){\n        options = options || {};\n        options.keys = [ 'type_id', 'element_count' ].join( ',' );\n        options.filters = _.extend( options.filters || {}, {\n            history_content_type: 'dataset_collection',\n        });\n        options.remove = false;\n        return this.fetch( options );\n    },\n\n    // ............. quasi-batch ops\n    // TODO: to batch\n    /** helper that fetches using filterParams then calls save on each fetched using updateWhat as the save params */\n    _filterAndUpdate : function( filterParams, updateWhat ){\n        var self = this;\n        var idAttribute = self.model.prototype.idAttribute;\n        var updateArgs = [ updateWhat ];\n\n        return self.fetch({ filters: filterParams, remove: false })\n            .then( function( fetched ){\n                // convert filtered json array to model array\n                fetched = fetched.reduce( function( modelArray, currJson, i ){\n                    var model = self.get( currJson[ idAttribute ] );\n                    return model? modelArray.concat( model ) : modelArray;\n                }, []);\n                return self.ajaxQueue( 'save', updateArgs, fetched );\n            });\n    },\n\n    /** using a queue, perform ajaxFn on each of the models in this collection */\n    ajaxQueue : function( ajaxFn, args, collection ){\n        collection = collection || this.models;\n        return new AJAX_QUEUE.AjaxQueue( collection.slice().reverse().map( function( content, i ){\n            var fn = _.isString( ajaxFn )? content[ ajaxFn ] : ajaxFn;\n            return function(){ return fn.apply( content, args ); };\n        })).deferred;\n    },\n\n    /** fetch contents' details in batches of limitPerCall - note: only get searchable details here */\n    progressivelyFetchDetails : function( options ){\n        options = options || {};\n        var deferred = jQuery.Deferred();\n        var self = this;\n        var limit = options.limitPerCall || self.limitPerProgressiveFetch;\n        // TODO: only fetch tags and annotations if specifically requested\n        var searchAttributes = HDA_MODEL.HistoryDatasetAssociation.prototype.searchAttributes;\n        var detailKeys = searchAttributes.join( ',' );\n\n        function _recursivelyFetch( offset ){\n            offset = offset || 0;\n            var _options = _.extend( _.clone( options ), {\n                view    : 'summary',\n                keys    : detailKeys,\n                limit   : limit,\n                offset  : offset,\n                reset   : offset === 0,\n                remove  : false\n            });\n\n            _.defer( function(){\n                self.fetch.call( self, _options )\n                    .fail( deferred.reject )\n                    .done( function( response ){\n                        deferred.notify( response, limit, offset );\n                        if( response.length !== limit ){\n                            self.allFetched = true;\n                            deferred.resolve( response, limit, offset );\n\n                        } else {\n                            _recursivelyFetch( offset + limit );\n                        }\n                    });\n            });\n        }\n        _recursivelyFetch();\n        return deferred;\n    },\n\n    /** does some bit of JSON represent something that can be copied into this contents collection */\n    isCopyable : function( contentsJSON ){\n        var copyableModelClasses = [\n            'HistoryDatasetAssociation',\n            'HistoryDatasetCollectionAssociation'\n        ];\n        return ( ( _.isObject( contentsJSON ) && contentsJSON.id )\n              && ( _.contains( copyableModelClasses, contentsJSON.model_class ) ) );\n    },\n\n    /** copy an existing, accessible hda into this collection */\n    copy : function( json ){\n        // TODO: somehow showhorn all this into 'save'\n        var id, type, contentType;\n        if( _.isString( json ) ){\n            id = json;\n            contentType = 'hda';\n            type = 'dataset';\n        } else {\n            id = json.id;\n            contentType = ({\n                'HistoryDatasetAssociation' : 'hda',\n                'LibraryDatasetDatasetAssociation' : 'ldda',\n                'HistoryDatasetCollectionAssociation' : 'hdca'\n            })[ json.model_class ] || 'hda';\n            type = ( contentType === 'hdca'? 'dataset_collection' : 'dataset' );\n        }\n        var collection = this,\n            xhr = jQuery.ajax( this.url(), {\n                method: 'POST',\n                contentType: 'application/json',\n                data: JSON.stringify({\n                    content : id,\n                    source  : contentType,\n                    type    : type\n                })\n            })\n            .done( function( response ){\n                collection.add([ response ], { parse: true });\n            })\n            .fail( function( error, status, message ){\n                collection.trigger( 'error', collection, xhr, {},\n                    'Error copying contents', { type: type, id: id, source: contentType });\n            });\n        return xhr;\n    },\n\n    /** create a new HDCA in this collection */\n    createHDCA : function( elementIdentifiers, collectionType, name, hideSourceItems, options ){\n        // normally collection.create returns the new model, but we need the promise from the ajax, so we fake create\n        //precondition: elementIdentifiers is an array of plain js objects\n        //  in the proper form to create the collectionType\n        var hdca = this.model({\n            history_content_type: 'dataset_collection',\n            collection_type     : collectionType,\n            history_id          : this.historyId,\n            name                : name,\n            hide_source_items   : hideSourceItems || false,\n            // should probably be able to just send in a bunch of json here and restruct per class\n            // note: element_identifiers is now (incorrectly) an attribute\n            element_identifiers : elementIdentifiers\n        // do not create the model on the client until the ajax returns\n        });\n        return hdca.save( options );\n    },\n\n    // ........................................................................ searching\n    /** return true if all contents have the searchable attributes */\n    haveSearchDetails : function(){\n        return this.allFetched && this.all( function( content ){\n            // null (which is a valid returned annotation value)\n            // will return false when using content.has( 'annotation' )\n            //TODO: a bit hacky - formalize\n            return _.has( content.attributes, 'annotation' );\n        });\n    },\n\n    /** return a new collection of contents whose attributes contain the substring matchesWhat */\n    matches : function( matchesWhat ){\n        return this.filter( function( content ){\n            return content.matches( matchesWhat );\n        });\n    },\n\n    // ........................................................................ misc\n    /** In this override, copy the historyId to the clone */\n    clone : function(){\n        var clone = Backbone.Collection.prototype.clone.call( this );\n        clone.historyId = this.historyId;\n        return clone;\n    },\n\n    /** String representation. */\n    toString : function(){\n         return ([ 'HistoryContents(', [ this.historyId, this.length ].join(), ')' ].join( '' ));\n    }\n});\n\n\n//==============================================================================\n    return {\n        HistoryContents : HistoryContents\n    };\n});\n"]}