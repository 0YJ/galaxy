{"version":3,"sources":["mvc/history/history-contents.js"],"names":["define","CONTROLLED_FETCH_COLLECTION","HDA_MODEL","HDCA_MODEL","HISTORY_PREFS","BASE_MVC","AJAX_QUEUE","_super","PaginatedCollection","HistoryContents","extend","LoggableMixin","_logNamespace","model","attrs","options","history_content_type","HistoryDatasetAssociation","collection_type","HistoryListDatasetCollection","HistoryPairDatasetCollection","HistoryListPairedDatasetCollection","HistoryListOfListsDatasetCollection","msg","console","warn","validationError","limitPerPage","limitPerProgressiveFetch","order","urlRoot","Galaxy","root","url","this","historyId","initialize","models","prototype","call","history","setHistoryId","includeDeleted","includeHidden","idAttribute","newId","_setUpWebStorage","initialSettings","storage","HistoryPrefs","id","historyStorageKey","trigger","on","include-deleted","newVal","include-hidden","comparators","_","clone","name","buildComparator","ascending","name-dsc","hid","hid-asc","running","filter","c","inReadyState","runningAndActive","get","getByHid","findWhere","haveDetails","all","hasDetails","hidden","deleted","visibleAndUndeleted","setIncludeDeleted","setting","isBoolean","result","setIncludeHidden","fetch","details","prefs","toJSON","isEmpty","expandedIds","values","join","_buildFetchData","v","_fetchParams","concat","_buildFetchFilters","superFilters","filters","purged","visible","defaults","getTotalItemCount","contentsShown","fetchUpdated","since","remove","update_time-ge","toISOString","fetchDeleted","self","undefined","always","fetchHidden","fetchAllDetails","detailsFlag","data","fetchCollectionCounts","keys","_filterAndUpdate","filterParams","updateWhat","updateArgs","then","fetched","reduce","modelArray","currJson","i","ajaxQueue","ajaxFn","args","collection","AjaxQueue","slice","reverse","map","content","fn","isString","apply","deferred","progressivelyFetchDetails","_recursivelyFetch","offset","_options","view","detailKeys","limit","reset","defer","fail","reject","done","response","notify","length","allFetched","resolve","jQuery","Deferred","limitPerCall","searchAttributes","isCopyable","contentsJSON","copyableModelClasses","isObject","contains","model_class","copy","json","type","contentType","LibraryDatasetDatasetAssociation","HistoryDatasetCollectionAssociation","xhr","ajax","method","JSON","stringify","source","add","parse","error","status","message","createHDCA","elementIdentifiers","collectionType","hideSourceItems","history_id","hide_source_items","element_identifiers","save","haveSearchDetails","has","attributes","matches","matchesWhat","Backbone","Collection","toString"],"mappings":"AAAAA,QACI,uCACA,wBACA,yBACA,kCACA,eACA,oBACD,SAAUC,EAA6BC,EAAWC,EAAYC,EAAeC,EAAUC,GAC1F,YAGA,IAAIC,GAASN,EAA4BO,mBAgdrC,QACIC,gBAxccF,EAAOG,OAAQL,EAASM,eAAgBD,QAC1DE,cAAgB,UAIhBC,MAAQ,SAAUC,EAAOC,GACrB,GAAmC,YAA/BD,EAAME,qBACN,MAAO,IAAId,GAAUe,0BAA2BH,EAAOC,EAEpD,IAAmC,uBAA/BD,EAAME,qBAAgD,CAC7D,OAAQF,EAAMI,iBACV,IAAK,OACD,MAAO,IAAIf,GAAWgB,6BAA8BL,EAAOC,EAC/D,KAAK,SACD,MAAO,IAAIZ,GAAWiB,6BAA8BN,EAAOC,EAC/D,KAAK,cACD,MAAO,IAAIZ,GAAWkB,mCAAoCP,EAAOC,EACrE,KAAK,YACD,MAAO,IAAIZ,GAAWmB,oCAAqCR,EAAOC,GAM1E,GAAIQ,GAAM,4BAA8BT,EAAMI,eAE9C,OADAM,SAAQC,KAAMF,EAAKT,IACVY,gBAAkBH,GAE/B,OAASG,gBAAkB,iCAAmCZ,EAAME,uBAIxEW,aAAe,IAGfC,yBAA2B,IAG3BC,MAAQ,MAGRC,QAAUC,OAAOC,KAAO,gBAGxBC,IAAM,WACF,MAAOC,MAAKJ,QAAU,IAAMI,KAAKC,UAAY,aAIjDC,WAAa,SAAUC,EAAQtB,GAC3BA,EAAUA,MACVR,EAAO+B,UAAUF,WAAWG,KAAML,KAAMG,EAAQtB,GAEhDmB,KAAKM,QAAUzB,EAAQyB,SAAW,KAClCN,KAAKO,aAAc1B,EAAQoB,WAAa,MAExCD,KAAKQ,eAAiB3B,EAAQ2B,gBAAkBR,KAAKQ,eAErDR,KAAKS,cAAgB5B,EAAQ4B,eAAiBT,KAAKS,cAKnDT,KAAKrB,MAAMyB,UAAUM,YAAc,WAGvCH,aAAe,SAAUI,GACrBX,KAAKC,UAAYU,EACjBX,KAAKY,oBAITA,iBAAmB,SAAUC,GAEzB,GAAKb,KAAKC,UAiBV,MAhBAD,MAAKc,QAAU,GAAI5C,GAAc6C,cAC7BC,GAAI9C,EAAc6C,aAAaE,kBAAmBjB,KAAKC,aAE3DD,KAAKkB,QAAS,cAAelB,KAAKc,QAASd,MAE3CA,KAAKmB,IACDC,kBAAoB,SAAUC,GAC1BrB,KAAKc,QAAQN,eAAgBa,IAEjCC,iBAAmB,SAAUD,GACzBrB,KAAKc,QAAQL,cAAeY,MAIpCrB,KAAKQ,eAAiBR,KAAKc,QAAQN,mBAAoB,EACvDR,KAAKS,cAAiBT,KAAKc,QAAQL,kBAAoB,EAChDT,MAKXuB,YAAcC,EAAEhD,OAAQgD,EAAEC,MAAOpD,EAAO+B,UAAUmB,cAC9CG,KAAevD,EAASwD,gBAAiB,QAAUC,WAAW,IAC9DC,WAAe1D,EAASwD,gBAAiB,QAAUC,WAAW,IAC9DE,IAAe3D,EAASwD,gBAAiB,OAAUC,WAAW,IAC9DG,UAAe5D,EAASwD,gBAAiB,OAAUC,WAAW,MAIlEI,QAAU,WACN,MAAOhC,MAAKiC,OAAQ,SAAUC,GAAK,OAAQA,EAAEC,kBAIjDC,iBAAmB,WACf,MAAOpC,MAAKiC,OAAQ,SAAUC,GAC1B,OAAUA,EAAEC,gBACFD,EAAEG,IAAK,aAEPH,EAAEG,IAAK,cAQzBC,SAAW,SAAUR,GAEjB,MAAO9B,MAAKuC,WAAYT,IAAKA,KAIjCU,YAAc,WACV,MAAOxC,MAAKyC,IAAK,SAAUP,GAAK,MAAOA,GAAEQ,gBAK7CC,OAAS,WACL,MAAO3C,MAAKiC,OAAQ,SAAUC,GAAK,MAAOA,GAAES,YAIhDC,QAAU,WACN,MAAO5C,MAAKiC,OAAQ,SAAUC,GAAK,MAAOA,GAAEG,IAAK,cAIrDQ,oBAAsB,WAClB,MAAO7C,MAAKiC,OAAQ,SAAUC,GAC1B,MAAUA,GAAEG,IAAK,aAEPH,EAAEG,IAAK,cAKzBS,kBAAoB,SAAUC,EAASlE,GACnC,GAAI2C,EAAEwB,UAAWD,IAAaA,IAAY/C,KAAKQ,eAAgB,CAE3D,GADAR,KAAKQ,eAAiBuC,EAClBvB,EAAEyB,OAAQpE,EAAS,UAAc,MACrCmB,MAAKkB,QAAS,kBAAmB6B,EAAS/C,QAKlDkD,iBAAmB,SAAUH,EAASlE,GAClC,GAAI2C,EAAEwB,UAAWD,IAAaA,IAAY/C,KAAKS,cAAe,CAG1D,GAFAT,KAAKS,cAAgBsC,EACrBlE,EAAUA,MACN2C,EAAEyB,OAAQpE,EAAS,UAAc,MACrCmB,MAAKkB,QAAS,iBAAkB6B,EAAS/C,QAOjDmD,MAAQ,SAAUtE,GAEd,GADAA,EAAUA,MACNmB,KAAKC,YAAcpB,EAAQuE,QAAS,CACpC,GAAIC,GAAQnF,EAAc6C,aAAasB,IAAKrC,KAAKC,WAAYqD,QACxD9B,GAAE+B,QAASF,EAAMG,eAClB3E,EAAQuE,QAAU5B,EAAEiC,OAAQJ,EAAMG,aAAcE,KAAM,MAG9D,MAAOrF,GAAO+B,UAAU+C,MAAM9C,KAAML,KAAMnB,IAK9C8E,gBAAkB,SAAU9E,GACxB,MAAO2C,GAAEhD,OAAQH,EAAO+B,UAAUuD,gBAAgBtD,KAAML,KAAMnB,IAC1D+E,EAAI,SAKZC,aAAexF,EAAO+B,UAAUyD,aAAaC,QAGzC,IAEA,YAIJC,mBAAqB,SAAUlF,GAC3B,GAAImF,GAAe3F,EAAO+B,UAAU2D,mBAAmB1D,KAAML,KAAMnB,OAC/DoF,IAQJ,OAPKjE,MAAKQ,iBACNyD,EAAQrB,SAAU,EAClBqB,EAAQC,QAAS,GAEhBlE,KAAKS,gBACNwD,EAAQE,SAAU,GAEf3C,EAAE4C,SAAUJ,EAAcC,IAIrCI,kBAAoB,WAChB,MAAOrE,MAAKM,QAAQgE,iBAKxBC,aAAe,SAAUC,EAAO3F,GAY5B,MAXI2F,KACA3F,EAAUA,IAAaoF,YACvBpF,EAAQ4F,QAAS,EACjB5F,EAAQoF,SACJS,iBAAmBF,EAAMG,cAIzBR,QAAmB,KAGpBnE,KAAKmD,MAAOtE,IAIvB+F,aAAe,SAAU/F,GACrBA,EAAUA,KACV,IAAIgG,GAAO7E,IASX,OARAnB,GAAQoF,QAAUzC,EAAEhD,OAAQK,EAAQoF,SAEhCrB,SAAU,EACVsB,WAAUY,KAEdjG,EAAQ4F,QAAS,EAEjBI,EAAK3D,QAAS,mBAAoB2D,GAC3BA,EAAK1B,MAAOtE,GACdkG,OAAQ,WAAYF,EAAK3D,QAAS,wBAAyB2D,MAIpEG,YAAc,SAAUnG,GACpBA,EAAUA,KACV,IAAIgG,GAAO7E,IAOX,OANAnB,GAAQoF,QAAUzC,EAAEhD,OAAQK,EAAQoF,SAChCE,SAAU,IAEdtF,EAAQ4F,QAAS,EAEjBI,EAAK3D,QAAS,kBAAmB2D,GAC1BA,EAAK1B,MAAOtE,GACdkG,OAAQ,WAAYF,EAAK3D,QAAS,uBAAwB2D,MAInEI,gBAAkB,SAAUpG,GACxBA,EAAUA,KACV,IAAIqG,IAAgB9B,QAAS,MAE7B,OADAvE,GAAQsG,KAAO3D,EAAEhD,OAAQK,EAAQsG,SAAYD,GACtClF,KAAKmD,MAAOtE,IAIvBuG,sBAAwB,SAAUvG,GAO9B,MANAA,GAAUA,MACVA,EAAQwG,MAAS,UAAW,iBAAkB3B,KAAM,KACpD7E,EAAQoF,QAAUzC,EAAEhD,OAAQK,EAAQoF,aAChCnF,qBAAsB,uBAE1BD,EAAQ4F,QAAS,EACVzE,KAAKmD,MAAOtE,IAMvByG,iBAAmB,SAAUC,EAAcC,GACvC,GAAIX,GAAO7E,KACPU,EAAcmE,EAAKlG,MAAMyB,UAAUM,YACnC+E,GAAeD,EAEnB,OAAOX,GAAK1B,OAAQc,QAASsB,EAAcd,QAAQ,IAC9CiB,KAAM,SAAUC,GAMb,MAJAA,GAAUA,EAAQC,OAAQ,SAAUC,EAAYC,EAAUC,GACtD,GAAIpH,GAAQkG,EAAKxC,IAAKyD,EAAUpF,GAChC,OAAO/B,GAAOkH,EAAW/B,OAAQnF,GAAUkH,OAExChB,EAAKmB,UAAW,OAAQP,EAAYE,MAKvDK,UAAY,SAAUC,EAAQC,EAAMC,GAEhC,MADAA,GAAaA,GAAcnG,KAAKG,OACzB,GAAI/B,GAAWgI,UAAWD,EAAWE,QAAQC,UAAUC,IAAK,SAAUC,EAAST,GAClF,GAAIU,GAAKjF,EAAEkF,SAAUT,GAAUO,EAASP,GAAWA,CACnD,OAAO,YAAY,MAAOQ,GAAGE,MAAOH,EAASN,OAC7CU,UAIRC,0BAA4B,SAAUhI,GASlC,QAASiI,GAAmBC,GACxBA,EAASA,GAAU,CACnB,IAAIC,GAAWxF,EAAEhD,OAAQgD,EAAEC,MAAO5C,IAC9BoI,KAAU,UACV5B,KAAU6B,EACVC,MAAUA,EACVJ,OAAUA,EACVK,MAAqB,IAAXL,EACVtC,QAAU,GAGdjD,GAAE6F,MAAO,WACLxC,EAAK1B,MAAM9C,KAAMwE,EAAMmC,GAClBM,KAAMV,EAASW,QACfC,KAAM,SAAUC,GACbb,EAASc,OAAQD,EAAUN,EAAOJ,GAC9BU,EAASE,SAAWR,GACpBtC,EAAK+C,YAAa,EAClBhB,EAASiB,QAASJ,EAAUN,EAAOJ,IAGnCD,EAAmBC,EAASI,OA7BhDtI,EAAUA,KACV,IAAI+H,GAAWkB,OAAOC,WAClBlD,EAAO7E,KACPmH,EAAQtI,EAAQmJ,cAAgBnD,EAAKnF,yBAErCuI,EAAmBjK,EAAUe,0BAA0BqB,UAAU6H,iBACjEf,EAAae,EAAiBvE,KAAM,IA6BxC,OADAoD,KACOF,GAIXsB,WAAa,SAAUC,GACnB,GAAIC,IACA,4BACA,sCAEJ,OAAW5G,GAAE6G,SAAUF,IAAkBA,EAAanH,IAC3CQ,EAAE8G,SAAUF,EAAsBD,EAAaI,cAI9DC,KAAO,SAAUC,GAEb,GAAIzH,GAAI0H,EAAMC,CACVnH,GAAEkF,SAAU+B,IACZzH,EAAKyH,EACLE,EAAc,MACdD,EAAO,YAEP1H,EAAKyH,EAAKzH,GACV2H,GACI5J,0BAA8B,MAC9B6J,iCAAqC,OACrCC,oCAAwC,QACxCJ,EAAKF,cAAiB,MAC1BG,EAAyB,SAAhBC,EAAwB,qBAAuB,UAE5D,IAAIxC,GAAanG,KACb8I,EAAMhB,OAAOiB,KAAM/I,KAAKD,OACpBiJ,OAAQ,OACRL,YAAa,mBACbxD,KAAM8D,KAAKC,WACP1C,QAAUxF,EACVmI,OAAUR,EACVD,KAAUA,MAGjBlB,KAAM,SAAUC,GACbtB,EAAWiD,KAAM3B,IAAc4B,OAAO,MAEzC/B,KAAM,SAAUgC,EAAOC,EAAQC,GAC5BrD,EAAWjF,QAAS,QAASiF,EAAY2C,KACrC,0BAA4BJ,KAAMA,EAAM1H,GAAIA,EAAImI,OAAQR,KAEpE,OAAOG,IAIXW,WAAa,SAAUC,EAAoBC,EAAgBjI,EAAMkI,EAAiB/K,GAe9E,MAXWmB,MAAKrB,OACZG,qBAAsB,qBACtBE,gBAAsB2K,EACtBE,WAAsB7J,KAAKC,UAC3ByB,KAAsBA,EACtBoI,kBAAsBF,IAAmB,EAGzCG,oBAAsBL,IAGdM,KAAMnL,IAKtBoL,kBAAoB,WAChB,MAAOjK,MAAK4H,YAAc5H,KAAKyC,IAAK,SAAU+D,GAI1C,MAAOhF,GAAE0I,IAAK1D,EAAQ2D,WAAY,iBAK1CC,QAAU,SAAUC,GAChB,MAAOrK,MAAKiC,OAAQ,SAAUuE,GAC1B,MAAOA,GAAQ4D,QAASC,MAMhC5I,MAAQ,WACJ,GAAIA,GAAQ6I,SAASC,WAAWnK,UAAUqB,MAAMpB,KAAML,KAEtD,OADAyB,GAAMxB,UAAYD,KAAKC,UAChBwB,GAIX+I,SAAW,WACN,OAAU,oBAAsBxK,KAAKC,UAAWD,KAAK2H,QAASjE,OAAQ,KAAMA,KAAM","file":"../../../scripts/mvc/history/history-contents.js","sourcesContent":["define([\n    \"mvc/base/controlled-fetch-collection\",\n    \"mvc/history/hda-model\",\n    \"mvc/history/hdca-model\",\n    \"mvc/history/history-preferences\",\n    \"mvc/base-mvc\",\n    \"utils/ajax-queue\"\n], function( CONTROLLED_FETCH_COLLECTION, HDA_MODEL, HDCA_MODEL, HISTORY_PREFS, BASE_MVC, AJAX_QUEUE ){\n'use strict';\n\n//==============================================================================\nvar _super = CONTROLLED_FETCH_COLLECTION.PaginatedCollection;\n/** @class Backbone collection for history content.\n *      NOTE: history content seems like a dataset collection, but differs in that it is mixed:\n *          each element can be either an HDA (dataset) or a DatasetCollection and co-exist on\n *          the same level.\n *      Dataset collections on the other hand are not mixed and (so far) can only contain either\n *          HDAs or child dataset collections on one level.\n *      This is why this does not inherit from any of the DatasetCollections (currently).\n */\nvar HistoryContents = _super.extend( BASE_MVC.LoggableMixin ).extend({\n    _logNamespace : 'history',\n\n    // ........................................................................ composite collection\n    /** since history content is a mix, override model fn into a factory, creating based on history_content_type */\n    model : function( attrs, options ) {\n        if( attrs.history_content_type === \"dataset\" ) {\n            return new HDA_MODEL.HistoryDatasetAssociation( attrs, options );\n\n        } else if( attrs.history_content_type === \"dataset_collection\" ) {\n            switch( attrs.collection_type ){\n                case 'list':\n                    return new HDCA_MODEL.HistoryListDatasetCollection( attrs, options );\n                case 'paired':\n                    return new HDCA_MODEL.HistoryPairDatasetCollection( attrs, options );\n                case 'list:paired':\n                    return new HDCA_MODEL.HistoryListPairedDatasetCollection( attrs, options );\n                case 'list:list':\n                    return new HDCA_MODEL.HistoryListOfListsDatasetCollection( attrs, options );\n            }\n            // This is a hack inside a hack:\n            // Raise a plain object with validationError to fake a model.validationError\n            // (since we don't have a model to use validate with)\n            // (the outer hack being the mixed content/model function in this collection)\n            var msg = 'Unknown collection_type: ' + attrs.collection_type;\n            console.warn( msg, attrs );\n            return { validationError : msg };\n        }\n        return { validationError : 'Unknown history_content_type: ' + attrs.history_content_type };\n    },\n\n    // ........................................................................ set up\n    limitPerPage : 500,\n\n    /** @type {Integer} how many contents per call to fetch when using progressivelyFetchDetails */\n    limitPerProgressiveFetch : 500,\n\n    /** @type {String} order used here and when fetching from server */\n    order : 'hid',\n\n    /** root api url */\n    urlRoot : Galaxy.root + 'api/histories',\n\n    /** complete api url */\n    url : function(){\n        return this.urlRoot + '/' + this.historyId + '/contents';\n    },\n\n    /** Set up */\n    initialize : function( models, options ){\n        options = options || {};\n        _super.prototype.initialize.call( this, models, options );\n\n        this.history = options.history || null;\n        this.setHistoryId( options.historyId || null );\n        /** @type {Boolean} does this collection contain and fetch deleted elements */\n        this.includeDeleted = options.includeDeleted || this.includeDeleted;\n        /** @type {Boolean} does this collection contain and fetch non-visible elements */\n        this.includeHidden = options.includeHidden || this.includeHidden;\n\n        // backbonejs uses collection.model.prototype.idAttribute to determine if a model is *already* in a collection\n        //  and either merged or replaced. In this case, our 'model' is a function so we need to add idAttribute\n        //  manually here - if we don't, contents will not merge but be replaced/swapped.\n        this.model.prototype.idAttribute = 'type_id';\n    },\n\n    setHistoryId : function( newId ){\n        this.historyId = newId;\n        this._setUpWebStorage();\n    },\n\n    /** Set up client side storage. Currently PersistanStorage keyed under 'history:<id>' */\n    _setUpWebStorage : function( initialSettings ){\n        // TODO: use initialSettings\n        if( !this.historyId ){ return; }\n        this.storage = new HISTORY_PREFS.HistoryPrefs({\n            id: HISTORY_PREFS.HistoryPrefs.historyStorageKey( this.historyId )\n        });\n        this.trigger( 'new-storage', this.storage, this );\n\n        this.on({\n            'include-deleted' : function( newVal ){\n                this.storage.includeDeleted( newVal );\n            },\n            'include-hidden' : function( newVal ){\n                this.storage.includeHidden( newVal );\n            }\n        });\n\n        this.includeDeleted = this.storage.includeDeleted() || false;\n        this.includeHidden  = this.storage.includeHidden()  || false;\n        return this;\n    },\n\n    // ........................................................................ common queries\n    /** @type {Object} map of collection available sorting orders containing comparator fns */\n    comparators : _.extend( _.clone( _super.prototype.comparators ), {\n        'name'       : BASE_MVC.buildComparator( 'name', { ascending: true }),\n        'name-dsc'   : BASE_MVC.buildComparator( 'name', { ascending: false }),\n        'hid'        : BASE_MVC.buildComparator( 'hid',  { ascending: false }),\n        'hid-asc'    : BASE_MVC.buildComparator( 'hid',  { ascending: true }),\n    }),\n\n    /** Get every model in this collection not in a 'ready' state (running). */\n    running : function(){\n        return this.filter( function( c ){ return !c.inReadyState(); });\n    },\n\n    /** return contents that are not ready and not deleted/hidden */\n    runningAndActive : function(){\n        return this.filter( function( c ){\n            return ( !c.inReadyState() )\n                && (  c.get( 'visible' ) )\n                // TODO: deletedOrPurged?\n                && ( !c.get( 'deleted' ) );\n        });\n    },\n\n    /** Get the model with the given hid\n     *  @param {Int} hid the hid to search for\n     *  @returns {HistoryDatasetAssociation} the model with the given hid or undefined if not found\n     */\n    getByHid : function( hid ){\n        // note: there *can* be more than one content with a given hid, this finds the first based on order\n        return this.findWhere({ hid: hid });\n    },\n\n    /** return true if all contents have details */\n    haveDetails : function(){\n        return this.all( function( c ){ return c.hasDetails(); });\n    },\n\n    // ........................................................................ hidden / deleted\n    /** return a new contents collection of only hidden items */\n    hidden : function(){\n        return this.filter( function( c ){ return c.hidden(); });\n    },\n\n    /** return a new contents collection of only hidden items */\n    deleted : function(){\n        return this.filter( function( c ){ return c.get( 'deleted' ); });\n    },\n\n    /** return a new contents collection of only hidden items */\n    visibleAndUndeleted : function(){\n        return this.filter( function( c ){\n            return (  c.get( 'visible' ) )\n                // TODO: deletedOrPurged?\n                && ( !c.get( 'deleted' ) );\n        });\n    },\n\n    /** create a setter in order to publish the change */\n    setIncludeDeleted : function( setting, options ){\n        if( _.isBoolean( setting ) && setting !== this.includeDeleted ){\n            this.includeDeleted = setting;\n            if( _.result( options, 'silent' ) ){ return; }\n            this.trigger( 'include-deleted', setting, this );\n        }\n    },\n\n    /** create a setter in order to publish the change */\n    setIncludeHidden : function( setting, options ){\n        if( _.isBoolean( setting ) && setting !== this.includeHidden ){\n            this.includeHidden = setting;\n            options = options || {};\n            if( _.result( options, 'silent' ) ){ return; }\n            this.trigger( 'include-hidden', setting, this );\n        }\n    },\n\n    // ........................................................................ ajax\n    // ............ controlled fetch collection\n    /** override to get expanded ids from sessionStorage and pass to API as details */\n    fetch : function( options ){\n        options = options || {};\n        if( this.historyId && !options.details ){\n            var prefs = HISTORY_PREFS.HistoryPrefs.get( this.historyId ).toJSON();\n            if( !_.isEmpty( prefs.expandedIds ) ){\n                options.details = _.values( prefs.expandedIds ).join( ',' );\n            }\n        }\n        return _super.prototype.fetch.call( this, options );\n    },\n\n    // ............. ControlledFetch stuff\n    /** override to include the API versioning flag */\n    _buildFetchData : function( options ){\n        return _.extend( _super.prototype._buildFetchData.call( this, options ), {\n            v : 'dev'\n        });\n    },\n\n    /** Extend to include details and version */\n    _fetchParams : _super.prototype._fetchParams.concat([\n        // TODO: remove (the need for) both\n        /** version */\n        'v',\n        /** dataset ids to get full details of */\n        'details',\n    ]),\n\n    /** override to add deleted/hidden filters */\n    _buildFetchFilters : function( options ){\n        var superFilters = _super.prototype._buildFetchFilters.call( this, options ) || {};\n        var filters = {};\n        if( !this.includeDeleted ){\n            filters.deleted = false;\n            filters.purged = false;\n        }\n        if( !this.includeHidden ){\n            filters.visible = true;\n        }\n        return _.defaults( superFilters, filters );\n    },\n\n    // ............ paginated collection\n    getTotalItemCount : function(){\n        return this.history.contentsShown();\n    },\n\n    // ............ history contents specific ajax\n    /** override to filter requested contents to those updated after the Date 'since' */\n    fetchUpdated : function( since, options ){\n        if( since ){\n            options = options || { filters: {} };\n            options.remove = false;\n            options.filters = {\n                'update_time-ge' : since.toISOString(),\n                // workflows will produce hidden datasets (non-output datasets) that still\n                // need to be updated in the collection or they'll update forever\n                // we can remove the default visible filter by using an 'empty' value\n                visible          : ''\n            };\n        }\n        return this.fetch( options );\n    },\n\n    /** fetch all the deleted==true contents of this collection */\n    fetchDeleted : function( options ){\n        options = options || {};\n        var self = this;\n        options.filters = _.extend( options.filters, {\n            // all deleted, purged or not\n            deleted : true,\n            purged  : undefined\n        });\n        options.remove = false;\n\n        self.trigger( 'fetching-deleted', self );\n        return self.fetch( options )\n            .always( function(){ self.trigger( 'fetching-deleted-done', self ); });\n    },\n\n    /** fetch all the visible==false contents of this collection */\n    fetchHidden : function( options ){\n        options = options || {};\n        var self = this;\n        options.filters = _.extend( options.filters, {\n            visible : false\n        });\n        options.remove = false;\n\n        self.trigger( 'fetching-hidden', self );\n        return self.fetch( options )\n            .always( function(){ self.trigger( 'fetching-hidden-done', self ); });\n    },\n\n    /** fetch detailed model data for all contents in this collection */\n    fetchAllDetails : function( options ){\n        options = options || {};\n        var detailsFlag = { details: 'all' };\n        options.data = _.extend( options.data || {}, detailsFlag );\n        return this.fetch( options );\n    },\n\n    /** specialty fetch method for retrieving the element_counts of all hdcas in the history */\n    fetchCollectionCounts : function( options ){\n        options = options || {};\n        options.keys = [ 'type_id', 'element_count' ].join( ',' );\n        options.filters = _.extend( options.filters || {}, {\n            history_content_type: 'dataset_collection',\n        });\n        options.remove = false;\n        return this.fetch( options );\n    },\n\n    // ............. quasi-batch ops\n    // TODO: to batch\n    /** helper that fetches using filterParams then calls save on each fetched using updateWhat as the save params */\n    _filterAndUpdate : function( filterParams, updateWhat ){\n        var self = this;\n        var idAttribute = self.model.prototype.idAttribute;\n        var updateArgs = [ updateWhat ];\n\n        return self.fetch({ filters: filterParams, remove: false })\n            .then( function( fetched ){\n                // convert filtered json array to model array\n                fetched = fetched.reduce( function( modelArray, currJson, i ){\n                    var model = self.get( currJson[ idAttribute ] );\n                    return model? modelArray.concat( model ) : modelArray;\n                }, []);\n                return self.ajaxQueue( 'save', updateArgs, fetched );\n            });\n    },\n\n    /** using a queue, perform ajaxFn on each of the models in this collection */\n    ajaxQueue : function( ajaxFn, args, collection ){\n        collection = collection || this.models;\n        return new AJAX_QUEUE.AjaxQueue( collection.slice().reverse().map( function( content, i ){\n            var fn = _.isString( ajaxFn )? content[ ajaxFn ] : ajaxFn;\n            return function(){ return fn.apply( content, args ); };\n        })).deferred;\n    },\n\n    /** fetch contents' details in batches of limitPerCall - note: only get searchable details here */\n    progressivelyFetchDetails : function( options ){\n        options = options || {};\n        var deferred = jQuery.Deferred();\n        var self = this;\n        var limit = options.limitPerCall || self.limitPerProgressiveFetch;\n        // TODO: only fetch tags and annotations if specifically requested\n        var searchAttributes = HDA_MODEL.HistoryDatasetAssociation.prototype.searchAttributes;\n        var detailKeys = searchAttributes.join( ',' );\n\n        function _recursivelyFetch( offset ){\n            offset = offset || 0;\n            var _options = _.extend( _.clone( options ), {\n                view    : 'summary',\n                keys    : detailKeys,\n                limit   : limit,\n                offset  : offset,\n                reset   : offset === 0,\n                remove  : false\n            });\n\n            _.defer( function(){\n                self.fetch.call( self, _options )\n                    .fail( deferred.reject )\n                    .done( function( response ){\n                        deferred.notify( response, limit, offset );\n                        if( response.length !== limit ){\n                            self.allFetched = true;\n                            deferred.resolve( response, limit, offset );\n\n                        } else {\n                            _recursivelyFetch( offset + limit );\n                        }\n                    });\n            });\n        }\n        _recursivelyFetch();\n        return deferred;\n    },\n\n    /** does some bit of JSON represent something that can be copied into this contents collection */\n    isCopyable : function( contentsJSON ){\n        var copyableModelClasses = [\n            'HistoryDatasetAssociation',\n            'HistoryDatasetCollectionAssociation'\n        ];\n        return ( ( _.isObject( contentsJSON ) && contentsJSON.id )\n              && ( _.contains( copyableModelClasses, contentsJSON.model_class ) ) );\n    },\n\n    /** copy an existing, accessible hda into this collection */\n    copy : function( json ){\n        // TODO: somehow showhorn all this into 'save'\n        var id, type, contentType;\n        if( _.isString( json ) ){\n            id = json;\n            contentType = 'hda';\n            type = 'dataset';\n        } else {\n            id = json.id;\n            contentType = ({\n                'HistoryDatasetAssociation' : 'hda',\n                'LibraryDatasetDatasetAssociation' : 'ldda',\n                'HistoryDatasetCollectionAssociation' : 'hdca'\n            })[ json.model_class ] || 'hda';\n            type = ( contentType === 'hdca'? 'dataset_collection' : 'dataset' );\n        }\n        var collection = this,\n            xhr = jQuery.ajax( this.url(), {\n                method: 'POST',\n                contentType: 'application/json',\n                data: JSON.stringify({\n                    content : id,\n                    source  : contentType,\n                    type    : type\n                })\n            })\n            .done( function( response ){\n                collection.add([ response ], { parse: true });\n            })\n            .fail( function( error, status, message ){\n                collection.trigger( 'error', collection, xhr, {},\n                    'Error copying contents', { type: type, id: id, source: contentType });\n            });\n        return xhr;\n    },\n\n    /** create a new HDCA in this collection */\n    createHDCA : function( elementIdentifiers, collectionType, name, hideSourceItems, options ){\n        // normally collection.create returns the new model, but we need the promise from the ajax, so we fake create\n        //precondition: elementIdentifiers is an array of plain js objects\n        //  in the proper form to create the collectionType\n        var hdca = this.model({\n            history_content_type: 'dataset_collection',\n            collection_type     : collectionType,\n            history_id          : this.historyId,\n            name                : name,\n            hide_source_items   : hideSourceItems || false,\n            // should probably be able to just send in a bunch of json here and restruct per class\n            // note: element_identifiers is now (incorrectly) an attribute\n            element_identifiers : elementIdentifiers\n        // do not create the model on the client until the ajax returns\n        });\n        return hdca.save( options );\n    },\n\n    // ........................................................................ searching\n    /** return true if all contents have the searchable attributes */\n    haveSearchDetails : function(){\n        return this.allFetched && this.all( function( content ){\n            // null (which is a valid returned annotation value)\n            // will return false when using content.has( 'annotation' )\n            //TODO: a bit hacky - formalize\n            return _.has( content.attributes, 'annotation' );\n        });\n    },\n\n    /** return a new collection of contents whose attributes contain the substring matchesWhat */\n    matches : function( matchesWhat ){\n        return this.filter( function( content ){\n            return content.matches( matchesWhat );\n        });\n    },\n\n    // ........................................................................ misc\n    /** In this override, copy the historyId to the clone */\n    clone : function(){\n        var clone = Backbone.Collection.prototype.clone.call( this );\n        clone.historyId = this.historyId;\n        return clone;\n    },\n\n    /** String representation. */\n    toString : function(){\n         return ([ 'HistoryContents(', [ this.historyId, this.length ].join(), ')' ].join( '' ));\n    }\n});\n\n\n//==============================================================================\n    return {\n        HistoryContents : HistoryContents\n    };\n});\n"]}