{"version":3,"sources":["mvc/history/history-contents.js"],"names":["_controlledFetchCollection","require","_hdaModel","_hdcaModel","_historyPreferences","_baseMvc","_ajaxQueue","_super","_controlledFetchCollection2","default","PaginatedCollection","HistoryContents","extend","_baseMvc2","LoggableMixin","_logNamespace","model","attrs","options","history_content_type","_hdaModel2","HistoryDatasetAssociation","collection_type","_hdcaModel2","HistoryListDatasetCollection","HistoryPairDatasetCollection","HistoryListPairedDatasetCollection","HistoryListOfListsDatasetCollection","msg","console","warn","validationError","limitPerPage","order","urlRoot","Galaxy","root","this","historyId","initialize","models","prototype","call","history","setHistoryId","url","includeDeleted","includeHidden","newId","_setUpWebStorage","initialSettings","storage","_historyPreferences2","HistoryPrefs","on","include-deleted","newVal","include-hidden","trigger","comparators","_","clone","name","ascending","name-dsc","buildComparator","hid","hid-asc","running","filter","c","inReadyState","get","getByHid","findWhere","haveDetails","all","hasDetails","hidden","deleted","visibleAndUndeleted","setIncludeDeleted","setting","isBoolean","result","setIncludeHidden","fetch","details","prefs","toJSON","isEmpty","expandedIds","values","join","_buildFetchData","v","_fetchParams","_buildFetchFilters","superFilters","filters","getTotalItemCount","defaults","fetchUpdated","since","contentsShown","remove","fetchDeleted","self","purged","undefined","visible","always","detailsFlag","data","keys","_filterAndUpdate","filterParams","updateWhat","idAttribute","updateArgs","fetched","reduce","modelArray","currJson","i","concat","ajaxQueue","ajaxFn","args","collection","_ajaxQueue2","AjaxQueue","reverse","fn","isString","content","apply","deferred","progressivelyFetchDetails","Deferred","view","offset","detailKeys","limit","reset","defer","fail","reject","_recursivelyFetch","notify","response","length","allFetched","resolve","limitPerCall","searchAttributes","limitPerProgressiveFetch","copy","json","copyableModelClasses","id","contentType","type","contentsJSON","model_class","xhr","method","source","LibraryDatasetDatasetAssociation","jQuery","ajax","JSON","stringify","history_id","add","parse","error","status","message","element_identifiers","haveSearchDetails","createHDCA","elementIdentifiers","collectionType","hideSourceItems","toString","Collection","save","has","attributes","matches","matchesWhat","Backbone"],"mappings":"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","file":"../../../scripts/mvc/history/history-contents.js","sourcesContent":["import CONTROLLED_FETCH_COLLECTION from \"mvc/base/controlled-fetch-collection\";\nimport HDA_MODEL from \"mvc/history/hda-model\";\nimport HDCA_MODEL from \"mvc/history/hdca-model\";\nimport HISTORY_PREFS from \"mvc/history/history-preferences\";\nimport BASE_MVC from \"mvc/base-mvc\";\nimport AJAX_QUEUE from \"utils/ajax-queue\";\n\n//==============================================================================\nvar _super = CONTROLLED_FETCH_COLLECTION.PaginatedCollection;\n/** @class Backbone collection for history content.\n *      NOTE: history content seems like a dataset collection, but differs in that it is mixed:\n *          each element can be either an HDA (dataset) or a DatasetCollection and co-exist on\n *          the same level.\n *      Dataset collections on the other hand are not mixed and (so far) can only contain either\n *          HDAs or child dataset collections on one level.\n *      This is why this does not inherit from any of the DatasetCollections (currently).\n */\nvar HistoryContents = _super.extend(BASE_MVC.LoggableMixin).extend({\n    _logNamespace: \"history\",\n\n    // ........................................................................ composite collection\n    /** since history content is a mix, override model fn into a factory, creating based on history_content_type */\n    model: function(attrs, options) {\n        if (attrs.history_content_type === \"dataset\") {\n            return new HDA_MODEL.HistoryDatasetAssociation(attrs, options);\n        } else if (attrs.history_content_type === \"dataset_collection\") {\n            switch (attrs.collection_type) {\n                case \"list\":\n                    return new HDCA_MODEL.HistoryListDatasetCollection(\n                        attrs,\n                        options\n                    );\n                case \"paired\":\n                    return new HDCA_MODEL.HistoryPairDatasetCollection(\n                        attrs,\n                        options\n                    );\n                case \"list:paired\":\n                    return new HDCA_MODEL.HistoryListPairedDatasetCollection(\n                        attrs,\n                        options\n                    );\n                case \"list:list\":\n                    return new HDCA_MODEL.HistoryListOfListsDatasetCollection(\n                        attrs,\n                        options\n                    );\n            }\n            // This is a hack inside a hack:\n            // Raise a plain object with validationError to fake a model.validationError\n            // (since we don't have a model to use validate with)\n            // (the outer hack being the mixed content/model function in this collection)\n            var msg = \"Unknown collection_type: \" + attrs.collection_type;\n            console.warn(msg, attrs);\n            return { validationError: msg };\n        }\n        return {\n            validationError:\n                \"Unknown history_content_type: \" + attrs.history_content_type\n        };\n    },\n\n    // ........................................................................ set up\n    limitPerPage: 500,\n\n    /** @type {Integer} how many contents per call to fetch when using progressivelyFetchDetails */\n    limitPerProgressiveFetch: 500,\n\n    /** @type {String} order used here and when fetching from server */\n    order: \"hid\",\n\n    /** root api url */\n    urlRoot: Galaxy.root + \"api/histories\",\n\n    /** complete api url */\n    url: function() {\n        return this.urlRoot + \"/\" + this.historyId + \"/contents\";\n    },\n\n    /** Set up */\n    initialize: function(models, options) {\n        options = options || {};\n        _super.prototype.initialize.call(this, models, options);\n\n        this.history = options.history || null;\n        this.setHistoryId(options.historyId || null);\n        /** @type {Boolean} does this collection contain and fetch deleted elements */\n        this.includeDeleted = options.includeDeleted || this.includeDeleted;\n        /** @type {Boolean} does this collection contain and fetch non-visible elements */\n        this.includeHidden = options.includeHidden || this.includeHidden;\n\n        // backbonejs uses collection.model.prototype.idAttribute to determine if a model is *already* in a collection\n        //  and either merged or replaced. In this case, our 'model' is a function so we need to add idAttribute\n        //  manually here - if we don't, contents will not merge but be replaced/swapped.\n        this.model.prototype.idAttribute = \"type_id\";\n    },\n\n    setHistoryId: function(newId) {\n        this.historyId = newId;\n        this._setUpWebStorage();\n    },\n\n    /** Set up client side storage. Currently PersistanStorage keyed under 'history:<id>' */\n    _setUpWebStorage: function(initialSettings) {\n        // TODO: use initialSettings\n        if (!this.historyId) {\n            return;\n        }\n        this.storage = new HISTORY_PREFS.HistoryPrefs({\n            id: HISTORY_PREFS.HistoryPrefs.historyStorageKey(this.historyId)\n        });\n        this.trigger(\"new-storage\", this.storage, this);\n\n        this.on({\n            \"include-deleted\": function(newVal) {\n                this.storage.includeDeleted(newVal);\n            },\n            \"include-hidden\": function(newVal) {\n                this.storage.includeHidden(newVal);\n            }\n        });\n\n        this.includeDeleted = this.storage.includeDeleted() || false;\n        this.includeHidden = this.storage.includeHidden() || false;\n        return this;\n    },\n\n    // ........................................................................ common queries\n    /** @type {Object} map of collection available sorting orders containing comparator fns */\n    comparators: _.extend(_.clone(_super.prototype.comparators), {\n        name: BASE_MVC.buildComparator(\"name\", { ascending: true }),\n        \"name-dsc\": BASE_MVC.buildComparator(\"name\", {\n            ascending: false\n        }),\n        hid: BASE_MVC.buildComparator(\"hid\", { ascending: false }),\n        \"hid-asc\": BASE_MVC.buildComparator(\"hid\", { ascending: true })\n    }),\n\n    /** Get every model in this collection not in a 'ready' state (running). */\n    running: function() {\n        return this.filter(function(c) {\n            return !c.inReadyState();\n        });\n    },\n\n    /** return contents that are not ready and not deleted/hidden */\n    runningAndActive: function() {\n        return this.filter(function(c) {\n            return (\n                !c.inReadyState() &&\n                c.get(\"visible\") &&\n                // TODO: deletedOrPurged?\n                !c.get(\"deleted\")\n            );\n        });\n    },\n\n    /** Get the model with the given hid\n     *  @param {Int} hid the hid to search for\n     *  @returns {HistoryDatasetAssociation} the model with the given hid or undefined if not found\n     */\n    getByHid: function(hid) {\n        // note: there *can* be more than one content with a given hid, this finds the first based on order\n        return this.findWhere({ hid: hid });\n    },\n\n    /** return true if all contents have details */\n    haveDetails: function() {\n        return this.all(function(c) {\n            return c.hasDetails();\n        });\n    },\n\n    // ........................................................................ hidden / deleted\n    /** return a new contents collection of only hidden items */\n    hidden: function() {\n        return this.filter(function(c) {\n            return c.hidden();\n        });\n    },\n\n    /** return a new contents collection of only hidden items */\n    deleted: function() {\n        return this.filter(function(c) {\n            return c.get(\"deleted\");\n        });\n    },\n\n    /** return a new contents collection of only hidden items */\n    visibleAndUndeleted: function() {\n        return this.filter(function(c) {\n            return (\n                c.get(\"visible\") &&\n                // TODO: deletedOrPurged?\n                !c.get(\"deleted\")\n            );\n        });\n    },\n\n    /** create a setter in order to publish the change */\n    setIncludeDeleted: function(setting, options) {\n        if (_.isBoolean(setting) && setting !== this.includeDeleted) {\n            this.includeDeleted = setting;\n            if (_.result(options, \"silent\")) {\n                return;\n            }\n            this.trigger(\"include-deleted\", setting, this);\n        }\n    },\n\n    /** create a setter in order to publish the change */\n    setIncludeHidden: function(setting, options) {\n        if (_.isBoolean(setting) && setting !== this.includeHidden) {\n            this.includeHidden = setting;\n            options = options || {};\n            if (_.result(options, \"silent\")) {\n                return;\n            }\n            this.trigger(\"include-hidden\", setting, this);\n        }\n    },\n\n    // ........................................................................ ajax\n    // ............ controlled fetch collection\n    /** override to get expanded ids from sessionStorage and pass to API as details */\n    fetch: function(options) {\n        options = options || {};\n        if (this.historyId && !options.details) {\n            var prefs = HISTORY_PREFS.HistoryPrefs.get(this.historyId).toJSON();\n            if (!_.isEmpty(prefs.expandedIds)) {\n                options.details = _.values(prefs.expandedIds).join(\",\");\n            }\n        }\n        return _super.prototype.fetch.call(this, options);\n    },\n\n    // ............. ControlledFetch stuff\n    /** override to include the API versioning flag */\n    _buildFetchData: function(options) {\n        return _.extend(_super.prototype._buildFetchData.call(this, options), {\n            v: \"dev\"\n        });\n    },\n\n    /** Extend to include details and version */\n    _fetchParams: _super.prototype._fetchParams.concat([\n        // TODO: remove (the need for) both\n        /** version */\n        \"v\",\n        /** dataset ids to get full details of */\n        \"details\"\n    ]),\n\n    /** override to add deleted/hidden filters */\n    _buildFetchFilters: function(options) {\n        var superFilters =\n            _super.prototype._buildFetchFilters.call(this, options) || {};\n        var filters = {};\n        if (!this.includeDeleted) {\n            filters.deleted = false;\n            filters.purged = false;\n        }\n        if (!this.includeHidden) {\n            filters.visible = true;\n        }\n        return _.defaults(superFilters, filters);\n    },\n\n    // ............ paginated collection\n    getTotalItemCount: function() {\n        return this.history.contentsShown();\n    },\n\n    // ............ history contents specific ajax\n    /** override to filter requested contents to those updated after the Date 'since' */\n    fetchUpdated: function(since, options) {\n        if (since) {\n            options = options || { filters: {} };\n            options.remove = false;\n            options.filters = {\n                \"update_time-ge\": since.toISOString(),\n                // workflows will produce hidden datasets (non-output datasets) that still\n                // need to be updated in the collection or they'll update forever\n                // we can remove the default visible filter by using an 'empty' value\n                visible: \"\"\n            };\n        }\n        return this.fetch(options);\n    },\n\n    /** fetch all the deleted==true contents of this collection */\n    fetchDeleted: function(options) {\n        options = options || {};\n        var self = this;\n        options.filters = _.extend(options.filters, {\n            // all deleted, purged or not\n            deleted: true,\n            purged: undefined\n        });\n        options.remove = false;\n\n        self.trigger(\"fetching-deleted\", self);\n        return self.fetch(options).always(function() {\n            self.trigger(\"fetching-deleted-done\", self);\n        });\n    },\n\n    /** fetch all the visible==false contents of this collection */\n    fetchHidden: function(options) {\n        options = options || {};\n        var self = this;\n        options.filters = _.extend(options.filters, {\n            visible: false\n        });\n        options.remove = false;\n\n        self.trigger(\"fetching-hidden\", self);\n        return self.fetch(options).always(function() {\n            self.trigger(\"fetching-hidden-done\", self);\n        });\n    },\n\n    /** fetch detailed model data for all contents in this collection */\n    fetchAllDetails: function(options) {\n        options = options || {};\n        var detailsFlag = { details: \"all\" };\n        options.data = _.extend(options.data || {}, detailsFlag);\n        return this.fetch(options);\n    },\n\n    /** specialty fetch method for retrieving the element_counts of all hdcas in the history */\n    fetchCollectionCounts: function(options) {\n        options = options || {};\n        options.keys = [\"type_id\", \"element_count\"].join(\",\");\n        options.filters = _.extend(options.filters || {}, {\n            history_content_type: \"dataset_collection\"\n        });\n        options.remove = false;\n        return this.fetch(options);\n    },\n\n    // ............. quasi-batch ops\n    // TODO: to batch\n    /** helper that fetches using filterParams then calls save on each fetched using updateWhat as the save params */\n    _filterAndUpdate: function(filterParams, updateWhat) {\n        var self = this;\n        var idAttribute = self.model.prototype.idAttribute;\n        var updateArgs = [updateWhat];\n\n        return self\n            .fetch({ filters: filterParams, remove: false })\n            .then(function(fetched) {\n                // convert filtered json array to model array\n                fetched = fetched.reduce(function(modelArray, currJson, i) {\n                    var model = self.get(currJson[idAttribute]);\n                    return model ? modelArray.concat(model) : modelArray;\n                }, []);\n                return self.ajaxQueue(\"save\", updateArgs, fetched);\n            });\n    },\n\n    /** using a queue, perform ajaxFn on each of the models in this collection */\n    ajaxQueue: function(ajaxFn, args, collection) {\n        collection = collection || this.models;\n        return new AJAX_QUEUE.AjaxQueue(\n            collection\n                .slice()\n                .reverse()\n                .map(function(content, i) {\n                    var fn = _.isString(ajaxFn) ? content[ajaxFn] : ajaxFn;\n                    return function() {\n                        return fn.apply(content, args);\n                    };\n                })\n        ).deferred;\n    },\n\n    /** fetch contents' details in batches of limitPerCall - note: only get searchable details here */\n    progressivelyFetchDetails: function(options) {\n        options = options || {};\n        var deferred = jQuery.Deferred();\n        var self = this;\n        var limit = options.limitPerCall || self.limitPerProgressiveFetch;\n        // TODO: only fetch tags and annotations if specifically requested\n        var searchAttributes =\n            HDA_MODEL.HistoryDatasetAssociation.prototype.searchAttributes;\n        var detailKeys = searchAttributes.join(\",\");\n\n        function _recursivelyFetch(offset) {\n            offset = offset || 0;\n            var _options = _.extend(_.clone(options), {\n                view: \"summary\",\n                keys: detailKeys,\n                limit: limit,\n                offset: offset,\n                reset: offset === 0,\n                remove: false\n            });\n\n            _.defer(function() {\n                self.fetch\n                    .call(self, _options)\n                    .fail(deferred.reject)\n                    .done(function(response) {\n                        deferred.notify(response, limit, offset);\n                        if (response.length !== limit) {\n                            self.allFetched = true;\n                            deferred.resolve(response, limit, offset);\n                        } else {\n                            _recursivelyFetch(offset + limit);\n                        }\n                    });\n            });\n        }\n        _recursivelyFetch();\n        return deferred;\n    },\n\n    /** does some bit of JSON represent something that can be copied into this contents collection */\n    isCopyable: function(contentsJSON) {\n        var copyableModelClasses = [\n            \"HistoryDatasetAssociation\",\n            \"HistoryDatasetCollectionAssociation\"\n        ];\n        return (\n            _.isObject(contentsJSON) &&\n            contentsJSON.id &&\n            _.contains(copyableModelClasses, contentsJSON.model_class)\n        );\n    },\n\n    /** copy an existing, accessible hda into this collection */\n    copy: function(json) {\n        // TODO: somehow showhorn all this into 'save'\n        var id, type, contentType;\n        if (_.isString(json)) {\n            id = json;\n            contentType = \"hda\";\n            type = \"dataset\";\n        } else {\n            id = json.id;\n            contentType =\n                {\n                    HistoryDatasetAssociation: \"hda\",\n                    LibraryDatasetDatasetAssociation: \"ldda\",\n                    HistoryDatasetCollectionAssociation: \"hdca\"\n                }[json.model_class] || \"hda\";\n            type = contentType === \"hdca\" ? \"dataset_collection\" : \"dataset\";\n        }\n        var collection = this,\n            xhr = jQuery\n                .ajax(this.url(), {\n                    method: \"POST\",\n                    contentType: \"application/json\",\n                    data: JSON.stringify({\n                        content: id,\n                        source: contentType,\n                        type: type\n                    })\n                })\n                .done(function(response) {\n                    collection.add([response], { parse: true });\n                })\n                .fail(function(error, status, message) {\n                    collection.trigger(\n                        \"error\",\n                        collection,\n                        xhr,\n                        {},\n                        \"Error copying contents\",\n                        { type: type, id: id, source: contentType }\n                    );\n                });\n        return xhr;\n    },\n\n    /** create a new HDCA in this collection */\n    createHDCA: function(\n        elementIdentifiers,\n        collectionType,\n        name,\n        hideSourceItems,\n        options\n    ) {\n        // normally collection.create returns the new model, but we need the promise from the ajax, so we fake create\n        //precondition: elementIdentifiers is an array of plain js objects\n        //  in the proper form to create the collectionType\n        var hdca = this.model({\n            history_content_type: \"dataset_collection\",\n            collection_type: collectionType,\n            history_id: this.historyId,\n            name: name,\n            hide_source_items: hideSourceItems || false,\n            // should probably be able to just send in a bunch of json here and restruct per class\n            // note: element_identifiers is now (incorrectly) an attribute\n            element_identifiers: elementIdentifiers\n            // do not create the model on the client until the ajax returns\n        });\n        return hdca.save(options);\n    },\n\n    // ........................................................................ searching\n    /** return true if all contents have the searchable attributes */\n    haveSearchDetails: function() {\n        return (\n            this.allFetched &&\n            this.all(function(content) {\n                // null (which is a valid returned annotation value)\n                // will return false when using content.has( 'annotation' )\n                //TODO: a bit hacky - formalize\n                return _.has(content.attributes, \"annotation\");\n            })\n        );\n    },\n\n    /** return a new collection of contents whose attributes contain the substring matchesWhat */\n    matches: function(matchesWhat) {\n        return this.filter(function(content) {\n            return content.matches(matchesWhat);\n        });\n    },\n\n    // ........................................................................ misc\n    /** In this override, copy the historyId to the clone */\n    clone: function() {\n        var clone = Backbone.Collection.prototype.clone.call(this);\n        clone.historyId = this.historyId;\n        return clone;\n    },\n\n    /** String representation. */\n    toString: function() {\n        return [\n            \"HistoryContents(\",\n            [this.historyId, this.length].join(),\n            \")\"\n        ].join(\"\");\n    }\n});\n\n//==============================================================================\nexport default {\n    HistoryContents: HistoryContents\n};\n"]}