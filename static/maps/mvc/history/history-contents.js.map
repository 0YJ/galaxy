{"version":3,"sources":["mvc/history/history-contents.js"],"names":["limitPerPageDefault","localStorage","getItem","err","_super","_controlledFetchCollection2","default","PaginatedCollection","HistoryContents","extend","_baseMvc2","LoggableMixin","_logNamespace","limitPerPage","limitPerProgressiveFetch","order","url","this","urlRoot","historyId","initialize","models","options","trackJobStates","Galaxy","root","prototype","call","history","setHistoryId","includeDeleted","includeHidden","idAttribute","_this","each","historyContent","history_content_type","attributes","job_source_type","jobSourceId","job_source_id","jobStateSummariesCollection","add","model","jobSourceType","history_id","collection_id","id","get","jobStatesSummary","attrs","_hdcaModel2","stopPolling","active","clearUpdateTimeout","newId","_setUpWebStorage","_jobStatesModel2","JobStatesSummaryCollection","validationError","monitor","storage","_historyPreferences2","HistoryPrefs","historyStorageKey","trigger","on","include-deleted","newVal","include-hidden","comparators","_","clone","buildComparator","name-dsc","ascending","hid","hid-asc","running","filter","c","inReadyState","runningAndActive","getByHid","findWhere","haveDetails","all","hasDetails","hidden","deleted","visibleAndUndeleted","setIncludeDeleted","setting","isBoolean","result","setIncludeHidden","fetch","details","prefs","toJSON","isEmpty","values","expandedIds","join","_buildFetchData","_fetchParams","concat","_buildFetchFilters","superFilters","filters","visible","getTotalItemCount","contentsShown","fetchUpdated","since","remove","toISOString","fetchDeleted","_this2","purged","undefined","always","fetchHidden","self","detailsFlag","data","_filterAndUpdate","filterParams","updateWhat","then","fetched","reduce","modelArray","currJson","i","ajaxQueue","ajaxFn","args","collection","fetchAllDetails","reverse","map","content","fn","isString","apply","deferred","progressivelyFetchDetails","_recursivelyFetch","offset","_options","view","detailKeys","reset","defer","fail","reject","notify","response","limit","jQuery","Deferred","allFetched","limitPerCall","searchAttributes","HistoryDatasetAssociation","isObject","contentsJSON","contains","copyableModelClasses","model_class","type","contentType","json","HistoryDatasetCollectionAssociation","xhr","ajax","stringify","LibraryDatasetDatasetAssociation","message","source","createHDCA","elementIdentifiers","collectionType","name","hideSourceItems","hide_source_items","element_identifiers","save","collection_type","has","matches","matchesWhat","haveSearchDetails","length"],"mappings":"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","file":"../../../scripts/mvc/history/history-contents.js","sourcesContent":["import CONTROLLED_FETCH_COLLECTION from \"mvc/base/controlled-fetch-collection\";\nimport HDA_MODEL from \"mvc/history/hda-model\";\nimport HDCA_MODEL from \"mvc/history/hdca-model\";\nimport HISTORY_PREFS from \"mvc/history/history-preferences\";\nimport JOB_STATES_MODEL from \"mvc/history/job-states-model\";\nimport BASE_MVC from \"mvc/base-mvc\";\nimport AJAX_QUEUE from \"utils/ajax-queue\";\n\nvar limitPerPageDefault = 500;\ntry {\n    limitPerPageDefault = localStorage.getItem(\"historyContentsLimitPerPageDefault\") || limitPerPageDefault;\n} catch (err) {}\n\n//==============================================================================\nvar _super = CONTROLLED_FETCH_COLLECTION.PaginatedCollection;\n/** @class Backbone collection for history content.\n *      NOTE: history content seems like a dataset collection, but differs in that it is mixed:\n *          each element can be either an HDA (dataset) or a DatasetCollection and co-exist on\n *          the same level.\n *      Dataset collections on the other hand are not mixed and (so far) can only contain either\n *          HDAs or child dataset collections on one level.\n *      This is why this does not inherit from any of the DatasetCollections (currently).\n */\nvar HistoryContents = _super.extend(BASE_MVC.LoggableMixin).extend({\n    _logNamespace: \"history\",\n\n    // ........................................................................ set up\n    limitPerPage: limitPerPageDefault,\n\n    /** @type {Integer} how many contents per call to fetch when using progressivelyFetchDetails */\n    limitPerProgressiveFetch: limitPerPageDefault,\n\n    /** @type {String} order used here and when fetching from server */\n    order: \"hid\",\n\n    /** complete api url */\n    url: function() {\n        return `${this.urlRoot}/${this.historyId}/contents`;\n    },\n\n    /** Set up */\n    initialize: function(models, options) {\n        this.on({\n            \"sync add\": this.trackJobStates\n        });\n\n        options = options || {};\n        this.urlRoot = `${Galaxy.root}api/histories`;\n        _super.prototype.initialize.call(this, models, options);\n\n        this.history = options.history || null;\n        this.setHistoryId(options.historyId || null);\n        /** @type {Boolean} does this collection contain and fetch deleted elements */\n        this.includeDeleted = options.includeDeleted || this.includeDeleted;\n        /** @type {Boolean} does this collection contain and fetch non-visible elements */\n        this.includeHidden = options.includeHidden || this.includeHidden;\n\n        // backbonejs uses collection.model.prototype.idAttribute to determine if a model is *already* in a collection\n        //  and either merged or replaced. In this case, our 'model' is a function so we need to add idAttribute\n        //  manually here - if we don't, contents will not merge but be replaced/swapped.\n        this.model.prototype.idAttribute = \"type_id\";\n    },\n\n    trackJobStates: function() {\n        this.each(historyContent => {\n            if (historyContent.has(\"job_states_summary\")) {\n                return;\n            }\n\n            if (historyContent.attributes.history_content_type === \"dataset_collection\") {\n                var jobSourceType = historyContent.attributes.job_source_type;\n                var jobSourceId = historyContent.attributes.job_source_id;\n                if (jobSourceType && this.jobStateSummariesCollection) {\n                    this.jobStateSummariesCollection.add({\n                        id: jobSourceId,\n                        model: jobSourceType,\n                        history_id: this.history_id,\n                        collection_id: historyContent.attributes.id\n                    });\n                    var jobStatesSummary = this.jobStateSummariesCollection.get(jobSourceId);\n                    historyContent.jobStatesSummary = jobStatesSummary;\n                }\n            }\n        });\n    },\n\n    // ........................................................................ composite collection\n    /** since history content is a mix, override model fn into a factory, creating based on history_content_type */\n    model: function(attrs, options) {\n        if (attrs.history_content_type === \"dataset\") {\n            return new HDA_MODEL.HistoryDatasetAssociation(attrs, options);\n        } else if (attrs.history_content_type === \"dataset_collection\") {\n            return new HDCA_MODEL.HistoryDatasetCollection(attrs, options);\n        } else {\n            return {\n                validationError: `Unknown history_content_type: ${attrs.history_content_type}`\n            };\n        }\n    },\n\n    stopPolling: function() {\n        if (this.jobStateSummariesCollection) {\n            this.jobStateSummariesCollection.active = false;\n            this.jobStateSummariesCollection.clearUpdateTimeout();\n        }\n    },\n\n    setHistoryId: function(newId) {\n        this.stopPolling();\n        this.historyId = newId;\n        if (newId) {\n            // If actually reflecting a history - setup storage and monitor jobs.\n\n            this._setUpWebStorage();\n\n            this.jobStateSummariesCollection = new JOB_STATES_MODEL.JobStatesSummaryCollection();\n            this.jobStateSummariesCollection.historyId = newId;\n            this.jobStateSummariesCollection.monitor();\n        }\n    },\n\n    /** Set up client side storage. Currently PersistanStorage keyed under 'history:<id>' */\n    _setUpWebStorage: function(initialSettings) {\n        // TODO: use initialSettings\n        this.storage = new HISTORY_PREFS.HistoryPrefs({\n            id: HISTORY_PREFS.HistoryPrefs.historyStorageKey(this.historyId)\n        });\n        this.trigger(\"new-storage\", this.storage, this);\n\n        this.on({\n            \"include-deleted\": function(newVal) {\n                this.storage.includeDeleted(newVal);\n            },\n            \"include-hidden\": function(newVal) {\n                this.storage.includeHidden(newVal);\n            }\n        });\n\n        this.includeDeleted = this.storage.includeDeleted() || false;\n        this.includeHidden = this.storage.includeHidden() || false;\n        return this;\n    },\n\n    // ........................................................................ common queries\n    /** @type {Object} map of collection available sorting orders containing comparator fns */\n    comparators: _.extend(_.clone(_super.prototype.comparators), {\n        name: BASE_MVC.buildComparator(\"name\", { ascending: true }),\n        \"name-dsc\": BASE_MVC.buildComparator(\"name\", {\n            ascending: false\n        }),\n        hid: BASE_MVC.buildComparator(\"hid\", { ascending: false }),\n        \"hid-asc\": BASE_MVC.buildComparator(\"hid\", { ascending: true })\n    }),\n\n    /** Get every model in this collection not in a 'ready' state (running). */\n    running: function() {\n        return this.filter(c => !c.inReadyState());\n    },\n\n    /** return contents that are not ready and not deleted/hidden */\n    runningAndActive: function() {\n        return this.filter(\n            c =>\n                !c.inReadyState() &&\n                c.get(\"visible\") &&\n                // TODO: deletedOrPurged?\n                !c.get(\"deleted\")\n        );\n    },\n\n    /** Get the model with the given hid\n     *  @param {Int} hid the hid to search for\n     *  @returns {HistoryDatasetAssociation} the model with the given hid or undefined if not found\n     */\n    getByHid: function(hid) {\n        // note: there *can* be more than one content with a given hid, this finds the first based on order\n        return this.findWhere({ hid: hid });\n    },\n\n    /** return true if all contents have details */\n    haveDetails: function() {\n        return this.all(c => c.hasDetails());\n    },\n\n    // ........................................................................ hidden / deleted\n    /** return a new contents collection of only hidden items */\n    hidden: function() {\n        return this.filter(c => c.hidden());\n    },\n\n    /** return a new contents collection of only hidden items */\n    deleted: function() {\n        return this.filter(c => c.get(\"deleted\"));\n    },\n\n    /** return a new contents collection of only hidden items */\n    visibleAndUndeleted: function() {\n        return this.filter(\n            c =>\n                c.get(\"visible\") &&\n                // TODO: deletedOrPurged?\n                !c.get(\"deleted\")\n        );\n    },\n\n    /** create a setter in order to publish the change */\n    setIncludeDeleted: function(setting, options) {\n        if (_.isBoolean(setting) && setting !== this.includeDeleted) {\n            this.includeDeleted = setting;\n            if (_.result(options, \"silent\")) {\n                return;\n            }\n            this.trigger(\"include-deleted\", setting, this);\n        }\n    },\n\n    /** create a setter in order to publish the change */\n    setIncludeHidden: function(setting, options) {\n        if (_.isBoolean(setting) && setting !== this.includeHidden) {\n            this.includeHidden = setting;\n            options = options || {};\n            if (_.result(options, \"silent\")) {\n                return;\n            }\n            this.trigger(\"include-hidden\", setting, this);\n        }\n    },\n\n    // ........................................................................ ajax\n    // ............ controlled fetch collection\n    /** override to get expanded ids from sessionStorage and pass to API as details */\n    fetch: function(options) {\n        options = options || {};\n        if (this.historyId && !options.details) {\n            var prefs = HISTORY_PREFS.HistoryPrefs.get(this.historyId).toJSON();\n            if (!_.isEmpty(prefs.expandedIds)) {\n                options.details = _.values(prefs.expandedIds).join(\",\");\n            }\n        }\n        return _super.prototype.fetch.call(this, options);\n    },\n\n    // ............. ControlledFetch stuff\n    /** override to include the API versioning flag */\n    _buildFetchData: function(options) {\n        return _.extend(_super.prototype._buildFetchData.call(this, options), {\n            v: \"dev\"\n        });\n    },\n\n    /** Extend to include details and version */\n    _fetchParams: _super.prototype._fetchParams.concat([\n        // TODO: remove (the need for) both\n        /** version */\n        \"v\",\n        /** dataset ids to get full details of */\n        \"details\"\n    ]),\n\n    /** override to add deleted/hidden filters */\n    _buildFetchFilters: function(options) {\n        var superFilters = _super.prototype._buildFetchFilters.call(this, options) || {};\n        var filters = {};\n        if (!this.includeDeleted) {\n            filters.deleted = false;\n            filters.purged = false;\n        }\n        if (!this.includeHidden) {\n            filters.visible = true;\n        }\n        return _.defaults(superFilters, filters);\n    },\n\n    // ............ paginated collection\n    getTotalItemCount: function() {\n        return this.history.contentsShown();\n    },\n\n    // ............ history contents specific ajax\n    /** override to filter requested contents to those updated after the Date 'since' */\n    fetchUpdated: function(since, options) {\n        if (since) {\n            options = options || { filters: {} };\n            options.remove = false;\n            options.filters = {\n                \"update_time-ge\": since.toISOString(),\n                // workflows will produce hidden datasets (non-output datasets) that still\n                // need to be updated in the collection or they'll update forever\n                // we can remove the default visible filter by using an 'empty' value\n                visible: \"\"\n            };\n        }\n        return this.fetch(options);\n    },\n\n    /** fetch all the deleted==true contents of this collection */\n    fetchDeleted: function(options) {\n        options = options || {};\n        options.filters = _.extend(options.filters, {\n            // all deleted, purged or not\n            deleted: true,\n            purged: undefined\n        });\n        options.remove = false;\n\n        this.trigger(\"fetching-deleted\", this);\n        return this.fetch(options).always(() => {\n            this.trigger(\"fetching-deleted-done\", this);\n        });\n    },\n\n    /** fetch all the visible==false contents of this collection */\n    fetchHidden: function(options) {\n        options = options || {};\n        var self = this;\n        options.filters = _.extend(options.filters, {\n            visible: false\n        });\n        options.remove = false;\n\n        self.trigger(\"fetching-hidden\", self);\n        return self.fetch(options).always(() => {\n            self.trigger(\"fetching-hidden-done\", self);\n        });\n    },\n\n    /** fetch detailed model data for all contents in this collection */\n    fetchAllDetails: function(options) {\n        options = options || {};\n        var detailsFlag = { details: \"all\" };\n        options.data = _.extend(options.data || {}, detailsFlag);\n        return this.fetch(options);\n    },\n\n    // ............. quasi-batch ops\n    // TODO: to batch\n    /** helper that fetches using filterParams then calls save on each fetched using updateWhat as the save params */\n    _filterAndUpdate: function(filterParams, updateWhat) {\n        var self = this;\n        var idAttribute = self.model.prototype.idAttribute;\n        var updateArgs = [updateWhat];\n\n        return self.fetch({ filters: filterParams, remove: false }).then(fetched => {\n            // convert filtered json array to model array\n            fetched = fetched.reduce((modelArray, currJson, i) => {\n                var model = self.get(currJson[idAttribute]);\n                return model ? modelArray.concat(model) : modelArray;\n            }, []);\n            return self.ajaxQueue(\"save\", updateArgs, fetched);\n        });\n    },\n\n    /** using a queue, perform ajaxFn on each of the models in this collection */\n    ajaxQueue: function(ajaxFn, args, collection) {\n        collection = collection || this.models;\n        return new AJAX_QUEUE.AjaxQueue(\n            collection\n                .slice()\n                .reverse()\n                .map((content, i) => {\n                    var fn = _.isString(ajaxFn) ? content[ajaxFn] : ajaxFn;\n                    return () => fn.apply(content, args);\n                })\n        ).deferred;\n    },\n\n    /** fetch contents' details in batches of limitPerCall - note: only get searchable details here */\n    progressivelyFetchDetails: function(options) {\n        options = options || {};\n        var deferred = jQuery.Deferred();\n        var self = this;\n        var limit = options.limitPerCall || self.limitPerProgressiveFetch;\n        // TODO: only fetch tags and annotations if specifically requested\n        var searchAttributes = HDA_MODEL.HistoryDatasetAssociation.prototype.searchAttributes;\n        var detailKeys = searchAttributes.join(\",\");\n\n        function _recursivelyFetch(offset) {\n            offset = offset || 0;\n            var _options = _.extend(_.clone(options), {\n                view: \"summary\",\n                keys: detailKeys,\n                limit: limit,\n                offset: offset,\n                reset: offset === 0,\n                remove: false\n            });\n\n            _.defer(() => {\n                self.fetch\n                    .call(self, _options)\n                    .fail(deferred.reject)\n                    .done(response => {\n                        deferred.notify(response, limit, offset);\n                        if (response.length !== limit) {\n                            self.allFetched = true;\n                            deferred.resolve(response, limit, offset);\n                        } else {\n                            _recursivelyFetch(offset + limit);\n                        }\n                    });\n            });\n        }\n        _recursivelyFetch();\n        return deferred;\n    },\n\n    /** does some bit of JSON represent something that can be copied into this contents collection */\n    isCopyable: function(contentsJSON) {\n        var copyableModelClasses = [\"HistoryDatasetAssociation\", \"HistoryDatasetCollectionAssociation\"];\n        return (\n            _.isObject(contentsJSON) && contentsJSON.id && _.contains(copyableModelClasses, contentsJSON.model_class)\n        );\n    },\n\n    /** copy an existing, accessible hda into this collection */\n    copy: function(json) {\n        // TODO: somehow showhorn all this into 'save'\n        var id;\n\n        var type;\n        var contentType;\n        if (_.isString(json)) {\n            id = json;\n            contentType = \"hda\";\n            type = \"dataset\";\n        } else {\n            id = json.id;\n            contentType =\n                {\n                    HistoryDatasetAssociation: \"hda\",\n                    LibraryDatasetDatasetAssociation: \"ldda\",\n                    HistoryDatasetCollectionAssociation: \"hdca\"\n                }[json.model_class] || \"hda\";\n            type = contentType === \"hdca\" ? \"dataset_collection\" : \"dataset\";\n        }\n        var collection = this;\n\n        var xhr = jQuery\n            .ajax(this.url(), {\n                method: \"POST\",\n                contentType: \"application/json\",\n                data: JSON.stringify({\n                    content: id,\n                    source: contentType,\n                    type: type\n                })\n            })\n            .done(response => {\n                collection.add([response], { parse: true });\n            })\n            .fail((error, status, message) => {\n                collection.trigger(\"error\", collection, xhr, {}, \"Error copying contents\", {\n                    type: type,\n                    id: id,\n                    source: contentType\n                });\n            });\n\n        return xhr;\n    },\n\n    /** create a new HDCA in this collection */\n    createHDCA: function(elementIdentifiers, collectionType, name, hideSourceItems, options) {\n        // normally collection.create returns the new model, but we need the promise from the ajax, so we fake create\n        //precondition: elementIdentifiers is an array of plain js objects\n        //  in the proper form to create the collectionType\n        var hdca = this.model({\n            history_content_type: \"dataset_collection\",\n            collection_type: collectionType,\n            history_id: this.historyId,\n            name: name,\n            hide_source_items: hideSourceItems || false,\n            // should probably be able to just send in a bunch of json here and restruct per class\n            // note: element_identifiers is now (incorrectly) an attribute\n            element_identifiers: elementIdentifiers\n            // do not create the model on the client until the ajax returns\n        });\n        return hdca.save(options);\n    },\n\n    // ........................................................................ searching\n    /** return true if all contents have the searchable attributes */\n    haveSearchDetails: function() {\n        return (\n            this.allFetched &&\n            this.all((\n                content // null (which is a valid returned annotation value)\n            ) =>\n                // will return false when using content.has( 'annotation' )\n                //TODO: a bit hacky - formalize\n                _.has(content.attributes, \"annotation\")\n            )\n        );\n    },\n\n    /** return a new collection of contents whose attributes contain the substring matchesWhat */\n    matches: function(matchesWhat) {\n        return this.filter(content => content.matches(matchesWhat));\n    },\n\n    // ........................................................................ misc\n    /** In this override, copy the historyId to the clone */\n    clone: function() {\n        var clone = Backbone.Collection.prototype.clone.call(this);\n        clone.historyId = this.historyId;\n        return clone;\n    },\n\n    /** String representation. */\n    toString: function() {\n        return [\"HistoryContents(\", [this.historyId, this.length].join(), \")\"].join(\"\");\n    }\n});\n\n//==============================================================================\nexport default {\n    HistoryContents: HistoryContents\n};\n"]}