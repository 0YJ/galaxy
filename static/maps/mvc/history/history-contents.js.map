{"version":3,"sources":["mvc/history/history-contents.js"],"names":["_super","_controlledFetchCollection2","default","PaginatedCollection","HistoryContents","extend","_baseMvc2","LoggableMixin","_logNamespace","model","attrs","options","history_content_type","_hdaModel2","HistoryDatasetAssociation","collection_type","_hdcaModel2","HistoryListDatasetCollection","HistoryPairDatasetCollection","HistoryListPairedDatasetCollection","msg","HistoryListOfListsDatasetCollection","console","warn","validationError","limitPerPage","limitPerProgressiveFetch","order","this","urlRoot","historyId","initialize","models","url","prototype","call","history","setHistoryId","includeDeleted","includeHidden","idAttribute","newId","_setUpWebStorage","initialSettings","storage","_historyPreferences2","HistoryPrefs","historyStorageKey","trigger","on","include-deleted","newVal","id","include-hidden","comparators","name","buildComparator","ascending","name-dsc","hid","running","filter","c","runningAndActive","inReadyState","get","getByHid","findWhere","all","hasDetails","haveDetails","hidden","deleted","visibleAndUndeleted","setIncludeDeleted","setting","_","isBoolean","result","details","prefs","toJSON","isEmpty","expandedIds","values","join","fetch","_buildFetchData","v","_fetchParams","concat","_buildFetchFilters","superFilters","filters","purged","visible","contentsShown","fetchUpdated","since","getTotalItemCount","update_time-ge","toISOString","remove","fetchDeleted","undefined","self","always","fetchHidden","data","detailsFlag","fetchCollectionCounts","fetchAllDetails","updateWhat","updateArgs","filterParams","then","fetched","_filterAndUpdate","reduce","modelArray","i","currJson","ajaxQueue","ajaxFn","collection","_ajaxQueue2","slice","reverse","map","content","fn","isString","args","deferred","progressivelyFetchDetails","searchAttributes","offset","detailKeys","_options","clone","view","_recursivelyFetch","limit","keys","defer","reject","notify","response","length","allFetched","resolve","jQuery","Deferred","limitPerCall","isCopyable","contentsJSON","copyableModelClasses","copy","isObject","contains","model_class","type","contentType","LibraryDatasetDatasetAssociation","HistoryDatasetCollectionAssociation","json","xhr","method","JSON","done","fail","stringify","createHDCA","add","parse","error","status","message","hdca","history_id","hide_source_items","source","elementIdentifiers","haveSearchDetails","hideSourceItems","collectionType","matches","element_identifiers","save","toString","has","attributes","matchesWhat","Backbone","Collection"],"mappings":"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","file":"../../../scripts/mvc/history/history-contents.js","sourcesContent":["import CONTROLLED_FETCH_COLLECTION from \"mvc/base/controlled-fetch-collection\";\nimport HDA_MODEL from \"mvc/history/hda-model\";\nimport HDCA_MODEL from \"mvc/history/hdca-model\";\nimport HISTORY_PREFS from \"mvc/history/history-preferences\";\nimport BASE_MVC from \"mvc/base-mvc\";\nimport AJAX_QUEUE from \"utils/ajax-queue\";\n\n//==============================================================================\nvar _super = CONTROLLED_FETCH_COLLECTION.PaginatedCollection;\n/** @class Backbone collection for history content.\n *      NOTE: history content seems like a dataset collection, but differs in that it is mixed:\n *          each element can be either an HDA (dataset) or a DatasetCollection and co-exist on\n *          the same level.\n *      Dataset collections on the other hand are not mixed and (so far) can only contain either\n *          HDAs or child dataset collections on one level.\n *      This is why this does not inherit from any of the DatasetCollections (currently).\n */\nvar HistoryContents = _super.extend(BASE_MVC.LoggableMixin).extend({\n    _logNamespace: \"history\",\n\n    // ........................................................................ composite collection\n    /** since history content is a mix, override model fn into a factory, creating based on history_content_type */\n    model: function(attrs, options) {\n        if (attrs.history_content_type === \"dataset\") {\n            return new HDA_MODEL.HistoryDatasetAssociation(attrs, options);\n        } else if (attrs.history_content_type === \"dataset_collection\") {\n            switch (attrs.collection_type) {\n                case \"list\":\n                    return new HDCA_MODEL.HistoryListDatasetCollection(\n                        attrs,\n                        options\n                    );\n                case \"paired\":\n                    return new HDCA_MODEL.HistoryPairDatasetCollection(\n                        attrs,\n                        options\n                    );\n                case \"list:paired\":\n                    return new HDCA_MODEL.HistoryListPairedDatasetCollection(\n                        attrs,\n                        options\n                    );\n                case \"list:list\":\n                    return new HDCA_MODEL.HistoryListOfListsDatasetCollection(\n                        attrs,\n                        options\n                    );\n            }\n            // This is a hack inside a hack:\n            // Raise a plain object with validationError to fake a model.validationError\n            // (since we don't have a model to use validate with)\n            // (the outer hack being the mixed content/model function in this collection)\n            var msg = `Unknown collection_type: ${attrs.collection_type}`;\n            console.warn(msg, attrs);\n            return { validationError: msg };\n        }\n        return {\n            validationError: `Unknown history_content_type: ${attrs.history_content_type}`\n        };\n    },\n\n    // ........................................................................ set up\n    limitPerPage: 500,\n\n    /** @type {Integer} how many contents per call to fetch when using progressivelyFetchDetails */\n    limitPerProgressiveFetch: 500,\n\n    /** @type {String} order used here and when fetching from server */\n    order: \"hid\",\n\n    /** root api url */\n    urlRoot: `${Galaxy.root}api/histories`,\n\n    /** complete api url */\n    url: function() {\n        return `${this.urlRoot}/${this.historyId}/contents`;\n    },\n\n    /** Set up */\n    initialize: function(models, options) {\n        options = options || {};\n        _super.prototype.initialize.call(this, models, options);\n\n        this.history = options.history || null;\n        this.setHistoryId(options.historyId || null);\n        /** @type {Boolean} does this collection contain and fetch deleted elements */\n        this.includeDeleted = options.includeDeleted || this.includeDeleted;\n        /** @type {Boolean} does this collection contain and fetch non-visible elements */\n        this.includeHidden = options.includeHidden || this.includeHidden;\n\n        // backbonejs uses collection.model.prototype.idAttribute to determine if a model is *already* in a collection\n        //  and either merged or replaced. In this case, our 'model' is a function so we need to add idAttribute\n        //  manually here - if we don't, contents will not merge but be replaced/swapped.\n        this.model.prototype.idAttribute = \"type_id\";\n    },\n\n    setHistoryId: function(newId) {\n        this.historyId = newId;\n        this._setUpWebStorage();\n    },\n\n    /** Set up client side storage. Currently PersistanStorage keyed under 'history:<id>' */\n    _setUpWebStorage: function(initialSettings) {\n        // TODO: use initialSettings\n        if (!this.historyId) {\n            return;\n        }\n        this.storage = new HISTORY_PREFS.HistoryPrefs({\n            id: HISTORY_PREFS.HistoryPrefs.historyStorageKey(this.historyId)\n        });\n        this.trigger(\"new-storage\", this.storage, this);\n\n        this.on({\n            \"include-deleted\": function(newVal) {\n                this.storage.includeDeleted(newVal);\n            },\n            \"include-hidden\": function(newVal) {\n                this.storage.includeHidden(newVal);\n            }\n        });\n\n        this.includeDeleted = this.storage.includeDeleted() || false;\n        this.includeHidden = this.storage.includeHidden() || false;\n        return this;\n    },\n\n    // ........................................................................ common queries\n    /** @type {Object} map of collection available sorting orders containing comparator fns */\n    comparators: _.extend(_.clone(_super.prototype.comparators), {\n        name: BASE_MVC.buildComparator(\"name\", { ascending: true }),\n        \"name-dsc\": BASE_MVC.buildComparator(\"name\", {\n            ascending: false\n        }),\n        hid: BASE_MVC.buildComparator(\"hid\", { ascending: false }),\n        \"hid-asc\": BASE_MVC.buildComparator(\"hid\", { ascending: true })\n    }),\n\n    /** Get every model in this collection not in a 'ready' state (running). */\n    running: function() {\n        return this.filter(c => !c.inReadyState());\n    },\n\n    /** return contents that are not ready and not deleted/hidden */\n    runningAndActive: function() {\n        return this.filter(\n            c =>\n                !c.inReadyState() &&\n                c.get(\"visible\") &&\n                // TODO: deletedOrPurged?\n                !c.get(\"deleted\")\n        );\n    },\n\n    /** Get the model with the given hid\n     *  @param {Int} hid the hid to search for\n     *  @returns {HistoryDatasetAssociation} the model with the given hid or undefined if not found\n     */\n    getByHid: function(hid) {\n        // note: there *can* be more than one content with a given hid, this finds the first based on order\n        return this.findWhere({ hid: hid });\n    },\n\n    /** return true if all contents have details */\n    haveDetails: function() {\n        return this.all(c => c.hasDetails());\n    },\n\n    // ........................................................................ hidden / deleted\n    /** return a new contents collection of only hidden items */\n    hidden: function() {\n        return this.filter(c => c.hidden());\n    },\n\n    /** return a new contents collection of only hidden items */\n    deleted: function() {\n        return this.filter(c => c.get(\"deleted\"));\n    },\n\n    /** return a new contents collection of only hidden items */\n    visibleAndUndeleted: function() {\n        return this.filter(\n            c =>\n                c.get(\"visible\") &&\n                // TODO: deletedOrPurged?\n                !c.get(\"deleted\")\n        );\n    },\n\n    /** create a setter in order to publish the change */\n    setIncludeDeleted: function(setting, options) {\n        if (_.isBoolean(setting) && setting !== this.includeDeleted) {\n            this.includeDeleted = setting;\n            if (_.result(options, \"silent\")) {\n                return;\n            }\n            this.trigger(\"include-deleted\", setting, this);\n        }\n    },\n\n    /** create a setter in order to publish the change */\n    setIncludeHidden: function(setting, options) {\n        if (_.isBoolean(setting) && setting !== this.includeHidden) {\n            this.includeHidden = setting;\n            options = options || {};\n            if (_.result(options, \"silent\")) {\n                return;\n            }\n            this.trigger(\"include-hidden\", setting, this);\n        }\n    },\n\n    // ........................................................................ ajax\n    // ............ controlled fetch collection\n    /** override to get expanded ids from sessionStorage and pass to API as details */\n    fetch: function(options) {\n        options = options || {};\n        if (this.historyId && !options.details) {\n            var prefs = HISTORY_PREFS.HistoryPrefs.get(this.historyId).toJSON();\n            if (!_.isEmpty(prefs.expandedIds)) {\n                options.details = _.values(prefs.expandedIds).join(\",\");\n            }\n        }\n        return _super.prototype.fetch.call(this, options);\n    },\n\n    // ............. ControlledFetch stuff\n    /** override to include the API versioning flag */\n    _buildFetchData: function(options) {\n        return _.extend(_super.prototype._buildFetchData.call(this, options), {\n            v: \"dev\"\n        });\n    },\n\n    /** Extend to include details and version */\n    _fetchParams: _super.prototype._fetchParams.concat([\n        // TODO: remove (the need for) both\n        /** version */\n        \"v\",\n        /** dataset ids to get full details of */\n        \"details\"\n    ]),\n\n    /** override to add deleted/hidden filters */\n    _buildFetchFilters: function(options) {\n        var superFilters =\n            _super.prototype._buildFetchFilters.call(this, options) || {};\n        var filters = {};\n        if (!this.includeDeleted) {\n            filters.deleted = false;\n            filters.purged = false;\n        }\n        if (!this.includeHidden) {\n            filters.visible = true;\n        }\n        return _.defaults(superFilters, filters);\n    },\n\n    // ............ paginated collection\n    getTotalItemCount: function() {\n        return this.history.contentsShown();\n    },\n\n    // ............ history contents specific ajax\n    /** override to filter requested contents to those updated after the Date 'since' */\n    fetchUpdated: function(since, options) {\n        if (since) {\n            options = options || { filters: {} };\n            options.remove = false;\n            options.filters = {\n                \"update_time-ge\": since.toISOString(),\n                // workflows will produce hidden datasets (non-output datasets) that still\n                // need to be updated in the collection or they'll update forever\n                // we can remove the default visible filter by using an 'empty' value\n                visible: \"\"\n            };\n        }\n        return this.fetch(options);\n    },\n\n    /** fetch all the deleted==true contents of this collection */\n    fetchDeleted: function(options) {\n        options = options || {};\n        var self = this;\n        options.filters = _.extend(options.filters, {\n            // all deleted, purged or not\n            deleted: true,\n            purged: undefined\n        });\n        options.remove = false;\n\n        self.trigger(\"fetching-deleted\", self);\n        return self.fetch(options).always(() => {\n            self.trigger(\"fetching-deleted-done\", self);\n        });\n    },\n\n    /** fetch all the visible==false contents of this collection */\n    fetchHidden: function(options) {\n        options = options || {};\n        var self = this;\n        options.filters = _.extend(options.filters, {\n            visible: false\n        });\n        options.remove = false;\n\n        self.trigger(\"fetching-hidden\", self);\n        return self.fetch(options).always(() => {\n            self.trigger(\"fetching-hidden-done\", self);\n        });\n    },\n\n    /** fetch detailed model data for all contents in this collection */\n    fetchAllDetails: function(options) {\n        options = options || {};\n        var detailsFlag = { details: \"all\" };\n        options.data = _.extend(options.data || {}, detailsFlag);\n        return this.fetch(options);\n    },\n\n    /** specialty fetch method for retrieving the element_counts of all hdcas in the history */\n    fetchCollectionCounts: function(options) {\n        options = options || {};\n        options.keys = [\"type_id\", \"element_count\"].join(\",\");\n        options.filters = _.extend(options.filters || {}, {\n            history_content_type: \"dataset_collection\"\n        });\n        options.remove = false;\n        return this.fetch(options);\n    },\n\n    // ............. quasi-batch ops\n    // TODO: to batch\n    /** helper that fetches using filterParams then calls save on each fetched using updateWhat as the save params */\n    _filterAndUpdate: function(filterParams, updateWhat) {\n        var self = this;\n        var idAttribute = self.model.prototype.idAttribute;\n        var updateArgs = [updateWhat];\n\n        return self\n            .fetch({ filters: filterParams, remove: false })\n            .then(fetched => {\n                // convert filtered json array to model array\n                fetched = fetched.reduce((modelArray, currJson, i) => {\n                    var model = self.get(currJson[idAttribute]);\n                    return model ? modelArray.concat(model) : modelArray;\n                }, []);\n                return self.ajaxQueue(\"save\", updateArgs, fetched);\n            });\n    },\n\n    /** using a queue, perform ajaxFn on each of the models in this collection */\n    ajaxQueue: function(ajaxFn, args, collection) {\n        collection = collection || this.models;\n        return new AJAX_QUEUE.AjaxQueue(\n            collection\n                .slice()\n                .reverse()\n                .map((content, i) => {\n                    var fn = _.isString(ajaxFn) ? content[ajaxFn] : ajaxFn;\n                    return () => fn.apply(content, args);\n                })\n        ).deferred;\n    },\n\n    /** fetch contents' details in batches of limitPerCall - note: only get searchable details here */\n    progressivelyFetchDetails: function(options) {\n        options = options || {};\n        var deferred = jQuery.Deferred();\n        var self = this;\n        var limit = options.limitPerCall || self.limitPerProgressiveFetch;\n        // TODO: only fetch tags and annotations if specifically requested\n        var searchAttributes =\n            HDA_MODEL.HistoryDatasetAssociation.prototype.searchAttributes;\n        var detailKeys = searchAttributes.join(\",\");\n\n        function _recursivelyFetch(offset) {\n            offset = offset || 0;\n            var _options = _.extend(_.clone(options), {\n                view: \"summary\",\n                keys: detailKeys,\n                limit: limit,\n                offset: offset,\n                reset: offset === 0,\n                remove: false\n            });\n\n            _.defer(() => {\n                self.fetch\n                    .call(self, _options)\n                    .fail(deferred.reject)\n                    .done(response => {\n                        deferred.notify(response, limit, offset);\n                        if (response.length !== limit) {\n                            self.allFetched = true;\n                            deferred.resolve(response, limit, offset);\n                        } else {\n                            _recursivelyFetch(offset + limit);\n                        }\n                    });\n            });\n        }\n        _recursivelyFetch();\n        return deferred;\n    },\n\n    /** does some bit of JSON represent something that can be copied into this contents collection */\n    isCopyable: function(contentsJSON) {\n        var copyableModelClasses = [\n            \"HistoryDatasetAssociation\",\n            \"HistoryDatasetCollectionAssociation\"\n        ];\n        return (\n            _.isObject(contentsJSON) &&\n            contentsJSON.id &&\n            _.contains(copyableModelClasses, contentsJSON.model_class)\n        );\n    },\n\n    /** copy an existing, accessible hda into this collection */\n    copy: function(json) {\n        // TODO: somehow showhorn all this into 'save'\n        var id;\n\n        var type;\n        var contentType;\n        if (_.isString(json)) {\n            id = json;\n            contentType = \"hda\";\n            type = \"dataset\";\n        } else {\n            id = json.id;\n            contentType =\n                {\n                    HistoryDatasetAssociation: \"hda\",\n                    LibraryDatasetDatasetAssociation: \"ldda\",\n                    HistoryDatasetCollectionAssociation: \"hdca\"\n                }[json.model_class] || \"hda\";\n            type = contentType === \"hdca\" ? \"dataset_collection\" : \"dataset\";\n        }\n        var collection = this;\n\n        var xhr = jQuery\n            .ajax(this.url(), {\n                method: \"POST\",\n                contentType: \"application/json\",\n                data: JSON.stringify({\n                    content: id,\n                    source: contentType,\n                    type: type\n                })\n            })\n            .done(response => {\n                collection.add([response], { parse: true });\n            })\n            .fail((error, status, message) => {\n                collection.trigger(\n                    \"error\",\n                    collection,\n                    xhr,\n                    {},\n                    \"Error copying contents\",\n                    { type: type, id: id, source: contentType }\n                );\n            });\n\n        return xhr;\n    },\n\n    /** create a new HDCA in this collection */\n    createHDCA: function(\n        elementIdentifiers,\n        collectionType,\n        name,\n        hideSourceItems,\n        options\n    ) {\n        // normally collection.create returns the new model, but we need the promise from the ajax, so we fake create\n        //precondition: elementIdentifiers is an array of plain js objects\n        //  in the proper form to create the collectionType\n        var hdca = this.model({\n            history_content_type: \"dataset_collection\",\n            collection_type: collectionType,\n            history_id: this.historyId,\n            name: name,\n            hide_source_items: hideSourceItems || false,\n            // should probably be able to just send in a bunch of json here and restruct per class\n            // note: element_identifiers is now (incorrectly) an attribute\n            element_identifiers: elementIdentifiers\n            // do not create the model on the client until the ajax returns\n        });\n        return hdca.save(options);\n    },\n\n    // ........................................................................ searching\n    /** return true if all contents have the searchable attributes */\n    haveSearchDetails: function() {\n        return (\n            this.allFetched &&\n            this.all((\n                content // null (which is a valid returned annotation value)\n            ) =>\n                // will return false when using content.has( 'annotation' )\n                //TODO: a bit hacky - formalize\n                _.has(content.attributes, \"annotation\")\n            )\n        );\n    },\n\n    /** return a new collection of contents whose attributes contain the substring matchesWhat */\n    matches: function(matchesWhat) {\n        return this.filter(content => content.matches(matchesWhat));\n    },\n\n    // ........................................................................ misc\n    /** In this override, copy the historyId to the clone */\n    clone: function() {\n        var clone = Backbone.Collection.prototype.clone.call(this);\n        clone.historyId = this.historyId;\n        return clone;\n    },\n\n    /** String representation. */\n    toString: function() {\n        return [\n            \"HistoryContents(\",\n            [this.historyId, this.length].join(),\n            \")\"\n        ].join(\"\");\n    }\n});\n\n//==============================================================================\nexport default {\n    HistoryContents: HistoryContents\n};\n"]}