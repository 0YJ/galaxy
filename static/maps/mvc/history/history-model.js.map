{"version":3,"sources":["mvc/history/history-model.js"],"names":["_historyContents","require","_historyPreferences","_controlledFetchCollection","_utils","_baseMvc","_localization","History","Backbone","Model","extend","_baseMvc2","default","LoggableMixin","mixin","SearchableModelMixin","_logNamespace","UPDATE_DELAY","defaults","model_class","id","name","state","deleted","contents_active","contents_states","urlRoot","Galaxy","root","contentsClass","_historyContents2","HistoryContents","searchAttributes","searchAliases","tag","historyJSON","options","logger","this","log","contents","history","historyId","get","order","_setUpListeners","_setUpCollectionListeners","updateTimeoutId","error","model","xhr","msg","details","clearUpdateTimeout","change:id","newId","listenTo","trigger","apply","jQuery","makeArray","arguments","contentsShown","contentsActive","shown","active","includeDeleted","includeHidden","hidden","nice_size","size","bytesToString","_localization2","toJSON","_","prototype","call","key","ownedByCurrUser","user","isAnonymous","numOfUnfinishedJobs","unfinishedJobIds","length","numOfUnfinishedShownContents","runningAndActive","_fetchContentRelatedAttributes","contentRelatedAttrs","fetch","data","$","param","join","keys","lastUpdateTime","self","allFetched","currentPage","fetchPage","fetchUpdated","done","response","status","serverResponseDatetime","Date","getResponseHeader","err","checkForUpdates","_delayThenUpdate","setTimeout","delay","clearTimeout","parse","parsed","create_time","fetchWithContents","update_time","contentsOptions","view","then","setHistoryId","fetchContents","fetchCurrentPage","_delete","save","when","purge","purged","undelete","copy","current","allDatasets","postData","undefined","history_id","Error","all_datasets","newHistory","getJSON","setAsCurrent","toString","limitOnFirstFetch","_controlledFetchCollection2","InfinitelyScrollingCollection","HistoryCollection","_collectionSuper","currentHistoryId","limitPerFetch","setUpListeners","initialize","models","remove","url","on","change:deleted","oldCurrentId","_buildFetchData","copied","original","newData","setCurrent","superFilters","filters","silent","limit","_buildFetchFilters","fetchFirst","ascending","encoded_id-in","buildComparator","offset","comparators","clone","name-dsc","create","size-asc","sort","currentHistory","hdas","historyOptions","xhrOptions","collection","unshift"],"mappings":"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","file":"../../../scripts/mvc/history/history-model.js","sourcesContent":["import HISTORY_CONTENTS from \"mvc/history/history-contents\";\nimport HISTORY_PREFS from \"mvc/history/history-preferences\";\nimport CONTROLLED_FETCH_COLLECTION from \"mvc/base/controlled-fetch-collection\";\nimport UTILS from \"utils/utils\";\nimport BASE_MVC from \"mvc/base-mvc\";\nimport _l from \"utils/localization\";\n\n//==============================================================================\n/** @class Model for a Galaxy history resource - both a record of user\n *      tool use and a collection of the datasets those tools produced.\n *  @name History\n *  @augments Backbone.Model\n */\nvar History = Backbone.Model.extend(BASE_MVC.LoggableMixin).extend(\n    BASE_MVC.mixin(\n        BASE_MVC.SearchableModelMixin,\n        /** @lends History.prototype */ {\n            _logNamespace: \"history\",\n\n            /** ms between fetches when checking running jobs/datasets for updates */\n            UPDATE_DELAY: 4000,\n\n            // values from api (may need more)\n            defaults: {\n                model_class: \"History\",\n                id: null,\n                name: \"Unnamed History\",\n                state: \"new\",\n\n                deleted: false,\n                contents_active: {},\n                contents_states: {}\n            },\n\n            urlRoot: Galaxy.root + \"api/histories\",\n\n            contentsClass: HISTORY_CONTENTS.HistoryContents,\n\n            /** What model fields to search with */\n            searchAttributes: [\"name\", \"annotation\", \"tags\"],\n\n            /** Adding title and singular tag */\n            searchAliases: {\n                title: \"name\",\n                tag: \"tags\"\n            },\n\n            // ........................................................................ set up/tear down\n            /** Set up the model\n     *  @param {Object} historyJSON model data for this History\n     *  @param {Object} options     any extra settings including logger\n     */\n            initialize: function(historyJSON, options) {\n                options = options || {};\n                this.logger = options.logger || null;\n                this.log(this + \".initialize:\", historyJSON, options);\n\n                /** HistoryContents collection of the HDAs contained in this history. */\n                this.contents = new this.contentsClass([], {\n                    history: this,\n                    historyId: this.get(\"id\"),\n                    order: options.order\n                });\n\n                this._setUpListeners();\n                this._setUpCollectionListeners();\n\n                /** cached timeout id for the dataset updater */\n                this.updateTimeoutId = null;\n            },\n\n            /** set up any event listeners for this history including those to the contained HDAs\n     *  events: error:contents  if an error occurred with the contents collection\n     */\n            _setUpListeners: function() {\n                // if the model's id changes ('current' or null -> an actual id), update the contents history_id\n                return this.on({\n                    error: function(model, xhr, options, msg, details) {\n                        this.clearUpdateTimeout();\n                    },\n                    \"change:id\": function(model, newId) {\n                        if (this.contents) {\n                            this.contents.historyId = newId;\n                        }\n                    }\n                });\n            },\n\n            /** event handlers for the contents submodels */\n            _setUpCollectionListeners: function() {\n                if (!this.contents) {\n                    return this;\n                }\n                // bubble up errors\n                return this.listenTo(this.contents, {\n                    error: function() {\n                        this.trigger.apply(this, jQuery.makeArray(arguments));\n                    }\n                });\n            },\n\n            // ........................................................................ derived attributes\n            /**  */\n            contentsShown: function() {\n                var contentsActive = this.get(\"contents_active\");\n                var shown = contentsActive.active || 0;\n                shown += this.contents.includeDeleted\n                    ? contentsActive.deleted\n                    : 0;\n                shown += this.contents.includeHidden\n                    ? contentsActive.hidden\n                    : 0;\n                return shown;\n            },\n\n            /** convert size in bytes to a more human readable version */\n            nice_size: function() {\n                var size = this.get(\"size\");\n                return size\n                    ? UTILS.bytesToString(size, true, 2)\n                    : _l(\"(empty)\");\n            },\n\n            /** override to add nice_size */\n            toJSON: function() {\n                return _.extend(Backbone.Model.prototype.toJSON.call(this), {\n                    nice_size: this.nice_size()\n                });\n            },\n\n            /** override to allow getting nice_size */\n            get: function(key) {\n                if (key === \"nice_size\") {\n                    return this.nice_size();\n                }\n                return Backbone.Model.prototype.get.apply(this, arguments);\n            },\n\n            // ........................................................................ common queries\n            /** T/F is this history owned by the current user (Galaxy.user)\n     *      Note: that this will return false for an anon user even if the history is theirs.\n     */\n            ownedByCurrUser: function() {\n                // no currUser\n                if (!Galaxy || !Galaxy.user) {\n                    return false;\n                }\n                // user is anon or history isn't owned\n                if (\n                    Galaxy.user.isAnonymous() ||\n                    Galaxy.user.id !== this.get(\"user_id\")\n                ) {\n                    return false;\n                }\n                return true;\n            },\n\n            /** Return the number of running jobs assoc with this history (note: unknown === 0) */\n            numOfUnfinishedJobs: function() {\n                var unfinishedJobIds = this.get(\"non_ready_jobs\");\n                return unfinishedJobIds ? unfinishedJobIds.length : 0;\n            },\n\n            /** Return the number of running hda/hdcas in this history (note: unknown === 0) */\n            numOfUnfinishedShownContents: function() {\n                return this.contents.runningAndActive().length || 0;\n            },\n\n            // ........................................................................ updates\n            _fetchContentRelatedAttributes: function() {\n                var contentRelatedAttrs = [\n                    \"size\",\n                    \"non_ready_jobs\",\n                    \"contents_active\",\n                    \"hid_counter\"\n                ];\n                return this.fetch({\n                    data: $.param({\n                        keys: contentRelatedAttrs.join(\",\")\n                    })\n                });\n            },\n\n            /** check for any changes since the last time we updated (or fetch all if ) */\n            refresh: function(options) {\n                // console.log( this + '.refresh' );\n                options = options || {};\n                var self = this;\n\n                // note if there was no previous update time, all summary contents will be fetched\n                var lastUpdateTime = self.lastUpdateTime;\n                // if we don't flip this, then a fully-fetched list will not be re-checked via fetch\n                this.contents.allFetched = false;\n                var fetchFn =\n                    self.contents.currentPage !== 0\n                        ? function() {\n                              return self.contents.fetchPage(\n                                  self.contents.currentPage\n                              );\n                          }\n                        : function() {\n                              return self.contents.fetchUpdated(lastUpdateTime);\n                          };\n                // note: if there was no previous update time, all summary contents will be fetched\n                return fetchFn().done(function(response, status, xhr) {\n                    var serverResponseDatetime;\n                    try {\n                        serverResponseDatetime = new Date(\n                            xhr.getResponseHeader(\"Date\")\n                        );\n                    } catch (err) {}\n                    self.lastUpdateTime = serverResponseDatetime || new Date();\n                    self.checkForUpdates(options);\n                });\n            },\n\n            /** continuously fetch updated contents every UPDATE_DELAY ms if this history's datasets or jobs are unfinished */\n            checkForUpdates: function(options) {\n                // console.log( this + '.checkForUpdates' );\n                options = options || {};\n                var delay = this.UPDATE_DELAY;\n                var self = this;\n                if (!self.id) {\n                    return;\n                }\n\n                function _delayThenUpdate() {\n                    // prevent buildup of updater timeouts by clearing previous if any, then set new and cache id\n                    self.clearUpdateTimeout();\n                    self.updateTimeoutId = setTimeout(function() {\n                        self.refresh(options);\n                    }, delay);\n                }\n\n                // if there are still datasets in the non-ready state, recurse into this function with the new time\n                var nonReadyContentCount = this.numOfUnfinishedShownContents();\n                // console.log( 'nonReadyContentCount:', nonReadyContentCount );\n                if (nonReadyContentCount > 0) {\n                    _delayThenUpdate();\n                } else {\n                    // no datasets are running, but currently runnning jobs may still produce new datasets\n                    // see if the history has any running jobs and continue to update if so\n                    // (also update the size for the user in either case)\n                    self\n                        ._fetchContentRelatedAttributes()\n                        .done(function(historyData) {\n                            // console.log( 'non_ready_jobs:', historyData.non_ready_jobs );\n                            if (self.numOfUnfinishedJobs() > 0) {\n                                _delayThenUpdate();\n                            } else {\n                                // otherwise, let listeners know that all updates have stopped\n                                self.trigger(\"ready\");\n                            }\n                        });\n                }\n            },\n\n            /** clear the timeout and the cached timeout id */\n            clearUpdateTimeout: function() {\n                if (this.updateTimeoutId) {\n                    clearTimeout(this.updateTimeoutId);\n                    this.updateTimeoutId = null;\n                }\n            },\n\n            // ........................................................................ ajax\n            /** override to use actual Dates objects for create/update times */\n            parse: function(response, options) {\n                var parsed = Backbone.Model.prototype.parse.call(\n                    this,\n                    response,\n                    options\n                );\n                if (parsed.create_time) {\n                    parsed.create_time = new Date(parsed.create_time);\n                }\n                if (parsed.update_time) {\n                    parsed.update_time = new Date(parsed.update_time);\n                }\n                return parsed;\n            },\n\n            /** fetch this histories data (using options) then it's contents (using contentsOptions) */\n            fetchWithContents: function(options, contentsOptions) {\n                options = options || {};\n                var self = this;\n\n                // console.log( this + '.fetchWithContents' );\n                // TODO: push down to a base class\n                options.view = \"dev-detailed\";\n\n                // fetch history then use history data to fetch (paginated) contents\n                return this.fetch(options).then(function getContents(history) {\n                    self.contents.history = self;\n                    self.contents.setHistoryId(history.id);\n                    return self.fetchContents(contentsOptions);\n                });\n            },\n\n            /** fetch this histories contents, adjusting options based on the stored history preferences */\n            fetchContents: function(options) {\n                options = options || {};\n                var self = this;\n\n                // we're updating, reset the update time\n                self.lastUpdateTime = new Date();\n                return self.contents.fetchCurrentPage(options);\n            },\n\n            /** save this history, _Mark_ing it as deleted (just a flag) */\n            _delete: function(options) {\n                if (this.get(\"deleted\")) {\n                    return jQuery.when();\n                }\n                return this.save({ deleted: true }, options);\n            },\n            /** purge this history, _Mark_ing it as purged and removing all dataset data from the server */\n            purge: function(options) {\n                if (this.get(\"purged\")) {\n                    return jQuery.when();\n                }\n                return this.save({ deleted: true, purged: true }, options);\n            },\n            /** save this history, _Mark_ing it as undeleted */\n            undelete: function(options) {\n                if (!this.get(\"deleted\")) {\n                    return jQuery.when();\n                }\n                return this.save({ deleted: false }, options);\n            },\n\n            /** Make a copy of this history on the server\n     *  @param {Boolean} current    if true, set the copy as the new current history (default: true)\n     *  @param {String} name        name of new history (default: none - server sets to: Copy of <current name>)\n     *  @fires copied               passed this history and the response JSON from the copy\n     *  @returns {xhr}\n     */\n            copy: function(current, name, allDatasets) {\n                current = current !== undefined ? current : true;\n                if (!this.id) {\n                    throw new Error(\n                        \"You must set the history ID before copying it.\"\n                    );\n                }\n\n                var postData = { history_id: this.id };\n                if (current) {\n                    postData.current = true;\n                }\n                if (name) {\n                    postData.name = name;\n                }\n                if (!allDatasets) {\n                    postData.all_datasets = false;\n                }\n                postData.view = \"dev-detailed\";\n\n                var history = this;\n                var copy = jQuery.post(this.urlRoot, postData);\n                // if current - queue to setAsCurrent before firing 'copied'\n                if (current) {\n                    return copy.then(function(response) {\n                        var newHistory = new History(response);\n                        return newHistory.setAsCurrent().done(function() {\n                            history.trigger(\"copied\", history, response);\n                        });\n                    });\n                }\n                return copy.done(function(response) {\n                    history.trigger(\"copied\", history, response);\n                });\n            },\n\n            setAsCurrent: function() {\n                var history = this,\n                    xhr = jQuery.getJSON(\n                        Galaxy.root + \"history/set_as_current?id=\" + this.id\n                    );\n\n                xhr.done(function() {\n                    history.trigger(\"set-as-current\", history);\n                });\n                return xhr;\n            },\n\n            // ........................................................................ misc\n            toString: function() {\n                return (\n                    \"History(\" + this.get(\"id\") + \",\" + this.get(\"name\") + \")\"\n                );\n            }\n        }\n    )\n);\n\n//==============================================================================\nvar _collectionSuper =\n    CONTROLLED_FETCH_COLLECTION.InfinitelyScrollingCollection;\n/** @class A collection of histories (per user)\n *      that maintains the current history as the first in the collection.\n *  New or copied histories become the current history.\n */\nvar HistoryCollection = _collectionSuper.extend(BASE_MVC.LoggableMixin).extend({\n    _logNamespace: \"history\",\n\n    model: History,\n    /** @type {String} initial order used by collection */\n    order: \"update_time\",\n    /** @type {Number} limit used for the first fetch (or a reset) */\n    limitOnFirstFetch: 10,\n    /** @type {Number} limit used for each subsequent fetch */\n    limitPerFetch: 10,\n\n    initialize: function(models, options) {\n        options = options || {};\n        this.log(\"HistoryCollection.initialize\", models, options);\n        _collectionSuper.prototype.initialize.call(this, models, options);\n\n        /** @type {boolean} should deleted histories be included */\n        this.includeDeleted = options.includeDeleted || false;\n\n        /** @type {String} encoded id of the history that's current */\n        this.currentHistoryId = options.currentHistoryId;\n\n        this.setUpListeners();\n        // note: models are sent to reset *after* this fn ends; up to this point\n        // the collection *is empty*\n    },\n\n    urlRoot: Galaxy.root + \"api/histories\",\n    url: function() {\n        return this.urlRoot;\n    },\n\n    /** set up reflexive event handlers */\n    setUpListeners: function setUpListeners() {\n        return this.on({\n            // when a history is deleted, remove it from the collection (if optionally set to do so)\n            \"change:deleted\": function(history) {\n                // TODO: this becomes complicated when more filters are used\n                this.debug(\n                    \"change:deleted\",\n                    this.includeDeleted,\n                    history.get(\"deleted\")\n                );\n                if (!this.includeDeleted && history.get(\"deleted\")) {\n                    this.remove(history);\n                }\n            },\n            // listen for a history copy, setting it to current\n            copied: function(original, newData) {\n                this.setCurrent(new History(newData, []));\n            },\n            // when a history is made current, track the id in the collection\n            \"set-as-current\": function(history) {\n                var oldCurrentId = this.currentHistoryId;\n                this.trigger(\"no-longer-current\", oldCurrentId);\n                this.currentHistoryId = history.id;\n            }\n        });\n    },\n\n    /** override to change view */\n    _buildFetchData: function(options) {\n        return _.extend(\n            _collectionSuper.prototype._buildFetchData.call(this, options),\n            {\n                view: \"dev-detailed\"\n            }\n        );\n    },\n\n    /** override to filter out deleted and purged */\n    _buildFetchFilters: function(options) {\n        var superFilters =\n            _collectionSuper.prototype._buildFetchFilters.call(this, options) ||\n            {};\n        var filters = {};\n        if (!this.includeDeleted) {\n            filters.deleted = false;\n            filters.purged = false;\n        } else {\n            // force API to return both deleted and non\n            //TODO: when the API is updated, remove this\n            filters.deleted = null;\n        }\n        return _.defaults(superFilters, filters);\n    },\n\n    /** override to fetch current as well (as it may be outside the first 10, etc.) */\n    fetchFirst: function(options) {\n        var self = this;\n        // TODO: batch?\n        var xhr = $.when();\n        if (this.currentHistoryId) {\n            xhr = _collectionSuper.prototype.fetchFirst.call(self, {\n                silent: true,\n                limit: 1,\n                filters: {\n                    // without these a deleted current history will return [] here and block the other xhr\n                    purged: \"\",\n                    deleted: \"\",\n                    \"encoded_id-in\": this.currentHistoryId\n                }\n            });\n        }\n        return xhr.then(function() {\n            options = options || {};\n            options.offset = 0;\n            return self.fetchMore(options);\n        });\n    },\n\n    /** @type {Object} map of collection available sorting orders containing comparator fns */\n    comparators: _.extend(_.clone(_collectionSuper.prototype.comparators), {\n        name: BASE_MVC.buildComparator(\"name\", {\n            ascending: true\n        }),\n        \"name-dsc\": BASE_MVC.buildComparator(\"name\", {\n            ascending: false\n        }),\n        size: BASE_MVC.buildComparator(\"size\", {\n            ascending: false\n        }),\n        \"size-asc\": BASE_MVC.buildComparator(\"size\", {\n            ascending: true\n        })\n    }),\n\n    /** override to always have the current history first */\n    sort: function(options) {\n        options = options || {};\n        var silent = options.silent;\n        var currentHistory = this.remove(this.get(this.currentHistoryId));\n        _collectionSuper.prototype.sort.call(\n            this,\n            _.defaults({ silent: true }, options)\n        );\n        this.unshift(currentHistory, { silent: true });\n        if (!silent) {\n            this.trigger(\"sort\", this, options);\n        }\n        return this;\n    },\n\n    /** create a new history and by default set it to be the current history */\n    create: function create(data, hdas, historyOptions, xhrOptions) {\n        //TODO: .create is actually a collection function that's overridden here\n        var collection = this,\n            xhr = jQuery.getJSON(Galaxy.root + \"history/create_new_current\");\n        return xhr.done(function(newData) {\n            collection.setCurrent(\n                new History(newData, [], historyOptions || {})\n            );\n        });\n    },\n\n    /** set the current history to the given history, placing it first in the collection.\n     *  Pass standard bbone options for use in unshift.\n     *  @triggers new-current passed history and this collection\n     */\n    setCurrent: function(history, options) {\n        options = options || {};\n        // new histories go in the front\n        this.unshift(history, options);\n        this.currentHistoryId = history.get(\"id\");\n        if (!options.silent) {\n            this.trigger(\"new-current\", history, this);\n        }\n        return this;\n    },\n\n    toString: function toString() {\n        return (\n            \"HistoryCollection(\" +\n            this.length +\n            \",current:\" +\n            this.currentHistoryId +\n            \")\"\n        );\n    }\n});\n\n//==============================================================================\nexport default {\n    History: History,\n    HistoryCollection: HistoryCollection\n};\n"]}