{"version":3,"sources":["mvc/history/history-model.js"],"names":["define","HISTORY_CONTENTS","HISTORY_PREFS","CONTROLLED_FETCH_COLLECTION","UTILS","BASE_MVC","_l","History","Backbone","Model","extend","LoggableMixin","defaults","mixin","SearchableModelMixin","model_class","state","contents_active","contents_states","id","name","urlRoot","root","contentsClass","Galaxy","title","HistoryContents","searchAttributes","searchAliases","initialize","options","order","this","logger","log","_setUpListeners","historyJSON","contents","history","updateTimeoutId","historyId","get","on","error","model","xhr","msg","details","clearUpdateTimeout","_setUpCollectionListeners","newId","listenTo","contentsShown","apply","jQuery","makeArray","arguments","contentsActive","nice_size","active","shown","size","includeDeleted","deleted","hidden","bytesToString","_","key","prototype","toJSON","call","ownedByCurrUser","user","numOfUnfinishedJobs","unfinishedJobIds","length","numOfUnfinishedShownContents","data","runningAndActive","_fetchContentRelatedAttributes","self","$","param","keys","contentRelatedAttrs","join","refresh","fetchFn","lastUpdateTime","serverResponseDatetime","fetchPage","currentPage","fetchUpdated","getResponseHeader","checkForUpdates","Date","err","setTimeout","delay","_delayThenUpdate","trigger","parse","response","parsed","create_time","fetchWithContents","update_time","contentsOptions","view","fetch","then","fetchContents","when","fetchCurrentPage","purge","save","undelete","purged","current","undefined","Error","postData","history_id","all_datasets","copy","post","newHistory","setAsCurrent","done","getJSON","toString","_collectionSuper","InfinitelyScrollingCollection","_logNamespace","limitOnFirstFetch","models","currentHistoryId","setUpListeners","url","change:deleted","debug","remove","copied","setCurrent","newData","set-as-current","oldCurrentId","_buildFetchData","_buildFetchFilters","superFilters","filters","fetchFirst","silent","limit","encoded_id-in","offset","fetchMore","comparators","buildComparator","ascending","name-dsc","size-asc","currentHistory","sort","unshift","create","hdas","historyOptions","xhrOptions","collection","HistoryCollection"],"mappings":"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","file":"../../../scripts/mvc/history/history-model.js","sourcesContent":["\ndefine([\n    \"mvc/history/history-contents\",\n    \"mvc/history/history-preferences\",\n    \"mvc/base/controlled-fetch-collection\",\n    \"utils/utils\",\n    \"mvc/base-mvc\",\n    \"utils/localization\"\n], function( HISTORY_CONTENTS, HISTORY_PREFS, CONTROLLED_FETCH_COLLECTION, UTILS, BASE_MVC, _l ){\n'use strict';\n\n//==============================================================================\n/** @class Model for a Galaxy history resource - both a record of user\n *      tool use and a collection of the datasets those tools produced.\n *  @name History\n *  @augments Backbone.Model\n */\nvar History = Backbone.Model\n        .extend( BASE_MVC.LoggableMixin )\n        .extend( BASE_MVC.mixin( BASE_MVC.SearchableModelMixin, /** @lends History.prototype */{\n    _logNamespace : 'history',\n\n    /** ms between fetches when checking running jobs/datasets for updates */\n    UPDATE_DELAY : 4000,\n\n    // values from api (may need more)\n    defaults : {\n        model_class     : 'History',\n        id              : null,\n        name            : 'Unnamed History',\n        state           : 'new',\n\n        deleted         : false,\n        contents_active : {},\n        contents_states : {},\n    },\n\n    urlRoot: Galaxy.root + 'api/histories',\n\n    contentsClass : HISTORY_CONTENTS.HistoryContents,\n\n    /** What model fields to search with */\n    searchAttributes : [\n        'name', 'annotation', 'tags'\n    ],\n\n    /** Adding title and singular tag */\n    searchAliases : {\n        title       : 'name',\n        tag         : 'tags'\n    },\n\n    // ........................................................................ set up/tear down\n    /** Set up the model\n     *  @param {Object} historyJSON model data for this History\n     *  @param {Object} options     any extra settings including logger\n     */\n    initialize : function( historyJSON, options ){\n        options = options || {};\n        this.logger = options.logger || null;\n        this.log( this + \".initialize:\", historyJSON, options );\n\n        /** HistoryContents collection of the HDAs contained in this history. */\n        this.contents = new this.contentsClass( [], {\n            history     : this,\n            historyId   : this.get( 'id' ),\n            order       : options.order,\n        });\n\n        this._setUpListeners();\n        this._setUpCollectionListeners();\n\n        /** cached timeout id for the dataset updater */\n        this.updateTimeoutId = null;\n    },\n\n    /** set up any event listeners for this history including those to the contained HDAs\n     *  events: error:contents  if an error occurred with the contents collection\n     */\n    _setUpListeners : function(){\n        // if the model's id changes ('current' or null -> an actual id), update the contents history_id\n        return this.on({\n            'error' : function( model, xhr, options, msg, details ){\n                this.clearUpdateTimeout();\n            },\n            'change:id' : function( model, newId ){\n                if( this.contents ){\n                    this.contents.historyId = newId;\n                }\n            },\n        });\n    },\n\n    /** event handlers for the contents submodels */\n    _setUpCollectionListeners : function(){\n        if( !this.contents ){ return this; }\n        // bubble up errors\n        return this.listenTo( this.contents, {\n            'error' : function(){\n                this.trigger.apply( this, jQuery.makeArray( arguments ) );\n            },\n        });\n    },\n\n    // ........................................................................ derived attributes\n    /**  */\n    contentsShown : function(){\n        var contentsActive = this.get( 'contents_active' );\n        var shown = contentsActive.active || 0;\n        shown += this.contents.includeDeleted? contentsActive.deleted : 0;\n        shown += this.contents.includeHidden?  contentsActive.hidden  : 0;\n        return shown;\n    },\n\n    /** convert size in bytes to a more human readable version */\n    nice_size : function(){\n        var size = this.get( 'size' );\n        return size? UTILS.bytesToString( size, true, 2 ) : _l( '(empty)' );\n    },\n\n    /** override to add nice_size */\n    toJSON : function(){\n        return _.extend( Backbone.Model.prototype.toJSON.call( this ), {\n            nice_size : this.nice_size()\n        });\n    },\n\n    /** override to allow getting nice_size */\n    get : function( key ){\n        if( key === 'nice_size' ){\n            return this.nice_size();\n        }\n        return Backbone.Model.prototype.get.apply( this, arguments );\n    },\n\n    // ........................................................................ common queries\n    /** T/F is this history owned by the current user (Galaxy.user)\n     *      Note: that this will return false for an anon user even if the history is theirs.\n     */\n    ownedByCurrUser : function(){\n        // no currUser\n        if( !Galaxy || !Galaxy.user ){\n            return false;\n        }\n        // user is anon or history isn't owned\n        if( Galaxy.user.isAnonymous() || Galaxy.user.id !== this.get( 'user_id' ) ){\n            return false;\n        }\n        return true;\n    },\n\n    /** Return the number of running jobs assoc with this history (note: unknown === 0) */\n    numOfUnfinishedJobs : function(){\n        var unfinishedJobIds = this.get( 'non_ready_jobs' );\n        return unfinishedJobIds? unfinishedJobIds.length : 0;\n    },\n\n    /** Return the number of running hda/hdcas in this history (note: unknown === 0) */\n    numOfUnfinishedShownContents : function(){\n        return this.contents.runningAndActive().length || 0;\n    },\n\n    // ........................................................................ updates\n    _fetchContentRelatedAttributes : function(){\n        var contentRelatedAttrs = [ 'size', 'non_ready_jobs', 'contents_active', 'hid_counter' ];\n        return this.fetch({ data : $.param({ keys : contentRelatedAttrs.join( ',' ) }) });\n    },\n\n    /** check for any changes since the last time we updated (or fetch all if ) */\n    refresh : function( options ){\n        // console.log( this + '.refresh' );\n        options = options || {};\n        var self = this;\n\n        // note if there was no previous update time, all summary contents will be fetched\n        var lastUpdateTime = self.lastUpdateTime;\n        // if we don't flip this, then a fully-fetched list will not be re-checked via fetch\n        this.contents.allFetched = false;\n        var fetchFn = self.contents.currentPage !== 0\n            ? function(){ return self.contents.fetchPage( self.contents.currentPage ); }\n            : function(){ return self.contents.fetchUpdated( lastUpdateTime ); };\n        // note: if there was no previous update time, all summary contents will be fetched\n        return fetchFn()\n            .done( function( response, status, xhr ){\n                var serverResponseDatetime;\n                try {\n                    serverResponseDatetime = new Date( xhr.getResponseHeader( 'Date' ) );\n                } catch( err ){}\n                self.lastUpdateTime = serverResponseDatetime || new Date();\n                self.checkForUpdates( options );\n            });\n    },\n\n    /** continuously fetch updated contents every UPDATE_DELAY ms if this history's datasets or jobs are unfinished */\n    checkForUpdates : function( options ){\n        // console.log( this + '.checkForUpdates' );\n        options = options || {};\n        var delay = this.UPDATE_DELAY;\n        var self = this;\n        if( !self.id ){ return; }\n\n        function _delayThenUpdate(){\n            // prevent buildup of updater timeouts by clearing previous if any, then set new and cache id\n            self.clearUpdateTimeout();\n            self.updateTimeoutId = setTimeout( function(){\n                self.refresh( options );\n            }, delay );\n        }\n\n        // if there are still datasets in the non-ready state, recurse into this function with the new time\n        var nonReadyContentCount = this.numOfUnfinishedShownContents();\n        // console.log( 'nonReadyContentCount:', nonReadyContentCount );\n        if( nonReadyContentCount > 0 ){\n            _delayThenUpdate();\n\n        } else {\n            // no datasets are running, but currently runnning jobs may still produce new datasets\n            // see if the history has any running jobs and continue to update if so\n            // (also update the size for the user in either case)\n            self._fetchContentRelatedAttributes()\n                .done( function( historyData ){\n                    // console.log( 'non_ready_jobs:', historyData.non_ready_jobs );\n                    if( self.numOfUnfinishedJobs() > 0 ){\n                        _delayThenUpdate();\n\n                    } else {\n                        // otherwise, let listeners know that all updates have stopped\n                        self.trigger( 'ready' );\n                    }\n                });\n        }\n    },\n\n    /** clear the timeout and the cached timeout id */\n    clearUpdateTimeout : function(){\n        if( this.updateTimeoutId ){\n            clearTimeout( this.updateTimeoutId );\n            this.updateTimeoutId = null;\n        }\n    },\n\n    // ........................................................................ ajax\n    /** override to use actual Dates objects for create/update times */\n    parse : function( response, options ){\n        var parsed = Backbone.Model.prototype.parse.call( this, response, options );\n        if( parsed.create_time ){\n            parsed.create_time = new Date( parsed.create_time );\n        }\n        if( parsed.update_time ){\n            parsed.update_time = new Date( parsed.update_time );\n        }\n        return parsed;\n    },\n\n    /** fetch this histories data (using options) then it's contents (using contentsOptions) */\n    fetchWithContents : function( options, contentsOptions ){\n        options = options || {};\n        var self = this;\n\n        // console.log( this + '.fetchWithContents' );\n        // TODO: push down to a base class\n        options.view = 'dev-detailed';\n\n        // fetch history then use history data to fetch (paginated) contents\n        return this.fetch( options ).then( function getContents( history ){\n            self.contents.history = self;\n            self.contents.setHistoryId( history.id );\n            return self.fetchContents( contentsOptions );\n        });\n    },\n\n    /** fetch this histories contents, adjusting options based on the stored history preferences */\n    fetchContents : function( options ){\n        options = options || {};\n        var self = this;\n\n        // we're updating, reset the update time\n        self.lastUpdateTime = new Date();\n        return self.contents.fetchCurrentPage( options );\n    },\n\n    /** save this history, _Mark_ing it as deleted (just a flag) */\n    _delete : function( options ){\n        if( this.get( 'deleted' ) ){ return jQuery.when(); }\n        return this.save( { deleted: true }, options );\n    },\n    /** purge this history, _Mark_ing it as purged and removing all dataset data from the server */\n    purge : function( options ){\n        if( this.get( 'purged' ) ){ return jQuery.when(); }\n        return this.save( { deleted: true, purged: true }, options );\n    },\n    /** save this history, _Mark_ing it as undeleted */\n    undelete : function( options ){\n        if( !this.get( 'deleted' ) ){ return jQuery.when(); }\n        return this.save( { deleted: false }, options );\n    },\n\n    /** Make a copy of this history on the server\n     *  @param {Boolean} current    if true, set the copy as the new current history (default: true)\n     *  @param {String} name        name of new history (default: none - server sets to: Copy of <current name>)\n     *  @fires copied               passed this history and the response JSON from the copy\n     *  @returns {xhr}\n     */\n    copy : function( current, name, allDatasets ){\n        current = ( current !== undefined )?( current ):( true );\n        if( !this.id ){\n            throw new Error( 'You must set the history ID before copying it.' );\n        }\n\n        var postData = { history_id  : this.id };\n        if( current ){\n            postData.current = true;\n        }\n        if( name ){\n            postData.name = name;\n        }\n        if( !allDatasets ){\n            postData.all_datasets = false;\n        }\n        postData.view = 'dev-detailed';\n\n        var history = this;\n        var copy = jQuery.post( this.urlRoot, postData );\n        // if current - queue to setAsCurrent before firing 'copied'\n        if( current ){\n            return copy.then( function( response ){\n                var newHistory = new History( response );\n                return newHistory.setAsCurrent()\n                    .done( function(){\n                        history.trigger( 'copied', history, response );\n                    });\n            });\n        }\n        return copy.done( function( response ){\n            history.trigger( 'copied', history, response );\n        });\n    },\n\n    setAsCurrent : function(){\n        var history = this,\n            xhr = jQuery.getJSON( Galaxy.root + 'history/set_as_current?id=' + this.id );\n\n        xhr.done( function(){\n            history.trigger( 'set-as-current', history );\n        });\n        return xhr;\n    },\n\n    // ........................................................................ misc\n    toString : function(){\n        return 'History(' + this.get( 'id' ) + ',' + this.get( 'name' ) + ')';\n    }\n}));\n\n\n//==============================================================================\nvar _collectionSuper = CONTROLLED_FETCH_COLLECTION.InfinitelyScrollingCollection;\n/** @class A collection of histories (per user)\n *      that maintains the current history as the first in the collection.\n *  New or copied histories become the current history.\n */\nvar HistoryCollection = _collectionSuper.extend( BASE_MVC.LoggableMixin ).extend({\n    _logNamespace       : 'history',\n\n    model               : History,\n    /** @type {String} initial order used by collection */\n    order               : 'update_time',\n    /** @type {Number} limit used for the first fetch (or a reset) */\n    limitOnFirstFetch   : 10,\n    /** @type {Number} limit used for each subsequent fetch */\n    limitPerFetch       : 10,\n\n    initialize : function( models, options ){\n        options = options || {};\n        this.log( 'HistoryCollection.initialize', models, options );\n        _collectionSuper.prototype.initialize.call( this, models, options );\n\n        /** @type {boolean} should deleted histories be included */\n        this.includeDeleted = options.includeDeleted || false;\n\n        /** @type {String} encoded id of the history that's current */\n        this.currentHistoryId = options.currentHistoryId;\n\n        this.setUpListeners();\n        // note: models are sent to reset *after* this fn ends; up to this point\n        // the collection *is empty*\n    },\n\n    urlRoot : Galaxy.root + 'api/histories',\n    url     : function(){ return this.urlRoot; },\n\n    /** set up reflexive event handlers */\n    setUpListeners : function setUpListeners(){\n        return this.on({\n            // when a history is deleted, remove it from the collection (if optionally set to do so)\n            'change:deleted' : function( history ){\n                // TODO: this becomes complicated when more filters are used\n                this.debug( 'change:deleted', this.includeDeleted, history.get( 'deleted' ) );\n                if( !this.includeDeleted && history.get( 'deleted' ) ){\n                    this.remove( history );\n                }\n            },\n            // listen for a history copy, setting it to current\n            'copied' : function( original, newData ){\n                this.setCurrent( new History( newData, [] ) );\n            },\n            // when a history is made current, track the id in the collection\n            'set-as-current' : function( history ){\n                var oldCurrentId = this.currentHistoryId;\n                this.trigger( 'no-longer-current', oldCurrentId );\n                this.currentHistoryId = history.id;\n            }\n        });\n    },\n\n    /** override to change view */\n    _buildFetchData : function( options ){\n        return _.extend( _collectionSuper.prototype._buildFetchData.call( this, options ), {\n            view : 'dev-detailed'\n        });\n    },\n\n    /** override to filter out deleted and purged */\n    _buildFetchFilters : function( options ){\n        var superFilters = _collectionSuper.prototype._buildFetchFilters.call( this, options ) || {};\n        var filters = {};\n        if( !this.includeDeleted ){\n            filters.deleted = false;\n            filters.purged = false;\n        } else {\n            // force API to return both deleted and non\n            //TODO: when the API is updated, remove this\n            filters.deleted = null;\n        }\n        return _.defaults( superFilters, filters );\n    },\n\n    /** override to fetch current as well (as it may be outside the first 10, etc.) */\n    fetchFirst : function( options ){\n        var self = this;\n        // TODO: batch?\n        var xhr = $.when();\n        if( this.currentHistoryId ){\n            xhr = _collectionSuper.prototype.fetchFirst.call( self, {\n                silent: true,\n                limit : 1,\n                filters: {\n                    // without these a deleted current history will return [] here and block the other xhr\n                    'purged'        : '',\n                    'deleted'       : '',\n                    'encoded_id-in' : this.currentHistoryId,\n                }\n            });\n        }\n        return xhr.then( function(){\n            options = options || {};\n            options.offset = 0;\n            return self.fetchMore( options );\n        });\n    },\n\n    /** @type {Object} map of collection available sorting orders containing comparator fns */\n    comparators : _.extend( _.clone( _collectionSuper.prototype.comparators ), {\n        'name'       : BASE_MVC.buildComparator( 'name', { ascending: true }),\n        'name-dsc'   : BASE_MVC.buildComparator( 'name', { ascending: false }),\n        'size'       : BASE_MVC.buildComparator( 'size', { ascending: false }),\n        'size-asc'   : BASE_MVC.buildComparator( 'size', { ascending: true }),\n    }),\n\n    /** override to always have the current history first */\n    sort : function( options ){\n        options = options || {};\n        var silent = options.silent;\n        var currentHistory = this.remove( this.get( this.currentHistoryId ) );\n        _collectionSuper.prototype.sort.call( this, _.defaults({ silent: true }, options ) );\n        this.unshift( currentHistory, { silent: true });\n        if( !silent ){\n            this.trigger( 'sort', this, options );\n        }\n        return this;\n    },\n\n    /** create a new history and by default set it to be the current history */\n    create : function create( data, hdas, historyOptions, xhrOptions ){\n        //TODO: .create is actually a collection function that's overridden here\n        var collection = this,\n            xhr = jQuery.getJSON( Galaxy.root + 'history/create_new_current'  );\n        return xhr.done( function( newData ){\n            collection.setCurrent( new History( newData, [], historyOptions || {} ) );\n        });\n    },\n\n    /** set the current history to the given history, placing it first in the collection.\n     *  Pass standard bbone options for use in unshift.\n     *  @triggers new-current passed history and this collection\n     */\n    setCurrent : function( history, options ){\n        options = options || {};\n        // new histories go in the front\n        this.unshift( history, options );\n        this.currentHistoryId = history.get( 'id' );\n        if( !options.silent ){\n            this.trigger( 'new-current', history, this );\n        }\n        return this;\n    },\n\n    toString: function toString(){\n        return 'HistoryCollection(' + this.length + ',current:' + this.currentHistoryId + ')';\n    }\n});\n\n\n//==============================================================================\nreturn {\n    History           : History,\n    HistoryCollection : HistoryCollection\n};});\n"]}