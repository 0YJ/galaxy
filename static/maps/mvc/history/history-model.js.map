{"version":3,"sources":["mvc/history/history-model.js"],"names":["define","HISTORY_CONTENTS","HISTORY_PREFS","CONTROLLED_FETCH_COLLECTION","UTILS","BASE_MVC","_l","History","Backbone","Model","extend","LoggableMixin","mixin","SearchableModelMixin","_logNamespace","UPDATE_DELAY","defaults","model_class","id","name","state","deleted","contents_active","contents_states","urlRoot","Galaxy","root","contentsClass","HistoryContents","searchAttributes","searchAliases","title","tag","initialize","historyJSON","options","this","logger","log","contents","history","historyId","get","order","_setUpListeners","_setUpCollectionListeners","updateTimeoutId","on","error","model","xhr","msg","details","clearUpdateTimeout","change:id","newId","listenTo","trigger","apply","jQuery","makeArray","arguments","contentsShown","contentsActive","shown","active","includeDeleted","includeHidden","hidden","nice_size","size","bytesToString","toJSON","_","prototype","call","key","ownedByCurrUser","user","isAnonymous","numOfUnfinishedJobs","unfinishedJobIds","length","numOfUnfinishedShownContents","runningAndActive","_fetchContentRelatedAttributes","contentRelatedAttrs","fetch","data","$","param","keys","join","refresh","self","lastUpdateTime","allFetched","currentPage","fetchPage","fetchUpdated","done","response","status","serverResponseDatetime","Date","getResponseHeader","err","checkForUpdates","_delayThenUpdate","setTimeout","delay","historyData","clearTimeout","parse","parsed","create_time","update_time","fetchWithContents","contentsOptions","view","then","setHistoryId","fetchContents","fetchCurrentPage","_delete","when","save","purge","purged","undelete","copy","current","allDatasets","undefined","Error","postData","history_id","all_datasets","post","setAsCurrent","getJSON","toString","_collectionSuper","InfinitelyScrollingCollection","HistoryCollection","limitOnFirstFetch","limitPerFetch","models","currentHistoryId","setUpListeners","url","change:deleted","debug","remove","copied","original","newData","setCurrent","set-as-current","oldCurrentId","_buildFetchData","_buildFetchFilters","superFilters","filters","fetchFirst","silent","limit","encoded_id-in","offset","fetchMore","comparators","clone","buildComparator","ascending","name-dsc","size-asc","sort","currentHistory","unshift","create","hdas","historyOptions","xhrOptions","collection"],"mappings":"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","file":"../../../scripts/mvc/history/history-model.js","sourcesContent":["\ndefine([\n    \"mvc/history/history-contents\",\n    \"mvc/history/history-preferences\",\n    \"mvc/base/controlled-fetch-collection\",\n    \"utils/utils\",\n    \"mvc/base-mvc\",\n    \"utils/localization\"\n], function( HISTORY_CONTENTS, HISTORY_PREFS, CONTROLLED_FETCH_COLLECTION, UTILS, BASE_MVC, _l ){\n'use strict';\n\n//==============================================================================\n/** @class Model for a Galaxy history resource - both a record of user\n *      tool use and a collection of the datasets those tools produced.\n *  @name History\n *  @augments Backbone.Model\n */\nvar History = Backbone.Model\n        .extend( BASE_MVC.LoggableMixin )\n        .extend( BASE_MVC.mixin( BASE_MVC.SearchableModelMixin, /** @lends History.prototype */{\n    _logNamespace : 'history',\n\n    /** ms between fetches when checking running jobs/datasets for updates */\n    UPDATE_DELAY : 4000,\n\n    // values from api (may need more)\n    defaults : {\n        model_class     : 'History',\n        id              : null,\n        name            : 'Unnamed History',\n        state           : 'new',\n\n        deleted         : false,\n        contents_active : {},\n        contents_states : {},\n    },\n\n    urlRoot: Galaxy.root + 'api/histories',\n\n    contentsClass : HISTORY_CONTENTS.HistoryContents,\n\n    /** What model fields to search with */\n    searchAttributes : [\n        'name', 'annotation', 'tags'\n    ],\n\n    /** Adding title and singular tag */\n    searchAliases : {\n        title       : 'name',\n        tag         : 'tags'\n    },\n\n    // ........................................................................ set up/tear down\n    /** Set up the model\n     *  @param {Object} historyJSON model data for this History\n     *  @param {Object} options     any extra settings including logger\n     */\n    initialize : function( historyJSON, options ){\n        options = options || {};\n        this.logger = options.logger || null;\n        this.log( this + \".initialize:\", historyJSON, options );\n\n        /** HistoryContents collection of the HDAs contained in this history. */\n        this.contents = new this.contentsClass( [], {\n            history     : this,\n            historyId   : this.get( 'id' ),\n            order       : options.order,\n        });\n\n        this._setUpListeners();\n        this._setUpCollectionListeners();\n\n        /** cached timeout id for the dataset updater */\n        this.updateTimeoutId = null;\n    },\n\n    /** set up any event listeners for this history including those to the contained HDAs\n     *  events: error:contents  if an error occurred with the contents collection\n     */\n    _setUpListeners : function(){\n        // if the model's id changes ('current' or null -> an actual id), update the contents history_id\n        return this.on({\n            'error' : function( model, xhr, options, msg, details ){\n                this.clearUpdateTimeout();\n            },\n            'change:id' : function( model, newId ){\n                if( this.contents ){\n                    this.contents.historyId = newId;\n                }\n            },\n        });\n    },\n\n    /** event handlers for the contents submodels */\n    _setUpCollectionListeners : function(){\n        if( !this.contents ){ return this; }\n        // bubble up errors\n        return this.listenTo( this.contents, {\n            'error' : function(){\n                this.trigger.apply( this, jQuery.makeArray( arguments ) );\n            },\n        });\n    },\n\n    // ........................................................................ derived attributes\n    /**  */\n    contentsShown : function(){\n        var contentsActive = this.get( 'contents_active' );\n        var shown = contentsActive.active || 0;\n        shown += this.contents.includeDeleted? contentsActive.deleted : 0;\n        shown += this.contents.includeHidden?  contentsActive.hidden  : 0;\n        return shown;\n    },\n\n    /** convert size in bytes to a more human readable version */\n    nice_size : function(){\n        var size = this.get( 'size' );\n        return size? UTILS.bytesToString( size, true, 2 ) : _l( '(empty)' );\n    },\n\n    /** override to add nice_size */\n    toJSON : function(){\n        return _.extend( Backbone.Model.prototype.toJSON.call( this ), {\n            nice_size : this.nice_size()\n        });\n    },\n\n    /** override to allow getting nice_size */\n    get : function( key ){\n        if( key === 'nice_size' ){\n            return this.nice_size();\n        }\n        return Backbone.Model.prototype.get.apply( this, arguments );\n    },\n\n    // ........................................................................ common queries\n    /** T/F is this history owned by the current user (Galaxy.user)\n     *      Note: that this will return false for an anon user even if the history is theirs.\n     */\n    ownedByCurrUser : function(){\n        // no currUser\n        if( !Galaxy || !Galaxy.user ){\n            return false;\n        }\n        // user is anon or history isn't owned\n        if( Galaxy.user.isAnonymous() || Galaxy.user.id !== this.get( 'user_id' ) ){\n            return false;\n        }\n        return true;\n    },\n\n    /** Return the number of running jobs assoc with this history (note: unknown === 0) */\n    numOfUnfinishedJobs : function(){\n        var unfinishedJobIds = this.get( 'non_ready_jobs' );\n        return unfinishedJobIds? unfinishedJobIds.length : 0;\n    },\n\n    /** Return the number of running hda/hdcas in this history (note: unknown === 0) */\n    numOfUnfinishedShownContents : function(){\n        return this.contents.runningAndActive().length || 0;\n    },\n\n    // ........................................................................ updates\n    _fetchContentRelatedAttributes : function(){\n        var contentRelatedAttrs = [ 'size', 'non_ready_jobs', 'contents_active', 'hid_counter' ];\n        return this.fetch({ data : $.param({ keys : contentRelatedAttrs.join( ',' ) }) });\n    },\n\n    /** check for any changes since the last time we updated (or fetch all if ) */\n    refresh : function( options ){\n        // console.log( this + '.refresh' );\n        options = options || {};\n        var self = this;\n\n        // note if there was no previous update time, all summary contents will be fetched\n        var lastUpdateTime = self.lastUpdateTime;\n        // if we don't flip this, then a fully-fetched list will not be re-checked via fetch\n        this.contents.allFetched = false;\n        var fetchFn = self.contents.currentPage !== 0\n            ? function(){ return self.contents.fetchPage( self.contents.currentPage ); }\n            : function(){ return self.contents.fetchUpdated( lastUpdateTime ); };\n        // note: if there was no previous update time, all summary contents will be fetched\n        return fetchFn()\n            .done( function( response, status, xhr ){\n                var serverResponseDatetime;\n                try {\n                    serverResponseDatetime = new Date( xhr.getResponseHeader( 'Date' ) );\n                } catch( err ){}\n                self.lastUpdateTime = serverResponseDatetime || new Date();\n                self.checkForUpdates( options );\n            });\n    },\n\n    /** continuously fetch updated contents every UPDATE_DELAY ms if this history's datasets or jobs are unfinished */\n    checkForUpdates : function( options ){\n        // console.log( this + '.checkForUpdates' );\n        options = options || {};\n        var delay = this.UPDATE_DELAY;\n        var self = this;\n        if( !self.id ){ return; }\n\n        function _delayThenUpdate(){\n            // prevent buildup of updater timeouts by clearing previous if any, then set new and cache id\n            self.clearUpdateTimeout();\n            self.updateTimeoutId = setTimeout( function(){\n                self.refresh( options );\n            }, delay );\n        }\n\n        // if there are still datasets in the non-ready state, recurse into this function with the new time\n        var nonReadyContentCount = this.numOfUnfinishedShownContents();\n        // console.log( 'nonReadyContentCount:', nonReadyContentCount );\n        if( nonReadyContentCount > 0 ){\n            _delayThenUpdate();\n\n        } else {\n            // no datasets are running, but currently runnning jobs may still produce new datasets\n            // see if the history has any running jobs and continue to update if so\n            // (also update the size for the user in either case)\n            self._fetchContentRelatedAttributes()\n                .done( function( historyData ){\n                    // console.log( 'non_ready_jobs:', historyData.non_ready_jobs );\n                    if( self.numOfUnfinishedJobs() > 0 ){\n                        _delayThenUpdate();\n\n                    } else {\n                        // otherwise, let listeners know that all updates have stopped\n                        self.trigger( 'ready' );\n                    }\n                });\n        }\n    },\n\n    /** clear the timeout and the cached timeout id */\n    clearUpdateTimeout : function(){\n        if( this.updateTimeoutId ){\n            clearTimeout( this.updateTimeoutId );\n            this.updateTimeoutId = null;\n        }\n    },\n\n    // ........................................................................ ajax\n    /** override to use actual Dates objects for create/update times */\n    parse : function( response, options ){\n        var parsed = Backbone.Model.prototype.parse.call( this, response, options );\n        if( parsed.create_time ){\n            parsed.create_time = new Date( parsed.create_time );\n        }\n        if( parsed.update_time ){\n            parsed.update_time = new Date( parsed.update_time );\n        }\n        return parsed;\n    },\n\n    /** fetch this histories data (using options) then it's contents (using contentsOptions) */\n    fetchWithContents : function( options, contentsOptions ){\n        options = options || {};\n        var self = this;\n\n        // console.log( this + '.fetchWithContents' );\n        // TODO: push down to a base class\n        options.view = 'dev-detailed';\n\n        // fetch history then use history data to fetch (paginated) contents\n        return this.fetch( options ).then( function getContents( history ){\n            self.contents.history = self;\n            self.contents.setHistoryId( history.id );\n            return self.fetchContents( contentsOptions );\n        });\n    },\n\n    /** fetch this histories contents, adjusting options based on the stored history preferences */\n    fetchContents : function( options ){\n        options = options || {};\n        var self = this;\n\n        // we're updating, reset the update time\n        self.lastUpdateTime = new Date();\n        return self.contents.fetchCurrentPage( options );\n    },\n\n    /** save this history, _Mark_ing it as deleted (just a flag) */\n    _delete : function( options ){\n        if( this.get( 'deleted' ) ){ return jQuery.when(); }\n        return this.save( { deleted: true }, options );\n    },\n    /** purge this history, _Mark_ing it as purged and removing all dataset data from the server */\n    purge : function( options ){\n        if( this.get( 'purged' ) ){ return jQuery.when(); }\n        return this.save( { deleted: true, purged: true }, options );\n    },\n    /** save this history, _Mark_ing it as undeleted */\n    undelete : function( options ){\n        if( !this.get( 'deleted' ) ){ return jQuery.when(); }\n        return this.save( { deleted: false }, options );\n    },\n\n    /** Make a copy of this history on the server\n     *  @param {Boolean} current    if true, set the copy as the new current history (default: true)\n     *  @param {String} name        name of new history (default: none - server sets to: Copy of <current name>)\n     *  @fires copied               passed this history and the response JSON from the copy\n     *  @returns {xhr}\n     */\n    copy : function( current, name, allDatasets ){\n        current = ( current !== undefined )?( current ):( true );\n        if( !this.id ){\n            throw new Error( 'You must set the history ID before copying it.' );\n        }\n\n        var postData = { history_id  : this.id };\n        if( current ){\n            postData.current = true;\n        }\n        if( name ){\n            postData.name = name;\n        }\n        if( !allDatasets ){\n            postData.all_datasets = false;\n        }\n        postData.view = 'dev-detailed';\n\n        var history = this;\n        var copy = jQuery.post( this.urlRoot, postData );\n        // if current - queue to setAsCurrent before firing 'copied'\n        if( current ){\n            return copy.then( function( response ){\n                var newHistory = new History( response );\n                return newHistory.setAsCurrent()\n                    .done( function(){\n                        history.trigger( 'copied', history, response );\n                    });\n            });\n        }\n        return copy.done( function( response ){\n            history.trigger( 'copied', history, response );\n        });\n    },\n\n    setAsCurrent : function(){\n        var history = this,\n            xhr = jQuery.getJSON( Galaxy.root + 'history/set_as_current?id=' + this.id );\n\n        xhr.done( function(){\n            history.trigger( 'set-as-current', history );\n        });\n        return xhr;\n    },\n\n    // ........................................................................ misc\n    toString : function(){\n        return 'History(' + this.get( 'id' ) + ',' + this.get( 'name' ) + ')';\n    }\n}));\n\n\n//==============================================================================\nvar _collectionSuper = CONTROLLED_FETCH_COLLECTION.InfinitelyScrollingCollection;\n/** @class A collection of histories (per user)\n *      that maintains the current history as the first in the collection.\n *  New or copied histories become the current history.\n */\nvar HistoryCollection = _collectionSuper.extend( BASE_MVC.LoggableMixin ).extend({\n    _logNamespace       : 'history',\n\n    model               : History,\n    /** @type {String} initial order used by collection */\n    order               : 'update_time',\n    /** @type {Number} limit used for the first fetch (or a reset) */\n    limitOnFirstFetch   : 10,\n    /** @type {Number} limit used for each subsequent fetch */\n    limitPerFetch       : 10,\n\n    initialize : function( models, options ){\n        options = options || {};\n        this.log( 'HistoryCollection.initialize', models, options );\n        _collectionSuper.prototype.initialize.call( this, models, options );\n\n        /** @type {boolean} should deleted histories be included */\n        this.includeDeleted = options.includeDeleted || false;\n\n        /** @type {String} encoded id of the history that's current */\n        this.currentHistoryId = options.currentHistoryId;\n\n        this.setUpListeners();\n        // note: models are sent to reset *after* this fn ends; up to this point\n        // the collection *is empty*\n    },\n\n    urlRoot : Galaxy.root + 'api/histories',\n    url     : function(){ return this.urlRoot; },\n\n    /** set up reflexive event handlers */\n    setUpListeners : function setUpListeners(){\n        return this.on({\n            // when a history is deleted, remove it from the collection (if optionally set to do so)\n            'change:deleted' : function( history ){\n                // TODO: this becomes complicated when more filters are used\n                this.debug( 'change:deleted', this.includeDeleted, history.get( 'deleted' ) );\n                if( !this.includeDeleted && history.get( 'deleted' ) ){\n                    this.remove( history );\n                }\n            },\n            // listen for a history copy, setting it to current\n            'copied' : function( original, newData ){\n                this.setCurrent( new History( newData, [] ) );\n            },\n            // when a history is made current, track the id in the collection\n            'set-as-current' : function( history ){\n                var oldCurrentId = this.currentHistoryId;\n                this.trigger( 'no-longer-current', oldCurrentId );\n                this.currentHistoryId = history.id;\n            }\n        });\n    },\n\n    /** override to change view */\n    _buildFetchData : function( options ){\n        return _.extend( _collectionSuper.prototype._buildFetchData.call( this, options ), {\n            view : 'dev-detailed'\n        });\n    },\n\n    /** override to filter out deleted and purged */\n    _buildFetchFilters : function( options ){\n        var superFilters = _collectionSuper.prototype._buildFetchFilters.call( this, options ) || {};\n        var filters = {};\n        if( !this.includeDeleted ){\n            filters.deleted = false;\n            filters.purged = false;\n        } else {\n            // force API to return both deleted and non\n            //TODO: when the API is updated, remove this\n            filters.deleted = null;\n        }\n        return _.defaults( superFilters, filters );\n    },\n\n    /** override to fetch current as well (as it may be outside the first 10, etc.) */\n    fetchFirst : function( options ){\n        var self = this;\n        // TODO: batch?\n        var xhr = $.when();\n        if( this.currentHistoryId ){\n            xhr = _collectionSuper.prototype.fetchFirst.call( self, {\n                silent: true,\n                limit : 1,\n                filters: {\n                    // without these a deleted current history will return [] here and block the other xhr\n                    'purged'        : '',\n                    'deleted'       : '',\n                    'encoded_id-in' : this.currentHistoryId,\n                }\n            });\n        }\n        return xhr.then( function(){\n            options = options || {};\n            options.offset = 0;\n            return self.fetchMore( options );\n        });\n    },\n\n    /** @type {Object} map of collection available sorting orders containing comparator fns */\n    comparators : _.extend( _.clone( _collectionSuper.prototype.comparators ), {\n        'name'       : BASE_MVC.buildComparator( 'name', { ascending: true }),\n        'name-dsc'   : BASE_MVC.buildComparator( 'name', { ascending: false }),\n        'size'       : BASE_MVC.buildComparator( 'size', { ascending: false }),\n        'size-asc'   : BASE_MVC.buildComparator( 'size', { ascending: true }),\n    }),\n\n    /** override to always have the current history first */\n    sort : function( options ){\n        options = options || {};\n        var silent = options.silent;\n        var currentHistory = this.remove( this.get( this.currentHistoryId ) );\n        _collectionSuper.prototype.sort.call( this, _.defaults({ silent: true }, options ) );\n        this.unshift( currentHistory, { silent: true });\n        if( !silent ){\n            this.trigger( 'sort', this, options );\n        }\n        return this;\n    },\n\n    /** create a new history and by default set it to be the current history */\n    create : function create( data, hdas, historyOptions, xhrOptions ){\n        //TODO: .create is actually a collection function that's overridden here\n        var collection = this,\n            xhr = jQuery.getJSON( Galaxy.root + 'history/create_new_current'  );\n        return xhr.done( function( newData ){\n            collection.setCurrent( new History( newData, [], historyOptions || {} ) );\n        });\n    },\n\n    /** set the current history to the given history, placing it first in the collection.\n     *  Pass standard bbone options for use in unshift.\n     *  @triggers new-current passed history and this collection\n     */\n    setCurrent : function( history, options ){\n        options = options || {};\n        // new histories go in the front\n        this.unshift( history, options );\n        this.currentHistoryId = history.get( 'id' );\n        if( !options.silent ){\n            this.trigger( 'new-current', history, this );\n        }\n        return this;\n    },\n\n    toString: function toString(){\n        return 'HistoryCollection(' + this.length + ',current:' + this.currentHistoryId + ')';\n    }\n});\n\n\n//==============================================================================\nreturn {\n    History           : History,\n    HistoryCollection : HistoryCollection\n};});\n"]}