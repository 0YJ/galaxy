{"version":3,"sources":["mvc/history/history-model.js"],"names":["History","Backbone","Model","extend","_baseMvc2","default","LoggableMixin","mixin","SearchableModelMixin","_logNamespace","UPDATE_DELAY","defaults","model_class","id","name","state","deleted","contents_active","urlRoot","Galaxy","root","_historyContents2","HistoryContents","tag","contentsClass","historyJSON","options","this","logger","searchAttributes","searchAliases","history","historyId","get","order","_setUpListeners","_setUpCollectionListeners","initialize","updateTimeoutId","on","clearUpdateTimeout","model","newId","contents","error","trigger","apply","arguments","contentsShown","contentsActive","active","shown","includeDeleted","includeHidden","hidden","nice_size","size","bytesToString","toJSON","_","prototype","call","key","ownedByCurrUser","user","isAnonymous","numOfUnfinishedJobs","unfinishedJobIds","length","numOfUnfinishedShownContents","runningAndActive","_fetchContentRelatedAttributes","contentRelatedAttrs","fetch","join","refresh","self","lastUpdateTime","serverResponseDatetime","allFetched","fetchPage","currentPage","done","response","xhr","getResponseHeader","checkForUpdates","Date","err","_delayThenUpdate","setTimeout","nonReadyContentCount","delay","historyData","clearTimeout","parsed","parse","create_time","update_time","setHistoryId","view","then","fetchContents","fetchCurrentPage","jQuery","_delete","when","save","purge","purged","undelete","current","postData","allDatasets","undefined","all_datasets","copy","post","newHistory","setAsCurrent","getJSON","HistoryCollection","toString","_collectionSuper","_controlledFetchCollection2","InfinitelyScrollingCollection","currentHistoryId","limitPerFetch","models","setUpListeners","remove","url","change:deleted","_buildFetchFilters","filters","newData","set-as-current","oldCurrentId","superFilters","_buildFetchData","silent","fetchMore","buildComparator","ascending","limit","unshift","offset","create","data","historyOptions","xhrOptions","collection","name-dsc","size-asc","sort","currentHistory","setCurrent"],"mappings":"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","file":"../../../scripts/mvc/history/history-model.js","sourcesContent":["import HISTORY_CONTENTS from \"mvc/history/history-contents\";\nimport HISTORY_PREFS from \"mvc/history/history-preferences\";\nimport CONTROLLED_FETCH_COLLECTION from \"mvc/base/controlled-fetch-collection\";\nimport UTILS from \"utils/utils\";\nimport BASE_MVC from \"mvc/base-mvc\";\nimport _l from \"utils/localization\";\n\n//==============================================================================\n/** @class Model for a Galaxy history resource - both a record of user\n *      tool use and a collection of the datasets those tools produced.\n *  @name History\n *  @augments Backbone.Model\n */\nvar History = Backbone.Model.extend(BASE_MVC.LoggableMixin).extend(\n    BASE_MVC.mixin(\n        BASE_MVC.SearchableModelMixin,\n        /** @lends History.prototype */ {\n            _logNamespace: \"history\",\n\n            /** ms between fetches when checking running jobs/datasets for updates */\n            UPDATE_DELAY: 4000,\n\n            // values from api (may need more)\n            defaults: {\n                model_class: \"History\",\n                id: null,\n                name: \"Unnamed History\",\n                state: \"new\",\n\n                deleted: false,\n                contents_active: {},\n                contents_states: {}\n            },\n\n            urlRoot: Galaxy.root + \"api/histories\",\n\n            contentsClass: HISTORY_CONTENTS.HistoryContents,\n\n            /** What model fields to search with */\n            searchAttributes: [\"name\", \"annotation\", \"tags\"],\n\n            /** Adding title and singular tag */\n            searchAliases: {\n                title: \"name\",\n                tag: \"tags\"\n            },\n\n            // ........................................................................ set up/tear down\n            /** Set up the model\n     *  @param {Object} historyJSON model data for this History\n     *  @param {Object} options     any extra settings including logger\n     */\n            initialize: function(historyJSON, options) {\n                options = options || {};\n                this.logger = options.logger || null;\n                this.log(this + \".initialize:\", historyJSON, options);\n\n                /** HistoryContents collection of the HDAs contained in this history. */\n                this.contents = new this.contentsClass([], {\n                    history: this,\n                    historyId: this.get(\"id\"),\n                    order: options.order\n                });\n\n                this._setUpListeners();\n                this._setUpCollectionListeners();\n\n                /** cached timeout id for the dataset updater */\n                this.updateTimeoutId = null;\n            },\n\n            /** set up any event listeners for this history including those to the contained HDAs\n     *  events: error:contents  if an error occurred with the contents collection\n     */\n            _setUpListeners: function() {\n                // if the model's id changes ('current' or null -> an actual id), update the contents history_id\n                return this.on({\n                    error: function(model, xhr, options, msg, details) {\n                        this.clearUpdateTimeout();\n                    },\n                    \"change:id\": function(model, newId) {\n                        if (this.contents) {\n                            this.contents.historyId = newId;\n                        }\n                    }\n                });\n            },\n\n            /** event handlers for the contents submodels */\n            _setUpCollectionListeners: function() {\n                if (!this.contents) {\n                    return this;\n                }\n                // bubble up errors\n                return this.listenTo(this.contents, {\n                    error: function() {\n                        this.trigger.apply(this, jQuery.makeArray(arguments));\n                    }\n                });\n            },\n\n            // ........................................................................ derived attributes\n            /**  */\n            contentsShown: function() {\n                var contentsActive = this.get(\"contents_active\");\n                var shown = contentsActive.active || 0;\n                shown += this.contents.includeDeleted\n                    ? contentsActive.deleted\n                    : 0;\n                shown += this.contents.includeHidden\n                    ? contentsActive.hidden\n                    : 0;\n                return shown;\n            },\n\n            /** convert size in bytes to a more human readable version */\n            nice_size: function() {\n                var size = this.get(\"size\");\n                return size\n                    ? UTILS.bytesToString(size, true, 2)\n                    : _l(\"(empty)\");\n            },\n\n            /** override to add nice_size */\n            toJSON: function() {\n                return _.extend(Backbone.Model.prototype.toJSON.call(this), {\n                    nice_size: this.nice_size()\n                });\n            },\n\n            /** override to allow getting nice_size */\n            get: function(key) {\n                if (key === \"nice_size\") {\n                    return this.nice_size();\n                }\n                return Backbone.Model.prototype.get.apply(this, arguments);\n            },\n\n            // ........................................................................ common queries\n            /** T/F is this history owned by the current user (Galaxy.user)\n     *      Note: that this will return false for an anon user even if the history is theirs.\n     */\n            ownedByCurrUser: function() {\n                // no currUser\n                if (!Galaxy || !Galaxy.user) {\n                    return false;\n                }\n                // user is anon or history isn't owned\n                if (\n                    Galaxy.user.isAnonymous() ||\n                    Galaxy.user.id !== this.get(\"user_id\")\n                ) {\n                    return false;\n                }\n                return true;\n            },\n\n            /** Return the number of running jobs assoc with this history (note: unknown === 0) */\n            numOfUnfinishedJobs: function() {\n                var unfinishedJobIds = this.get(\"non_ready_jobs\");\n                return unfinishedJobIds ? unfinishedJobIds.length : 0;\n            },\n\n            /** Return the number of running hda/hdcas in this history (note: unknown === 0) */\n            numOfUnfinishedShownContents: function() {\n                return this.contents.runningAndActive().length || 0;\n            },\n\n            // ........................................................................ updates\n            _fetchContentRelatedAttributes: function() {\n                var contentRelatedAttrs = [\n                    \"size\",\n                    \"non_ready_jobs\",\n                    \"contents_active\",\n                    \"hid_counter\"\n                ];\n                return this.fetch({\n                    data: $.param({\n                        keys: contentRelatedAttrs.join(\",\")\n                    })\n                });\n            },\n\n            /** check for any changes since the last time we updated (or fetch all if ) */\n            refresh: function(options) {\n                // console.log( this + '.refresh' );\n                options = options || {};\n                var self = this;\n\n                // note if there was no previous update time, all summary contents will be fetched\n                var lastUpdateTime = self.lastUpdateTime;\n                // if we don't flip this, then a fully-fetched list will not be re-checked via fetch\n                this.contents.allFetched = false;\n                var fetchFn =\n                    self.contents.currentPage !== 0\n                        ? function() {\n                              return self.contents.fetchPage(\n                                  self.contents.currentPage\n                              );\n                          }\n                        : function() {\n                              return self.contents.fetchUpdated(lastUpdateTime);\n                          };\n                // note: if there was no previous update time, all summary contents will be fetched\n                return fetchFn().done(function(response, status, xhr) {\n                    var serverResponseDatetime;\n                    try {\n                        serverResponseDatetime = new Date(\n                            xhr.getResponseHeader(\"Date\")\n                        );\n                    } catch (err) {}\n                    self.lastUpdateTime = serverResponseDatetime || new Date();\n                    self.checkForUpdates(options);\n                });\n            },\n\n            /** continuously fetch updated contents every UPDATE_DELAY ms if this history's datasets or jobs are unfinished */\n            checkForUpdates: function(options) {\n                // console.log( this + '.checkForUpdates' );\n                options = options || {};\n                var delay = this.UPDATE_DELAY;\n                var self = this;\n                if (!self.id) {\n                    return;\n                }\n\n                function _delayThenUpdate() {\n                    // prevent buildup of updater timeouts by clearing previous if any, then set new and cache id\n                    self.clearUpdateTimeout();\n                    self.updateTimeoutId = setTimeout(function() {\n                        self.refresh(options);\n                    }, delay);\n                }\n\n                // if there are still datasets in the non-ready state, recurse into this function with the new time\n                var nonReadyContentCount = this.numOfUnfinishedShownContents();\n                // console.log( 'nonReadyContentCount:', nonReadyContentCount );\n                if (nonReadyContentCount > 0) {\n                    _delayThenUpdate();\n                } else {\n                    // no datasets are running, but currently runnning jobs may still produce new datasets\n                    // see if the history has any running jobs and continue to update if so\n                    // (also update the size for the user in either case)\n                    self\n                        ._fetchContentRelatedAttributes()\n                        .done(function(historyData) {\n                            // console.log( 'non_ready_jobs:', historyData.non_ready_jobs );\n                            if (self.numOfUnfinishedJobs() > 0) {\n                                _delayThenUpdate();\n                            } else {\n                                // otherwise, let listeners know that all updates have stopped\n                                self.trigger(\"ready\");\n                            }\n                        });\n                }\n            },\n\n            /** clear the timeout and the cached timeout id */\n            clearUpdateTimeout: function() {\n                if (this.updateTimeoutId) {\n                    clearTimeout(this.updateTimeoutId);\n                    this.updateTimeoutId = null;\n                }\n            },\n\n            // ........................................................................ ajax\n            /** override to use actual Dates objects for create/update times */\n            parse: function(response, options) {\n                var parsed = Backbone.Model.prototype.parse.call(\n                    this,\n                    response,\n                    options\n                );\n                if (parsed.create_time) {\n                    parsed.create_time = new Date(parsed.create_time);\n                }\n                if (parsed.update_time) {\n                    parsed.update_time = new Date(parsed.update_time);\n                }\n                return parsed;\n            },\n\n            /** fetch this histories data (using options) then it's contents (using contentsOptions) */\n            fetchWithContents: function(options, contentsOptions) {\n                options = options || {};\n                var self = this;\n\n                // console.log( this + '.fetchWithContents' );\n                // TODO: push down to a base class\n                options.view = \"dev-detailed\";\n\n                // fetch history then use history data to fetch (paginated) contents\n                return this.fetch(options).then(function getContents(history) {\n                    self.contents.history = self;\n                    self.contents.setHistoryId(history.id);\n                    return self.fetchContents(contentsOptions);\n                });\n            },\n\n            /** fetch this histories contents, adjusting options based on the stored history preferences */\n            fetchContents: function(options) {\n                options = options || {};\n                var self = this;\n\n                // we're updating, reset the update time\n                self.lastUpdateTime = new Date();\n                return self.contents.fetchCurrentPage(options);\n            },\n\n            /** save this history, _Mark_ing it as deleted (just a flag) */\n            _delete: function(options) {\n                if (this.get(\"deleted\")) {\n                    return jQuery.when();\n                }\n                return this.save({ deleted: true }, options);\n            },\n            /** purge this history, _Mark_ing it as purged and removing all dataset data from the server */\n            purge: function(options) {\n                if (this.get(\"purged\")) {\n                    return jQuery.when();\n                }\n                return this.save({ deleted: true, purged: true }, options);\n            },\n            /** save this history, _Mark_ing it as undeleted */\n            undelete: function(options) {\n                if (!this.get(\"deleted\")) {\n                    return jQuery.when();\n                }\n                return this.save({ deleted: false }, options);\n            },\n\n            /** Make a copy of this history on the server\n     *  @param {Boolean} current    if true, set the copy as the new current history (default: true)\n     *  @param {String} name        name of new history (default: none - server sets to: Copy of <current name>)\n     *  @fires copied               passed this history and the response JSON from the copy\n     *  @returns {xhr}\n     */\n            copy: function(current, name, allDatasets) {\n                current = current !== undefined ? current : true;\n                if (!this.id) {\n                    throw new Error(\n                        \"You must set the history ID before copying it.\"\n                    );\n                }\n\n                var postData = { history_id: this.id };\n                if (current) {\n                    postData.current = true;\n                }\n                if (name) {\n                    postData.name = name;\n                }\n                if (!allDatasets) {\n                    postData.all_datasets = false;\n                }\n                postData.view = \"dev-detailed\";\n\n                var history = this;\n                var copy = jQuery.post(this.urlRoot, postData);\n                // if current - queue to setAsCurrent before firing 'copied'\n                if (current) {\n                    return copy.then(function(response) {\n                        var newHistory = new History(response);\n                        return newHistory.setAsCurrent().done(function() {\n                            history.trigger(\"copied\", history, response);\n                        });\n                    });\n                }\n                return copy.done(function(response) {\n                    history.trigger(\"copied\", history, response);\n                });\n            },\n\n            setAsCurrent: function() {\n                var history = this,\n                    xhr = jQuery.getJSON(\n                        Galaxy.root + \"history/set_as_current?id=\" + this.id\n                    );\n\n                xhr.done(function() {\n                    history.trigger(\"set-as-current\", history);\n                });\n                return xhr;\n            },\n\n            // ........................................................................ misc\n            toString: function() {\n                return (\n                    \"History(\" + this.get(\"id\") + \",\" + this.get(\"name\") + \")\"\n                );\n            }\n        }\n    )\n);\n\n//==============================================================================\nvar _collectionSuper =\n    CONTROLLED_FETCH_COLLECTION.InfinitelyScrollingCollection;\n/** @class A collection of histories (per user)\n *      that maintains the current history as the first in the collection.\n *  New or copied histories become the current history.\n */\nvar HistoryCollection = _collectionSuper.extend(BASE_MVC.LoggableMixin).extend({\n    _logNamespace: \"history\",\n\n    model: History,\n    /** @type {String} initial order used by collection */\n    order: \"update_time\",\n    /** @type {Number} limit used for the first fetch (or a reset) */\n    limitOnFirstFetch: 10,\n    /** @type {Number} limit used for each subsequent fetch */\n    limitPerFetch: 10,\n\n    initialize: function(models, options) {\n        options = options || {};\n        this.log(\"HistoryCollection.initialize\", models, options);\n        _collectionSuper.prototype.initialize.call(this, models, options);\n\n        /** @type {boolean} should deleted histories be included */\n        this.includeDeleted = options.includeDeleted || false;\n\n        /** @type {String} encoded id of the history that's current */\n        this.currentHistoryId = options.currentHistoryId;\n\n        this.setUpListeners();\n        // note: models are sent to reset *after* this fn ends; up to this point\n        // the collection *is empty*\n    },\n\n    urlRoot: Galaxy.root + \"api/histories\",\n    url: function() {\n        return this.urlRoot;\n    },\n\n    /** set up reflexive event handlers */\n    setUpListeners: function setUpListeners() {\n        return this.on({\n            // when a history is deleted, remove it from the collection (if optionally set to do so)\n            \"change:deleted\": function(history) {\n                // TODO: this becomes complicated when more filters are used\n                this.debug(\n                    \"change:deleted\",\n                    this.includeDeleted,\n                    history.get(\"deleted\")\n                );\n                if (!this.includeDeleted && history.get(\"deleted\")) {\n                    this.remove(history);\n                }\n            },\n            // listen for a history copy, setting it to current\n            copied: function(original, newData) {\n                this.setCurrent(new History(newData, []));\n            },\n            // when a history is made current, track the id in the collection\n            \"set-as-current\": function(history) {\n                var oldCurrentId = this.currentHistoryId;\n                this.trigger(\"no-longer-current\", oldCurrentId);\n                this.currentHistoryId = history.id;\n            }\n        });\n    },\n\n    /** override to change view */\n    _buildFetchData: function(options) {\n        return _.extend(\n            _collectionSuper.prototype._buildFetchData.call(this, options),\n            {\n                view: \"dev-detailed\"\n            }\n        );\n    },\n\n    /** override to filter out deleted and purged */\n    _buildFetchFilters: function(options) {\n        var superFilters =\n            _collectionSuper.prototype._buildFetchFilters.call(this, options) ||\n            {};\n        var filters = {};\n        if (!this.includeDeleted) {\n            filters.deleted = false;\n            filters.purged = false;\n        } else {\n            // force API to return both deleted and non\n            //TODO: when the API is updated, remove this\n            filters.deleted = null;\n        }\n        return _.defaults(superFilters, filters);\n    },\n\n    /** override to fetch current as well (as it may be outside the first 10, etc.) */\n    fetchFirst: function(options) {\n        var self = this;\n        // TODO: batch?\n        var xhr = $.when();\n        if (this.currentHistoryId) {\n            xhr = _collectionSuper.prototype.fetchFirst.call(self, {\n                silent: true,\n                limit: 1,\n                filters: {\n                    // without these a deleted current history will return [] here and block the other xhr\n                    purged: \"\",\n                    deleted: \"\",\n                    \"encoded_id-in\": this.currentHistoryId\n                }\n            });\n        }\n        return xhr.then(function() {\n            options = options || {};\n            options.offset = 0;\n            return self.fetchMore(options);\n        });\n    },\n\n    /** @type {Object} map of collection available sorting orders containing comparator fns */\n    comparators: _.extend(_.clone(_collectionSuper.prototype.comparators), {\n        name: BASE_MVC.buildComparator(\"name\", {\n            ascending: true\n        }),\n        \"name-dsc\": BASE_MVC.buildComparator(\"name\", {\n            ascending: false\n        }),\n        size: BASE_MVC.buildComparator(\"size\", {\n            ascending: false\n        }),\n        \"size-asc\": BASE_MVC.buildComparator(\"size\", {\n            ascending: true\n        })\n    }),\n\n    /** override to always have the current history first */\n    sort: function(options) {\n        options = options || {};\n        var silent = options.silent;\n        var currentHistory = this.remove(this.get(this.currentHistoryId));\n        _collectionSuper.prototype.sort.call(\n            this,\n            _.defaults({ silent: true }, options)\n        );\n        this.unshift(currentHistory, { silent: true });\n        if (!silent) {\n            this.trigger(\"sort\", this, options);\n        }\n        return this;\n    },\n\n    /** create a new history and by default set it to be the current history */\n    create: function create(data, hdas, historyOptions, xhrOptions) {\n        //TODO: .create is actually a collection function that's overridden here\n        var collection = this,\n            xhr = jQuery.getJSON(Galaxy.root + \"history/create_new_current\");\n        return xhr.done(function(newData) {\n            collection.setCurrent(\n                new History(newData, [], historyOptions || {})\n            );\n        });\n    },\n\n    /** set the current history to the given history, placing it first in the collection.\n     *  Pass standard bbone options for use in unshift.\n     *  @triggers new-current passed history and this collection\n     */\n    setCurrent: function(history, options) {\n        options = options || {};\n        // new histories go in the front\n        this.unshift(history, options);\n        this.currentHistoryId = history.get(\"id\");\n        if (!options.silent) {\n            this.trigger(\"new-current\", history, this);\n        }\n        return this;\n    },\n\n    toString: function toString() {\n        return (\n            \"HistoryCollection(\" +\n            this.length +\n            \",current:\" +\n            this.currentHistoryId +\n            \")\"\n        );\n    }\n});\n\n//==============================================================================\nexport default {\n    History: History,\n    HistoryCollection: HistoryCollection\n};\n"]}