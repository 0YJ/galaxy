{"version":3,"sources":["mvc/history/history-model.js"],"names":["define","HISTORY_CONTENTS","HISTORY_PREFS","CONTROLLED_FETCH_COLLECTION","UTILS","BASE_MVC","_l","UPDATE_DELAY","Model","extend","LoggableMixin","mixin","SearchableModelMixin","defaults","name","deleted","contents_active","contents_states","state","contentsClass","urlRoot","Galaxy","root","searchAliases","HistoryContents","searchAttributes","title","initialize","historyId","historyJSON","options","order","this","logger","log","contents","history","updateTimeoutId","_setUpListeners","_setUpCollectionListeners","on","error","model","xhr","msg","details","clearUpdateTimeout","change:id","newId","listenTo","trigger","apply","jQuery","makeArray","arguments","contentsShown","contentsActive","get","shown","active","nice_size","includeDeleted","size","includeHidden","hidden","toJSON","_","Backbone","bytesToString","prototype","call","key","ownedByCurrUser","user","isAnonymous","id","numOfUnfinishedShownContents","unfinishedJobIds","runningAndActive","length","contentRelatedAttrs","keys","refresh","$","param","join","lastUpdateTime","self","fetchFn","allFetched","currentPage","serverResponseDatetime","fetchPage","fetchUpdated","Date","getResponseHeader","err","checkForUpdates","setTimeout","delay","_delayThenUpdate","_fetchContentRelatedAttributes","done","historyData","numOfUnfinishedJobs","clearTimeout","parse","response","parsed","update_time","create_time","fetchWithContents","contentsOptions","view","fetch","then","fetchContents","setHistoryId","_delete","purge","when","save","purged","undelete","copy","current","allDatasets","Error","postData","history_id","all_datasets","post","newHistory","History","setAsCurrent","getJSON","toString","_collectionSuper","InfinitelyScrollingCollection","HistoryCollection","limitOnFirstFetch","limitPerFetch","models","currentHistoryId","setUpListeners","url","change:deleted","debug","remove","copied","original","setCurrent","set-as-current","oldCurrentId","_buildFetchData","_buildFetchFilters","superFilters","filters","fetchFirst","silent","limit","encoded_id-in","offset","fetchMore","comparators","buildComparator","ascending","name-dsc","size-asc","sort","currentHistory","unshift","create","hdas","historyOptions","xhrOptions","collection","newData"],"mappings":"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","file":"../../../scripts/mvc/history/history-model.js","sourcesContent":["define([\n    \"mvc/history/history-contents\",\n    \"mvc/history/history-preferences\",\n    \"mvc/base/controlled-fetch-collection\",\n    \"utils/utils\",\n    \"mvc/base-mvc\",\n    \"utils/localization\"\n], function( HISTORY_CONTENTS, HISTORY_PREFS, CONTROLLED_FETCH_COLLECTION, UTILS, BASE_MVC, _l ){\n'use strict';\n\n//==============================================================================\n/** @class Model for a Galaxy history resource - both a record of user\n *      tool use and a collection of the datasets those tools produced.\n *  @name History\n *  @augments Backbone.Model\n */\nvar History = Backbone.Model\n        .extend( BASE_MVC.LoggableMixin )\n        .extend( BASE_MVC.mixin( BASE_MVC.SearchableModelMixin, /** @lends History.prototype */{\n    _logNamespace : 'history',\n\n    /** ms between fetches when checking running jobs/datasets for updates */\n    UPDATE_DELAY : 4000,\n\n    // values from api (may need more)\n    defaults : {\n        model_class     : 'History',\n        id              : null,\n        name            : 'Unnamed History',\n        state           : 'new',\n\n        deleted         : false,\n        contents_active : {},\n        contents_states : {},\n    },\n\n    urlRoot: Galaxy.root + 'api/histories',\n\n    contentsClass : HISTORY_CONTENTS.HistoryContents,\n\n    /** What model fields to search with */\n    searchAttributes : [\n        'name', 'annotation', 'tags'\n    ],\n\n    /** Adding title and singular tag */\n    searchAliases : {\n        title       : 'name',\n        tag         : 'tags'\n    },\n\n    // ........................................................................ set up/tear down\n    /** Set up the model\n     *  @param {Object} historyJSON model data for this History\n     *  @param {Object} options     any extra settings including logger\n     */\n    initialize : function( historyJSON, options ){\n        options = options || {};\n        this.logger = options.logger || null;\n        this.log( this + \".initialize:\", historyJSON, options );\n\n        /** HistoryContents collection of the HDAs contained in this history. */\n        this.contents = new this.contentsClass( [], {\n            history     : this,\n            historyId   : this.get( 'id' ),\n            order       : options.order,\n        });\n\n        this._setUpListeners();\n        this._setUpCollectionListeners();\n\n        /** cached timeout id for the dataset updater */\n        this.updateTimeoutId = null;\n    },\n\n    /** set up any event listeners for this history including those to the contained HDAs\n     *  events: error:contents  if an error occurred with the contents collection\n     */\n    _setUpListeners : function(){\n        // if the model's id changes ('current' or null -> an actual id), update the contents history_id\n        return this.on({\n            'error' : function( model, xhr, options, msg, details ){\n                this.clearUpdateTimeout();\n            },\n            'change:id' : function( model, newId ){\n                if( this.contents ){\n                    this.contents.historyId = newId;\n                }\n            },\n        });\n    },\n\n    /** event handlers for the contents submodels */\n    _setUpCollectionListeners : function(){\n        if( !this.contents ){ return this; }\n        // bubble up errors\n        return this.listenTo( this.contents, {\n            'error' : function(){\n                this.trigger.apply( this, jQuery.makeArray( arguments ) );\n            },\n        });\n    },\n\n    // ........................................................................ derived attributes\n    /**  */\n    contentsShown : function(){\n        var contentsActive = this.get( 'contents_active' );\n        var shown = contentsActive.active || 0;\n        shown += this.contents.includeDeleted? contentsActive.deleted : 0;\n        shown += this.contents.includeHidden?  contentsActive.hidden  : 0;\n        return shown;\n    },\n\n    /** convert size in bytes to a more human readable version */\n    nice_size : function(){\n        var size = this.get( 'size' );\n        return size? UTILS.bytesToString( size, true, 2 ) : _l( '(empty)' );\n    },\n\n    /** override to add nice_size */\n    toJSON : function(){\n        return _.extend( Backbone.Model.prototype.toJSON.call( this ), {\n            nice_size : this.nice_size()\n        });\n    },\n\n    /** override to allow getting nice_size */\n    get : function( key ){\n        if( key === 'nice_size' ){\n            return this.nice_size();\n        }\n        return Backbone.Model.prototype.get.apply( this, arguments );\n    },\n\n    // ........................................................................ common queries\n    /** T/F is this history owned by the current user (Galaxy.user)\n     *      Note: that this will return false for an anon user even if the history is theirs.\n     */\n    ownedByCurrUser : function(){\n        // no currUser\n        if( !Galaxy || !Galaxy.user ){\n            return false;\n        }\n        // user is anon or history isn't owned\n        if( Galaxy.user.isAnonymous() || Galaxy.user.id !== this.get( 'user_id' ) ){\n            return false;\n        }\n        return true;\n    },\n\n    /** Return the number of running jobs assoc with this history (note: unknown === 0) */\n    numOfUnfinishedJobs : function(){\n        var unfinishedJobIds = this.get( 'non_ready_jobs' );\n        return unfinishedJobIds? unfinishedJobIds.length : 0;\n    },\n\n    /** Return the number of running hda/hdcas in this history (note: unknown === 0) */\n    numOfUnfinishedShownContents : function(){\n        return this.contents.runningAndActive().length || 0;\n    },\n\n    // ........................................................................ updates\n    _fetchContentRelatedAttributes : function(){\n        var contentRelatedAttrs = [ 'size', 'non_ready_jobs', 'contents_active', 'hid_counter' ];\n        return this.fetch({ data : $.param({ keys : contentRelatedAttrs.join( ',' ) }) });\n    },\n\n    /** check for any changes since the last time we updated (or fetch all if ) */\n    refresh : function( options ){\n        // console.log( this + '.refresh' );\n        options = options || {};\n        var self = this;\n\n        // note if there was no previous update time, all summary contents will be fetched\n        var lastUpdateTime = self.lastUpdateTime;\n        // if we don't flip this, then a fully-fetched list will not be re-checked via fetch\n        this.contents.allFetched = false;\n        var fetchFn = self.contents.currentPage !== 0\n            ? function(){ return self.contents.fetchPage( self.contents.currentPage ); }\n            : function(){ return self.contents.fetchUpdated( lastUpdateTime ); };\n        // note: if there was no previous update time, all summary contents will be fetched\n        return fetchFn()\n            .done( function( response, status, xhr ){\n                var serverResponseDatetime;\n                try {\n                    serverResponseDatetime = new Date( xhr.getResponseHeader( 'Date' ) );\n                } catch( err ){}\n                self.lastUpdateTime = serverResponseDatetime || new Date();\n                self.checkForUpdates( options );\n            });\n    },\n\n    /** continuously fetch updated contents every UPDATE_DELAY ms if this history's datasets or jobs are unfinished */\n    checkForUpdates : function( options ){\n        // console.log( this + '.checkForUpdates' );\n        options = options || {};\n        var delay = this.UPDATE_DELAY;\n        var self = this;\n        if( !self.id ){ return; }\n\n        function _delayThenUpdate(){\n            // prevent buildup of updater timeouts by clearing previous if any, then set new and cache id\n            self.clearUpdateTimeout();\n            self.updateTimeoutId = setTimeout( function(){\n                self.refresh( options );\n            }, delay );\n        }\n\n        // if there are still datasets in the non-ready state, recurse into this function with the new time\n        var nonReadyContentCount = this.numOfUnfinishedShownContents();\n        // console.log( 'nonReadyContentCount:', nonReadyContentCount );\n        if( nonReadyContentCount > 0 ){\n            _delayThenUpdate();\n\n        } else {\n            // no datasets are running, but currently runnning jobs may still produce new datasets\n            // see if the history has any running jobs and continue to update if so\n            // (also update the size for the user in either case)\n            self._fetchContentRelatedAttributes()\n                .done( function( historyData ){\n                    // console.log( 'non_ready_jobs:', historyData.non_ready_jobs );\n                    if( self.numOfUnfinishedJobs() > 0 ){\n                        _delayThenUpdate();\n\n                    } else {\n                        // otherwise, let listeners know that all updates have stopped\n                        self.trigger( 'ready' );\n                    }\n                });\n        }\n    },\n\n    /** clear the timeout and the cached timeout id */\n    clearUpdateTimeout : function(){\n        if( this.updateTimeoutId ){\n            clearTimeout( this.updateTimeoutId );\n            this.updateTimeoutId = null;\n        }\n    },\n\n    // ........................................................................ ajax\n    /** override to use actual Dates objects for create/update times */\n    parse : function( response, options ){\n        var parsed = Backbone.Model.prototype.parse.call( this, response, options );\n        if( parsed.create_time ){\n            parsed.create_time = new Date( parsed.create_time );\n        }\n        if( parsed.update_time ){\n            parsed.update_time = new Date( parsed.update_time );\n        }\n        return parsed;\n    },\n\n    /** fetch this histories data (using options) then it's contents (using contentsOptions) */\n    fetchWithContents : function( options, contentsOptions ){\n        options = options || {};\n        var self = this;\n\n        // console.log( this + '.fetchWithContents' );\n        // TODO: push down to a base class\n        options.view = 'dev-detailed';\n\n        // fetch history then use history data to fetch (paginated) contents\n        return this.fetch( options ).then( function getContents( history ){\n            self.contents.history = self;\n            self.contents.setHistoryId( history.id );\n            return self.fetchContents( contentsOptions );\n        });\n    },\n\n    /** fetch this histories contents, adjusting options based on the stored history preferences */\n    fetchContents : function( options ){\n        options = options || {};\n        var self = this;\n\n        // we're updating, reset the update time\n        self.lastUpdateTime = new Date();\n        return self.contents.fetchCurrentPage( options );\n    },\n\n    /** save this history, _Mark_ing it as deleted (just a flag) */\n    _delete : function( options ){\n        if( this.get( 'deleted' ) ){ return jQuery.when(); }\n        return this.save( { deleted: true }, options );\n    },\n    /** purge this history, _Mark_ing it as purged and removing all dataset data from the server */\n    purge : function( options ){\n        if( this.get( 'purged' ) ){ return jQuery.when(); }\n        return this.save( { deleted: true, purged: true }, options );\n    },\n    /** save this history, _Mark_ing it as undeleted */\n    undelete : function( options ){\n        if( !this.get( 'deleted' ) ){ return jQuery.when(); }\n        return this.save( { deleted: false }, options );\n    },\n\n    /** Make a copy of this history on the server\n     *  @param {Boolean} current    if true, set the copy as the new current history (default: true)\n     *  @param {String} name        name of new history (default: none - server sets to: Copy of <current name>)\n     *  @fires copied               passed this history and the response JSON from the copy\n     *  @returns {xhr}\n     */\n    copy : function( current, name, allDatasets ){\n        current = ( current !== undefined )?( current ):( true );\n        if( !this.id ){\n            throw new Error( 'You must set the history ID before copying it.' );\n        }\n\n        var postData = { history_id  : this.id };\n        if( current ){\n            postData.current = true;\n        }\n        if( name ){\n            postData.name = name;\n        }\n        if( !allDatasets ){\n            postData.all_datasets = false;\n        }\n        postData.view = 'dev-detailed';\n\n        var history = this;\n        var copy = jQuery.post( this.urlRoot, postData );\n        // if current - queue to setAsCurrent before firing 'copied'\n        if( current ){\n            return copy.then( function( response ){\n                var newHistory = new History( response );\n                return newHistory.setAsCurrent()\n                    .done( function(){\n                        history.trigger( 'copied', history, response );\n                    });\n            });\n        }\n        return copy.done( function( response ){\n            history.trigger( 'copied', history, response );\n        });\n    },\n\n    setAsCurrent : function(){\n        var history = this,\n            xhr = jQuery.getJSON( Galaxy.root + 'history/set_as_current?id=' + this.id );\n\n        xhr.done( function(){\n            history.trigger( 'set-as-current', history );\n        });\n        return xhr;\n    },\n\n    // ........................................................................ misc\n    toString : function(){\n        return 'History(' + this.get( 'id' ) + ',' + this.get( 'name' ) + ')';\n    }\n}));\n\n\n//==============================================================================\nvar _collectionSuper = CONTROLLED_FETCH_COLLECTION.InfinitelyScrollingCollection;\n/** @class A collection of histories (per user)\n *      that maintains the current history as the first in the collection.\n *  New or copied histories become the current history.\n */\nvar HistoryCollection = _collectionSuper.extend( BASE_MVC.LoggableMixin ).extend({\n    _logNamespace       : 'history',\n\n    model               : History,\n    /** @type {String} initial order used by collection */\n    order               : 'update_time',\n    /** @type {Number} limit used for the first fetch (or a reset) */\n    limitOnFirstFetch   : 10,\n    /** @type {Number} limit used for each subsequent fetch */\n    limitPerFetch       : 10,\n\n    initialize : function( models, options ){\n        options = options || {};\n        this.log( 'HistoryCollection.initialize', models, options );\n        _collectionSuper.prototype.initialize.call( this, models, options );\n\n        /** @type {boolean} should deleted histories be included */\n        this.includeDeleted = options.includeDeleted || false;\n\n        /** @type {String} encoded id of the history that's current */\n        this.currentHistoryId = options.currentHistoryId;\n\n        this.setUpListeners();\n        // note: models are sent to reset *after* this fn ends; up to this point\n        // the collection *is empty*\n    },\n\n    urlRoot : Galaxy.root + 'api/histories',\n    url     : function(){ return this.urlRoot; },\n\n    /** set up reflexive event handlers */\n    setUpListeners : function setUpListeners(){\n        return this.on({\n            // when a history is deleted, remove it from the collection (if optionally set to do so)\n            'change:deleted' : function( history ){\n                // TODO: this becomes complicated when more filters are used\n                this.debug( 'change:deleted', this.includeDeleted, history.get( 'deleted' ) );\n                if( !this.includeDeleted && history.get( 'deleted' ) ){\n                    this.remove( history );\n                }\n            },\n            // listen for a history copy, setting it to current\n            'copied' : function( original, newData ){\n                this.setCurrent( new History( newData, [] ) );\n            },\n            // when a history is made current, track the id in the collection\n            'set-as-current' : function( history ){\n                var oldCurrentId = this.currentHistoryId;\n                this.trigger( 'no-longer-current', oldCurrentId );\n                this.currentHistoryId = history.id;\n            }\n        });\n    },\n\n    /** override to change view */\n    _buildFetchData : function( options ){\n        return _.extend( _collectionSuper.prototype._buildFetchData.call( this, options ), {\n            view : 'dev-detailed'\n        });\n    },\n\n    /** override to filter out deleted and purged */\n    _buildFetchFilters : function( options ){\n        var superFilters = _collectionSuper.prototype._buildFetchFilters.call( this, options ) || {};\n        var filters = {};\n        if( !this.includeDeleted ){\n            filters.deleted = false;\n            filters.purged = false;\n        } else {\n            // force API to return both deleted and non\n            //TODO: when the API is updated, remove this\n            filters.deleted = null;\n        }\n        return _.defaults( superFilters, filters );\n    },\n\n    /** override to fetch current as well (as it may be outside the first 10, etc.) */\n    fetchFirst : function( options ){\n        var self = this;\n        // TODO: batch?\n        var xhr = $.when();\n        if( this.currentHistoryId ){\n            xhr = _collectionSuper.prototype.fetchFirst.call( self, {\n                silent: true,\n                limit : 1,\n                filters: {\n                    // without these a deleted current history will return [] here and block the other xhr\n                    'purged'        : '',\n                    'deleted'       : '',\n                    'encoded_id-in' : this.currentHistoryId,\n                }\n            });\n        }\n        return xhr.then( function(){\n            options = options || {};\n            options.offset = 0;\n            return self.fetchMore( options );\n        });\n    },\n\n    /** @type {Object} map of collection available sorting orders containing comparator fns */\n    comparators : _.extend( _.clone( _collectionSuper.prototype.comparators ), {\n        'name'       : BASE_MVC.buildComparator( 'name', { ascending: true }),\n        'name-dsc'   : BASE_MVC.buildComparator( 'name', { ascending: false }),\n        'size'       : BASE_MVC.buildComparator( 'size', { ascending: false }),\n        'size-asc'   : BASE_MVC.buildComparator( 'size', { ascending: true }),\n    }),\n\n    /** override to always have the current history first */\n    sort : function( options ){\n        options = options || {};\n        var silent = options.silent;\n        var currentHistory = this.remove( this.get( this.currentHistoryId ) );\n        _collectionSuper.prototype.sort.call( this, _.defaults({ silent: true }, options ) );\n        this.unshift( currentHistory, { silent: true });\n        if( !silent ){\n            this.trigger( 'sort', this, options );\n        }\n        return this;\n    },\n\n    /** create a new history and by default set it to be the current history */\n    create : function create( data, hdas, historyOptions, xhrOptions ){\n        //TODO: .create is actually a collection function that's overridden here\n        var collection = this,\n            xhr = jQuery.getJSON( Galaxy.root + 'history/create_new_current'  );\n        return xhr.done( function( newData ){\n            collection.setCurrent( new History( newData, [], historyOptions || {} ) );\n        });\n    },\n\n    /** set the current history to the given history, placing it first in the collection.\n     *  Pass standard bbone options for use in unshift.\n     *  @triggers new-current passed history and this collection\n     */\n    setCurrent : function( history, options ){\n        options = options || {};\n        // new histories go in the front\n        this.unshift( history, options );\n        this.currentHistoryId = history.get( 'id' );\n        if( !options.silent ){\n            this.trigger( 'new-current', history, this );\n        }\n        return this;\n    },\n\n    toString: function toString(){\n        return 'HistoryCollection(' + this.length + ',current:' + this.currentHistoryId + ')';\n    }\n});\n\n\n//==============================================================================\nreturn {\n    History           : History,\n    HistoryCollection : HistoryCollection\n};});\n"]}