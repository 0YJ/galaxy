{"version":3,"sources":["mvc/history/history-model.js"],"names":["History","Backbone","Model","extend","_baseMvc2","default","LoggableMixin","mixin","SearchableModelMixin","_logNamespace","UPDATE_DELAY","defaults","model_class","id","name","state","deleted","contents_active","urlRoot","Galaxy","root","_historyContents2","HistoryContents","tag","contentsClass","historyJSON","options","this","logger","searchAttributes","searchAliases","history","historyId","get","order","_setUpListeners","_setUpCollectionListeners","initialize","updateTimeoutId","on","clearUpdateTimeout","model","newId","contents","error","trigger","apply","arguments","contentsShown","contentsActive","active","shown","includeDeleted","includeHidden","hidden","nice_size","size","bytesToString","toJSON","_","prototype","call","key","ownedByCurrUser","user","isAnonymous","numOfUnfinishedJobs","unfinishedJobIds","length","numOfUnfinishedShownContents","runningAndActive","_fetchContentRelatedAttributes","contentRelatedAttrs","fetch","join","refresh","self","lastUpdateTime","allFetched","fetchPage","currentPage","fetchUpdated","done","response","status","xhr","serverResponseDatetime","fetchFn","Date","getResponseHeader","err","checkForUpdates","_delayThenUpdate","setTimeout","delay","historyData","clearTimeout","parse","parsed","fetchWithContents","update_time","create_time","contentsOptions","view","then","setHistoryId","fetchContents","_delete","jQuery","when","save","purge","purged","undelete","copy","current","allDatasets","postData","undefined","Error","history_id","all_datasets","newHistory","getJSON","toString","limitOnFirstFetch","_controlledFetchCollection2","InfinitelyScrollingCollection","HistoryCollection","_collectionSuper","models","currentHistoryId","limitPerFetch","setUpListeners","log","url","change:deleted","oldCurrentId","debug","_buildFetchData","remove","copied","original","newData","setCurrent","set-as-current","superFilters","filters","silent","limit","_buildFetchFilters","offset","fetchFirst","$","ascending","encoded_id-in","buildComparator","sort","comparators","clone","name-dsc","create","hdas","size-asc","currentHistory","unshift","historyOptions","xhrOptions","collection"],"mappings":"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","file":"../../../scripts/mvc/history/history-model.js","sourcesContent":["import HISTORY_CONTENTS from \"mvc/history/history-contents\";\nimport HISTORY_PREFS from \"mvc/history/history-preferences\";\nimport CONTROLLED_FETCH_COLLECTION from \"mvc/base/controlled-fetch-collection\";\nimport UTILS from \"utils/utils\";\nimport BASE_MVC from \"mvc/base-mvc\";\nimport _l from \"utils/localization\";\n\n//==============================================================================\n/** @class Model for a Galaxy history resource - both a record of user\n *      tool use and a collection of the datasets those tools produced.\n *  @name History\n *  @augments Backbone.Model\n */\nvar History = Backbone.Model.extend(BASE_MVC.LoggableMixin).extend(\n    BASE_MVC.mixin(\n        BASE_MVC.SearchableModelMixin,\n        /** @lends History.prototype */ {\n            _logNamespace: \"history\",\n\n            /** ms between fetches when checking running jobs/datasets for updates */\n            UPDATE_DELAY: 4000,\n\n            // values from api (may need more)\n            defaults: {\n                model_class: \"History\",\n                id: null,\n                name: \"Unnamed History\",\n                state: \"new\",\n\n                deleted: false,\n                contents_active: {},\n                contents_states: {}\n            },\n\n            urlRoot: Galaxy.root + \"api/histories\",\n\n            contentsClass: HISTORY_CONTENTS.HistoryContents,\n\n            /** What model fields to search with */\n            searchAttributes: [\"name\", \"annotation\", \"tags\"],\n\n            /** Adding title and singular tag */\n            searchAliases: {\n                title: \"name\",\n                tag: \"tags\"\n            },\n\n            // ........................................................................ set up/tear down\n            /** Set up the model\n     *  @param {Object} historyJSON model data for this History\n     *  @param {Object} options     any extra settings including logger\n     */\n            initialize: function(historyJSON, options) {\n                options = options || {};\n                this.logger = options.logger || null;\n                this.log(this + \".initialize:\", historyJSON, options);\n\n                /** HistoryContents collection of the HDAs contained in this history. */\n                this.contents = new this.contentsClass([], {\n                    history: this,\n                    historyId: this.get(\"id\"),\n                    order: options.order\n                });\n\n                this._setUpListeners();\n                this._setUpCollectionListeners();\n\n                /** cached timeout id for the dataset updater */\n                this.updateTimeoutId = null;\n            },\n\n            /** set up any event listeners for this history including those to the contained HDAs\n     *  events: error:contents  if an error occurred with the contents collection\n     */\n            _setUpListeners: function() {\n                // if the model's id changes ('current' or null -> an actual id), update the contents history_id\n                return this.on({\n                    error: function(model, xhr, options, msg, details) {\n                        this.clearUpdateTimeout();\n                    },\n                    \"change:id\": function(model, newId) {\n                        if (this.contents) {\n                            this.contents.historyId = newId;\n                        }\n                    }\n                });\n            },\n\n            /** event handlers for the contents submodels */\n            _setUpCollectionListeners: function() {\n                if (!this.contents) {\n                    return this;\n                }\n                // bubble up errors\n                return this.listenTo(this.contents, {\n                    error: function() {\n                        this.trigger.apply(this, jQuery.makeArray(arguments));\n                    }\n                });\n            },\n\n            // ........................................................................ derived attributes\n            /**  */\n            contentsShown: function() {\n                var contentsActive = this.get(\"contents_active\");\n                var shown = contentsActive.active || 0;\n                shown += this.contents.includeDeleted\n                    ? contentsActive.deleted\n                    : 0;\n                shown += this.contents.includeHidden\n                    ? contentsActive.hidden\n                    : 0;\n                return shown;\n            },\n\n            /** convert size in bytes to a more human readable version */\n            nice_size: function() {\n                var size = this.get(\"size\");\n                return size\n                    ? UTILS.bytesToString(size, true, 2)\n                    : _l(\"(empty)\");\n            },\n\n            /** override to add nice_size */\n            toJSON: function() {\n                return _.extend(Backbone.Model.prototype.toJSON.call(this), {\n                    nice_size: this.nice_size()\n                });\n            },\n\n            /** override to allow getting nice_size */\n            get: function(key) {\n                if (key === \"nice_size\") {\n                    return this.nice_size();\n                }\n                return Backbone.Model.prototype.get.apply(this, arguments);\n            },\n\n            // ........................................................................ common queries\n            /** T/F is this history owned by the current user (Galaxy.user)\n     *      Note: that this will return false for an anon user even if the history is theirs.\n     */\n            ownedByCurrUser: function() {\n                // no currUser\n                if (!Galaxy || !Galaxy.user) {\n                    return false;\n                }\n                // user is anon or history isn't owned\n                if (\n                    Galaxy.user.isAnonymous() ||\n                    Galaxy.user.id !== this.get(\"user_id\")\n                ) {\n                    return false;\n                }\n                return true;\n            },\n\n            /** Return the number of running jobs assoc with this history (note: unknown === 0) */\n            numOfUnfinishedJobs: function() {\n                var unfinishedJobIds = this.get(\"non_ready_jobs\");\n                return unfinishedJobIds ? unfinishedJobIds.length : 0;\n            },\n\n            /** Return the number of running hda/hdcas in this history (note: unknown === 0) */\n            numOfUnfinishedShownContents: function() {\n                return this.contents.runningAndActive().length || 0;\n            },\n\n            // ........................................................................ updates\n            _fetchContentRelatedAttributes: function() {\n                var contentRelatedAttrs = [\n                    \"size\",\n                    \"non_ready_jobs\",\n                    \"contents_active\",\n                    \"hid_counter\"\n                ];\n                return this.fetch({\n                    data: $.param({\n                        keys: contentRelatedAttrs.join(\",\")\n                    })\n                });\n            },\n\n            /** check for any changes since the last time we updated (or fetch all if ) */\n            refresh: function(options) {\n                // console.log( this + '.refresh' );\n                options = options || {};\n                var self = this;\n\n                // note if there was no previous update time, all summary contents will be fetched\n                var lastUpdateTime = self.lastUpdateTime;\n                // if we don't flip this, then a fully-fetched list will not be re-checked via fetch\n                this.contents.allFetched = false;\n                var fetchFn =\n                    self.contents.currentPage !== 0\n                        ? () =>\n                              self.contents.fetchPage(self.contents.currentPage)\n                        : () => self.contents.fetchUpdated(lastUpdateTime);\n                // note: if there was no previous update time, all summary contents will be fetched\n                return fetchFn().done((response, status, xhr) => {\n                    var serverResponseDatetime;\n                    try {\n                        serverResponseDatetime = new Date(\n                            xhr.getResponseHeader(\"Date\")\n                        );\n                    } catch (err) {}\n                    self.lastUpdateTime = serverResponseDatetime || new Date();\n                    self.checkForUpdates(options);\n                });\n            },\n\n            /** continuously fetch updated contents every UPDATE_DELAY ms if this history's datasets or jobs are unfinished */\n            checkForUpdates: function(options) {\n                // console.log( this + '.checkForUpdates' );\n                options = options || {};\n                var delay = this.UPDATE_DELAY;\n                var self = this;\n                if (!self.id) {\n                    return;\n                }\n\n                function _delayThenUpdate() {\n                    // prevent buildup of updater timeouts by clearing previous if any, then set new and cache id\n                    self.clearUpdateTimeout();\n                    self.updateTimeoutId = setTimeout(() => {\n                        self.refresh(options);\n                    }, delay);\n                }\n\n                // if there are still datasets in the non-ready state, recurse into this function with the new time\n                var nonReadyContentCount = this.numOfUnfinishedShownContents();\n                // console.log( 'nonReadyContentCount:', nonReadyContentCount );\n                if (nonReadyContentCount > 0) {\n                    _delayThenUpdate();\n                } else {\n                    // no datasets are running, but currently runnning jobs may still produce new datasets\n                    // see if the history has any running jobs and continue to update if so\n                    // (also update the size for the user in either case)\n                    self._fetchContentRelatedAttributes().done(historyData => {\n                        // console.log( 'non_ready_jobs:', historyData.non_ready_jobs );\n                        if (self.numOfUnfinishedJobs() > 0) {\n                            _delayThenUpdate();\n                        } else {\n                            // otherwise, let listeners know that all updates have stopped\n                            self.trigger(\"ready\");\n                        }\n                    });\n                }\n            },\n\n            /** clear the timeout and the cached timeout id */\n            clearUpdateTimeout: function() {\n                if (this.updateTimeoutId) {\n                    clearTimeout(this.updateTimeoutId);\n                    this.updateTimeoutId = null;\n                }\n            },\n\n            // ........................................................................ ajax\n            /** override to use actual Dates objects for create/update times */\n            parse: function(response, options) {\n                var parsed = Backbone.Model.prototype.parse.call(\n                    this,\n                    response,\n                    options\n                );\n                if (parsed.create_time) {\n                    parsed.create_time = new Date(parsed.create_time);\n                }\n                if (parsed.update_time) {\n                    parsed.update_time = new Date(parsed.update_time);\n                }\n                return parsed;\n            },\n\n            /** fetch this histories data (using options) then it's contents (using contentsOptions) */\n            fetchWithContents: function(options, contentsOptions) {\n                options = options || {};\n                var self = this;\n\n                // console.log( this + '.fetchWithContents' );\n                // TODO: push down to a base class\n                options.view = \"dev-detailed\";\n\n                // fetch history then use history data to fetch (paginated) contents\n                return this.fetch(options).then(function getContents(history) {\n                    self.contents.history = self;\n                    self.contents.setHistoryId(history.id);\n                    return self.fetchContents(contentsOptions);\n                });\n            },\n\n            /** fetch this histories contents, adjusting options based on the stored history preferences */\n            fetchContents: function(options) {\n                options = options || {};\n                var self = this;\n\n                // we're updating, reset the update time\n                self.lastUpdateTime = new Date();\n                return self.contents.fetchCurrentPage(options);\n            },\n\n            /** save this history, _Mark_ing it as deleted (just a flag) */\n            _delete: function(options) {\n                if (this.get(\"deleted\")) {\n                    return jQuery.when();\n                }\n                return this.save({ deleted: true }, options);\n            },\n            /** purge this history, _Mark_ing it as purged and removing all dataset data from the server */\n            purge: function(options) {\n                if (this.get(\"purged\")) {\n                    return jQuery.when();\n                }\n                return this.save({ deleted: true, purged: true }, options);\n            },\n            /** save this history, _Mark_ing it as undeleted */\n            undelete: function(options) {\n                if (!this.get(\"deleted\")) {\n                    return jQuery.when();\n                }\n                return this.save({ deleted: false }, options);\n            },\n\n            /** Make a copy of this history on the server\n     *  @param {Boolean} current    if true, set the copy as the new current history (default: true)\n     *  @param {String} name        name of new history (default: none - server sets to: Copy of <current name>)\n     *  @fires copied               passed this history and the response JSON from the copy\n     *  @returns {xhr}\n     */\n            copy: function(current, name, allDatasets) {\n                current = current !== undefined ? current : true;\n                if (!this.id) {\n                    throw new Error(\n                        \"You must set the history ID before copying it.\"\n                    );\n                }\n\n                var postData = { history_id: this.id };\n                if (current) {\n                    postData.current = true;\n                }\n                if (name) {\n                    postData.name = name;\n                }\n                if (!allDatasets) {\n                    postData.all_datasets = false;\n                }\n                postData.view = \"dev-detailed\";\n\n                var history = this;\n                var copy = jQuery.post(this.urlRoot, postData);\n                // if current - queue to setAsCurrent before firing 'copied'\n                if (current) {\n                    return copy.then(response => {\n                        var newHistory = new History(response);\n                        return newHistory.setAsCurrent().done(() => {\n                            history.trigger(\"copied\", history, response);\n                        });\n                    });\n                }\n                return copy.done(response => {\n                    history.trigger(\"copied\", history, response);\n                });\n            },\n\n            setAsCurrent: function() {\n                var history = this;\n\n                var xhr = jQuery.getJSON(\n                    Galaxy.root + \"history/set_as_current?id=\" + this.id\n                );\n\n                xhr.done(() => {\n                    history.trigger(\"set-as-current\", history);\n                });\n                return xhr;\n            },\n\n            // ........................................................................ misc\n            toString: function() {\n                return (\n                    \"History(\" + this.get(\"id\") + \",\" + this.get(\"name\") + \")\"\n                );\n            }\n        }\n    )\n);\n\n//==============================================================================\nvar _collectionSuper =\n    CONTROLLED_FETCH_COLLECTION.InfinitelyScrollingCollection;\n/** @class A collection of histories (per user)\n *      that maintains the current history as the first in the collection.\n *  New or copied histories become the current history.\n */\nvar HistoryCollection = _collectionSuper.extend(BASE_MVC.LoggableMixin).extend({\n    _logNamespace: \"history\",\n\n    model: History,\n    /** @type {String} initial order used by collection */\n    order: \"update_time\",\n    /** @type {Number} limit used for the first fetch (or a reset) */\n    limitOnFirstFetch: 10,\n    /** @type {Number} limit used for each subsequent fetch */\n    limitPerFetch: 10,\n\n    initialize: function(models, options) {\n        options = options || {};\n        this.log(\"HistoryCollection.initialize\", models, options);\n        _collectionSuper.prototype.initialize.call(this, models, options);\n\n        /** @type {boolean} should deleted histories be included */\n        this.includeDeleted = options.includeDeleted || false;\n\n        /** @type {String} encoded id of the history that's current */\n        this.currentHistoryId = options.currentHistoryId;\n\n        this.setUpListeners();\n        // note: models are sent to reset *after* this fn ends; up to this point\n        // the collection *is empty*\n    },\n\n    urlRoot: Galaxy.root + \"api/histories\",\n    url: function() {\n        return this.urlRoot;\n    },\n\n    /** set up reflexive event handlers */\n    setUpListeners: function setUpListeners() {\n        return this.on({\n            // when a history is deleted, remove it from the collection (if optionally set to do so)\n            \"change:deleted\": function(history) {\n                // TODO: this becomes complicated when more filters are used\n                this.debug(\n                    \"change:deleted\",\n                    this.includeDeleted,\n                    history.get(\"deleted\")\n                );\n                if (!this.includeDeleted && history.get(\"deleted\")) {\n                    this.remove(history);\n                }\n            },\n            // listen for a history copy, setting it to current\n            copied: function(original, newData) {\n                this.setCurrent(new History(newData, []));\n            },\n            // when a history is made current, track the id in the collection\n            \"set-as-current\": function(history) {\n                var oldCurrentId = this.currentHistoryId;\n                this.trigger(\"no-longer-current\", oldCurrentId);\n                this.currentHistoryId = history.id;\n            }\n        });\n    },\n\n    /** override to change view */\n    _buildFetchData: function(options) {\n        return _.extend(\n            _collectionSuper.prototype._buildFetchData.call(this, options),\n            {\n                view: \"dev-detailed\"\n            }\n        );\n    },\n\n    /** override to filter out deleted and purged */\n    _buildFetchFilters: function(options) {\n        var superFilters =\n            _collectionSuper.prototype._buildFetchFilters.call(this, options) ||\n            {};\n        var filters = {};\n        if (!this.includeDeleted) {\n            filters.deleted = false;\n            filters.purged = false;\n        } else {\n            // force API to return both deleted and non\n            //TODO: when the API is updated, remove this\n            filters.deleted = null;\n        }\n        return _.defaults(superFilters, filters);\n    },\n\n    /** override to fetch current as well (as it may be outside the first 10, etc.) */\n    fetchFirst: function(options) {\n        var self = this;\n        // TODO: batch?\n        var xhr = $.when();\n        if (this.currentHistoryId) {\n            xhr = _collectionSuper.prototype.fetchFirst.call(self, {\n                silent: true,\n                limit: 1,\n                filters: {\n                    // without these a deleted current history will return [] here and block the other xhr\n                    purged: \"\",\n                    deleted: \"\",\n                    \"encoded_id-in\": this.currentHistoryId\n                }\n            });\n        }\n        return xhr.then(() => {\n            options = options || {};\n            options.offset = 0;\n            return self.fetchMore(options);\n        });\n    },\n\n    /** @type {Object} map of collection available sorting orders containing comparator fns */\n    comparators: _.extend(_.clone(_collectionSuper.prototype.comparators), {\n        name: BASE_MVC.buildComparator(\"name\", {\n            ascending: true\n        }),\n        \"name-dsc\": BASE_MVC.buildComparator(\"name\", {\n            ascending: false\n        }),\n        size: BASE_MVC.buildComparator(\"size\", {\n            ascending: false\n        }),\n        \"size-asc\": BASE_MVC.buildComparator(\"size\", {\n            ascending: true\n        })\n    }),\n\n    /** override to always have the current history first */\n    sort: function(options) {\n        options = options || {};\n        var silent = options.silent;\n        var currentHistory = this.remove(this.get(this.currentHistoryId));\n        _collectionSuper.prototype.sort.call(\n            this,\n            _.defaults({ silent: true }, options)\n        );\n        this.unshift(currentHistory, { silent: true });\n        if (!silent) {\n            this.trigger(\"sort\", this, options);\n        }\n        return this;\n    },\n\n    /** create a new history and by default set it to be the current history */\n    create: function create(data, hdas, historyOptions, xhrOptions) {\n        //TODO: .create is actually a collection function that's overridden here\n        var collection = this;\n\n        var xhr = jQuery.getJSON(Galaxy.root + \"history/create_new_current\");\n        return xhr.done(newData => {\n            collection.setCurrent(\n                new History(newData, [], historyOptions || {})\n            );\n        });\n    },\n\n    /** set the current history to the given history, placing it first in the collection.\n     *  Pass standard bbone options for use in unshift.\n     *  @triggers new-current passed history and this collection\n     */\n    setCurrent: function(history, options) {\n        options = options || {};\n        // new histories go in the front\n        this.unshift(history, options);\n        this.currentHistoryId = history.get(\"id\");\n        if (!options.silent) {\n            this.trigger(\"new-current\", history, this);\n        }\n        return this;\n    },\n\n    toString: function toString() {\n        return (\n            \"HistoryCollection(\" +\n            this.length +\n            \",current:\" +\n            this.currentHistoryId +\n            \")\"\n        );\n    }\n});\n\n//==============================================================================\nexport default {\n    History: History,\n    HistoryCollection: HistoryCollection\n};\n"]}