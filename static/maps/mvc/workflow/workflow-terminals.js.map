{"version":3,"sources":["mvc/workflow/workflow-terminals.js"],"names":["CollectionTypeDescription","collectionType","this","isCollection","rank","split","length","window","workflow_globals","NULL_COLLECTION_TYPE_DESCRIPTION","canMatch","canMapOver","other","otherCollectionType","toString","ANY_COLLECTION_TYPE_DESCRIPTION","equal","$","extend","prototype","otherCollectionTypeDescription","requiredSuffix","effectiveMapOver","effectiveCollectionType","_endsWith","suffix","initialize","substring","terminal","setMapOver","str","mapOver","collectionTypeDescription","TerminalMapping","Backbone","Model","Terminal","attr","connectors","connect","disconnect","trigger","redraw","element","connector","push","destroy","node","each","markChanged","destroyInvalidConnections","_","resetMappingIfNeeded","c","output_terminals","outputTerminal","terminalMapping","val","multiple","resetMapping","OutputTerminal","datatypes","mappedInput","disableMapOver","noMappedInputs","call","connectedInput","hasConnectedOutputTerminals","mappedInputTerminals","attachable","destroyIfInvalid","BaseInputTerminal","update","input","canAccept","_inputFilled","hasConnectedMappedInputTerminals","inputFilled","hasMappedOverInputTerminals","connected","_collectionAttached","inputsFilled","constraints","handle1","firstOutput","isMappedOver","_mappingConstraints","cat_outputs","_otherCollectionType","first","values","other_datatype_i","inputTerminal","other_datatype","_producesAcceptableDatatype","t","otherMapOver","concat","post_job_actions","pja_i","InputTerminal","extensions","action_type","pja","output_name","name","action_arguments","thisMapOver","collection","other_output","InputCollectionTerminal","collection_types","collectionTypes","every","bind","collectionTypeIndex","effectiveCollectionTypes","_effectiveMapOver","some","collectionTypeSource","console","_effectiveCollectionTypes","collection_type","newCollectionType","map","append","OutputCollectionTerminal","collection_type_source","log","output"],"mappings":"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","file":"../../../scripts/mvc/workflow/workflow-terminals.js","sourcesContent":["// TODO; tie into Galaxy state?\nwindow.workflow_globals = window.workflow_globals || {};\nfunction CollectionTypeDescription(collectionType) {\n    this.collectionType = collectionType;\n    this.isCollection = true;\n    this.rank = collectionType.split(\":\").length;\n}\n\nvar NULL_COLLECTION_TYPE_DESCRIPTION = {\n    isCollection: false,\n    canMatch: function(other) {\n        return false;\n    },\n    canMapOver: function(other) {\n        return false;\n    },\n    toString: function() {\n        return \"NullCollectionType[]\";\n    },\n    append: function(otherCollectionType) {\n        return otherCollectionType;\n    },\n    equal: function(other) {\n        return other === this;\n    }\n};\n\nvar ANY_COLLECTION_TYPE_DESCRIPTION = {\n    isCollection: true,\n    canMatch: function(other) {\n        return NULL_COLLECTION_TYPE_DESCRIPTION !== other;\n    },\n    canMapOver: function(other) {\n        return false;\n    },\n    toString: function() {\n        return \"AnyCollectionType[]\";\n    },\n    append: function(otherCollectionType) {\n        throw \"Cannot append to ANY_COLLECTION_TYPE_DESCRIPTION\";\n    },\n    equal: function(other) {\n        return other === this;\n    }\n};\n\n$.extend(CollectionTypeDescription.prototype, {\n    append: function(otherCollectionTypeDescription) {\n        if (\n            otherCollectionTypeDescription === NULL_COLLECTION_TYPE_DESCRIPTION\n        ) {\n            return this;\n        }\n        if (\n            otherCollectionTypeDescription === ANY_COLLECTION_TYPE_DESCRIPTION\n        ) {\n            return otherCollectionType;\n        }\n        return new CollectionTypeDescription(\n            `${this\n                .collectionType}:${otherCollectionTypeDescription.collectionType}`\n        );\n    },\n    canMatch: function(otherCollectionTypeDescription) {\n        if (\n            otherCollectionTypeDescription === NULL_COLLECTION_TYPE_DESCRIPTION\n        ) {\n            return false;\n        }\n        if (\n            otherCollectionTypeDescription === ANY_COLLECTION_TYPE_DESCRIPTION\n        ) {\n            return true;\n        }\n        return (\n            otherCollectionTypeDescription.collectionType == this.collectionType\n        );\n    },\n    canMapOver: function(otherCollectionTypeDescription) {\n        if (\n            otherCollectionTypeDescription === NULL_COLLECTION_TYPE_DESCRIPTION\n        ) {\n            return false;\n        }\n        if (\n            otherCollectionTypeDescription === ANY_COLLECTION_TYPE_DESCRIPTION\n        ) {\n            return false;\n        }\n        if (this.rank <= otherCollectionTypeDescription.rank) {\n            // Cannot map over self...\n            return false;\n        }\n        var requiredSuffix = otherCollectionTypeDescription.collectionType;\n        return this._endsWith(this.collectionType, requiredSuffix);\n    },\n    effectiveMapOver: function(otherCollectionTypeDescription) {\n        var otherCollectionType = otherCollectionTypeDescription.collectionType;\n        var effectiveCollectionType = this.collectionType.substring(\n            0,\n            this.collectionType.length - otherCollectionType.length - 1\n        );\n        return new CollectionTypeDescription(effectiveCollectionType);\n    },\n    equal: function(otherCollectionTypeDescription) {\n        return (\n            otherCollectionTypeDescription.collectionType == this.collectionType\n        );\n    },\n    toString: function() {\n        return `CollectionType[${this.collectionType}]`;\n    },\n    _endsWith: function(str, suffix) {\n        return str.indexOf(suffix, str.length - suffix.length) !== -1;\n    }\n});\n\nvar TerminalMapping = Backbone.Model.extend({\n    initialize: function(attr) {\n        this.mapOver = attr.mapOver || NULL_COLLECTION_TYPE_DESCRIPTION;\n        this.terminal = attr.terminal;\n        this.terminal.terminalMapping = this;\n    },\n    disableMapOver: function() {\n        this.setMapOver(NULL_COLLECTION_TYPE_DESCRIPTION);\n    },\n    setMapOver: function(collectionTypeDescription) {\n        // TODO: Can I use \"attributes\" or something to auto trigger \"change\"\n        // event?\n        this.mapOver = collectionTypeDescription;\n        this.trigger(\"change\");\n    }\n});\n\nvar Terminal = Backbone.Model.extend({\n    initialize: function(attr) {\n        this.element = attr.element;\n        this.connectors = [];\n    },\n    connect: function(connector) {\n        this.connectors.push(connector);\n        if (this.node) {\n            this.node.markChanged();\n        }\n    },\n    disconnect: function(connector) {\n        this.connectors.splice($.inArray(connector, this.connectors), 1);\n        if (this.node) {\n            this.node.markChanged();\n            this.resetMappingIfNeeded();\n        }\n    },\n    redraw: function() {\n        $.each(this.connectors, (_, c) => {\n            c.redraw();\n        });\n    },\n    destroy: function() {\n        $.each(this.connectors.slice(), (_, c) => {\n            c.destroy();\n        });\n    },\n    destroyInvalidConnections: function() {\n        _.each(this.connectors, connector => {\n            connector && connector.destroyIfInvalid();\n        });\n    },\n    setMapOver: function(val) {\n        if (this.multiple) {\n            return; // Cannot set this to be multirun...\n        }\n\n        if (!this.mapOver().equal(val)) {\n            this.terminalMapping.setMapOver(val);\n            _.each(this.node.output_terminals, outputTerminal => {\n                outputTerminal.setMapOver(val);\n            });\n        }\n    },\n    mapOver: function() {\n        if (!this.terminalMapping) {\n            return NULL_COLLECTION_TYPE_DESCRIPTION;\n        } else {\n            return this.terminalMapping.mapOver;\n        }\n    },\n    isMappedOver: function() {\n        return (\n            this.terminalMapping && this.terminalMapping.mapOver.isCollection\n        );\n    },\n    resetMapping: function() {\n        this.terminalMapping.disableMapOver();\n    },\n\n    resetMappingIfNeeded: function() {} // Subclasses should override this...\n});\n\nvar OutputTerminal = Terminal.extend({\n    initialize: function(attr) {\n        Terminal.prototype.initialize.call(this, attr);\n        this.datatypes = attr.datatypes;\n    },\n\n    resetMappingIfNeeded: function() {\n        // If inputs were only mapped over to preserve\n        // an output just disconnected reset these...\n        if (\n            !this.node.hasConnectedOutputTerminals() &&\n            !this.node.hasConnectedMappedInputTerminals()\n        ) {\n            _.each(this.node.mappedInputTerminals(), mappedInput => {\n                mappedInput.resetMappingIfNeeded();\n            });\n        }\n\n        var noMappedInputs = !this.node.hasMappedOverInputTerminals();\n        if (noMappedInputs) {\n            this.resetMapping();\n        }\n    },\n\n    resetMapping: function() {\n        this.terminalMapping.disableMapOver();\n        _.each(this.connectors, connector => {\n            var connectedInput = connector.handle2;\n            if (connectedInput) {\n                // Not exactly right because this is still connected.\n                // Either rewrite resetMappingIfNeeded or disconnect\n                // and reconnect if valid.\n                connectedInput.resetMappingIfNeeded();\n                connector.destroyIfInvalid();\n            }\n        });\n    }\n});\n\nvar BaseInputTerminal = Terminal.extend({\n    initialize: function(attr) {\n        Terminal.prototype.initialize.call(this, attr);\n        this.update(attr.input); // subclasses should implement this...\n    },\n    canAccept: function(other) {\n        if (this._inputFilled()) {\n            return false;\n        } else {\n            return this.attachable(other);\n        }\n    },\n    resetMappingIfNeeded: function() {\n        var mapOver = this.mapOver();\n        if (!mapOver.isCollection) {\n            return;\n        }\n        // No output terminals are counting on this being mapped\n        // over if connected inputs are still mapped over or if none\n        // of the outputs are connected...\n        var reset =\n            this.node.hasConnectedMappedInputTerminals() ||\n            !this.node.hasConnectedOutputTerminals();\n        if (reset) {\n            this.resetMapping();\n        }\n    },\n    resetMapping: function() {\n        this.terminalMapping.disableMapOver();\n        if (!this.node.hasMappedOverInputTerminals()) {\n            _.each(this.node.output_terminals, terminal => {\n                // This shouldn't be called if there are mapped over\n                // outputs.\n                terminal.resetMapping();\n            });\n        }\n    },\n    connected: function() {\n        return this.connectors.length !== 0;\n    },\n    _inputFilled: function() {\n        var inputFilled;\n        if (!this.connected()) {\n            inputFilled = false;\n        } else {\n            if (this.multiple) {\n                if (this._collectionAttached()) {\n                    // Can only attach one collection to multiple input\n                    // data parameter.\n                    inputsFilled = true;\n                } else {\n                    inputFilled = false;\n                }\n            } else {\n                inputFilled = true;\n            }\n        }\n        return inputFilled;\n    },\n    _collectionAttached: function() {\n        if (!this.connected()) {\n            return false;\n        } else {\n            var firstOutput = this.connectors[0].handle1;\n            if (!firstOutput) {\n                return false;\n            } else {\n                if (\n                    firstOutput.isCollection ||\n                    firstOutput.isMappedOver() ||\n                    firstOutput.datatypes.indexOf(\"input_collection\") > 0\n                ) {\n                    return true;\n                } else {\n                    return false;\n                }\n            }\n        }\n    },\n    _mappingConstraints: function() {\n        // If this is a connected terminal, return list of collection types\n        // other terminals connected to node are constraining mapping to.\n        if (!this.node) {\n            return []; // No node - completely unconstrained\n        }\n        var mapOver = this.mapOver();\n        if (mapOver.isCollection) {\n            return [mapOver];\n        }\n\n        var constraints = [];\n        if (!this.node.hasConnectedOutputTerminals()) {\n            _.each(this.node.connectedMappedInputTerminals(), inputTerminal => {\n                constraints.push(inputTerminal.mapOver());\n            });\n        } else {\n            // All outputs should have same mapOver status - least specific.\n            constraints.push(\n                _.first(_.values(this.node.output_terminals)).mapOver()\n            );\n        }\n        return constraints;\n    },\n    _producesAcceptableDatatype: function(other) {\n        // other is a non-collection output...\n        for (var t in this.datatypes) {\n            var thisDatatype = this.datatypes[t];\n            if (thisDatatype == \"input\") {\n                return true;\n            }\n            var cat_outputs = new Array();\n            cat_outputs = cat_outputs.concat(other.datatypes);\n            if (other.node.post_job_actions) {\n                for (var pja_i in other.node.post_job_actions) {\n                    var pja = other.node.post_job_actions[pja_i];\n                    if (\n                        pja.action_type == \"ChangeDatatypeAction\" &&\n                        (pja.output_name == \"\" ||\n                            pja.output_name == other.name) &&\n                        pja.action_arguments\n                    ) {\n                        cat_outputs.push(pja.action_arguments[\"newtype\"]);\n                    }\n                }\n            }\n            // FIXME: No idea what to do about case when datatype is 'input'\n            for (var other_datatype_i in cat_outputs) {\n                var other_datatype = cat_outputs[other_datatype_i];\n                if (\n                    other_datatype == \"input\" ||\n                    other_datatype == \"_sniff_\" ||\n                    other_datatype == \"input_collection\" ||\n                    window.workflow_globals.app.isSubType(\n                        cat_outputs[other_datatype_i],\n                        thisDatatype\n                    )\n                ) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    },\n    _otherCollectionType: function(other) {\n        var otherCollectionType = NULL_COLLECTION_TYPE_DESCRIPTION;\n        if (other.isCollection) {\n            otherCollectionType = other.collectionType;\n        }\n        var otherMapOver = other.mapOver();\n        if (otherMapOver.isCollection) {\n            otherCollectionType = otherMapOver.append(otherCollectionType);\n        }\n        return otherCollectionType;\n    }\n});\n\nvar InputTerminal = BaseInputTerminal.extend({\n    update: function(input) {\n        this.datatypes = input.extensions;\n        this.multiple = input.multiple;\n        this.collection = false;\n    },\n    connect: function(connector) {\n        BaseInputTerminal.prototype.connect.call(this, connector);\n        var other_output = connector.handle1;\n        if (!other_output) {\n            return;\n        }\n        var otherCollectionType = this._otherCollectionType(other_output);\n        if (otherCollectionType.isCollection) {\n            this.setMapOver(otherCollectionType);\n        }\n    },\n    attachable: function(other) {\n        var otherCollectionType = this._otherCollectionType(other);\n        var thisMapOver = this.mapOver();\n        if (otherCollectionType.isCollection) {\n            if (this.multiple) {\n                if (this.connected() && !this._collectionAttached()) {\n                    // if single inputs attached, cannot also attach a\n                    // collection (yet...)\n                    return false;\n                }\n                if (otherCollectionType.rank == 1) {\n                    return this._producesAcceptableDatatype(other);\n                } else {\n                    // TODO: Allow subcollection mapping over this as if it were\n                    // a list collection input.\n                    return false;\n                }\n            }\n            if (\n                thisMapOver.isCollection &&\n                thisMapOver.canMatch(otherCollectionType)\n            ) {\n                return this._producesAcceptableDatatype(other);\n            } else {\n                //  Need to check if this would break constraints...\n                var mappingConstraints = this._mappingConstraints();\n                if (\n                    mappingConstraints.every(\n                        _.bind(\n                            otherCollectionType.canMatch,\n                            otherCollectionType\n                        )\n                    )\n                ) {\n                    return this._producesAcceptableDatatype(other);\n                } else {\n                    return false;\n                }\n            }\n        } else if (thisMapOver.isCollection) {\n            // Attempting to match a non-collection output to an\n            // explicitly collection input.\n            return false;\n        }\n        return this._producesAcceptableDatatype(other);\n    }\n});\n\nvar InputCollectionTerminal = BaseInputTerminal.extend({\n    update: function(input) {\n        this.multiple = false;\n        this.collection = true;\n        this.datatypes = input.extensions;\n        var collectionTypes = [];\n        if (input.collection_types) {\n            _.each(input.collection_types, collectionType => {\n                collectionTypes.push(\n                    new CollectionTypeDescription(collectionType)\n                );\n            });\n        } else {\n            collectionTypes.push(ANY_COLLECTION_TYPE_DESCRIPTION);\n        }\n        this.collectionTypes = collectionTypes;\n    },\n    connect: function(connector) {\n        BaseInputTerminal.prototype.connect.call(this, connector);\n        var other = connector.handle1;\n        if (!other) {\n            return;\n        }\n\n        var effectiveMapOver = this._effectiveMapOver(other);\n        this.setMapOver(effectiveMapOver);\n    },\n    _effectiveMapOver: function(other) {\n        var collectionTypes = this.collectionTypes;\n        var otherCollectionType = this._otherCollectionType(other);\n        var canMatch = _.some(collectionTypes, collectionType =>\n            collectionType.canMatch(otherCollectionType)\n        );\n\n        if (!canMatch) {\n            for (var collectionTypeIndex in collectionTypes) {\n                var collectionType = collectionTypes[collectionTypeIndex];\n                if (otherCollectionType.canMapOver(collectionType)) {\n                    var effectiveMapOver = otherCollectionType.effectiveMapOver(\n                        collectionType\n                    );\n                    if (effectiveMapOver != NULL_COLLECTION_TYPE_DESCRIPTION) {\n                        return effectiveMapOver;\n                    }\n                }\n            }\n        }\n        return NULL_COLLECTION_TYPE_DESCRIPTION;\n    },\n    _effectiveCollectionTypes: function() {\n        var thisMapOver = this.mapOver();\n        return _.map(this.collectionTypes, t => thisMapOver.append(t));\n    },\n    attachable: function(other) {\n        var otherCollectionType = this._otherCollectionType(other);\n        if (otherCollectionType.isCollection) {\n            var effectiveCollectionTypes = this._effectiveCollectionTypes();\n            var thisMapOver = this.mapOver();\n            var canMatch = _.some(\n                effectiveCollectionTypes,\n                effectiveCollectionType =>\n                    effectiveCollectionType.canMatch(otherCollectionType)\n            );\n            if (canMatch) {\n                // Only way a direct match...\n                return this._producesAcceptableDatatype(other);\n                // Otherwise we need to mapOver\n            } else if (thisMapOver.isCollection) {\n                // In this case, mapOver already set and we didn't match skipping...\n                return false;\n            } else if (\n                _.some(this.collectionTypes, collectionType =>\n                    otherCollectionType.canMapOver(collectionType)\n                )\n            ) {\n                var effectiveMapOver = this._effectiveMapOver(other);\n                if (!effectiveMapOver.isCollection) {\n                    return false;\n                }\n                //  Need to check if this would break constraints...\n                var mappingConstraints = this._mappingConstraints();\n                if (mappingConstraints.every(effectiveMapOver.canMatch)) {\n                    return this._producesAcceptableDatatype(other);\n                }\n            }\n        }\n        return false;\n    }\n});\n\nvar OutputCollectionTerminal = Terminal.extend({\n    initialize: function(attr) {\n        Terminal.prototype.initialize.call(this, attr);\n        this.datatypes = attr.datatypes;\n        if (attr.collection_type) {\n            this.collectionType = new CollectionTypeDescription(\n                attr.collection_type\n            );\n        } else {\n            var collectionTypeSource = attr.collection_type_source;\n            if (!collectionTypeSource) {\n                console.log(\n                    \"Warning: No collection type or collection type source defined.\"\n                );\n            }\n            this.collectionType = ANY_COLLECTION_TYPE_DESCRIPTION;\n        }\n        this.isCollection = true;\n    },\n    update: function(output) {\n        var newCollectionType;\n        if (output.collection_type) {\n            newCollectionType = new CollectionTypeDescription(\n                output.collection_type\n            );\n        } else {\n            var collectionTypeSource = output.collection_type_source;\n            if (!collectionTypeSource) {\n                console.log(\n                    \"Warning: No collection type or collection type source defined.\"\n                );\n            }\n            newCollectionType = ANY_COLLECTION_TYPE_DESCRIPTION;\n        }\n\n        if (\n            newCollectionType.collectionType !=\n            this.collectionType.collectionType\n        ) {\n            _.each(this.connectors, connector => {\n                // TODO: consider checking if connection valid before removing...\n                connector.destroy();\n            });\n        }\n        this.collectionType = newCollectionType;\n    }\n});\n\nexport default {\n    InputTerminal: InputTerminal,\n    OutputTerminal: OutputTerminal,\n    InputCollectionTerminal: InputCollectionTerminal,\n    OutputCollectionTerminal: OutputCollectionTerminal,\n    TerminalMapping: TerminalMapping,\n\n    // test export\n    CollectionTypeDescription: CollectionTypeDescription,\n    NULL_COLLECTION_TYPE_DESCRIPTION: NULL_COLLECTION_TYPE_DESCRIPTION,\n    ANY_COLLECTION_TYPE_DESCRIPTION: ANY_COLLECTION_TYPE_DESCRIPTION\n};\n"]}