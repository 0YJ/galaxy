{"version":3,"sources":["mvc/workflow/workflow-terminals.js"],"names":["CollectionTypeDescription","collectionType","this","isCollection","rank","split","length","window","workflow_globals","NULL_COLLECTION_TYPE_DESCRIPTION","canMatch","canMapOver","other","otherCollectionType","toString","ANY_COLLECTION_TYPE_DESCRIPTION","equal","$","extend","prototype","otherCollectionTypeDescription","effectiveMapOver","requiredSuffix","_endsWith","str","suffix","mapOver","substring","TerminalMapping","Backbone","terminal","disableMapOver","setMapOver","collectionTypeDescription","trigger","Model","initialize","attr","element","connectors","terminalMapping","node","Terminal","redraw","c","connect","connector","destroy","push","each","destroyInvalidConnections","_","markChanged","resetMappingIfNeeded","outputTerminal","val","multiple","resetMapping","output_terminals","OutputTerminal","isMappedOver","hasConnectedOutputTerminals","noMappedInputs","call","datatypes","connectedInput","mappedInputTerminals","mappedInput","update","attachable","handle2","destroyIfInvalid","BaseInputTerminal","input","canAccept","hasConnectedMappedInputTerminals","inputFilled","hasMappedOverInputTerminals","connected","_inputFilled","_collectionAttached","inputsFilled","_mappingConstraints","firstOutput","constraints","indexOf","cat_outputs","_otherCollectionType","other_datatype","other_datatype_i","inputTerminal","_producesAcceptableDatatype","otherMapOver","thisDatatype","t","Array","InputTerminal","post_job_actions","extensions","pja_i","pja","action_type","output_name","name","other_output","action_arguments","thisMapOver","app","isSubType","mappingConstraints","append","collection","handle1","collectionTypes","InputCollectionTerminal","collection_types","_effectiveMapOver","OutputCollectionTerminal","some","collectionTypeIndex","collectionTypeSource","collection_type_source","console","newCollectionType","_effectiveCollectionTypes","effectiveCollectionTypes","effectiveCollectionType","every","collection_type","log","output"],"mappings":"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","file":"../../../scripts/mvc/workflow/workflow-terminals.js","sourcesContent":["// TODO; tie into Galaxy state?\nwindow.workflow_globals = window.workflow_globals || {};\nfunction CollectionTypeDescription(collectionType) {\n    this.collectionType = collectionType;\n    this.isCollection = true;\n    this.rank = collectionType.split(\":\").length;\n}\n\nvar NULL_COLLECTION_TYPE_DESCRIPTION = {\n    isCollection: false,\n    canMatch: function(other) {\n        return false;\n    },\n    canMapOver: function(other) {\n        return false;\n    },\n    toString: function() {\n        return \"NullCollectionType[]\";\n    },\n    append: function(otherCollectionType) {\n        return otherCollectionType;\n    },\n    equal: function(other) {\n        return other === this;\n    }\n};\n\nvar ANY_COLLECTION_TYPE_DESCRIPTION = {\n    isCollection: true,\n    canMatch: function(other) {\n        return NULL_COLLECTION_TYPE_DESCRIPTION !== other;\n    },\n    canMapOver: function(other) {\n        return false;\n    },\n    toString: function() {\n        return \"AnyCollectionType[]\";\n    },\n    append: function(otherCollectionType) {\n        throw \"Cannot append to ANY_COLLECTION_TYPE_DESCRIPTION\";\n    },\n    equal: function(other) {\n        return other === this;\n    }\n};\n\n$.extend(CollectionTypeDescription.prototype, {\n    append: function(otherCollectionTypeDescription) {\n        if (\n            otherCollectionTypeDescription === NULL_COLLECTION_TYPE_DESCRIPTION\n        ) {\n            return this;\n        }\n        if (\n            otherCollectionTypeDescription === ANY_COLLECTION_TYPE_DESCRIPTION\n        ) {\n            return otherCollectionType;\n        }\n        return new CollectionTypeDescription(\n            this.collectionType +\n                \":\" +\n                otherCollectionTypeDescription.collectionType\n        );\n    },\n    canMatch: function(otherCollectionTypeDescription) {\n        if (\n            otherCollectionTypeDescription === NULL_COLLECTION_TYPE_DESCRIPTION\n        ) {\n            return false;\n        }\n        if (\n            otherCollectionTypeDescription === ANY_COLLECTION_TYPE_DESCRIPTION\n        ) {\n            return true;\n        }\n        return (\n            otherCollectionTypeDescription.collectionType == this.collectionType\n        );\n    },\n    canMapOver: function(otherCollectionTypeDescription) {\n        if (\n            otherCollectionTypeDescription === NULL_COLLECTION_TYPE_DESCRIPTION\n        ) {\n            return false;\n        }\n        if (\n            otherCollectionTypeDescription === ANY_COLLECTION_TYPE_DESCRIPTION\n        ) {\n            return false;\n        }\n        if (this.rank <= otherCollectionTypeDescription.rank) {\n            // Cannot map over self...\n            return false;\n        }\n        var requiredSuffix = otherCollectionTypeDescription.collectionType;\n        return this._endsWith(this.collectionType, requiredSuffix);\n    },\n    effectiveMapOver: function(otherCollectionTypeDescription) {\n        var otherCollectionType = otherCollectionTypeDescription.collectionType;\n        var effectiveCollectionType = this.collectionType.substring(\n            0,\n            this.collectionType.length - otherCollectionType.length - 1\n        );\n        return new CollectionTypeDescription(effectiveCollectionType);\n    },\n    equal: function(otherCollectionTypeDescription) {\n        return (\n            otherCollectionTypeDescription.collectionType == this.collectionType\n        );\n    },\n    toString: function() {\n        return \"CollectionType[\" + this.collectionType + \"]\";\n    },\n    _endsWith: function(str, suffix) {\n        return str.indexOf(suffix, str.length - suffix.length) !== -1;\n    }\n});\n\nvar TerminalMapping = Backbone.Model.extend({\n    initialize: function(attr) {\n        this.mapOver = attr.mapOver || NULL_COLLECTION_TYPE_DESCRIPTION;\n        this.terminal = attr.terminal;\n        this.terminal.terminalMapping = this;\n    },\n    disableMapOver: function() {\n        this.setMapOver(NULL_COLLECTION_TYPE_DESCRIPTION);\n    },\n    setMapOver: function(collectionTypeDescription) {\n        // TODO: Can I use \"attributes\" or something to auto trigger \"change\"\n        // event?\n        this.mapOver = collectionTypeDescription;\n        this.trigger(\"change\");\n    }\n});\n\nvar Terminal = Backbone.Model.extend({\n    initialize: function(attr) {\n        this.element = attr.element;\n        this.connectors = [];\n    },\n    connect: function(connector) {\n        this.connectors.push(connector);\n        if (this.node) {\n            this.node.markChanged();\n        }\n    },\n    disconnect: function(connector) {\n        this.connectors.splice($.inArray(connector, this.connectors), 1);\n        if (this.node) {\n            this.node.markChanged();\n            this.resetMappingIfNeeded();\n        }\n    },\n    redraw: function() {\n        $.each(this.connectors, function(_, c) {\n            c.redraw();\n        });\n    },\n    destroy: function() {\n        $.each(this.connectors.slice(), function(_, c) {\n            c.destroy();\n        });\n    },\n    destroyInvalidConnections: function() {\n        _.each(this.connectors, function(connector) {\n            connector && connector.destroyIfInvalid();\n        });\n    },\n    setMapOver: function(val) {\n        if (this.multiple) {\n            return; // Cannot set this to be multirun...\n        }\n\n        if (!this.mapOver().equal(val)) {\n            this.terminalMapping.setMapOver(val);\n            _.each(this.node.output_terminals, function(outputTerminal) {\n                outputTerminal.setMapOver(val);\n            });\n        }\n    },\n    mapOver: function() {\n        if (!this.terminalMapping) {\n            return NULL_COLLECTION_TYPE_DESCRIPTION;\n        } else {\n            return this.terminalMapping.mapOver;\n        }\n    },\n    isMappedOver: function() {\n        return (\n            this.terminalMapping && this.terminalMapping.mapOver.isCollection\n        );\n    },\n    resetMapping: function() {\n        this.terminalMapping.disableMapOver();\n    },\n\n    resetMappingIfNeeded: function() {} // Subclasses should override this...\n});\n\nvar OutputTerminal = Terminal.extend({\n    initialize: function(attr) {\n        Terminal.prototype.initialize.call(this, attr);\n        this.datatypes = attr.datatypes;\n    },\n\n    resetMappingIfNeeded: function() {\n        // If inputs were only mapped over to preserve\n        // an output just disconnected reset these...\n        if (\n            !this.node.hasConnectedOutputTerminals() &&\n            !this.node.hasConnectedMappedInputTerminals()\n        ) {\n            _.each(this.node.mappedInputTerminals(), function(mappedInput) {\n                mappedInput.resetMappingIfNeeded();\n            });\n        }\n\n        var noMappedInputs = !this.node.hasMappedOverInputTerminals();\n        if (noMappedInputs) {\n            this.resetMapping();\n        }\n    },\n\n    resetMapping: function() {\n        this.terminalMapping.disableMapOver();\n        _.each(this.connectors, function(connector) {\n            var connectedInput = connector.handle2;\n            if (connectedInput) {\n                // Not exactly right because this is still connected.\n                // Either rewrite resetMappingIfNeeded or disconnect\n                // and reconnect if valid.\n                connectedInput.resetMappingIfNeeded();\n                connector.destroyIfInvalid();\n            }\n        });\n    }\n});\n\nvar BaseInputTerminal = Terminal.extend({\n    initialize: function(attr) {\n        Terminal.prototype.initialize.call(this, attr);\n        this.update(attr.input); // subclasses should implement this...\n    },\n    canAccept: function(other) {\n        if (this._inputFilled()) {\n            return false;\n        } else {\n            return this.attachable(other);\n        }\n    },\n    resetMappingIfNeeded: function() {\n        var mapOver = this.mapOver();\n        if (!mapOver.isCollection) {\n            return;\n        }\n        // No output terminals are counting on this being mapped\n        // over if connected inputs are still mapped over or if none\n        // of the outputs are connected...\n        var reset =\n            this.node.hasConnectedMappedInputTerminals() ||\n            !this.node.hasConnectedOutputTerminals();\n        if (reset) {\n            this.resetMapping();\n        }\n    },\n    resetMapping: function() {\n        this.terminalMapping.disableMapOver();\n        if (!this.node.hasMappedOverInputTerminals()) {\n            _.each(this.node.output_terminals, function(terminal) {\n                // This shouldn't be called if there are mapped over\n                // outputs.\n                terminal.resetMapping();\n            });\n        }\n    },\n    connected: function() {\n        return this.connectors.length !== 0;\n    },\n    _inputFilled: function() {\n        var inputFilled;\n        if (!this.connected()) {\n            inputFilled = false;\n        } else {\n            if (this.multiple) {\n                if (this._collectionAttached()) {\n                    // Can only attach one collection to multiple input\n                    // data parameter.\n                    inputsFilled = true;\n                } else {\n                    inputFilled = false;\n                }\n            } else {\n                inputFilled = true;\n            }\n        }\n        return inputFilled;\n    },\n    _collectionAttached: function() {\n        if (!this.connected()) {\n            return false;\n        } else {\n            var firstOutput = this.connectors[0].handle1;\n            if (!firstOutput) {\n                return false;\n            } else {\n                if (\n                    firstOutput.isCollection ||\n                    firstOutput.isMappedOver() ||\n                    firstOutput.datatypes.indexOf(\"input_collection\") > 0\n                ) {\n                    return true;\n                } else {\n                    return false;\n                }\n            }\n        }\n    },\n    _mappingConstraints: function() {\n        // If this is a connected terminal, return list of collection types\n        // other terminals connected to node are constraining mapping to.\n        if (!this.node) {\n            return []; // No node - completely unconstrained\n        }\n        var mapOver = this.mapOver();\n        if (mapOver.isCollection) {\n            return [mapOver];\n        }\n\n        var constraints = [];\n        if (!this.node.hasConnectedOutputTerminals()) {\n            _.each(this.node.connectedMappedInputTerminals(), function(\n                inputTerminal\n            ) {\n                constraints.push(inputTerminal.mapOver());\n            });\n        } else {\n            // All outputs should have same mapOver status - least specific.\n            constraints.push(\n                _.first(_.values(this.node.output_terminals)).mapOver()\n            );\n        }\n        return constraints;\n    },\n    _producesAcceptableDatatype: function(other) {\n        // other is a non-collection output...\n        for (var t in this.datatypes) {\n            var thisDatatype = this.datatypes[t];\n            if (thisDatatype == \"input\") {\n                return true;\n            }\n            var cat_outputs = new Array();\n            cat_outputs = cat_outputs.concat(other.datatypes);\n            if (other.node.post_job_actions) {\n                for (var pja_i in other.node.post_job_actions) {\n                    var pja = other.node.post_job_actions[pja_i];\n                    if (\n                        pja.action_type == \"ChangeDatatypeAction\" &&\n                        (pja.output_name == \"\" ||\n                            pja.output_name == other.name) &&\n                        pja.action_arguments\n                    ) {\n                        cat_outputs.push(pja.action_arguments[\"newtype\"]);\n                    }\n                }\n            }\n            // FIXME: No idea what to do about case when datatype is 'input'\n            for (var other_datatype_i in cat_outputs) {\n                var other_datatype = cat_outputs[other_datatype_i];\n                if (\n                    other_datatype == \"input\" ||\n                    other_datatype == \"_sniff_\" ||\n                    other_datatype == \"input_collection\" ||\n                    window.workflow_globals.app.isSubType(\n                        cat_outputs[other_datatype_i],\n                        thisDatatype\n                    )\n                ) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    },\n    _otherCollectionType: function(other) {\n        var otherCollectionType = NULL_COLLECTION_TYPE_DESCRIPTION;\n        if (other.isCollection) {\n            otherCollectionType = other.collectionType;\n        }\n        var otherMapOver = other.mapOver();\n        if (otherMapOver.isCollection) {\n            otherCollectionType = otherMapOver.append(otherCollectionType);\n        }\n        return otherCollectionType;\n    }\n});\n\nvar InputTerminal = BaseInputTerminal.extend({\n    update: function(input) {\n        this.datatypes = input.extensions;\n        this.multiple = input.multiple;\n        this.collection = false;\n    },\n    connect: function(connector) {\n        BaseInputTerminal.prototype.connect.call(this, connector);\n        var other_output = connector.handle1;\n        if (!other_output) {\n            return;\n        }\n        var otherCollectionType = this._otherCollectionType(other_output);\n        if (otherCollectionType.isCollection) {\n            this.setMapOver(otherCollectionType);\n        }\n    },\n    attachable: function(other) {\n        var otherCollectionType = this._otherCollectionType(other);\n        var thisMapOver = this.mapOver();\n        if (otherCollectionType.isCollection) {\n            if (this.multiple) {\n                if (this.connected() && !this._collectionAttached()) {\n                    // if single inputs attached, cannot also attach a\n                    // collection (yet...)\n                    return false;\n                }\n                if (otherCollectionType.rank == 1) {\n                    return this._producesAcceptableDatatype(other);\n                } else {\n                    // TODO: Allow subcollection mapping over this as if it were\n                    // a list collection input.\n                    return false;\n                }\n            }\n            if (\n                thisMapOver.isCollection &&\n                thisMapOver.canMatch(otherCollectionType)\n            ) {\n                return this._producesAcceptableDatatype(other);\n            } else {\n                //  Need to check if this would break constraints...\n                var mappingConstraints = this._mappingConstraints();\n                if (\n                    mappingConstraints.every(\n                        _.bind(\n                            otherCollectionType.canMatch,\n                            otherCollectionType\n                        )\n                    )\n                ) {\n                    return this._producesAcceptableDatatype(other);\n                } else {\n                    return false;\n                }\n            }\n        } else if (thisMapOver.isCollection) {\n            // Attempting to match a non-collection output to an\n            // explicitly collection input.\n            return false;\n        }\n        return this._producesAcceptableDatatype(other);\n    }\n});\n\nvar InputCollectionTerminal = BaseInputTerminal.extend({\n    update: function(input) {\n        this.multiple = false;\n        this.collection = true;\n        this.datatypes = input.extensions;\n        var collectionTypes = [];\n        if (input.collection_types) {\n            _.each(input.collection_types, function(collectionType) {\n                collectionTypes.push(\n                    new CollectionTypeDescription(collectionType)\n                );\n            });\n        } else {\n            collectionTypes.push(ANY_COLLECTION_TYPE_DESCRIPTION);\n        }\n        this.collectionTypes = collectionTypes;\n    },\n    connect: function(connector) {\n        BaseInputTerminal.prototype.connect.call(this, connector);\n        var other = connector.handle1;\n        if (!other) {\n            return;\n        }\n\n        var effectiveMapOver = this._effectiveMapOver(other);\n        this.setMapOver(effectiveMapOver);\n    },\n    _effectiveMapOver: function(other) {\n        var collectionTypes = this.collectionTypes;\n        var otherCollectionType = this._otherCollectionType(other);\n        var canMatch = _.some(collectionTypes, function(collectionType) {\n            return collectionType.canMatch(otherCollectionType);\n        });\n\n        if (!canMatch) {\n            for (var collectionTypeIndex in collectionTypes) {\n                var collectionType = collectionTypes[collectionTypeIndex];\n                if (otherCollectionType.canMapOver(collectionType)) {\n                    var effectiveMapOver = otherCollectionType.effectiveMapOver(\n                        collectionType\n                    );\n                    if (effectiveMapOver != NULL_COLLECTION_TYPE_DESCRIPTION) {\n                        return effectiveMapOver;\n                    }\n                }\n            }\n        }\n        return NULL_COLLECTION_TYPE_DESCRIPTION;\n    },\n    _effectiveCollectionTypes: function() {\n        var thisMapOver = this.mapOver();\n        return _.map(this.collectionTypes, function(t) {\n            return thisMapOver.append(t);\n        });\n    },\n    attachable: function(other) {\n        var otherCollectionType = this._otherCollectionType(other);\n        if (otherCollectionType.isCollection) {\n            var effectiveCollectionTypes = this._effectiveCollectionTypes();\n            var thisMapOver = this.mapOver();\n            var canMatch = _.some(effectiveCollectionTypes, function(\n                effectiveCollectionType\n            ) {\n                return effectiveCollectionType.canMatch(otherCollectionType);\n            });\n            if (canMatch) {\n                // Only way a direct match...\n                return this._producesAcceptableDatatype(other);\n                // Otherwise we need to mapOver\n            } else if (thisMapOver.isCollection) {\n                // In this case, mapOver already set and we didn't match skipping...\n                return false;\n            } else if (\n                _.some(this.collectionTypes, function(collectionType) {\n                    return otherCollectionType.canMapOver(collectionType);\n                })\n            ) {\n                var effectiveMapOver = this._effectiveMapOver(other);\n                if (!effectiveMapOver.isCollection) {\n                    return false;\n                }\n                //  Need to check if this would break constraints...\n                var mappingConstraints = this._mappingConstraints();\n                if (mappingConstraints.every(effectiveMapOver.canMatch)) {\n                    return this._producesAcceptableDatatype(other);\n                }\n            }\n        }\n        return false;\n    }\n});\n\nvar OutputCollectionTerminal = Terminal.extend({\n    initialize: function(attr) {\n        Terminal.prototype.initialize.call(this, attr);\n        this.datatypes = attr.datatypes;\n        if (attr.collection_type) {\n            this.collectionType = new CollectionTypeDescription(\n                attr.collection_type\n            );\n        } else {\n            var collectionTypeSource = attr.collection_type_source;\n            if (!collectionTypeSource) {\n                console.log(\n                    \"Warning: No collection type or collection type source defined.\"\n                );\n            }\n            this.collectionType = ANY_COLLECTION_TYPE_DESCRIPTION;\n        }\n        this.isCollection = true;\n    },\n    update: function(output) {\n        var newCollectionType;\n        if (output.collection_type) {\n            newCollectionType = new CollectionTypeDescription(\n                output.collection_type\n            );\n        } else {\n            var collectionTypeSource = output.collection_type_source;\n            if (!collectionTypeSource) {\n                console.log(\n                    \"Warning: No collection type or collection type source defined.\"\n                );\n            }\n            newCollectionType = ANY_COLLECTION_TYPE_DESCRIPTION;\n        }\n\n        if (\n            newCollectionType.collectionType !=\n            this.collectionType.collectionType\n        ) {\n            _.each(this.connectors, function(connector) {\n                // TODO: consider checking if connection valid before removing...\n                connector.destroy();\n            });\n        }\n        this.collectionType = newCollectionType;\n    }\n});\n\nexport default {\n    InputTerminal: InputTerminal,\n    OutputTerminal: OutputTerminal,\n    InputCollectionTerminal: InputCollectionTerminal,\n    OutputCollectionTerminal: OutputCollectionTerminal,\n    TerminalMapping: TerminalMapping,\n\n    // test export\n    CollectionTypeDescription: CollectionTypeDescription,\n    NULL_COLLECTION_TYPE_DESCRIPTION: NULL_COLLECTION_TYPE_DESCRIPTION,\n    ANY_COLLECTION_TYPE_DESCRIPTION: ANY_COLLECTION_TYPE_DESCRIPTION\n};\n"]}