{"version":3,"sources":["mvc/workflow/workflow-terminals.js"],"names":["define","Globals","CollectionTypeDescription","collectionType","this","isCollection","rank","NULL_COLLECTION_TYPE_DESCRIPTION","canMatch","other","canMapOver","toString","otherCollectionType","append","ANY_COLLECTION_TYPE_DESCRIPTION","$","extend","prototype","otherCollectionTypeDescription","effectiveCollectionType","equal","_endsWith","initialize","requiredSuffix","attr","terminal","terminalMapping","disableMapOver","trigger","collectionTypeDescription","length","Terminal","connect","connector","node","suffix","str","indexOf","markChanged","TerminalMapping","connectors","splice","inArray","mapOver","resetMappingIfNeeded","redraw","setMapOver","c","destroy","_","each","element","multiple","push","outputTerminal","isMappedOver","destroyInvalidConnections","destroyIfInvalid","OutputTerminal","val","output_terminals","noMappedInputs","resetMapping","connectedInput","call","datatypes","_inputFilled","hasConnectedMappedInputTerminals","attachable","mappedInput","hasMappedOverInputTerminals","reset","handle2","connected","input","canAccept","inputFilled","_collectionAttached","inputsFilled","firstOutput","_mappingConstraints","constraints","connectedMappedInputTerminals","_producesAcceptableDatatype","thisDatatype","handle1","cat_outputs","post_job_actions","pja_i","other_datatype","_otherCollectionType","hasConnectedOutputTerminals","InputTerminal","BaseInputTerminal","otherMapOver","inputTerminal","other_output","pja","thisMapOver","name","action_arguments","other_datatype_i","app","isSubType","mappingConstraints","collection","update","collectionTypes","collection_types","effectiveMapOver","_effectiveMapOver","effectiveCollectionTypes","_effectiveCollectionTypes","InputCollectionTerminal","extensions","every","collectionTypeSource","console","newCollectionType","some","output","collectionTypeIndex","collection_type_source","map","t","OutputCollectionTerminal","collection_type","log"],"mappings":"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","file":"../../../scripts/mvc/workflow/workflow-terminals.js","sourcesContent":["define([\"mvc/workflow/workflow-globals\"], function(Globals) {\n    function CollectionTypeDescription(collectionType) {\n        this.collectionType = collectionType;\n        this.isCollection = true;\n        this.rank = collectionType.split(\":\").length;\n    }\n\n    var NULL_COLLECTION_TYPE_DESCRIPTION = {\n        isCollection: false,\n        canMatch: function(other) {\n            return false;\n        },\n        canMapOver: function(other) {\n            return false;\n        },\n        toString: function() {\n            return \"NullCollectionType[]\";\n        },\n        append: function(otherCollectionType) {\n            return otherCollectionType;\n        },\n        equal: function(other) {\n            return other === this;\n        }\n    };\n\n    var ANY_COLLECTION_TYPE_DESCRIPTION = {\n        isCollection: true,\n        canMatch: function(other) {\n            return NULL_COLLECTION_TYPE_DESCRIPTION !== other;\n        },\n        canMapOver: function(other) {\n            return false;\n        },\n        toString: function() {\n            return \"AnyCollectionType[]\";\n        },\n        append: function(otherCollectionType) {\n            throw \"Cannot append to ANY_COLLECTION_TYPE_DESCRIPTION\";\n        },\n        equal: function(other) {\n            return other === this;\n        }\n    };\n\n    $.extend(CollectionTypeDescription.prototype, {\n        append: function(otherCollectionTypeDescription) {\n            if (\n                otherCollectionTypeDescription ===\n                NULL_COLLECTION_TYPE_DESCRIPTION\n            ) {\n                return this;\n            }\n            if (\n                otherCollectionTypeDescription ===\n                ANY_COLLECTION_TYPE_DESCRIPTION\n            ) {\n                return otherCollectionType;\n            }\n            return new CollectionTypeDescription(\n                this.collectionType +\n                    \":\" +\n                    otherCollectionTypeDescription.collectionType\n            );\n        },\n        canMatch: function(otherCollectionTypeDescription) {\n            if (\n                otherCollectionTypeDescription ===\n                NULL_COLLECTION_TYPE_DESCRIPTION\n            ) {\n                return false;\n            }\n            if (\n                otherCollectionTypeDescription ===\n                ANY_COLLECTION_TYPE_DESCRIPTION\n            ) {\n                return true;\n            }\n            return (\n                otherCollectionTypeDescription.collectionType ==\n                this.collectionType\n            );\n        },\n        canMapOver: function(otherCollectionTypeDescription) {\n            if (\n                otherCollectionTypeDescription ===\n                NULL_COLLECTION_TYPE_DESCRIPTION\n            ) {\n                return false;\n            }\n            if (\n                otherCollectionTypeDescription ===\n                ANY_COLLECTION_TYPE_DESCRIPTION\n            ) {\n                return false;\n            }\n            if (this.rank <= otherCollectionTypeDescription.rank) {\n                // Cannot map over self...\n                return false;\n            }\n            var requiredSuffix = otherCollectionTypeDescription.collectionType;\n            return this._endsWith(this.collectionType, requiredSuffix);\n        },\n        effectiveMapOver: function(otherCollectionTypeDescription) {\n            var otherCollectionType =\n                otherCollectionTypeDescription.collectionType;\n            var effectiveCollectionType = this.collectionType.substring(\n                0,\n                this.collectionType.length - otherCollectionType.length - 1\n            );\n            return new CollectionTypeDescription(effectiveCollectionType);\n        },\n        equal: function(otherCollectionTypeDescription) {\n            return (\n                otherCollectionTypeDescription.collectionType ==\n                this.collectionType\n            );\n        },\n        toString: function() {\n            return \"CollectionType[\" + this.collectionType + \"]\";\n        },\n        _endsWith: function(str, suffix) {\n            return str.indexOf(suffix, str.length - suffix.length) !== -1;\n        }\n    });\n\n    var TerminalMapping = Backbone.Model.extend({\n        initialize: function(attr) {\n            this.mapOver = attr.mapOver || NULL_COLLECTION_TYPE_DESCRIPTION;\n            this.terminal = attr.terminal;\n            this.terminal.terminalMapping = this;\n        },\n        disableMapOver: function() {\n            this.setMapOver(NULL_COLLECTION_TYPE_DESCRIPTION);\n        },\n        setMapOver: function(collectionTypeDescription) {\n            // TODO: Can I use \"attributes\" or something to auto trigger \"change\"\n            // event?\n            this.mapOver = collectionTypeDescription;\n            this.trigger(\"change\");\n        }\n    });\n\n    var Terminal = Backbone.Model.extend({\n        initialize: function(attr) {\n            this.element = attr.element;\n            this.connectors = [];\n        },\n        connect: function(connector) {\n            this.connectors.push(connector);\n            if (this.node) {\n                this.node.markChanged();\n            }\n        },\n        disconnect: function(connector) {\n            this.connectors.splice($.inArray(connector, this.connectors), 1);\n            if (this.node) {\n                this.node.markChanged();\n                this.resetMappingIfNeeded();\n            }\n        },\n        redraw: function() {\n            $.each(this.connectors, function(_, c) {\n                c.redraw();\n            });\n        },\n        destroy: function() {\n            $.each(this.connectors.slice(), function(_, c) {\n                c.destroy();\n            });\n        },\n        destroyInvalidConnections: function() {\n            _.each(this.connectors, function(connector) {\n                connector && connector.destroyIfInvalid();\n            });\n        },\n        setMapOver: function(val) {\n            if (this.multiple) {\n                return; // Cannot set this to be multirun...\n            }\n\n            if (!this.mapOver().equal(val)) {\n                this.terminalMapping.setMapOver(val);\n                _.each(this.node.output_terminals, function(outputTerminal) {\n                    outputTerminal.setMapOver(val);\n                });\n            }\n        },\n        mapOver: function() {\n            if (!this.terminalMapping) {\n                return NULL_COLLECTION_TYPE_DESCRIPTION;\n            } else {\n                return this.terminalMapping.mapOver;\n            }\n        },\n        isMappedOver: function() {\n            return (\n                this.terminalMapping &&\n                this.terminalMapping.mapOver.isCollection\n            );\n        },\n        resetMapping: function() {\n            this.terminalMapping.disableMapOver();\n        },\n\n        resetMappingIfNeeded: function() {} // Subclasses should override this...\n    });\n\n    var OutputTerminal = Terminal.extend({\n        initialize: function(attr) {\n            Terminal.prototype.initialize.call(this, attr);\n            this.datatypes = attr.datatypes;\n        },\n\n        resetMappingIfNeeded: function() {\n            // If inputs were only mapped over to preserve\n            // an output just disconnected reset these...\n            if (\n                !this.node.hasConnectedOutputTerminals() &&\n                !this.node.hasConnectedMappedInputTerminals()\n            ) {\n                _.each(this.node.mappedInputTerminals(), function(mappedInput) {\n                    mappedInput.resetMappingIfNeeded();\n                });\n            }\n\n            var noMappedInputs = !this.node.hasMappedOverInputTerminals();\n            if (noMappedInputs) {\n                this.resetMapping();\n            }\n        },\n\n        resetMapping: function() {\n            this.terminalMapping.disableMapOver();\n            _.each(this.connectors, function(connector) {\n                var connectedInput = connector.handle2;\n                if (connectedInput) {\n                    // Not exactly right because this is still connected.\n                    // Either rewrite resetMappingIfNeeded or disconnect\n                    // and reconnect if valid.\n                    connectedInput.resetMappingIfNeeded();\n                    connector.destroyIfInvalid();\n                }\n            });\n        }\n    });\n\n    var BaseInputTerminal = Terminal.extend({\n        initialize: function(attr) {\n            Terminal.prototype.initialize.call(this, attr);\n            this.update(attr.input); // subclasses should implement this...\n        },\n        canAccept: function(other) {\n            if (this._inputFilled()) {\n                return false;\n            } else {\n                return this.attachable(other);\n            }\n        },\n        resetMappingIfNeeded: function() {\n            var mapOver = this.mapOver();\n            if (!mapOver.isCollection) {\n                return;\n            }\n            // No output terminals are counting on this being mapped\n            // over if connected inputs are still mapped over or if none\n            // of the outputs are connected...\n            var reset =\n                this.node.hasConnectedMappedInputTerminals() ||\n                !this.node.hasConnectedOutputTerminals();\n            if (reset) {\n                this.resetMapping();\n            }\n        },\n        resetMapping: function() {\n            this.terminalMapping.disableMapOver();\n            if (!this.node.hasMappedOverInputTerminals()) {\n                _.each(this.node.output_terminals, function(terminal) {\n                    // This shouldn't be called if there are mapped over\n                    // outputs.\n                    terminal.resetMapping();\n                });\n            }\n        },\n        connected: function() {\n            return this.connectors.length !== 0;\n        },\n        _inputFilled: function() {\n            var inputFilled;\n            if (!this.connected()) {\n                inputFilled = false;\n            } else {\n                if (this.multiple) {\n                    if (this._collectionAttached()) {\n                        // Can only attach one collection to multiple input\n                        // data parameter.\n                        inputsFilled = true;\n                    } else {\n                        inputFilled = false;\n                    }\n                } else {\n                    inputFilled = true;\n                }\n            }\n            return inputFilled;\n        },\n        _collectionAttached: function() {\n            if (!this.connected()) {\n                return false;\n            } else {\n                var firstOutput = this.connectors[0].handle1;\n                if (!firstOutput) {\n                    return false;\n                } else {\n                    if (\n                        firstOutput.isCollection ||\n                        firstOutput.isMappedOver() ||\n                        firstOutput.datatypes.indexOf(\"input_collection\") > 0\n                    ) {\n                        return true;\n                    } else {\n                        return false;\n                    }\n                }\n            }\n        },\n        _mappingConstraints: function() {\n            // If this is a connected terminal, return list of collection types\n            // other terminals connected to node are constraining mapping to.\n            if (!this.node) {\n                return []; // No node - completely unconstrained\n            }\n            var mapOver = this.mapOver();\n            if (mapOver.isCollection) {\n                return [mapOver];\n            }\n\n            var constraints = [];\n            if (!this.node.hasConnectedOutputTerminals()) {\n                _.each(this.node.connectedMappedInputTerminals(), function(\n                    inputTerminal\n                ) {\n                    constraints.push(inputTerminal.mapOver());\n                });\n            } else {\n                // All outputs should have same mapOver status - least specific.\n                constraints.push(\n                    _.first(_.values(this.node.output_terminals)).mapOver()\n                );\n            }\n            return constraints;\n        },\n        _producesAcceptableDatatype: function(other) {\n            // other is a non-collection output...\n            for (var t in this.datatypes) {\n                var thisDatatype = this.datatypes[t];\n                if (thisDatatype == \"input\") {\n                    return true;\n                }\n                var cat_outputs = new Array();\n                cat_outputs = cat_outputs.concat(other.datatypes);\n                if (other.node.post_job_actions) {\n                    for (var pja_i in other.node.post_job_actions) {\n                        var pja = other.node.post_job_actions[pja_i];\n                        if (\n                            pja.action_type == \"ChangeDatatypeAction\" &&\n                            (pja.output_name == \"\" ||\n                                pja.output_name == other.name) &&\n                            pja.action_arguments\n                        ) {\n                            cat_outputs.push(pja.action_arguments[\"newtype\"]);\n                        }\n                    }\n                }\n                // FIXME: No idea what to do about case when datatype is 'input'\n                for (var other_datatype_i in cat_outputs) {\n                    var other_datatype = cat_outputs[other_datatype_i];\n                    if (\n                        other_datatype == \"input\" ||\n                        other_datatype == \"_sniff_\" ||\n                        other_datatype == \"input_collection\" ||\n                        Globals.app.isSubType(\n                            cat_outputs[other_datatype_i],\n                            thisDatatype\n                        )\n                    ) {\n                        return true;\n                    }\n                }\n            }\n            return false;\n        },\n        _otherCollectionType: function(other) {\n            var otherCollectionType = NULL_COLLECTION_TYPE_DESCRIPTION;\n            if (other.isCollection) {\n                otherCollectionType = other.collectionType;\n            }\n            var otherMapOver = other.mapOver();\n            if (otherMapOver.isCollection) {\n                otherCollectionType = otherMapOver.append(otherCollectionType);\n            }\n            return otherCollectionType;\n        }\n    });\n\n    var InputTerminal = BaseInputTerminal.extend({\n        update: function(input) {\n            this.datatypes = input.extensions;\n            this.multiple = input.multiple;\n            this.collection = false;\n        },\n        connect: function(connector) {\n            BaseInputTerminal.prototype.connect.call(this, connector);\n            var other_output = connector.handle1;\n            if (!other_output) {\n                return;\n            }\n            var otherCollectionType = this._otherCollectionType(other_output);\n            if (otherCollectionType.isCollection) {\n                this.setMapOver(otherCollectionType);\n            }\n        },\n        attachable: function(other) {\n            var otherCollectionType = this._otherCollectionType(other);\n            var thisMapOver = this.mapOver();\n            if (otherCollectionType.isCollection) {\n                if (this.multiple) {\n                    if (this.connected() && !this._collectionAttached()) {\n                        // if single inputs attached, cannot also attach a\n                        // collection (yet...)\n                        return false;\n                    }\n                    if (otherCollectionType.rank == 1) {\n                        return this._producesAcceptableDatatype(other);\n                    } else {\n                        // TODO: Allow subcollection mapping over this as if it were\n                        // a list collection input.\n                        return false;\n                    }\n                }\n                if (\n                    thisMapOver.isCollection &&\n                    thisMapOver.canMatch(otherCollectionType)\n                ) {\n                    return this._producesAcceptableDatatype(other);\n                } else {\n                    //  Need to check if this would break constraints...\n                    var mappingConstraints = this._mappingConstraints();\n                    if (\n                        mappingConstraints.every(\n                            _.bind(\n                                otherCollectionType.canMatch,\n                                otherCollectionType\n                            )\n                        )\n                    ) {\n                        return this._producesAcceptableDatatype(other);\n                    } else {\n                        return false;\n                    }\n                }\n            } else if (thisMapOver.isCollection) {\n                // Attempting to match a non-collection output to an\n                // explicitly collection input.\n                return false;\n            }\n            return this._producesAcceptableDatatype(other);\n        }\n    });\n\n    var InputCollectionTerminal = BaseInputTerminal.extend({\n        update: function(input) {\n            this.multiple = false;\n            this.collection = true;\n            this.datatypes = input.extensions;\n            var collectionTypes = [];\n            if (input.collection_types) {\n                _.each(input.collection_types, function(collectionType) {\n                    collectionTypes.push(\n                        new CollectionTypeDescription(collectionType)\n                    );\n                });\n            } else {\n                collectionTypes.push(ANY_COLLECTION_TYPE_DESCRIPTION);\n            }\n            this.collectionTypes = collectionTypes;\n        },\n        connect: function(connector) {\n            BaseInputTerminal.prototype.connect.call(this, connector);\n            var other = connector.handle1;\n            if (!other) {\n                return;\n            }\n\n            var effectiveMapOver = this._effectiveMapOver(other);\n            this.setMapOver(effectiveMapOver);\n        },\n        _effectiveMapOver: function(other) {\n            var collectionTypes = this.collectionTypes;\n            var otherCollectionType = this._otherCollectionType(other);\n            var canMatch = _.some(collectionTypes, function(collectionType) {\n                return collectionType.canMatch(otherCollectionType);\n            });\n\n            if (!canMatch) {\n                for (var collectionTypeIndex in collectionTypes) {\n                    var collectionType = collectionTypes[collectionTypeIndex];\n                    if (otherCollectionType.canMapOver(collectionType)) {\n                        var effectiveMapOver = otherCollectionType.effectiveMapOver(\n                            collectionType\n                        );\n                        if (\n                            effectiveMapOver != NULL_COLLECTION_TYPE_DESCRIPTION\n                        ) {\n                            return effectiveMapOver;\n                        }\n                    }\n                }\n            }\n            return NULL_COLLECTION_TYPE_DESCRIPTION;\n        },\n        _effectiveCollectionTypes: function() {\n            var thisMapOver = this.mapOver();\n            return _.map(this.collectionTypes, function(t) {\n                return thisMapOver.append(t);\n            });\n        },\n        attachable: function(other) {\n            var otherCollectionType = this._otherCollectionType(other);\n            if (otherCollectionType.isCollection) {\n                var effectiveCollectionTypes = this._effectiveCollectionTypes();\n                var thisMapOver = this.mapOver();\n                var canMatch = _.some(effectiveCollectionTypes, function(\n                    effectiveCollectionType\n                ) {\n                    return effectiveCollectionType.canMatch(\n                        otherCollectionType\n                    );\n                });\n                if (canMatch) {\n                    // Only way a direct match...\n                    return this._producesAcceptableDatatype(other);\n                    // Otherwise we need to mapOver\n                } else if (thisMapOver.isCollection) {\n                    // In this case, mapOver already set and we didn't match skipping...\n                    return false;\n                } else if (\n                    _.some(this.collectionTypes, function(collectionType) {\n                        return otherCollectionType.canMapOver(collectionType);\n                    })\n                ) {\n                    var effectiveMapOver = this._effectiveMapOver(other);\n                    if (!effectiveMapOver.isCollection) {\n                        return false;\n                    }\n                    //  Need to check if this would break constraints...\n                    var mappingConstraints = this._mappingConstraints();\n                    if (mappingConstraints.every(effectiveMapOver.canMatch)) {\n                        return this._producesAcceptableDatatype(other);\n                    }\n                }\n            }\n            return false;\n        }\n    });\n\n    var OutputCollectionTerminal = Terminal.extend({\n        initialize: function(attr) {\n            Terminal.prototype.initialize.call(this, attr);\n            this.datatypes = attr.datatypes;\n            if (attr.collection_type) {\n                this.collectionType = new CollectionTypeDescription(\n                    attr.collection_type\n                );\n            } else {\n                var collectionTypeSource = attr.collection_type_source;\n                if (!collectionTypeSource) {\n                    console.log(\n                        \"Warning: No collection type or collection type source defined.\"\n                    );\n                }\n                this.collectionType = ANY_COLLECTION_TYPE_DESCRIPTION;\n            }\n            this.isCollection = true;\n        },\n        update: function(output) {\n            var newCollectionType;\n            if (output.collection_type) {\n                newCollectionType = new CollectionTypeDescription(\n                    output.collection_type\n                );\n            } else {\n                var collectionTypeSource = output.collection_type_source;\n                if (!collectionTypeSource) {\n                    console.log(\n                        \"Warning: No collection type or collection type source defined.\"\n                    );\n                }\n                newCollectionType = ANY_COLLECTION_TYPE_DESCRIPTION;\n            }\n\n            if (\n                newCollectionType.collectionType !=\n                this.collectionType.collectionType\n            ) {\n                _.each(this.connectors, function(connector) {\n                    // TODO: consider checking if connection valid before removing...\n                    connector.destroy();\n                });\n            }\n            this.collectionType = newCollectionType;\n        }\n    });\n\n    return {\n        InputTerminal: InputTerminal,\n        OutputTerminal: OutputTerminal,\n        InputCollectionTerminal: InputCollectionTerminal,\n        OutputCollectionTerminal: OutputCollectionTerminal,\n        TerminalMapping: TerminalMapping,\n\n        // test export\n        CollectionTypeDescription: CollectionTypeDescription,\n        NULL_COLLECTION_TYPE_DESCRIPTION: NULL_COLLECTION_TYPE_DESCRIPTION,\n        ANY_COLLECTION_TYPE_DESCRIPTION: ANY_COLLECTION_TYPE_DESCRIPTION\n    };\n});\n"]}