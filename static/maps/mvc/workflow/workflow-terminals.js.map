{"version":3,"sources":["mvc/workflow/workflow-terminals.js"],"names":["define","Globals","CollectionTypeDescription","collectionType","this","length","$","extend","rank","prototype","append","otherCollectionTypeDescription","NULL_COLLECTION_TYPE_DESCRIPTION","ANY_COLLECTION_TYPE_DESCRIPTION","otherCollectionType","canMatch","canMapOver","requiredSuffix","_endsWith","effectiveMapOver","equal","toString","str","suffix","indexOf","isCollection","other","TerminalMapping","Backbone","Model","mapOver","terminal","attr","terminalMapping","initialize","setMapOver","disableMapOver","collectionTypeDescription","Terminal","trigger","element","connectors","connect","connector","node","markChanged","push","resetMappingIfNeeded","redraw","each","_","c","destroy","slice","destroyInvalidConnections","val","multiple","output_terminals","outputTerminal","isMappedOver","resetMapping","OutputTerminal","call","datatypes","hasConnectedOutputTerminals","hasConnectedMappedInputTerminals","mappedInputTerminals","mappedInput","noMappedInputs","connectedInput","handle2","BaseInputTerminal","update","input","canAccept","_inputFilled","reset","connected","inputFilled","_collectionAttached","inputsFilled","firstOutput","handle1","_mappingConstraints","connectedMappedInputTerminals","inputTerminal","constraints","_producesAcceptableDatatype","t","thisDatatype","cat_outputs","pja_i","post_job_actions","pja","output_name","name","action_arguments","concat","other_datatype","other_datatype_i","app","isSubType","_otherCollectionType","otherMapOver","extensions","collection","other_output","attachable","thisMapOver","InputCollectionTerminal","collection_types","collectionTypes","_effectiveMapOver","_effectiveCollectionTypes","map","effectiveCollectionType","effectiveCollectionTypes","every","mappingConstraints","output","newCollectionType","collection_type"],"mappings":"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","file":"../../../scripts/mvc/workflow/workflow-terminals.js","sourcesContent":["define(['mvc/workflow/workflow-globals'], function( Globals ) {\n    function CollectionTypeDescription( collectionType ) {\n        this.collectionType = collectionType;\n        this.isCollection = true;\n        this.rank = collectionType.split(\":\").length;\n    }\n    $.extend( CollectionTypeDescription.prototype, {\n        append: function( otherCollectionTypeDescription ) {\n            if( otherCollectionTypeDescription === NULL_COLLECTION_TYPE_DESCRIPTION ) {\n                return this;\n            }\n            if( otherCollectionTypeDescription === ANY_COLLECTION_TYPE_DESCRIPTION ) {\n                return otherCollectionType;\n            }\n            return new CollectionTypeDescription( this.collectionType + \":\" + otherCollectionTypeDescription.collectionType );\n        },\n        canMatch: function( otherCollectionTypeDescription ) {\n            if( otherCollectionTypeDescription === NULL_COLLECTION_TYPE_DESCRIPTION ) {\n                return false;\n            }\n            if( otherCollectionTypeDescription === ANY_COLLECTION_TYPE_DESCRIPTION ) {\n                return true;\n            }\n            return otherCollectionTypeDescription.collectionType == this.collectionType;\n        },\n        canMapOver: function( otherCollectionTypeDescription ) {\n            if( otherCollectionTypeDescription === NULL_COLLECTION_TYPE_DESCRIPTION ) {\n                return false;\n            }\n            if( otherCollectionTypeDescription === ANY_COLLECTION_TYPE_DESCRIPTION ) {\n                return false;\n            }\n            if( this.rank <= otherCollectionTypeDescription.rank ) {\n                // Cannot map over self...\n                return false;\n            }\n            var requiredSuffix = otherCollectionTypeDescription.collectionType\n            return this._endsWith( this.collectionType, requiredSuffix );\n        },\n        effectiveMapOver: function( otherCollectionTypeDescription ) {\n            var otherCollectionType = otherCollectionTypeDescription.collectionType;\n            var effectiveCollectionType = this.collectionType.substring( 0, this.collectionType.length - otherCollectionType.length - 1 );\n            return new CollectionTypeDescription( effectiveCollectionType );\n        },\n        equal: function( otherCollectionTypeDescription ) {\n            return otherCollectionTypeDescription.collectionType == this.collectionType;\n        },\n        toString: function() {\n            return \"CollectionType[\" + this.collectionType + \"]\";\n        },\n        _endsWith: function( str, suffix ) {\n            return str.indexOf(suffix, str.length - suffix.length) !== -1;\n        }\n    } );\n\n    NULL_COLLECTION_TYPE_DESCRIPTION = {\n        isCollection: false,\n        canMatch: function( other ) { return false; },\n        canMapOver: function( other ) {\n            return false;\n        },\n        toString: function() {\n            return \"NullCollectionType[]\";\n        },\n        append: function( otherCollectionType ) {\n            return otherCollectionType;\n        },\n        equal: function( other ) {\n            return other === this;\n        }\n    };\n\n    ANY_COLLECTION_TYPE_DESCRIPTION = {\n        isCollection: true,\n        canMatch: function( other ) { return NULL_COLLECTION_TYPE_DESCRIPTION !== other; },\n        canMapOver: function( other ) {\n            return false;\n        },\n        toString: function() {\n            return \"AnyCollectionType[]\";\n        },\n        append: function( otherCollectionType ) {\n            throw \"Cannot append to ANY_COLLECTION_TYPE_DESCRIPTION\";\n        },\n        equal: function( other ) {\n            return other === this;\n        }\n    };\n\n    var TerminalMapping = Backbone.Model.extend( {\n        initialize: function( attr ) {\n            this.mapOver = attr.mapOver || NULL_COLLECTION_TYPE_DESCRIPTION;\n            this.terminal = attr.terminal;\n            this.terminal.terminalMapping = this;\n        },\n        disableMapOver: function() {\n            this.setMapOver( NULL_COLLECTION_TYPE_DESCRIPTION );\n        },\n        setMapOver: function( collectionTypeDescription ) {\n            // TODO: Can I use \"attributes\" or something to auto trigger \"change\"\n            // event?\n            this.mapOver = collectionTypeDescription;\n            this.trigger(\"change\");\n        }\n    } );\n\n    var Terminal = Backbone.Model.extend( {\n        initialize: function( attr ) {\n            this.element = attr.element;\n            this.connectors = [];\n        },\n        connect: function ( connector ) {\n            this.connectors.push( connector );\n            if ( this.node ) {\n                this.node.markChanged();\n            }\n        },\n        disconnect: function ( connector ) {\n            this.connectors.splice( $.inArray( connector, this.connectors ), 1 );\n            if ( this.node ) {\n                this.node.markChanged();\n                this.resetMappingIfNeeded();\n            }\n        },\n        redraw: function () {\n            $.each( this.connectors, function( _, c ) {\n                c.redraw();  \n            });\n        },\n        destroy: function () {\n            $.each( this.connectors.slice(), function( _, c ) {\n                c.destroy();\n            });\n        },\n        destroyInvalidConnections: function( ) {\n            _.each( this.connectors, function( connector ) {\n                connector.destroyIfInvalid();\n            } );\n        },\n        setMapOver : function( val ) {\n            if( this.multiple ) {\n                return; // Cannot set this to be multirun...\n            }\n\n            if( ! this.mapOver().equal( val ) ) {\n                this.terminalMapping.setMapOver( val );\n                _.each( this.node.output_terminals, function( outputTerminal ) {\n                    outputTerminal.setMapOver( val );\n                } );\n            }\n        },\n        mapOver: function( ) {\n            if ( ! this.terminalMapping ) {\n                return NULL_COLLECTION_TYPE_DESCRIPTION;\n            } else {\n                return this.terminalMapping.mapOver;\n            }\n        },\n        isMappedOver: function( ) {\n            return this.terminalMapping && this.terminalMapping.mapOver.isCollection;\n        },\n        resetMapping: function() {\n            this.terminalMapping.disableMapOver();\n        },\n\n        resetMappingIfNeeded: function( ) {}, // Subclasses should override this...\n\n    } );\n\n    var OutputTerminal = Terminal.extend( {\n        initialize: function( attr ) {\n            Terminal.prototype.initialize.call( this, attr );\n            this.datatypes = attr.datatypes;\n        },\n\n        resetMappingIfNeeded: function( ) {\n            // If inputs were only mapped over to preserve\n            // an output just disconnected reset these...\n            if( ! this.node.hasConnectedOutputTerminals() && ! this.node.hasConnectedMappedInputTerminals()){\n                _.each( this.node.mappedInputTerminals(), function( mappedInput ) {\n                    mappedInput.resetMappingIfNeeded();\n                } );\n            }\n\n            var noMappedInputs = ! this.node.hasMappedOverInputTerminals();\n            if( noMappedInputs ) {\n                this.resetMapping();\n            }\n        },\n\n        resetMapping: function() {\n            this.terminalMapping.disableMapOver();\n            _.each( this.connectors, function( connector ) {\n                var connectedInput = connector.handle2;\n                if( connectedInput ) {\n                    // Not exactly right because this is still connected.\n                    // Either rewrite resetMappingIfNeeded or disconnect\n                    // and reconnect if valid.\n                    connectedInput.resetMappingIfNeeded();\n                    connector.destroyIfInvalid();\n                }\n            } );\n        }\n\n    } );\n\n    var BaseInputTerminal = Terminal.extend( {\n        initialize: function( attr ) {\n            Terminal.prototype.initialize.call( this, attr );\n            this.update( attr.input ); // subclasses should implement this...\n        },\n        canAccept: function ( other ) {\n            if( this._inputFilled() ) {\n                return false;\n            } else {\n                return this.attachable( other );\n            }\n        },\n        resetMappingIfNeeded: function( ) {\n            var mapOver = this.mapOver();\n            if( ! mapOver.isCollection ) {\n                return;\n            }\n            // No output terminals are counting on this being mapped\n            // over if connected inputs are still mapped over or if none\n            // of the outputs are connected...\n            var reset = this.node.hasConnectedMappedInputTerminals() ||\n                            ( ! this.node.hasConnectedOutputTerminals() );\n            if( reset ) {\n                this.resetMapping();\n            }\n        },\n        resetMapping: function() {\n            this.terminalMapping.disableMapOver();\n            if( ! this.node.hasMappedOverInputTerminals() ) {\n                _.each( this.node.output_terminals, function( terminal) {\n                    // This shouldn't be called if there are mapped over\n                    // outputs.\n                    terminal.resetMapping();\n                } );\n            }\n        },\n        connected: function() {\n            return this.connectors.length !== 0;\n        },\n        _inputFilled: function() {\n            var inputFilled;\n            if( ! this.connected() ) {\n                inputFilled = false;\n            } else {\n                if( this.multiple ) {\n                    if(this._collectionAttached()) {\n                        // Can only attach one collection to multiple input\n                        // data parameter.\n                        inputsFilled = true;\n                    } else {\n                        inputFilled = false;\n                    }\n                } else {\n                    inputFilled = true;\n                }\n            }\n            return inputFilled;\n        },\n        _collectionAttached: function( ) {\n            if( ! this.connected() ) {\n                return false;\n            } else {\n                var firstOutput = this.connectors[ 0 ].handle1;\n                if( ! firstOutput ){\n                    return false;\n                } else {\n                    if( firstOutput.isCollection || firstOutput.isMappedOver() || firstOutput.datatypes.indexOf( \"input_collection\" ) > 0 ) {\n                        return true;\n                    } else {\n                        return false;\n                    }\n                }\n            }\n        },\n        _mappingConstraints: function( ) {\n            // If this is a connected terminal, return list of collection types\n            // other terminals connected to node are constraining mapping to.\n            if( ! this.node ) {\n                return [];  // No node - completely unconstrained\n            }\n            var mapOver = this.mapOver();\n            if( mapOver.isCollection ) {\n                return [ mapOver ];\n            }\n\n            var constraints = [];\n            if( ! this.node.hasConnectedOutputTerminals() ) {\n                _.each( this.node.connectedMappedInputTerminals(), function( inputTerminal ) {\n                    constraints.push( inputTerminal.mapOver() );\n                } );\n            } else {\n                // All outputs should have same mapOver status - least specific.\n                constraints.push( _.first( _.values( this.node.output_terminals ) ).mapOver() );\n            }\n            return constraints;\n        },\n        _producesAcceptableDatatype: function( other ) {\n            // other is a non-collection output...\n            for ( var t in this.datatypes ) {\n                var thisDatatype = this.datatypes[t];\n                if( thisDatatype == \"input\" ) {\n                    return true;\n                }\n                var cat_outputs = new Array();\n                cat_outputs = cat_outputs.concat(other.datatypes);\n                if (other.node.post_job_actions){\n                    for (var pja_i in other.node.post_job_actions){\n                        var pja = other.node.post_job_actions[pja_i];\n                        if (pja.action_type == \"ChangeDatatypeAction\" && (pja.output_name == '' || pja.output_name == other.name) && pja.action_arguments){\n                            cat_outputs.push(pja.action_arguments['newtype']);\n                        }\n                    }\n                }\n                // FIXME: No idea what to do about case when datatype is 'input'\n                for ( var other_datatype_i in cat_outputs ) {\n                    var other_datatype = cat_outputs[other_datatype_i];\n                    if ( other_datatype == \"input\" || other_datatype == \"_sniff_\" || other_datatype == \"input_collection\" || Globals.app.isSubType( cat_outputs[other_datatype_i], thisDatatype ) ) {\n                        return true;\n                    }\n                }\n            }\n            return false;\n        },\n        _otherCollectionType: function( other ) {\n            var otherCollectionType = NULL_COLLECTION_TYPE_DESCRIPTION;\n            if( other.isCollection ) {\n                otherCollectionType = other.collectionType;\n            }\n            var otherMapOver = other.mapOver();\n            if( otherMapOver.isCollection ) {\n                otherCollectionType = otherMapOver.append(otherCollectionType);\n            }\n            return otherCollectionType;\n        },\n    } );\n\n    var InputTerminal = BaseInputTerminal.extend( {\n        update: function( input ) {\n            this.datatypes = input.extensions;\n            this.multiple = input.multiple;\n            this.collection = false;    \t\n        },\n        connect: function( connector ) {\n            BaseInputTerminal.prototype.connect.call( this, connector );\n            var other_output = connector.handle1;\n            if( ! other_output ) {\n                return;\n            }\n            var otherCollectionType = this._otherCollectionType( other_output );\n            if( otherCollectionType.isCollection ) {\n                this.setMapOver( otherCollectionType );\n            }\n        },\n        attachable: function( other ) {\n            var otherCollectionType = this._otherCollectionType( other );\n            var thisMapOver = this.mapOver();\n            if( otherCollectionType.isCollection ) {\n                if( this.multiple ) {\n                    if( this.connected() && ! this._collectionAttached() ) {\n                        // if single inputs attached, cannot also attach a\n                        // collection (yet...)\n                        return false;\n                    }\n                    if( otherCollectionType.rank == 1 ) {\n                        return this._producesAcceptableDatatype( other );\n                    } else {\n                        // TODO: Allow subcollection mapping over this as if it were\n                        // a list collection input.\n                        return false;\n                    }\n                }\n                if( thisMapOver.isCollection && thisMapOver.canMatch( otherCollectionType ) ) {\n                    return this._producesAcceptableDatatype( other );\n                } else {\n                    //  Need to check if this would break constraints...\n                    var mappingConstraints = this._mappingConstraints();\n                    if( mappingConstraints.every( _.bind( otherCollectionType.canMatch, otherCollectionType ) ) ) {\n                        return this._producesAcceptableDatatype( other );\n                    } else {\n                        return false;\n                    }\n                }\n            } else if( thisMapOver.isCollection ) {\n                // Attempting to match a non-collection output to an\n                // explicitly collection input.\n                return false;\n            }\n            return this._producesAcceptableDatatype( other );\n        }\n    });\n\n    var InputCollectionTerminal = BaseInputTerminal.extend( {\n        update: function( input ) {\n            this.multiple = false;\n            this.collection = true;\n            this.datatypes = input.extensions;\n            var collectionTypes = [];\n            if( input.collection_types ) {\n                _.each(input.collection_types, function(collectionType) {\n                    collectionTypes.push( new CollectionTypeDescription( collectionType ) );\n                });\n            } else {\n                collectionTypes.push(ANY_COLLECTION_TYPE_DESCRIPTION);\n            }\n            this.collectionTypes = collectionTypes;\n        },\n        connect: function( connector ) {\n            BaseInputTerminal.prototype.connect.call( this, connector );\n            var other = connector.handle1;\n            if( ! other ) {\n                return;\n            }\n\n            var effectiveMapOver = this._effectiveMapOver( other );\n            this.setMapOver( effectiveMapOver );\n        },\n        _effectiveMapOver: function( other ) {\n            var collectionTypes = this.collectionTypes;\n            var otherCollectionType = this._otherCollectionType( other );\n            var canMatch = _.some(collectionTypes, function( collectionType) { return collectionType.canMatch( otherCollectionType ); });\n\n            if( ! canMatch ) {\n                for( var collectionTypeIndex in collectionTypes ) {\n                    var collectionType = collectionTypes[collectionTypeIndex];\n                    if( otherCollectionType.canMapOver( collectionType ) ) {\n                        var effectiveMapOver = otherCollectionType.effectiveMapOver( collectionType );\n                        if( effectiveMapOver != NULL_COLLECTION_TYPE_DESCRIPTION ) {\n                            return effectiveMapOver;\n                        }\n                    }\n                }\n            }\n            return NULL_COLLECTION_TYPE_DESCRIPTION;\n        },\n        _effectiveCollectionTypes: function( ) {\n            var thisMapOver = this.mapOver();\n            return _.map(this.collectionTypes, function(t) { return thisMapOver.append(t); });\n        },\n        attachable: function ( other ) {\n            var otherCollectionType = this._otherCollectionType( other );\n            if( otherCollectionType.isCollection ) {\n                var effectiveCollectionTypes = this._effectiveCollectionTypes( );\n                var thisMapOver = this.mapOver();\n                var canMatch = _.some(effectiveCollectionTypes, function( effectiveCollectionType) { return effectiveCollectionType.canMatch( otherCollectionType ); });\n                if( canMatch ) {\n                    // Only way a direct match...\n                    return this._producesAcceptableDatatype( other );\n                    // Otherwise we need to mapOver\n                } else if( thisMapOver.isCollection ) {\n                    // In this case, mapOver already set and we didn't match skipping...\n                    return false;\n                } else if( _.some(this.collectionTypes, function(collectionType) { return otherCollectionType.canMapOver( collectionType ); }) ) {\n                    var effectiveMapOver = this._effectiveMapOver( other );\n                    if( ! effectiveMapOver.isCollection ) {\n                        return false;\n                    }\n                    //  Need to check if this would break constraints...\n                    var mappingConstraints = this._mappingConstraints();\n                    if( mappingConstraints.every( effectiveMapOver.canMatch ) ) {\n                        return this._producesAcceptableDatatype( other );\n                    }\n                }\n            }\n            return false;\n        }\n    });\n\n    var OutputCollectionTerminal = Terminal.extend( {\n        initialize: function( attr ) {\n            Terminal.prototype.initialize.call( this, attr );\n            this.datatypes = attr.datatypes;\n            this.collectionType = new CollectionTypeDescription( attr.collection_type );\n            this.isCollection = true;\n        },\n        update: function( output ) {\n            var newCollectionType = new CollectionTypeDescription( output.collection_type );\n            if( newCollectionType.collectionType != this.collectionType.collectionType ) {\n                _.each( this.connectors, function( connector ) {\n                    // TODO: consider checking if connection valid before removing...\n                    connector.destroy();\n                } );\n            }\n            this.collectionType = newCollectionType;\n        }\n    } );\n\n    return {\n        InputTerminal                       : InputTerminal,\n        OutputTerminal                      : OutputTerminal,\n        InputCollectionTerminal             : InputCollectionTerminal,\n        OutputCollectionTerminal            : OutputCollectionTerminal,\n        TerminalMapping                     : TerminalMapping,\n\n        // test export\n        CollectionTypeDescription           : CollectionTypeDescription,\n        NULL_COLLECTION_TYPE_DESCRIPTION    : NULL_COLLECTION_TYPE_DESCRIPTION,\n        ANY_COLLECTION_TYPE_DESCRIPTION     : ANY_COLLECTION_TYPE_DESCRIPTION\n    }\n});"]}