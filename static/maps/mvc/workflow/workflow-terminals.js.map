{"version":3,"sources":["mvc/workflow/workflow-terminals.js"],"names":["define","Globals","CollectionTypeDescription","collectionType","this","length","NULL_COLLECTION_TYPE_DESCRIPTION","isCollection","other","canMatch","toString","canMapOver","append","otherCollectionType","equal","ANY_COLLECTION_TYPE_DESCRIPTION","$","extend","prototype","otherCollectionTypeDescription","requiredSuffix","_endsWith","effectiveMapOver","substring","effectiveCollectionType","str","TerminalMapping","Backbone","Model","attr","mapOver","indexOf","suffix","terminal","terminalMapping","initialize","setMapOver","disableMapOver","collectionTypeDescription","Terminal","trigger","element","connectors","connect","connector","node","markChanged","push","resetMappingIfNeeded","redraw","each","_","c","destroy","slice","destroyInvalidConnections","val","multiple","output_terminals","outputTerminal","isMappedOver","resetMapping","OutputTerminal","call","datatypes","hasConnectedOutputTerminals","hasConnectedMappedInputTerminals","mappedInputTerminals","mappedInput","noMappedInputs","connectedInput","handle2","BaseInputTerminal","update","input","canAccept","_inputFilled","reset","connected","inputFilled","_collectionAttached","inputsFilled","firstOutput","handle1","_mappingConstraints","connectedMappedInputTerminals","inputTerminal","constraints","_producesAcceptableDatatype","t","thisDatatype","cat_outputs","pja_i","post_job_actions","pja","output_name","name","action_arguments","concat","other_datatype","other_datatype_i","app","isSubType","_otherCollectionType","otherMapOver","extensions","collection","other_output","attachable","thisMapOver","rank","InputCollectionTerminal","collection_types","collectionTypes","_effectiveMapOver","_effectiveCollectionTypes","map","effectiveCollectionTypes","every","mappingConstraints","output","newCollectionType","collection_type"],"mappings":"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","file":"../../../scripts/mvc/workflow/workflow-terminals.js","sourcesContent":["define(['mvc/workflow/workflow-globals'], function( Globals ) {\n    function CollectionTypeDescription( collectionType ) {\n        this.collectionType = collectionType;\n        this.isCollection = true;\n        this.rank = collectionType.split(\":\").length;\n    }\n\n    var NULL_COLLECTION_TYPE_DESCRIPTION = {\n        isCollection: false,\n        canMatch: function( other ) { return false; },\n        canMapOver: function( other ) {\n            return false;\n        },\n        toString: function() {\n            return \"NullCollectionType[]\";\n        },\n        append: function( otherCollectionType ) {\n            return otherCollectionType;\n        },\n        equal: function( other ) {\n            return other === this;\n        }\n    };\n\n    var ANY_COLLECTION_TYPE_DESCRIPTION = {\n        isCollection: true,\n        canMatch: function( other ) { return NULL_COLLECTION_TYPE_DESCRIPTION !== other; },\n        canMapOver: function( other ) {\n            return false;\n        },\n        toString: function() {\n            return \"AnyCollectionType[]\";\n        },\n        append: function( otherCollectionType ) {\n            throw \"Cannot append to ANY_COLLECTION_TYPE_DESCRIPTION\";\n        },\n        equal: function( other ) {\n            return other === this;\n        }\n    };\n\n    $.extend( CollectionTypeDescription.prototype, {\n        append: function( otherCollectionTypeDescription ) {\n            if( otherCollectionTypeDescription === NULL_COLLECTION_TYPE_DESCRIPTION ) {\n                return this;\n            }\n            if( otherCollectionTypeDescription === ANY_COLLECTION_TYPE_DESCRIPTION ) {\n                return otherCollectionType;\n            }\n            return new CollectionTypeDescription( this.collectionType + \":\" + otherCollectionTypeDescription.collectionType );\n        },\n        canMatch: function( otherCollectionTypeDescription ) {\n            if( otherCollectionTypeDescription === NULL_COLLECTION_TYPE_DESCRIPTION ) {\n                return false;\n            }\n            if( otherCollectionTypeDescription === ANY_COLLECTION_TYPE_DESCRIPTION ) {\n                return true;\n            }\n            return otherCollectionTypeDescription.collectionType == this.collectionType;\n        },\n        canMapOver: function( otherCollectionTypeDescription ) {\n            if( otherCollectionTypeDescription === NULL_COLLECTION_TYPE_DESCRIPTION ) {\n                return false;\n            }\n            if( otherCollectionTypeDescription === ANY_COLLECTION_TYPE_DESCRIPTION ) {\n                return false;\n            }\n            if( this.rank <= otherCollectionTypeDescription.rank ) {\n                // Cannot map over self...\n                return false;\n            }\n            var requiredSuffix = otherCollectionTypeDescription.collectionType\n            return this._endsWith( this.collectionType, requiredSuffix );\n        },\n        effectiveMapOver: function( otherCollectionTypeDescription ) {\n            var otherCollectionType = otherCollectionTypeDescription.collectionType;\n            var effectiveCollectionType = this.collectionType.substring( 0, this.collectionType.length - otherCollectionType.length - 1 );\n            return new CollectionTypeDescription( effectiveCollectionType );\n        },\n        equal: function( otherCollectionTypeDescription ) {\n            return otherCollectionTypeDescription.collectionType == this.collectionType;\n        },\n        toString: function() {\n            return \"CollectionType[\" + this.collectionType + \"]\";\n        },\n        _endsWith: function( str, suffix ) {\n            return str.indexOf(suffix, str.length - suffix.length) !== -1;\n        }\n    } );\n\n    var TerminalMapping = Backbone.Model.extend( {\n        initialize: function( attr ) {\n            this.mapOver = attr.mapOver || NULL_COLLECTION_TYPE_DESCRIPTION;\n            this.terminal = attr.terminal;\n            this.terminal.terminalMapping = this;\n        },\n        disableMapOver: function() {\n            this.setMapOver( NULL_COLLECTION_TYPE_DESCRIPTION );\n        },\n        setMapOver: function( collectionTypeDescription ) {\n            // TODO: Can I use \"attributes\" or something to auto trigger \"change\"\n            // event?\n            this.mapOver = collectionTypeDescription;\n            this.trigger(\"change\");\n        }\n    } );\n\n    var Terminal = Backbone.Model.extend( {\n        initialize: function( attr ) {\n            this.element = attr.element;\n            this.connectors = [];\n        },\n        connect: function ( connector ) {\n            this.connectors.push( connector );\n            if ( this.node ) {\n                this.node.markChanged();\n            }\n        },\n        disconnect: function ( connector ) {\n            this.connectors.splice( $.inArray( connector, this.connectors ), 1 );\n            if ( this.node ) {\n                this.node.markChanged();\n                this.resetMappingIfNeeded();\n            }\n        },\n        redraw: function () {\n            $.each( this.connectors, function( _, c ) {\n                c.redraw();  \n            });\n        },\n        destroy: function () {\n            $.each( this.connectors.slice(), function( _, c ) {\n                c.destroy();\n            });\n        },\n        destroyInvalidConnections: function( ) {\n            _.each( this.connectors, function( connector ) {\n                connector && connector.destroyIfInvalid();\n            } );\n        },\n        setMapOver : function( val ) {\n            if( this.multiple ) {\n                return; // Cannot set this to be multirun...\n            }\n\n            if( ! this.mapOver().equal( val ) ) {\n                this.terminalMapping.setMapOver( val );\n                _.each( this.node.output_terminals, function( outputTerminal ) {\n                    outputTerminal.setMapOver( val );\n                } );\n            }\n        },\n        mapOver: function( ) {\n            if ( ! this.terminalMapping ) {\n                return NULL_COLLECTION_TYPE_DESCRIPTION;\n            } else {\n                return this.terminalMapping.mapOver;\n            }\n        },\n        isMappedOver: function( ) {\n            return this.terminalMapping && this.terminalMapping.mapOver.isCollection;\n        },\n        resetMapping: function() {\n            this.terminalMapping.disableMapOver();\n        },\n\n        resetMappingIfNeeded: function( ) {}, // Subclasses should override this...\n\n    } );\n\n    var OutputTerminal = Terminal.extend( {\n        initialize: function( attr ) {\n            Terminal.prototype.initialize.call( this, attr );\n            this.datatypes = attr.datatypes;\n        },\n\n        resetMappingIfNeeded: function( ) {\n            // If inputs were only mapped over to preserve\n            // an output just disconnected reset these...\n            if( ! this.node.hasConnectedOutputTerminals() && ! this.node.hasConnectedMappedInputTerminals()){\n                _.each( this.node.mappedInputTerminals(), function( mappedInput ) {\n                    mappedInput.resetMappingIfNeeded();\n                } );\n            }\n\n            var noMappedInputs = ! this.node.hasMappedOverInputTerminals();\n            if( noMappedInputs ) {\n                this.resetMapping();\n            }\n        },\n\n        resetMapping: function() {\n            this.terminalMapping.disableMapOver();\n            _.each( this.connectors, function( connector ) {\n                var connectedInput = connector.handle2;\n                if( connectedInput ) {\n                    // Not exactly right because this is still connected.\n                    // Either rewrite resetMappingIfNeeded or disconnect\n                    // and reconnect if valid.\n                    connectedInput.resetMappingIfNeeded();\n                    connector.destroyIfInvalid();\n                }\n            } );\n        }\n\n    } );\n\n    var BaseInputTerminal = Terminal.extend( {\n        initialize: function( attr ) {\n            Terminal.prototype.initialize.call( this, attr );\n            this.update( attr.input ); // subclasses should implement this...\n        },\n        canAccept: function ( other ) {\n            if( this._inputFilled() ) {\n                return false;\n            } else {\n                return this.attachable( other );\n            }\n        },\n        resetMappingIfNeeded: function( ) {\n            var mapOver = this.mapOver();\n            if( ! mapOver.isCollection ) {\n                return;\n            }\n            // No output terminals are counting on this being mapped\n            // over if connected inputs are still mapped over or if none\n            // of the outputs are connected...\n            var reset = this.node.hasConnectedMappedInputTerminals() ||\n                            ( ! this.node.hasConnectedOutputTerminals() );\n            if( reset ) {\n                this.resetMapping();\n            }\n        },\n        resetMapping: function() {\n            this.terminalMapping.disableMapOver();\n            if( ! this.node.hasMappedOverInputTerminals() ) {\n                _.each( this.node.output_terminals, function( terminal) {\n                    // This shouldn't be called if there are mapped over\n                    // outputs.\n                    terminal.resetMapping();\n                } );\n            }\n        },\n        connected: function() {\n            return this.connectors.length !== 0;\n        },\n        _inputFilled: function() {\n            var inputFilled;\n            if( ! this.connected() ) {\n                inputFilled = false;\n            } else {\n                if( this.multiple ) {\n                    if(this._collectionAttached()) {\n                        // Can only attach one collection to multiple input\n                        // data parameter.\n                        inputsFilled = true;\n                    } else {\n                        inputFilled = false;\n                    }\n                } else {\n                    inputFilled = true;\n                }\n            }\n            return inputFilled;\n        },\n        _collectionAttached: function( ) {\n            if( ! this.connected() ) {\n                return false;\n            } else {\n                var firstOutput = this.connectors[ 0 ].handle1;\n                if( ! firstOutput ){\n                    return false;\n                } else {\n                    if( firstOutput.isCollection || firstOutput.isMappedOver() || firstOutput.datatypes.indexOf( \"input_collection\" ) > 0 ) {\n                        return true;\n                    } else {\n                        return false;\n                    }\n                }\n            }\n        },\n        _mappingConstraints: function( ) {\n            // If this is a connected terminal, return list of collection types\n            // other terminals connected to node are constraining mapping to.\n            if( ! this.node ) {\n                return [];  // No node - completely unconstrained\n            }\n            var mapOver = this.mapOver();\n            if( mapOver.isCollection ) {\n                return [ mapOver ];\n            }\n\n            var constraints = [];\n            if( ! this.node.hasConnectedOutputTerminals() ) {\n                _.each( this.node.connectedMappedInputTerminals(), function( inputTerminal ) {\n                    constraints.push( inputTerminal.mapOver() );\n                } );\n            } else {\n                // All outputs should have same mapOver status - least specific.\n                constraints.push( _.first( _.values( this.node.output_terminals ) ).mapOver() );\n            }\n            return constraints;\n        },\n        _producesAcceptableDatatype: function( other ) {\n            // other is a non-collection output...\n            for ( var t in this.datatypes ) {\n                var thisDatatype = this.datatypes[t];\n                if( thisDatatype == \"input\" ) {\n                    return true;\n                }\n                var cat_outputs = new Array();\n                cat_outputs = cat_outputs.concat(other.datatypes);\n                if (other.node.post_job_actions){\n                    for (var pja_i in other.node.post_job_actions){\n                        var pja = other.node.post_job_actions[pja_i];\n                        if (pja.action_type == \"ChangeDatatypeAction\" && (pja.output_name == '' || pja.output_name == other.name) && pja.action_arguments){\n                            cat_outputs.push(pja.action_arguments['newtype']);\n                        }\n                    }\n                }\n                // FIXME: No idea what to do about case when datatype is 'input'\n                for ( var other_datatype_i in cat_outputs ) {\n                    var other_datatype = cat_outputs[other_datatype_i];\n                    if ( other_datatype == \"input\" || other_datatype == \"_sniff_\" || other_datatype == \"input_collection\" || Globals.app.isSubType( cat_outputs[other_datatype_i], thisDatatype ) ) {\n                        return true;\n                    }\n                }\n            }\n            return false;\n        },\n        _otherCollectionType: function( other ) {\n            var otherCollectionType = NULL_COLLECTION_TYPE_DESCRIPTION;\n            if( other.isCollection ) {\n                otherCollectionType = other.collectionType;\n            }\n            var otherMapOver = other.mapOver();\n            if( otherMapOver.isCollection ) {\n                otherCollectionType = otherMapOver.append(otherCollectionType);\n            }\n            return otherCollectionType;\n        },\n    } );\n\n    var InputTerminal = BaseInputTerminal.extend( {\n        update: function( input ) {\n            this.datatypes = input.extensions;\n            this.multiple = input.multiple;\n            this.collection = false;    \t\n        },\n        connect: function( connector ) {\n            BaseInputTerminal.prototype.connect.call( this, connector );\n            var other_output = connector.handle1;\n            if( ! other_output ) {\n                return;\n            }\n            var otherCollectionType = this._otherCollectionType( other_output );\n            if( otherCollectionType.isCollection ) {\n                this.setMapOver( otherCollectionType );\n            }\n        },\n        attachable: function( other ) {\n            var otherCollectionType = this._otherCollectionType( other );\n            var thisMapOver = this.mapOver();\n            if( otherCollectionType.isCollection ) {\n                if( this.multiple ) {\n                    if( this.connected() && ! this._collectionAttached() ) {\n                        // if single inputs attached, cannot also attach a\n                        // collection (yet...)\n                        return false;\n                    }\n                    if( otherCollectionType.rank == 1 ) {\n                        return this._producesAcceptableDatatype( other );\n                    } else {\n                        // TODO: Allow subcollection mapping over this as if it were\n                        // a list collection input.\n                        return false;\n                    }\n                }\n                if( thisMapOver.isCollection && thisMapOver.canMatch( otherCollectionType ) ) {\n                    return this._producesAcceptableDatatype( other );\n                } else {\n                    //  Need to check if this would break constraints...\n                    var mappingConstraints = this._mappingConstraints();\n                    if( mappingConstraints.every( _.bind( otherCollectionType.canMatch, otherCollectionType ) ) ) {\n                        return this._producesAcceptableDatatype( other );\n                    } else {\n                        return false;\n                    }\n                }\n            } else if( thisMapOver.isCollection ) {\n                // Attempting to match a non-collection output to an\n                // explicitly collection input.\n                return false;\n            }\n            return this._producesAcceptableDatatype( other );\n        }\n    });\n\n    var InputCollectionTerminal = BaseInputTerminal.extend( {\n        update: function( input ) {\n            this.multiple = false;\n            this.collection = true;\n            this.datatypes = input.extensions;\n            var collectionTypes = [];\n            if( input.collection_types ) {\n                _.each(input.collection_types, function(collectionType) {\n                    collectionTypes.push( new CollectionTypeDescription( collectionType ) );\n                });\n            } else {\n                collectionTypes.push(ANY_COLLECTION_TYPE_DESCRIPTION);\n            }\n            this.collectionTypes = collectionTypes;\n        },\n        connect: function( connector ) {\n            BaseInputTerminal.prototype.connect.call( this, connector );\n            var other = connector.handle1;\n            if( ! other ) {\n                return;\n            }\n\n            var effectiveMapOver = this._effectiveMapOver( other );\n            this.setMapOver( effectiveMapOver );\n        },\n        _effectiveMapOver: function( other ) {\n            var collectionTypes = this.collectionTypes;\n            var otherCollectionType = this._otherCollectionType( other );\n            var canMatch = _.some(collectionTypes, function( collectionType) { return collectionType.canMatch( otherCollectionType ); });\n\n            if( ! canMatch ) {\n                for( var collectionTypeIndex in collectionTypes ) {\n                    var collectionType = collectionTypes[collectionTypeIndex];\n                    if( otherCollectionType.canMapOver( collectionType ) ) {\n                        var effectiveMapOver = otherCollectionType.effectiveMapOver( collectionType );\n                        if( effectiveMapOver != NULL_COLLECTION_TYPE_DESCRIPTION ) {\n                            return effectiveMapOver;\n                        }\n                    }\n                }\n            }\n            return NULL_COLLECTION_TYPE_DESCRIPTION;\n        },\n        _effectiveCollectionTypes: function( ) {\n            var thisMapOver = this.mapOver();\n            return _.map(this.collectionTypes, function(t) { return thisMapOver.append(t); });\n        },\n        attachable: function ( other ) {\n            var otherCollectionType = this._otherCollectionType( other );\n            if( otherCollectionType.isCollection ) {\n                var effectiveCollectionTypes = this._effectiveCollectionTypes( );\n                var thisMapOver = this.mapOver();\n                var canMatch = _.some(effectiveCollectionTypes, function( effectiveCollectionType) { return effectiveCollectionType.canMatch( otherCollectionType ); });\n                if( canMatch ) {\n                    // Only way a direct match...\n                    return this._producesAcceptableDatatype( other );\n                    // Otherwise we need to mapOver\n                } else if( thisMapOver.isCollection ) {\n                    // In this case, mapOver already set and we didn't match skipping...\n                    return false;\n                } else if( _.some(this.collectionTypes, function(collectionType) { return otherCollectionType.canMapOver( collectionType ); }) ) {\n                    var effectiveMapOver = this._effectiveMapOver( other );\n                    if( ! effectiveMapOver.isCollection ) {\n                        return false;\n                    }\n                    //  Need to check if this would break constraints...\n                    var mappingConstraints = this._mappingConstraints();\n                    if( mappingConstraints.every( effectiveMapOver.canMatch ) ) {\n                        return this._producesAcceptableDatatype( other );\n                    }\n                }\n            }\n            return false;\n        }\n    });\n\n    var OutputCollectionTerminal = Terminal.extend( {\n        initialize: function( attr ) {\n            Terminal.prototype.initialize.call( this, attr );\n            this.datatypes = attr.datatypes;\n            this.collectionType = new CollectionTypeDescription( attr.collection_type );\n            this.isCollection = true;\n        },\n        update: function( output ) {\n            var newCollectionType = new CollectionTypeDescription( output.collection_type );\n            if( newCollectionType.collectionType != this.collectionType.collectionType ) {\n                _.each( this.connectors, function( connector ) {\n                    // TODO: consider checking if connection valid before removing...\n                    connector.destroy();\n                } );\n            }\n            this.collectionType = newCollectionType;\n        }\n    } );\n\n    return {\n        InputTerminal                       : InputTerminal,\n        OutputTerminal                      : OutputTerminal,\n        InputCollectionTerminal             : InputCollectionTerminal,\n        OutputCollectionTerminal            : OutputCollectionTerminal,\n        TerminalMapping                     : TerminalMapping,\n\n        // test export\n        CollectionTypeDescription           : CollectionTypeDescription,\n        NULL_COLLECTION_TYPE_DESCRIPTION    : NULL_COLLECTION_TYPE_DESCRIPTION,\n        ANY_COLLECTION_TYPE_DESCRIPTION     : ANY_COLLECTION_TYPE_DESCRIPTION\n    }\n});"]}