{"version":3,"sources":["mvc/workflow/workflow-terminals.js"],"names":["define","Globals","CollectionTypeDescription","collectionType","this","isCollection","rank","split","length","$","extend","prototype","append","otherCollectionTypeDescription","NULL_COLLECTION_TYPE_DESCRIPTION","ANY_COLLECTION_TYPE_DESCRIPTION","otherCollectionType","canMatch","canMapOver","requiredSuffix","_endsWith","effectiveMapOver","substring","equal","toString","str","suffix","indexOf","other","TerminalMapping","Backbone","Model","initialize","attr","mapOver","terminal","terminalMapping","disableMapOver","setMapOver","collectionTypeDescription","trigger","Terminal","element","connectors","connect","connector","push","node","markChanged","disconnect","splice","inArray","resetMappingIfNeeded","redraw","each","_","c","destroy","slice","destroyInvalidConnections","destroyIfInvalid","val","multiple","output_terminals","outputTerminal","isMappedOver","resetMapping","OutputTerminal","call","datatypes","hasConnectedOutputTerminals","hasConnectedMappedInputTerminals","mappedInputTerminals","mappedInput","hasMappedOverInputTerminals","connectedInput","handle2","BaseInputTerminal","update","input","canAccept","_inputFilled","attachable","connected","inputFilled","_collectionAttached","inputsFilled","firstOutput","handle1","_mappingConstraints","constraints","first","values","connectedMappedInputTerminals","inputTerminal","_producesAcceptableDatatype","t","thisDatatype","cat_outputs","Array","concat","post_job_actions","pja_i","pja","action_type","output_name","name","action_arguments","other_datatype_i","other_datatype","app","isSubType","_otherCollectionType","otherMapOver","InputTerminal","extensions","collection","other_output","thisMapOver","every","bind","InputCollectionTerminal","collectionTypes","collection_types","_effectiveMapOver","some","collectionTypeIndex","_effectiveCollectionTypes","map","effectiveCollectionTypes","effectiveCollectionType","OutputCollectionTerminal","collection_type","output","newCollectionType"],"mappings":"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","file":"../../../scripts/mvc/workflow/workflow-terminals.js","sourcesContent":["define(['mvc/workflow/workflow-globals'], function( Globals ) {\n    function CollectionTypeDescription( collectionType ) {\n        this.collectionType = collectionType;\n        this.isCollection = true;\n        this.rank = collectionType.split(\":\").length;\n    }\n    $.extend( CollectionTypeDescription.prototype, {\n        append: function( otherCollectionTypeDescription ) {\n            if( otherCollectionTypeDescription === NULL_COLLECTION_TYPE_DESCRIPTION ) {\n                return this;\n            }\n            if( otherCollectionTypeDescription === ANY_COLLECTION_TYPE_DESCRIPTION ) {\n                return otherCollectionType;\n            }\n            return new CollectionTypeDescription( this.collectionType + \":\" + otherCollectionTypeDescription.collectionType );\n        },\n        canMatch: function( otherCollectionTypeDescription ) {\n            if( otherCollectionTypeDescription === NULL_COLLECTION_TYPE_DESCRIPTION ) {\n                return false;\n            }\n            if( otherCollectionTypeDescription === ANY_COLLECTION_TYPE_DESCRIPTION ) {\n                return true;\n            }\n            return otherCollectionTypeDescription.collectionType == this.collectionType;\n        },\n        canMapOver: function( otherCollectionTypeDescription ) {\n            if( otherCollectionTypeDescription === NULL_COLLECTION_TYPE_DESCRIPTION ) {\n                return false;\n            }\n            if( otherCollectionTypeDescription === ANY_COLLECTION_TYPE_DESCRIPTION ) {\n                return false;\n            }\n            if( this.rank <= otherCollectionTypeDescription.rank ) {\n                // Cannot map over self...\n                return false;\n            }\n            var requiredSuffix = otherCollectionTypeDescription.collectionType\n            return this._endsWith( this.collectionType, requiredSuffix );\n        },\n        effectiveMapOver: function( otherCollectionTypeDescription ) {\n            var otherCollectionType = otherCollectionTypeDescription.collectionType;\n            var effectiveCollectionType = this.collectionType.substring( 0, this.collectionType.length - otherCollectionType.length - 1 );\n            return new CollectionTypeDescription( effectiveCollectionType );\n        },\n        equal: function( otherCollectionTypeDescription ) {\n            return otherCollectionTypeDescription.collectionType == this.collectionType;\n        },\n        toString: function() {\n            return \"CollectionType[\" + this.collectionType + \"]\";\n        },\n        _endsWith: function( str, suffix ) {\n            return str.indexOf(suffix, str.length - suffix.length) !== -1;\n        }\n    } );\n\n    NULL_COLLECTION_TYPE_DESCRIPTION = {\n        isCollection: false,\n        canMatch: function( other ) { return false; },\n        canMapOver: function( other ) {\n            return false;\n        },\n        toString: function() {\n            return \"NullCollectionType[]\";\n        },\n        append: function( otherCollectionType ) {\n            return otherCollectionType;\n        },\n        equal: function( other ) {\n            return other === this;\n        }\n    };\n\n    ANY_COLLECTION_TYPE_DESCRIPTION = {\n        isCollection: true,\n        canMatch: function( other ) { return NULL_COLLECTION_TYPE_DESCRIPTION !== other; },\n        canMapOver: function( other ) {\n            return false;\n        },\n        toString: function() {\n            return \"AnyCollectionType[]\";\n        },\n        append: function( otherCollectionType ) {\n            throw \"Cannot append to ANY_COLLECTION_TYPE_DESCRIPTION\";\n        },\n        equal: function( other ) {\n            return other === this;\n        }\n    };\n\n    var TerminalMapping = Backbone.Model.extend( {\n        initialize: function( attr ) {\n            this.mapOver = attr.mapOver || NULL_COLLECTION_TYPE_DESCRIPTION;\n            this.terminal = attr.terminal;\n            this.terminal.terminalMapping = this;\n        },\n        disableMapOver: function() {\n            this.setMapOver( NULL_COLLECTION_TYPE_DESCRIPTION );\n        },\n        setMapOver: function( collectionTypeDescription ) {\n            // TODO: Can I use \"attributes\" or something to auto trigger \"change\"\n            // event?\n            this.mapOver = collectionTypeDescription;\n            this.trigger(\"change\");\n        }\n    } );\n\n    var Terminal = Backbone.Model.extend( {\n        initialize: function( attr ) {\n            this.element = attr.element;\n            this.connectors = [];\n        },\n        connect: function ( connector ) {\n            this.connectors.push( connector );\n            if ( this.node ) {\n                this.node.markChanged();\n            }\n        },\n        disconnect: function ( connector ) {\n            this.connectors.splice( $.inArray( connector, this.connectors ), 1 );\n            if ( this.node ) {\n                this.node.markChanged();\n                this.resetMappingIfNeeded();\n            }\n        },\n        redraw: function () {\n            $.each( this.connectors, function( _, c ) {\n                c.redraw();  \n            });\n        },\n        destroy: function () {\n            $.each( this.connectors.slice(), function( _, c ) {\n                c.destroy();\n            });\n        },\n        destroyInvalidConnections: function( ) {\n            _.each( this.connectors, function( connector ) {\n                connector.destroyIfInvalid();\n            } );\n        },\n        setMapOver : function( val ) {\n            if( this.multiple ) {\n                return; // Cannot set this to be multirun...\n            }\n\n            if( ! this.mapOver().equal( val ) ) {\n                this.terminalMapping.setMapOver( val );\n                _.each( this.node.output_terminals, function( outputTerminal ) {\n                    outputTerminal.setMapOver( val );\n                } );\n            }\n        },\n        mapOver: function( ) {\n            if ( ! this.terminalMapping ) {\n                return NULL_COLLECTION_TYPE_DESCRIPTION;\n            } else {\n                return this.terminalMapping.mapOver;\n            }\n        },\n        isMappedOver: function( ) {\n            return this.terminalMapping && this.terminalMapping.mapOver.isCollection;\n        },\n        resetMapping: function() {\n            this.terminalMapping.disableMapOver();\n        },\n\n        resetMappingIfNeeded: function( ) {}, // Subclasses should override this...\n\n    } );\n\n    var OutputTerminal = Terminal.extend( {\n        initialize: function( attr ) {\n            Terminal.prototype.initialize.call( this, attr );\n            this.datatypes = attr.datatypes;\n        },\n\n        resetMappingIfNeeded: function( ) {\n            // If inputs were only mapped over to preserve\n            // an output just disconnected reset these...\n            if( ! this.node.hasConnectedOutputTerminals() && ! this.node.hasConnectedMappedInputTerminals()){\n                _.each( this.node.mappedInputTerminals(), function( mappedInput ) {\n                    mappedInput.resetMappingIfNeeded();\n                } );\n            }\n\n            var noMappedInputs = ! this.node.hasMappedOverInputTerminals();\n            if( noMappedInputs ) {\n                this.resetMapping();\n            }\n        },\n\n        resetMapping: function() {\n            this.terminalMapping.disableMapOver();\n            _.each( this.connectors, function( connector ) {\n                var connectedInput = connector.handle2;\n                if( connectedInput ) {\n                    // Not exactly right because this is still connected.\n                    // Either rewrite resetMappingIfNeeded or disconnect\n                    // and reconnect if valid.\n                    connectedInput.resetMappingIfNeeded();\n                    connector.destroyIfInvalid();\n                }\n            } );\n        }\n\n    } );\n\n    var BaseInputTerminal = Terminal.extend( {\n        initialize: function( attr ) {\n            Terminal.prototype.initialize.call( this, attr );\n            this.update( attr.input ); // subclasses should implement this...\n        },\n        canAccept: function ( other ) {\n            if( this._inputFilled() ) {\n                return false;\n            } else {\n                return this.attachable( other );\n            }\n        },\n        resetMappingIfNeeded: function( ) {\n            var mapOver = this.mapOver();\n            if( ! mapOver.isCollection ) {\n                return;\n            }\n            // No output terminals are counting on this being mapped\n            // over if connected inputs are still mapped over or if none\n            // of the outputs are connected...\n            var reset = this.node.hasConnectedMappedInputTerminals() ||\n                            ( ! this.node.hasConnectedOutputTerminals() );\n            if( reset ) {\n                this.resetMapping();\n            }\n        },\n        resetMapping: function() {\n            this.terminalMapping.disableMapOver();\n            if( ! this.node.hasMappedOverInputTerminals() ) {\n                _.each( this.node.output_terminals, function( terminal) {\n                    // This shouldn't be called if there are mapped over\n                    // outputs.\n                    terminal.resetMapping();\n                } );\n            }\n        },\n        connected: function() {\n            return this.connectors.length !== 0;\n        },\n        _inputFilled: function() {\n            var inputFilled;\n            if( ! this.connected() ) {\n                inputFilled = false;\n            } else {\n                if( this.multiple ) {\n                    if(this._collectionAttached()) {\n                        // Can only attach one collection to multiple input\n                        // data parameter.\n                        inputsFilled = true;\n                    } else {\n                        inputFilled = false;\n                    }\n                } else {\n                    inputFilled = true;\n                }\n            }\n            return inputFilled;\n        },\n        _collectionAttached: function( ) {\n            if( ! this.connected() ) {\n                return false;\n            } else {\n                var firstOutput = this.connectors[ 0 ].handle1;\n                if( ! firstOutput ){\n                    return false;\n                } else {\n                    if( firstOutput.isCollection || firstOutput.isMappedOver() || firstOutput.datatypes.indexOf( \"input_collection\" ) > 0 ) {\n                        return true;\n                    } else {\n                        return false;\n                    }\n                }\n            }\n        },\n        _mappingConstraints: function( ) {\n            // If this is a connected terminal, return list of collection types\n            // other terminals connected to node are constraining mapping to.\n            if( ! this.node ) {\n                return [];  // No node - completely unconstrained\n            }\n            var mapOver = this.mapOver();\n            if( mapOver.isCollection ) {\n                return [ mapOver ];\n            }\n\n            var constraints = [];\n            if( ! this.node.hasConnectedOutputTerminals() ) {\n                _.each( this.node.connectedMappedInputTerminals(), function( inputTerminal ) {\n                    constraints.push( inputTerminal.mapOver() );\n                } );\n            } else {\n                // All outputs should have same mapOver status - least specific.\n                constraints.push( _.first( _.values( this.node.output_terminals ) ).mapOver() );\n            }\n            return constraints;\n        },\n        _producesAcceptableDatatype: function( other ) {\n            // other is a non-collection output...\n            for ( var t in this.datatypes ) {\n                var thisDatatype = this.datatypes[t];\n                if( thisDatatype == \"input\" ) {\n                    return true;\n                }\n                var cat_outputs = new Array();\n                cat_outputs = cat_outputs.concat(other.datatypes);\n                if (other.node.post_job_actions){\n                    for (var pja_i in other.node.post_job_actions){\n                        var pja = other.node.post_job_actions[pja_i];\n                        if (pja.action_type == \"ChangeDatatypeAction\" && (pja.output_name == '' || pja.output_name == other.name) && pja.action_arguments){\n                            cat_outputs.push(pja.action_arguments['newtype']);\n                        }\n                    }\n                }\n                // FIXME: No idea what to do about case when datatype is 'input'\n                for ( var other_datatype_i in cat_outputs ) {\n                    var other_datatype = cat_outputs[other_datatype_i];\n                    if ( other_datatype == \"input\" || other_datatype == \"_sniff_\" || other_datatype == \"input_collection\" || Globals.app.isSubType( cat_outputs[other_datatype_i], thisDatatype ) ) {\n                        return true;\n                    }\n                }\n            }\n            return false;\n        },\n        _otherCollectionType: function( other ) {\n            var otherCollectionType = NULL_COLLECTION_TYPE_DESCRIPTION;\n            if( other.isCollection ) {\n                otherCollectionType = other.collectionType;\n            }\n            var otherMapOver = other.mapOver();\n            if( otherMapOver.isCollection ) {\n                otherCollectionType = otherMapOver.append(otherCollectionType);\n            }\n            return otherCollectionType;\n        },\n    } );\n\n    var InputTerminal = BaseInputTerminal.extend( {\n        update: function( input ) {\n            this.datatypes = input.extensions;\n            this.multiple = input.multiple;\n            this.collection = false;    \t\n        },\n        connect: function( connector ) {\n            BaseInputTerminal.prototype.connect.call( this, connector );\n            var other_output = connector.handle1;\n            if( ! other_output ) {\n                return;\n            }\n            var otherCollectionType = this._otherCollectionType( other_output );\n            if( otherCollectionType.isCollection ) {\n                this.setMapOver( otherCollectionType );\n            }\n        },\n        attachable: function( other ) {\n            var otherCollectionType = this._otherCollectionType( other );\n            var thisMapOver = this.mapOver();\n            if( otherCollectionType.isCollection ) {\n                if( this.multiple ) {\n                    if( this.connected() && ! this._collectionAttached() ) {\n                        // if single inputs attached, cannot also attach a\n                        // collection (yet...)\n                        return false;\n                    }\n                    if( otherCollectionType.rank == 1 ) {\n                        return this._producesAcceptableDatatype( other );\n                    } else {\n                        // TODO: Allow subcollection mapping over this as if it were\n                        // a list collection input.\n                        return false;\n                    }\n                }\n                if( thisMapOver.isCollection && thisMapOver.canMatch( otherCollectionType ) ) {\n                    return this._producesAcceptableDatatype( other );\n                } else {\n                    //  Need to check if this would break constraints...\n                    var mappingConstraints = this._mappingConstraints();\n                    if( mappingConstraints.every( _.bind( otherCollectionType.canMatch, otherCollectionType ) ) ) {\n                        return this._producesAcceptableDatatype( other );\n                    } else {\n                        return false;\n                    }\n                }\n            } else if( thisMapOver.isCollection ) {\n                // Attempting to match a non-collection output to an\n                // explicitly collection input.\n                return false;\n            }\n            return this._producesAcceptableDatatype( other );\n        }\n    });\n\n    var InputCollectionTerminal = BaseInputTerminal.extend( {\n        update: function( input ) {\n            this.multiple = false;\n            this.collection = true;\n            this.datatypes = input.extensions;\n            var collectionTypes = [];\n            if( input.collection_types ) {\n                _.each(input.collection_types, function(collectionType) {\n                    collectionTypes.push( new CollectionTypeDescription( collectionType ) );\n                });\n            } else {\n                collectionTypes.push(ANY_COLLECTION_TYPE_DESCRIPTION);\n            }\n            this.collectionTypes = collectionTypes;\n        },\n        connect: function( connector ) {\n            BaseInputTerminal.prototype.connect.call( this, connector );\n            var other = connector.handle1;\n            if( ! other ) {\n                return;\n            }\n\n            var effectiveMapOver = this._effectiveMapOver( other );\n            this.setMapOver( effectiveMapOver );\n        },\n        _effectiveMapOver: function( other ) {\n            var collectionTypes = this.collectionTypes;\n            var otherCollectionType = this._otherCollectionType( other );\n            var canMatch = _.some(collectionTypes, function( collectionType) { return collectionType.canMatch( otherCollectionType ); });\n\n            if( ! canMatch ) {\n                for( var collectionTypeIndex in collectionTypes ) {\n                    var collectionType = collectionTypes[collectionTypeIndex];\n                    var effectiveMapOver = otherCollectionType.effectiveMapOver( collectionType );\n                    if( effectiveMapOver != NULL_COLLECTION_TYPE_DESCRIPTION ) {\n                        return effectiveMapOver;\n                    }\n                }\n            }\n            return NULL_COLLECTION_TYPE_DESCRIPTION;\n        },\n        _effectiveCollectionTypes: function( ) {\n            var thisMapOver = this.mapOver();\n            return _.map(this.collectionTypes, function(t) { return thisMapOver.append(t); });\n        },\n        attachable: function ( other ) {\n            var otherCollectionType = this._otherCollectionType( other );\n            if( otherCollectionType.isCollection ) {\n                var effectiveCollectionTypes = this._effectiveCollectionTypes( );\n                var thisMapOver = this.mapOver();\n                var canMatch = _.some(effectiveCollectionTypes, function( effectiveCollectionType) { return effectiveCollectionType.canMatch( otherCollectionType ); });\n                if( canMatch ) {\n                    // Only way a direct match...\n                    return this._producesAcceptableDatatype( other );\n                    // Otherwise we need to mapOver\n                } else if( thisMapOver.isCollection ) {\n                    // In this case, mapOver already set and we didn't match skipping...\n                    return false;\n                } else if( _.some(this.collectionTypes, function(collectionType) { return otherCollectionType.canMapOver( collectionType ); }) ) {\n                    var effectiveMapOver = this._effectiveMapOver( other );\n                    if( ! effectiveMapOver.isCollection ) {\n                        return false;\n                    }\n                    //  Need to check if this would break constraints...\n                    var mappingConstraints = this._mappingConstraints();\n                    if( mappingConstraints.every( effectiveMapOver.canMatch ) ) {\n                        return this._producesAcceptableDatatype( other );\n                    }\n                }\n            }\n            return false;\n        }\n    });\n\n    var OutputCollectionTerminal = Terminal.extend( {\n        initialize: function( attr ) {\n            Terminal.prototype.initialize.call( this, attr );\n            this.datatypes = attr.datatypes;\n            this.collectionType = new CollectionTypeDescription( attr.collection_type );\n            this.isCollection = true;\n        },\n        update: function( output ) {\n            var newCollectionType = new CollectionTypeDescription( output.collection_type );\n            if( newCollectionType.collectionType != this.collectionType.collectionType ) {\n                _.each( this.connectors, function( connector ) {\n                    // TODO: consider checking if connection valid before removing...\n                    connector.destroy();\n                } );\n            }\n            this.collectionType = newCollectionType;\n        }\n    } );\n\n    return {\n        InputTerminal                       : InputTerminal,\n        OutputTerminal                      : OutputTerminal,\n        InputCollectionTerminal             : InputCollectionTerminal,\n        OutputCollectionTerminal            : OutputCollectionTerminal,\n        TerminalMapping                     : TerminalMapping,\n\n        // test export\n        CollectionTypeDescription           : CollectionTypeDescription,\n        NULL_COLLECTION_TYPE_DESCRIPTION    : NULL_COLLECTION_TYPE_DESCRIPTION,\n        ANY_COLLECTION_TYPE_DESCRIPTION     : ANY_COLLECTION_TYPE_DESCRIPTION\n    }\n});"]}