{"version":3,"sources":["mvc/workflow/workflow-terminals.js"],"names":["define","Globals","CollectionTypeDescription","collectionType","this","length","$","extend","rank","prototype","append","otherCollectionTypeDescription","NULL_COLLECTION_TYPE_DESCRIPTION","ANY_COLLECTION_TYPE_DESCRIPTION","otherCollectionType","canMatch","canMapOver","requiredSuffix","_endsWith","effectiveMapOver","equal","toString","str","suffix","indexOf","isCollection","other","TerminalMapping","Backbone","Model","mapOver","terminal","attr","terminalMapping","initialize","setMapOver","disableMapOver","collectionTypeDescription","Terminal","trigger","element","connectors","connect","connector","node","markChanged","push","resetMappingIfNeeded","redraw","each","_","c","destroy","slice","destroyInvalidConnections","val","multiple","output_terminals","outputTerminal","isMappedOver","resetMapping","OutputTerminal","call","datatypes","hasConnectedOutputTerminals","hasConnectedMappedInputTerminals","mappedInputTerminals","mappedInput","connectedInput","handle2","destroyIfInvalid","BaseInputTerminal","update","input","attachable","hasMappedOverInputTerminals","connected","inputFilled","inputsFilled","_collectionAttached","_inputFilled","firstOutput","handle1","_mappingConstraints","constraints","first","values","connectedMappedInputTerminals","inputTerminal","_producesAcceptableDatatype","t","thisDatatype","Array","cat_outputs","concat","post_job_actions","pja","output_name","name","action_arguments","other_datatype_i","other_datatype","app","isSubType","_otherCollectionType","otherMapOver","InputTerminal","extensions","collection","other_output","thisMapOver","every","bind","InputCollectionTerminal","collectionTypes","_effectiveMapOver","some","_effectiveCollectionTypes","map","effectiveCollectionTypes","effectiveCollectionType","mappingConstraints","collection_type","output","newCollectionType"],"mappings":"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","file":"../../../scripts/mvc/workflow/workflow-terminals.js","sourcesContent":["define(['mvc/workflow/workflow-globals'], function( Globals ) {\n    function CollectionTypeDescription( collectionType ) {\n        this.collectionType = collectionType;\n        this.isCollection = true;\n        this.rank = collectionType.split(\":\").length;\n    }\n    $.extend( CollectionTypeDescription.prototype, {\n        append: function( otherCollectionTypeDescription ) {\n            if( otherCollectionTypeDescription === NULL_COLLECTION_TYPE_DESCRIPTION ) {\n                return this;\n            }\n            if( otherCollectionTypeDescription === ANY_COLLECTION_TYPE_DESCRIPTION ) {\n                return otherCollectionType;\n            }\n            return new CollectionTypeDescription( this.collectionType + \":\" + otherCollectionTypeDescription.collectionType );\n        },\n        canMatch: function( otherCollectionTypeDescription ) {\n            if( otherCollectionTypeDescription === NULL_COLLECTION_TYPE_DESCRIPTION ) {\n                return false;\n            }\n            if( otherCollectionTypeDescription === ANY_COLLECTION_TYPE_DESCRIPTION ) {\n                return true;\n            }\n            return otherCollectionTypeDescription.collectionType == this.collectionType;\n        },\n        canMapOver: function( otherCollectionTypeDescription ) {\n            if( otherCollectionTypeDescription === NULL_COLLECTION_TYPE_DESCRIPTION ) {\n                return false;\n            }\n            if( otherCollectionTypeDescription === ANY_COLLECTION_TYPE_DESCRIPTION ) {\n                return false;\n            }\n            if( this.rank <= otherCollectionTypeDescription.rank ) {\n                // Cannot map over self...\n                return false;\n            }\n            var requiredSuffix = otherCollectionTypeDescription.collectionType\n            return this._endsWith( this.collectionType, requiredSuffix );\n        },\n        effectiveMapOver: function( otherCollectionTypeDescription ) {\n            var otherCollectionType = otherCollectionTypeDescription.collectionType;\n            var effectiveCollectionType = this.collectionType.substring( 0, this.collectionType.length - otherCollectionType.length - 1 );\n            return new CollectionTypeDescription( effectiveCollectionType );\n        },\n        equal: function( otherCollectionTypeDescription ) {\n            return otherCollectionTypeDescription.collectionType == this.collectionType;\n        },\n        toString: function() {\n            return \"CollectionType[\" + this.collectionType + \"]\";\n        },\n        _endsWith: function( str, suffix ) {\n            return str.indexOf(suffix, str.length - suffix.length) !== -1;\n        }\n    } );\n\n    NULL_COLLECTION_TYPE_DESCRIPTION = {\n        isCollection: false,\n        canMatch: function( other ) { return false; },\n        canMapOver: function( other ) {\n            return false;\n        },\n        toString: function() {\n            return \"NullCollectionType[]\";\n        },\n        append: function( otherCollectionType ) {\n            return otherCollectionType;\n        },\n        equal: function( other ) {\n            return other === this;\n        }\n    };\n\n    ANY_COLLECTION_TYPE_DESCRIPTION = {\n        isCollection: true,\n        canMatch: function( other ) { return NULL_COLLECTION_TYPE_DESCRIPTION !== other; },\n        canMapOver: function( other ) {\n            return false;\n        },\n        toString: function() {\n            return \"AnyCollectionType[]\";\n        },\n        append: function( otherCollectionType ) {\n            throw \"Cannot append to ANY_COLLECTION_TYPE_DESCRIPTION\";\n        },\n        equal: function( other ) {\n            return other === this;\n        }\n    };\n\n    var TerminalMapping = Backbone.Model.extend( {\n        initialize: function( attr ) {\n            this.mapOver = attr.mapOver || NULL_COLLECTION_TYPE_DESCRIPTION;\n            this.terminal = attr.terminal;\n            this.terminal.terminalMapping = this;\n        },\n        disableMapOver: function() {\n            this.setMapOver( NULL_COLLECTION_TYPE_DESCRIPTION );\n        },\n        setMapOver: function( collectionTypeDescription ) {\n            // TODO: Can I use \"attributes\" or something to auto trigger \"change\"\n            // event?\n            this.mapOver = collectionTypeDescription;\n            this.trigger(\"change\");\n        }\n    } );\n\n    var Terminal = Backbone.Model.extend( {\n        initialize: function( attr ) {\n            this.element = attr.element;\n            this.connectors = [];\n        },\n        connect: function ( connector ) {\n            this.connectors.push( connector );\n            if ( this.node ) {\n                this.node.markChanged();\n            }\n        },\n        disconnect: function ( connector ) {\n            this.connectors.splice( $.inArray( connector, this.connectors ), 1 );\n            if ( this.node ) {\n                this.node.markChanged();\n                this.resetMappingIfNeeded();\n            }\n        },\n        redraw: function () {\n            $.each( this.connectors, function( _, c ) {\n                c.redraw();  \n            });\n        },\n        destroy: function () {\n            $.each( this.connectors.slice(), function( _, c ) {\n                c.destroy();\n            });\n        },\n        destroyInvalidConnections: function( ) {\n            _.each( this.connectors, function( connector ) {\n                connector.destroyIfInvalid();\n            } );\n        },\n        setMapOver : function( val ) {\n            if( this.multiple ) {\n                return; // Cannot set this to be multirun...\n            }\n\n            if( ! this.mapOver().equal( val ) ) {\n                this.terminalMapping.setMapOver( val );\n                _.each( this.node.output_terminals, function( outputTerminal ) {\n                    outputTerminal.setMapOver( val );\n                } );\n            }\n        },\n        mapOver: function( ) {\n            if ( ! this.terminalMapping ) {\n                return NULL_COLLECTION_TYPE_DESCRIPTION;\n            } else {\n                return this.terminalMapping.mapOver;\n            }\n        },\n        isMappedOver: function( ) {\n            return this.terminalMapping && this.terminalMapping.mapOver.isCollection;\n        },\n        resetMapping: function() {\n            this.terminalMapping.disableMapOver();\n        },\n\n        resetMappingIfNeeded: function( ) {}, // Subclasses should override this...\n\n    } );\n\n    var OutputTerminal = Terminal.extend( {\n        initialize: function( attr ) {\n            Terminal.prototype.initialize.call( this, attr );\n            this.datatypes = attr.datatypes;\n        },\n\n        resetMappingIfNeeded: function( ) {\n            // If inputs were only mapped over to preserve\n            // an output just disconnected reset these...\n            if( ! this.node.hasConnectedOutputTerminals() && ! this.node.hasConnectedMappedInputTerminals()){\n                _.each( this.node.mappedInputTerminals(), function( mappedInput ) {\n                    mappedInput.resetMappingIfNeeded();\n                } );\n            }\n\n            var noMappedInputs = ! this.node.hasMappedOverInputTerminals();\n            if( noMappedInputs ) {\n                this.resetMapping();\n            }\n        },\n\n        resetMapping: function() {\n            this.terminalMapping.disableMapOver();\n            _.each( this.connectors, function( connector ) {\n                var connectedInput = connector.handle2;\n                if( connectedInput ) {\n                    // Not exactly right because this is still connected.\n                    // Either rewrite resetMappingIfNeeded or disconnect\n                    // and reconnect if valid.\n                    connectedInput.resetMappingIfNeeded();\n                    connector.destroyIfInvalid();\n                }\n            } );\n        }\n\n    } );\n\n    var BaseInputTerminal = Terminal.extend( {\n        initialize: function( attr ) {\n            Terminal.prototype.initialize.call( this, attr );\n            this.update( attr.input ); // subclasses should implement this...\n        },\n        canAccept: function ( other ) {\n            if( this._inputFilled() ) {\n                return false;\n            } else {\n                return this.attachable( other );\n            }\n        },\n        resetMappingIfNeeded: function( ) {\n            var mapOver = this.mapOver();\n            if( ! mapOver.isCollection ) {\n                return;\n            }\n            // No output terminals are counting on this being mapped\n            // over if connected inputs are still mapped over or if none\n            // of the outputs are connected...\n            var reset = this.node.hasConnectedMappedInputTerminals() ||\n                            ( ! this.node.hasConnectedOutputTerminals() );\n            if( reset ) {\n                this.resetMapping();\n            }\n        },\n        resetMapping: function() {\n            this.terminalMapping.disableMapOver();\n            if( ! this.node.hasMappedOverInputTerminals() ) {\n                _.each( this.node.output_terminals, function( terminal) {\n                    // This shouldn't be called if there are mapped over\n                    // outputs.\n                    terminal.resetMapping();\n                } );\n            }\n        },\n        connected: function() {\n            return this.connectors.length !== 0;\n        },\n        _inputFilled: function() {\n            var inputFilled;\n            if( ! this.connected() ) {\n                inputFilled = false;\n            } else {\n                if( this.multiple ) {\n                    if(this._collectionAttached()) {\n                        // Can only attach one collection to multiple input\n                        // data parameter.\n                        inputsFilled = true;\n                    } else {\n                        inputFilled = false;\n                    }\n                } else {\n                    inputFilled = true;\n                }\n            }\n            return inputFilled;\n        },\n        _collectionAttached: function( ) {\n            if( ! this.connected() ) {\n                return false;\n            } else {\n                var firstOutput = this.connectors[ 0 ].handle1;\n                if( ! firstOutput ){\n                    return false;\n                } else {\n                    if( firstOutput.isCollection || firstOutput.isMappedOver() || firstOutput.datatypes.indexOf( \"input_collection\" ) > 0 ) {\n                        return true;\n                    } else {\n                        return false;\n                    }\n                }\n            }\n        },\n        _mappingConstraints: function( ) {\n            // If this is a connected terminal, return list of collection types\n            // other terminals connected to node are constraining mapping to.\n            if( ! this.node ) {\n                return [];  // No node - completely unconstrained\n            }\n            var mapOver = this.mapOver();\n            if( mapOver.isCollection ) {\n                return [ mapOver ];\n            }\n\n            var constraints = [];\n            if( ! this.node.hasConnectedOutputTerminals() ) {\n                _.each( this.node.connectedMappedInputTerminals(), function( inputTerminal ) {\n                    constraints.push( inputTerminal.mapOver() );\n                } );\n            } else {\n                // All outputs should have same mapOver status - least specific.\n                constraints.push( _.first( _.values( this.node.output_terminals ) ).mapOver() );\n            }\n            return constraints;\n        },\n        _producesAcceptableDatatype: function( other ) {\n            // other is a non-collection output...\n            for ( var t in this.datatypes ) {\n                var thisDatatype = this.datatypes[t];\n                if( thisDatatype == \"input\" ) {\n                    return true;\n                }\n                var cat_outputs = new Array();\n                cat_outputs = cat_outputs.concat(other.datatypes);\n                if (other.node.post_job_actions){\n                    for (var pja_i in other.node.post_job_actions){\n                        var pja = other.node.post_job_actions[pja_i];\n                        if (pja.action_type == \"ChangeDatatypeAction\" && (pja.output_name == '' || pja.output_name == other.name) && pja.action_arguments){\n                            cat_outputs.push(pja.action_arguments['newtype']);\n                        }\n                    }\n                }\n                // FIXME: No idea what to do about case when datatype is 'input'\n                for ( var other_datatype_i in cat_outputs ) {\n                    var other_datatype = cat_outputs[other_datatype_i];\n                    if ( other_datatype == \"input\" || other_datatype == \"_sniff_\" || other_datatype == \"input_collection\" || Globals.app.isSubType( cat_outputs[other_datatype_i], thisDatatype ) ) {\n                        return true;\n                    }\n                }\n            }\n            return false;\n        },\n        _otherCollectionType: function( other ) {\n            var otherCollectionType = NULL_COLLECTION_TYPE_DESCRIPTION;\n            if( other.isCollection ) {\n                otherCollectionType = other.collectionType;\n            }\n            var otherMapOver = other.mapOver();\n            if( otherMapOver.isCollection ) {\n                otherCollectionType = otherMapOver.append(otherCollectionType);\n            }\n            return otherCollectionType;\n        },\n    } );\n\n    var InputTerminal = BaseInputTerminal.extend( {\n        update: function( input ) {\n            this.datatypes = input.extensions;\n            this.multiple = input.multiple;\n            this.collection = false;    \t\n        },\n        connect: function( connector ) {\n            BaseInputTerminal.prototype.connect.call( this, connector );\n            var other_output = connector.handle1;\n            if( ! other_output ) {\n                return;\n            }\n            var otherCollectionType = this._otherCollectionType( other_output );\n            if( otherCollectionType.isCollection ) {\n                this.setMapOver( otherCollectionType );\n            }\n        },\n        attachable: function( other ) {\n            var otherCollectionType = this._otherCollectionType( other );\n            var thisMapOver = this.mapOver();\n            if( otherCollectionType.isCollection ) {\n                if( this.multiple ) {\n                    if( this.connected() && ! this._collectionAttached() ) {\n                        // if single inputs attached, cannot also attach a\n                        // collection (yet...)\n                        return false;\n                    }\n                    if( otherCollectionType.rank == 1 ) {\n                        return this._producesAcceptableDatatype( other );\n                    } else {\n                        // TODO: Allow subcollection mapping over this as if it were\n                        // a list collection input.\n                        return false;\n                    }\n                }\n                if( thisMapOver.isCollection && thisMapOver.canMatch( otherCollectionType ) ) {\n                    return this._producesAcceptableDatatype( other );\n                } else {\n                    //  Need to check if this would break constraints...\n                    var mappingConstraints = this._mappingConstraints();\n                    if( mappingConstraints.every( _.bind( otherCollectionType.canMatch, otherCollectionType ) ) ) {\n                        return this._producesAcceptableDatatype( other );\n                    } else {\n                        return false;\n                    }\n                }\n            } else if( thisMapOver.isCollection ) {\n                // Attempting to match a non-collection output to an\n                // explicitly collection input.\n                return false;\n            }\n            return this._producesAcceptableDatatype( other );\n        }\n    });\n\n    var InputCollectionTerminal = BaseInputTerminal.extend( {\n        update: function( input ) {\n            this.multiple = false;\n            this.collection = true;\n            this.datatypes = input.extensions;\n            var collectionTypes = [];\n            if( input.collection_types ) {\n                _.each(input.collection_types, function(collectionType) {\n                    collectionTypes.push( new CollectionTypeDescription( collectionType ) );\n                });\n            } else {\n                collectionTypes.push(ANY_COLLECTION_TYPE_DESCRIPTION);\n            }\n            this.collectionTypes = collectionTypes;\n        },\n        connect: function( connector ) {\n            BaseInputTerminal.prototype.connect.call( this, connector );\n            var other = connector.handle1;\n            if( ! other ) {\n                return;\n            }\n\n            var effectiveMapOver = this._effectiveMapOver( other );\n            this.setMapOver( effectiveMapOver );\n        },\n        _effectiveMapOver: function( other ) {\n            var collectionTypes = this.collectionTypes;\n            var otherCollectionType = this._otherCollectionType( other );\n            var canMatch = _.some(collectionTypes, function( collectionType) { return collectionType.canMatch( otherCollectionType ); });\n\n            if( ! canMatch ) {\n                for( var collectionTypeIndex in collectionTypes ) {\n                    var collectionType = collectionTypes[collectionTypeIndex];\n                    var effectiveMapOver = otherCollectionType.effectiveMapOver( collectionType );\n                    if( effectiveMapOver != NULL_COLLECTION_TYPE_DESCRIPTION ) {\n                        return effectiveMapOver;\n                    }\n                }\n            }\n            return NULL_COLLECTION_TYPE_DESCRIPTION;\n        },\n        _effectiveCollectionTypes: function( ) {\n            var thisMapOver = this.mapOver();\n            return _.map(this.collectionTypes, function(t) { return thisMapOver.append(t); });\n        },\n        attachable: function ( other ) {\n            var otherCollectionType = this._otherCollectionType( other );\n            if( otherCollectionType.isCollection ) {\n                var effectiveCollectionTypes = this._effectiveCollectionTypes( );\n                var thisMapOver = this.mapOver();\n                var canMatch = _.some(effectiveCollectionTypes, function( effectiveCollectionType) { return effectiveCollectionType.canMatch( otherCollectionType ); });\n                if( canMatch ) {\n                    // Only way a direct match...\n                    return this._producesAcceptableDatatype( other );\n                    // Otherwise we need to mapOver\n                } else if( thisMapOver.isCollection ) {\n                    // In this case, mapOver already set and we didn't match skipping...\n                    return false;\n                } else if( _.some(this.collectionTypes, function(collectionType) { return otherCollectionType.canMapOver( collectionType ); }) ) {\n                    var effectiveMapOver = this._effectiveMapOver( other );\n                    if( ! effectiveMapOver.isCollection ) {\n                        return false;\n                    }\n                    //  Need to check if this would break constraints...\n                    var mappingConstraints = this._mappingConstraints();\n                    if( mappingConstraints.every( effectiveMapOver.canMatch ) ) {\n                        return this._producesAcceptableDatatype( other );\n                    }\n                }\n            }\n            return false;\n        }\n    });\n\n    var OutputCollectionTerminal = Terminal.extend( {\n        initialize: function( attr ) {\n            Terminal.prototype.initialize.call( this, attr );\n            this.datatypes = attr.datatypes;\n            this.collectionType = new CollectionTypeDescription( attr.collection_type );\n            this.isCollection = true;\n        },\n        update: function( output ) {\n            var newCollectionType = new CollectionTypeDescription( output.collection_type );\n            if( newCollectionType.collectionType != this.collectionType.collectionType ) {\n                _.each( this.connectors, function( connector ) {\n                    // TODO: consider checking if connection valid before removing...\n                    connector.destroy();\n                } );\n            }\n            this.collectionType = newCollectionType;\n        }\n    } );\n\n    return {\n        InputTerminal                       : InputTerminal,\n        OutputTerminal                      : OutputTerminal,\n        InputCollectionTerminal             : InputCollectionTerminal,\n        OutputCollectionTerminal            : OutputCollectionTerminal,\n        TerminalMapping                     : TerminalMapping,\n\n        // test export\n        CollectionTypeDescription           : CollectionTypeDescription,\n        NULL_COLLECTION_TYPE_DESCRIPTION    : NULL_COLLECTION_TYPE_DESCRIPTION,\n        ANY_COLLECTION_TYPE_DESCRIPTION     : ANY_COLLECTION_TYPE_DESCRIPTION\n    }\n});"]}