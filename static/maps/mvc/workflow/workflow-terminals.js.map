{"version":3,"sources":["mvc/workflow/workflow-terminals.js"],"names":["CollectionTypeDescription","collectionType","this","isCollection","rank","split","length","NULL_COLLECTION_TYPE_DESCRIPTION","canMatch","other","canMapOver","toString","append","otherCollectionType","equal","ANY_COLLECTION_TYPE_DESCRIPTION","prototype","otherCollectionTypeDescription","requiredSuffix","effectiveCollectionType","effectiveMapOver","str","initialize","mapOver","_endsWith","terminal","terminalMapping","indexOf","suffix","setMapOver","Backbone","Model","extend","attr","collectionTypeDescription","trigger","disableMapOver","connect","Terminal","disconnect","element","connectors","node","resetMappingIfNeeded","markChanged","c","connector","splice","$","inArray","destroy","each","redraw","destroyInvalidConnections","_","slice","val","multiple","outputTerminal","resetMapping","isMappedOver","OutputTerminal","mappedInput","call","datatypes","hasConnectedOutputTerminals","connectedInput","handle2","BaseInputTerminal","destroyIfInvalid","update","input","canAccept","reset","attachable","hasMappedOverInputTerminals","connected","hasConnectedMappedInputTerminals","_inputFilled","inputFilled","_collectionAttached","inputsFilled","firstOutput","_mappingConstraints","handle1","constraints","thisDatatype","push","first","other_datatype","cat_outputs","other_datatype_i","pja","pja_i","inputTerminal","_producesAcceptableDatatype","t","_otherCollectionType","Array","otherMapOver","post_job_actions","action_type","output_name","name","extensions","action_arguments","other_output","InputTerminal","mappingConstraints","collection","InputCollectionTerminal","thisMapOver","collectionTypes","collectionTypeIndex","effectiveCollectionTypes","_effectiveCollectionTypes","some","_effectiveMapOver","OutputCollectionTerminal","collection_type","map","newCollectionType","collectionTypeSource","output","console","log","TerminalMapping","collection_type_source"],"mappings":"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","file":"../../../scripts/mvc/workflow/workflow-terminals.js","sourcesContent":["import Globals from \"mvc/workflow/workflow-globals\";\nfunction CollectionTypeDescription(collectionType) {\n    this.collectionType = collectionType;\n    this.isCollection = true;\n    this.rank = collectionType.split(\":\").length;\n}\n\nvar NULL_COLLECTION_TYPE_DESCRIPTION = {\n    isCollection: false,\n    canMatch: function(other) {\n        return false;\n    },\n    canMapOver: function(other) {\n        return false;\n    },\n    toString: function() {\n        return \"NullCollectionType[]\";\n    },\n    append: function(otherCollectionType) {\n        return otherCollectionType;\n    },\n    equal: function(other) {\n        return other === this;\n    }\n};\n\nvar ANY_COLLECTION_TYPE_DESCRIPTION = {\n    isCollection: true,\n    canMatch: function(other) {\n        return NULL_COLLECTION_TYPE_DESCRIPTION !== other;\n    },\n    canMapOver: function(other) {\n        return false;\n    },\n    toString: function() {\n        return \"AnyCollectionType[]\";\n    },\n    append: function(otherCollectionType) {\n        throw \"Cannot append to ANY_COLLECTION_TYPE_DESCRIPTION\";\n    },\n    equal: function(other) {\n        return other === this;\n    }\n};\n\n$.extend(CollectionTypeDescription.prototype, {\n    append: function(otherCollectionTypeDescription) {\n        if (\n            otherCollectionTypeDescription === NULL_COLLECTION_TYPE_DESCRIPTION\n        ) {\n            return this;\n        }\n        if (\n            otherCollectionTypeDescription === ANY_COLLECTION_TYPE_DESCRIPTION\n        ) {\n            return otherCollectionType;\n        }\n        return new CollectionTypeDescription(\n            this.collectionType +\n                \":\" +\n                otherCollectionTypeDescription.collectionType\n        );\n    },\n    canMatch: function(otherCollectionTypeDescription) {\n        if (\n            otherCollectionTypeDescription === NULL_COLLECTION_TYPE_DESCRIPTION\n        ) {\n            return false;\n        }\n        if (\n            otherCollectionTypeDescription === ANY_COLLECTION_TYPE_DESCRIPTION\n        ) {\n            return true;\n        }\n        return (\n            otherCollectionTypeDescription.collectionType == this.collectionType\n        );\n    },\n    canMapOver: function(otherCollectionTypeDescription) {\n        if (\n            otherCollectionTypeDescription === NULL_COLLECTION_TYPE_DESCRIPTION\n        ) {\n            return false;\n        }\n        if (\n            otherCollectionTypeDescription === ANY_COLLECTION_TYPE_DESCRIPTION\n        ) {\n            return false;\n        }\n        if (this.rank <= otherCollectionTypeDescription.rank) {\n            // Cannot map over self...\n            return false;\n        }\n        var requiredSuffix = otherCollectionTypeDescription.collectionType;\n        return this._endsWith(this.collectionType, requiredSuffix);\n    },\n    effectiveMapOver: function(otherCollectionTypeDescription) {\n        var otherCollectionType = otherCollectionTypeDescription.collectionType;\n        var effectiveCollectionType = this.collectionType.substring(\n            0,\n            this.collectionType.length - otherCollectionType.length - 1\n        );\n        return new CollectionTypeDescription(effectiveCollectionType);\n    },\n    equal: function(otherCollectionTypeDescription) {\n        return (\n            otherCollectionTypeDescription.collectionType == this.collectionType\n        );\n    },\n    toString: function() {\n        return \"CollectionType[\" + this.collectionType + \"]\";\n    },\n    _endsWith: function(str, suffix) {\n        return str.indexOf(suffix, str.length - suffix.length) !== -1;\n    }\n});\n\nvar TerminalMapping = Backbone.Model.extend({\n    initialize: function(attr) {\n        this.mapOver = attr.mapOver || NULL_COLLECTION_TYPE_DESCRIPTION;\n        this.terminal = attr.terminal;\n        this.terminal.terminalMapping = this;\n    },\n    disableMapOver: function() {\n        this.setMapOver(NULL_COLLECTION_TYPE_DESCRIPTION);\n    },\n    setMapOver: function(collectionTypeDescription) {\n        // TODO: Can I use \"attributes\" or something to auto trigger \"change\"\n        // event?\n        this.mapOver = collectionTypeDescription;\n        this.trigger(\"change\");\n    }\n});\n\nvar Terminal = Backbone.Model.extend({\n    initialize: function(attr) {\n        this.element = attr.element;\n        this.connectors = [];\n    },\n    connect: function(connector) {\n        this.connectors.push(connector);\n        if (this.node) {\n            this.node.markChanged();\n        }\n    },\n    disconnect: function(connector) {\n        this.connectors.splice($.inArray(connector, this.connectors), 1);\n        if (this.node) {\n            this.node.markChanged();\n            this.resetMappingIfNeeded();\n        }\n    },\n    redraw: function() {\n        $.each(this.connectors, function(_, c) {\n            c.redraw();\n        });\n    },\n    destroy: function() {\n        $.each(this.connectors.slice(), function(_, c) {\n            c.destroy();\n        });\n    },\n    destroyInvalidConnections: function() {\n        _.each(this.connectors, function(connector) {\n            connector && connector.destroyIfInvalid();\n        });\n    },\n    setMapOver: function(val) {\n        if (this.multiple) {\n            return; // Cannot set this to be multirun...\n        }\n\n        if (!this.mapOver().equal(val)) {\n            this.terminalMapping.setMapOver(val);\n            _.each(this.node.output_terminals, function(outputTerminal) {\n                outputTerminal.setMapOver(val);\n            });\n        }\n    },\n    mapOver: function() {\n        if (!this.terminalMapping) {\n            return NULL_COLLECTION_TYPE_DESCRIPTION;\n        } else {\n            return this.terminalMapping.mapOver;\n        }\n    },\n    isMappedOver: function() {\n        return (\n            this.terminalMapping && this.terminalMapping.mapOver.isCollection\n        );\n    },\n    resetMapping: function() {\n        this.terminalMapping.disableMapOver();\n    },\n\n    resetMappingIfNeeded: function() {} // Subclasses should override this...\n});\n\nvar OutputTerminal = Terminal.extend({\n    initialize: function(attr) {\n        Terminal.prototype.initialize.call(this, attr);\n        this.datatypes = attr.datatypes;\n    },\n\n    resetMappingIfNeeded: function() {\n        // If inputs were only mapped over to preserve\n        // an output just disconnected reset these...\n        if (\n            !this.node.hasConnectedOutputTerminals() &&\n            !this.node.hasConnectedMappedInputTerminals()\n        ) {\n            _.each(this.node.mappedInputTerminals(), function(mappedInput) {\n                mappedInput.resetMappingIfNeeded();\n            });\n        }\n\n        var noMappedInputs = !this.node.hasMappedOverInputTerminals();\n        if (noMappedInputs) {\n            this.resetMapping();\n        }\n    },\n\n    resetMapping: function() {\n        this.terminalMapping.disableMapOver();\n        _.each(this.connectors, function(connector) {\n            var connectedInput = connector.handle2;\n            if (connectedInput) {\n                // Not exactly right because this is still connected.\n                // Either rewrite resetMappingIfNeeded or disconnect\n                // and reconnect if valid.\n                connectedInput.resetMappingIfNeeded();\n                connector.destroyIfInvalid();\n            }\n        });\n    }\n});\n\nvar BaseInputTerminal = Terminal.extend({\n    initialize: function(attr) {\n        Terminal.prototype.initialize.call(this, attr);\n        this.update(attr.input); // subclasses should implement this...\n    },\n    canAccept: function(other) {\n        if (this._inputFilled()) {\n            return false;\n        } else {\n            return this.attachable(other);\n        }\n    },\n    resetMappingIfNeeded: function() {\n        var mapOver = this.mapOver();\n        if (!mapOver.isCollection) {\n            return;\n        }\n        // No output terminals are counting on this being mapped\n        // over if connected inputs are still mapped over or if none\n        // of the outputs are connected...\n        var reset =\n            this.node.hasConnectedMappedInputTerminals() ||\n            !this.node.hasConnectedOutputTerminals();\n        if (reset) {\n            this.resetMapping();\n        }\n    },\n    resetMapping: function() {\n        this.terminalMapping.disableMapOver();\n        if (!this.node.hasMappedOverInputTerminals()) {\n            _.each(this.node.output_terminals, function(terminal) {\n                // This shouldn't be called if there are mapped over\n                // outputs.\n                terminal.resetMapping();\n            });\n        }\n    },\n    connected: function() {\n        return this.connectors.length !== 0;\n    },\n    _inputFilled: function() {\n        var inputFilled;\n        if (!this.connected()) {\n            inputFilled = false;\n        } else {\n            if (this.multiple) {\n                if (this._collectionAttached()) {\n                    // Can only attach one collection to multiple input\n                    // data parameter.\n                    inputsFilled = true;\n                } else {\n                    inputFilled = false;\n                }\n            } else {\n                inputFilled = true;\n            }\n        }\n        return inputFilled;\n    },\n    _collectionAttached: function() {\n        if (!this.connected()) {\n            return false;\n        } else {\n            var firstOutput = this.connectors[0].handle1;\n            if (!firstOutput) {\n                return false;\n            } else {\n                if (\n                    firstOutput.isCollection ||\n                    firstOutput.isMappedOver() ||\n                    firstOutput.datatypes.indexOf(\"input_collection\") > 0\n                ) {\n                    return true;\n                } else {\n                    return false;\n                }\n            }\n        }\n    },\n    _mappingConstraints: function() {\n        // If this is a connected terminal, return list of collection types\n        // other terminals connected to node are constraining mapping to.\n        if (!this.node) {\n            return []; // No node - completely unconstrained\n        }\n        var mapOver = this.mapOver();\n        if (mapOver.isCollection) {\n            return [mapOver];\n        }\n\n        var constraints = [];\n        if (!this.node.hasConnectedOutputTerminals()) {\n            _.each(this.node.connectedMappedInputTerminals(), function(\n                inputTerminal\n            ) {\n                constraints.push(inputTerminal.mapOver());\n            });\n        } else {\n            // All outputs should have same mapOver status - least specific.\n            constraints.push(\n                _.first(_.values(this.node.output_terminals)).mapOver()\n            );\n        }\n        return constraints;\n    },\n    _producesAcceptableDatatype: function(other) {\n        // other is a non-collection output...\n        for (var t in this.datatypes) {\n            var thisDatatype = this.datatypes[t];\n            if (thisDatatype == \"input\") {\n                return true;\n            }\n            var cat_outputs = new Array();\n            cat_outputs = cat_outputs.concat(other.datatypes);\n            if (other.node.post_job_actions) {\n                for (var pja_i in other.node.post_job_actions) {\n                    var pja = other.node.post_job_actions[pja_i];\n                    if (\n                        pja.action_type == \"ChangeDatatypeAction\" &&\n                        (pja.output_name == \"\" ||\n                            pja.output_name == other.name) &&\n                        pja.action_arguments\n                    ) {\n                        cat_outputs.push(pja.action_arguments[\"newtype\"]);\n                    }\n                }\n            }\n            // FIXME: No idea what to do about case when datatype is 'input'\n            for (var other_datatype_i in cat_outputs) {\n                var other_datatype = cat_outputs[other_datatype_i];\n                if (\n                    other_datatype == \"input\" ||\n                    other_datatype == \"_sniff_\" ||\n                    other_datatype == \"input_collection\" ||\n                    Globals.app.isSubType(\n                        cat_outputs[other_datatype_i],\n                        thisDatatype\n                    )\n                ) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    },\n    _otherCollectionType: function(other) {\n        var otherCollectionType = NULL_COLLECTION_TYPE_DESCRIPTION;\n        if (other.isCollection) {\n            otherCollectionType = other.collectionType;\n        }\n        var otherMapOver = other.mapOver();\n        if (otherMapOver.isCollection) {\n            otherCollectionType = otherMapOver.append(otherCollectionType);\n        }\n        return otherCollectionType;\n    }\n});\n\nvar InputTerminal = BaseInputTerminal.extend({\n    update: function(input) {\n        this.datatypes = input.extensions;\n        this.multiple = input.multiple;\n        this.collection = false;\n    },\n    connect: function(connector) {\n        BaseInputTerminal.prototype.connect.call(this, connector);\n        var other_output = connector.handle1;\n        if (!other_output) {\n            return;\n        }\n        var otherCollectionType = this._otherCollectionType(other_output);\n        if (otherCollectionType.isCollection) {\n            this.setMapOver(otherCollectionType);\n        }\n    },\n    attachable: function(other) {\n        var otherCollectionType = this._otherCollectionType(other);\n        var thisMapOver = this.mapOver();\n        if (otherCollectionType.isCollection) {\n            if (this.multiple) {\n                if (this.connected() && !this._collectionAttached()) {\n                    // if single inputs attached, cannot also attach a\n                    // collection (yet...)\n                    return false;\n                }\n                if (otherCollectionType.rank == 1) {\n                    return this._producesAcceptableDatatype(other);\n                } else {\n                    // TODO: Allow subcollection mapping over this as if it were\n                    // a list collection input.\n                    return false;\n                }\n            }\n            if (\n                thisMapOver.isCollection &&\n                thisMapOver.canMatch(otherCollectionType)\n            ) {\n                return this._producesAcceptableDatatype(other);\n            } else {\n                //  Need to check if this would break constraints...\n                var mappingConstraints = this._mappingConstraints();\n                if (\n                    mappingConstraints.every(\n                        _.bind(\n                            otherCollectionType.canMatch,\n                            otherCollectionType\n                        )\n                    )\n                ) {\n                    return this._producesAcceptableDatatype(other);\n                } else {\n                    return false;\n                }\n            }\n        } else if (thisMapOver.isCollection) {\n            // Attempting to match a non-collection output to an\n            // explicitly collection input.\n            return false;\n        }\n        return this._producesAcceptableDatatype(other);\n    }\n});\n\nvar InputCollectionTerminal = BaseInputTerminal.extend({\n    update: function(input) {\n        this.multiple = false;\n        this.collection = true;\n        this.datatypes = input.extensions;\n        var collectionTypes = [];\n        if (input.collection_types) {\n            _.each(input.collection_types, function(collectionType) {\n                collectionTypes.push(\n                    new CollectionTypeDescription(collectionType)\n                );\n            });\n        } else {\n            collectionTypes.push(ANY_COLLECTION_TYPE_DESCRIPTION);\n        }\n        this.collectionTypes = collectionTypes;\n    },\n    connect: function(connector) {\n        BaseInputTerminal.prototype.connect.call(this, connector);\n        var other = connector.handle1;\n        if (!other) {\n            return;\n        }\n\n        var effectiveMapOver = this._effectiveMapOver(other);\n        this.setMapOver(effectiveMapOver);\n    },\n    _effectiveMapOver: function(other) {\n        var collectionTypes = this.collectionTypes;\n        var otherCollectionType = this._otherCollectionType(other);\n        var canMatch = _.some(collectionTypes, function(collectionType) {\n            return collectionType.canMatch(otherCollectionType);\n        });\n\n        if (!canMatch) {\n            for (var collectionTypeIndex in collectionTypes) {\n                var collectionType = collectionTypes[collectionTypeIndex];\n                if (otherCollectionType.canMapOver(collectionType)) {\n                    var effectiveMapOver = otherCollectionType.effectiveMapOver(\n                        collectionType\n                    );\n                    if (effectiveMapOver != NULL_COLLECTION_TYPE_DESCRIPTION) {\n                        return effectiveMapOver;\n                    }\n                }\n            }\n        }\n        return NULL_COLLECTION_TYPE_DESCRIPTION;\n    },\n    _effectiveCollectionTypes: function() {\n        var thisMapOver = this.mapOver();\n        return _.map(this.collectionTypes, function(t) {\n            return thisMapOver.append(t);\n        });\n    },\n    attachable: function(other) {\n        var otherCollectionType = this._otherCollectionType(other);\n        if (otherCollectionType.isCollection) {\n            var effectiveCollectionTypes = this._effectiveCollectionTypes();\n            var thisMapOver = this.mapOver();\n            var canMatch = _.some(effectiveCollectionTypes, function(\n                effectiveCollectionType\n            ) {\n                return effectiveCollectionType.canMatch(otherCollectionType);\n            });\n            if (canMatch) {\n                // Only way a direct match...\n                return this._producesAcceptableDatatype(other);\n                // Otherwise we need to mapOver\n            } else if (thisMapOver.isCollection) {\n                // In this case, mapOver already set and we didn't match skipping...\n                return false;\n            } else if (\n                _.some(this.collectionTypes, function(collectionType) {\n                    return otherCollectionType.canMapOver(collectionType);\n                })\n            ) {\n                var effectiveMapOver = this._effectiveMapOver(other);\n                if (!effectiveMapOver.isCollection) {\n                    return false;\n                }\n                //  Need to check if this would break constraints...\n                var mappingConstraints = this._mappingConstraints();\n                if (mappingConstraints.every(effectiveMapOver.canMatch)) {\n                    return this._producesAcceptableDatatype(other);\n                }\n            }\n        }\n        return false;\n    }\n});\n\nvar OutputCollectionTerminal = Terminal.extend({\n    initialize: function(attr) {\n        Terminal.prototype.initialize.call(this, attr);\n        this.datatypes = attr.datatypes;\n        if (attr.collection_type) {\n            this.collectionType = new CollectionTypeDescription(\n                attr.collection_type\n            );\n        } else {\n            var collectionTypeSource = attr.collection_type_source;\n            if (!collectionTypeSource) {\n                console.log(\n                    \"Warning: No collection type or collection type source defined.\"\n                );\n            }\n            this.collectionType = ANY_COLLECTION_TYPE_DESCRIPTION;\n        }\n        this.isCollection = true;\n    },\n    update: function(output) {\n        var newCollectionType;\n        if (output.collection_type) {\n            newCollectionType = new CollectionTypeDescription(\n                output.collection_type\n            );\n        } else {\n            var collectionTypeSource = output.collection_type_source;\n            if (!collectionTypeSource) {\n                console.log(\n                    \"Warning: No collection type or collection type source defined.\"\n                );\n            }\n            newCollectionType = ANY_COLLECTION_TYPE_DESCRIPTION;\n        }\n\n        if (\n            newCollectionType.collectionType !=\n            this.collectionType.collectionType\n        ) {\n            _.each(this.connectors, function(connector) {\n                // TODO: consider checking if connection valid before removing...\n                connector.destroy();\n            });\n        }\n        this.collectionType = newCollectionType;\n    }\n});\n\nexport default {\n    InputTerminal: InputTerminal,\n    OutputTerminal: OutputTerminal,\n    InputCollectionTerminal: InputCollectionTerminal,\n    OutputCollectionTerminal: OutputCollectionTerminal,\n    TerminalMapping: TerminalMapping,\n\n    // test export\n    CollectionTypeDescription: CollectionTypeDescription,\n    NULL_COLLECTION_TYPE_DESCRIPTION: NULL_COLLECTION_TYPE_DESCRIPTION,\n    ANY_COLLECTION_TYPE_DESCRIPTION: ANY_COLLECTION_TYPE_DESCRIPTION\n};\n"]}