{"version":3,"sources":["mvc/workflow/workflow-connector.js"],"names":["define","Connector","handle1","handle2","this","canvas","dragging","inner_color","outer_color","$","extend","connect","t1","t2","destroy","disconnect","destroyIfInvalid","redraw","canvas_container","append","style","zIndex","relativeLeft","e","offset","left","relativeTop","top","start_x","start_y","end_x","end_y","element","canvas_min_x","canvas_max_x","Math","max","canvas_min_y","min","canvas_max_y","cp_shift","canvas_left","canvas_top","canvas_extra","canvas_width","canvas_height","setAttribute","c","start_offsets","getContext","num_offsets","isMappedOver","end_offsets","connector","inner_width","i","outer_width","length","offset_start","offset_end","lineCap","strokeStyle","lineWidth","beginPath","moveTo","bezierCurveTo","stroke"],"mappings":"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","file":"../../../scripts/mvc/workflow/workflow-connector.js","sourcesContent":["define([], function() {\n    function Connector(handle1, handle2) {\n        this.canvas = null;\n        this.dragging = false;\n        this.inner_color = \"#FFFFFF\";\n        this.outer_color = \"#D8B365\";\n        if (handle1 && handle2) {\n            this.connect(handle1, handle2);\n        }\n    }\n    $.extend(Connector.prototype, {\n        connect: function(t1, t2) {\n            this.handle1 = t1;\n            if (this.handle1) {\n                this.handle1.connect(this);\n            }\n            this.handle2 = t2;\n            if (this.handle2) {\n                this.handle2.connect(this);\n            }\n        },\n        destroy: function() {\n            if (this.handle1) {\n                this.handle1.disconnect(this);\n            }\n            if (this.handle2) {\n                this.handle2.disconnect(this);\n            }\n            $(this.canvas).remove();\n        },\n        destroyIfInvalid: function() {\n            if (\n                this.handle1 &&\n                this.handle2 &&\n                !this.handle2.attachable(this.handle1)\n            ) {\n                this.destroy();\n            }\n        },\n        redraw: function() {\n            var canvas_container = $(\"#canvas-container\");\n            if (!this.canvas) {\n                this.canvas = document.createElement(\"canvas\");\n                canvas_container.append($(this.canvas));\n                if (this.dragging) {\n                    this.canvas.style.zIndex = \"300\";\n                }\n            }\n            var relativeLeft = function(e) {\n                return $(e).offset().left - canvas_container.offset().left;\n            };\n            var relativeTop = function(e) {\n                return $(e).offset().top - canvas_container.offset().top;\n            };\n            if (!this.handle1 || !this.handle2) {\n                return;\n            }\n            // Find the position of each handle\n            var start_x = relativeLeft(this.handle1.element) + 5;\n            var start_y = relativeTop(this.handle1.element) + 5;\n            var end_x = relativeLeft(this.handle2.element) + 5;\n            var end_y = relativeTop(this.handle2.element) + 5;\n            // Calculate canvas area\n            var canvas_extra = 100;\n            var canvas_min_x = Math.min(start_x, end_x);\n            var canvas_max_x = Math.max(start_x, end_x);\n            var canvas_min_y = Math.min(start_y, end_y);\n            var canvas_max_y = Math.max(start_y, end_y);\n            var cp_shift = Math.min(\n                Math.max(Math.abs(canvas_max_y - canvas_min_y) / 2, 100),\n                300\n            );\n            var canvas_left = canvas_min_x - canvas_extra;\n            var canvas_top = canvas_min_y - canvas_extra;\n            var canvas_width = canvas_max_x - canvas_min_x + 2 * canvas_extra;\n            var canvas_height = canvas_max_y - canvas_min_y + 2 * canvas_extra;\n            // Place the canvas\n            this.canvas.style.left = canvas_left + \"px\";\n            this.canvas.style.top = canvas_top + \"px\";\n            this.canvas.setAttribute(\"width\", canvas_width);\n            this.canvas.setAttribute(\"height\", canvas_height);\n            // Adjust points to be relative to the canvas\n            start_x -= canvas_left;\n            start_y -= canvas_top;\n            end_x -= canvas_left;\n            end_y -= canvas_top;\n            // Draw the line\n\n            var c = this.canvas.getContext(\"2d\"),\n                start_offsets = null,\n                end_offsets = null;\n            var num_offsets = 1;\n            if (this.handle1 && this.handle1.isMappedOver()) {\n                var start_offsets = [-6, -3, 0, 3, 6];\n                num_offsets = 5;\n            } else {\n                var start_offsets = [0];\n            }\n            if (this.handle2 && this.handle2.isMappedOver()) {\n                var end_offsets = [-6, -3, 0, 3, 6];\n                num_offsets = 5;\n            } else {\n                var end_offsets = [0];\n            }\n            var connector = this;\n            for (var i = 0; i < num_offsets; i++) {\n                var inner_width = 5,\n                    outer_width = 7;\n                if (start_offsets.length > 1 || end_offsets.length > 1) {\n                    // We have a multi-run, using many lines, make them small.\n                    inner_width = 1;\n                    outer_width = 3;\n                }\n                connector.draw_outlined_curve(\n                    start_x,\n                    start_y,\n                    end_x,\n                    end_y,\n                    cp_shift,\n                    inner_width,\n                    outer_width,\n                    start_offsets[i % start_offsets.length],\n                    end_offsets[i % end_offsets.length]\n                );\n            }\n        },\n        draw_outlined_curve: function(\n            start_x,\n            start_y,\n            end_x,\n            end_y,\n            cp_shift,\n            inner_width,\n            outer_width,\n            offset_start,\n            offset_end\n        ) {\n            var offset_start = offset_start || 0;\n            var offset_end = offset_end || 0;\n            var c = this.canvas.getContext(\"2d\");\n            c.lineCap = \"round\";\n            c.strokeStyle = this.outer_color;\n            c.lineWidth = outer_width;\n            c.beginPath();\n            c.moveTo(start_x, start_y + offset_start);\n            c.bezierCurveTo(\n                start_x + cp_shift,\n                start_y + offset_start,\n                end_x - cp_shift,\n                end_y + offset_end,\n                end_x,\n                end_y + offset_end\n            );\n            c.stroke();\n            // Inner line\n            c.strokeStyle = this.inner_color;\n            c.lineWidth = inner_width;\n            c.beginPath();\n            c.moveTo(start_x, start_y + offset_start);\n            c.bezierCurveTo(\n                start_x + cp_shift,\n                start_y + offset_start,\n                end_x - cp_shift,\n                end_y + offset_end,\n                end_x,\n                end_y + offset_end\n            );\n            c.stroke();\n        }\n    });\n    return Connector;\n});\n"]}