{"version":3,"sources":["mvc/workflow/workflow-connector.js"],"names":["Connector","handle1","handle2","this","canvas","dragging","inner_color","outer_color","$","extend","connect","t2","prototype","destroy","disconnect","destroyIfInvalid","attachable","redraw","canvas_container","append","relativeLeft","e","offset","left","relativeTop","top","start_x","element","start_y","end_x","end_y","canvas_min_x","Math","min","canvas_max_x","canvas_extra","max","canvas_min_y","canvas_max_y","cp_shift","canvas_left","canvas_top","canvas_width","canvas_height","style","setAttribute","getContext","start_offsets","end_offsets","num_offsets","isMappedOver","connector","i","inner_width","outer_width","length","draw_outlined_curve","offset_start","offset_end","c","lineCap","strokeStyle","lineWidth","beginPath","moveTo","bezierCurveTo","stroke"],"mappings":"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","file":"../../../scripts/mvc/workflow/workflow-connector.js","sourcesContent":["function Connector(handle1, handle2) {\n    this.canvas = null;\n    this.dragging = false;\n    this.inner_color = \"#FFFFFF\";\n    this.outer_color = \"#D8B365\";\n    if (handle1 && handle2) {\n        this.connect(handle1, handle2);\n    }\n}\n$.extend(Connector.prototype, {\n    connect: function(t1, t2) {\n        this.handle1 = t1;\n        if (this.handle1) {\n            this.handle1.connect(this);\n        }\n        this.handle2 = t2;\n        if (this.handle2) {\n            this.handle2.connect(this);\n        }\n    },\n    destroy: function() {\n        if (this.handle1) {\n            this.handle1.disconnect(this);\n        }\n        if (this.handle2) {\n            this.handle2.disconnect(this);\n        }\n        $(this.canvas).remove();\n    },\n    destroyIfInvalid: function() {\n        if (\n            this.handle1 &&\n            this.handle2 &&\n            !this.handle2.attachable(this.handle1)\n        ) {\n            this.destroy();\n        }\n    },\n    redraw: function() {\n        var canvas_container = $(\"#canvas-container\");\n        if (!this.canvas) {\n            this.canvas = document.createElement(\"canvas\");\n            canvas_container.append($(this.canvas));\n            if (this.dragging) {\n                this.canvas.style.zIndex = \"300\";\n            }\n        }\n        var relativeLeft = function(e) {\n            return $(e).offset().left - canvas_container.offset().left;\n        };\n        var relativeTop = function(e) {\n            return $(e).offset().top - canvas_container.offset().top;\n        };\n        if (!this.handle1 || !this.handle2) {\n            return;\n        }\n        // Find the position of each handle\n        var start_x = relativeLeft(this.handle1.element) + 5;\n        var start_y = relativeTop(this.handle1.element) + 5;\n        var end_x = relativeLeft(this.handle2.element) + 5;\n        var end_y = relativeTop(this.handle2.element) + 5;\n        // Calculate canvas area\n        var canvas_extra = 100;\n        var canvas_min_x = Math.min(start_x, end_x);\n        var canvas_max_x = Math.max(start_x, end_x);\n        var canvas_min_y = Math.min(start_y, end_y);\n        var canvas_max_y = Math.max(start_y, end_y);\n        var cp_shift = Math.min(\n            Math.max(Math.abs(canvas_max_y - canvas_min_y) / 2, 100),\n            300\n        );\n        var canvas_left = canvas_min_x - canvas_extra;\n        var canvas_top = canvas_min_y - canvas_extra;\n        var canvas_width = canvas_max_x - canvas_min_x + 2 * canvas_extra;\n        var canvas_height = canvas_max_y - canvas_min_y + 2 * canvas_extra;\n        // Place the canvas\n        this.canvas.style.left = canvas_left + \"px\";\n        this.canvas.style.top = canvas_top + \"px\";\n        this.canvas.setAttribute(\"width\", canvas_width);\n        this.canvas.setAttribute(\"height\", canvas_height);\n        // Adjust points to be relative to the canvas\n        start_x -= canvas_left;\n        start_y -= canvas_top;\n        end_x -= canvas_left;\n        end_y -= canvas_top;\n\n        // Draw the line\n\n        var c = this.canvas.getContext(\"2d\");\n\n        var start_offsets = null;\n        var end_offsets = null;\n        var num_offsets = 1;\n        if (this.handle1 && this.handle1.isMappedOver()) {\n            var start_offsets = [-6, -3, 0, 3, 6];\n            num_offsets = 5;\n        } else {\n            var start_offsets = [0];\n        }\n        if (this.handle2 && this.handle2.isMappedOver()) {\n            var end_offsets = [-6, -3, 0, 3, 6];\n            num_offsets = 5;\n        } else {\n            var end_offsets = [0];\n        }\n        var connector = this;\n        for (var i = 0; i < num_offsets; i++) {\n            var inner_width = 5;\n            var outer_width = 7;\n            if (start_offsets.length > 1 || end_offsets.length > 1) {\n                // We have a multi-run, using many lines, make them small.\n                inner_width = 1;\n                outer_width = 3;\n            }\n            connector.draw_outlined_curve(\n                start_x,\n                start_y,\n                end_x,\n                end_y,\n                cp_shift,\n                inner_width,\n                outer_width,\n                start_offsets[i % start_offsets.length],\n                end_offsets[i % end_offsets.length]\n            );\n        }\n    },\n    draw_outlined_curve: function(\n        start_x,\n        start_y,\n        end_x,\n        end_y,\n        cp_shift,\n        inner_width,\n        outer_width,\n        offset_start,\n        offset_end\n    ) {\n        var offset_start = offset_start || 0;\n        var offset_end = offset_end || 0;\n        var c = this.canvas.getContext(\"2d\");\n        c.lineCap = \"round\";\n        c.strokeStyle = this.outer_color;\n        c.lineWidth = outer_width;\n        c.beginPath();\n        c.moveTo(start_x, start_y + offset_start);\n        c.bezierCurveTo(\n            start_x + cp_shift,\n            start_y + offset_start,\n            end_x - cp_shift,\n            end_y + offset_end,\n            end_x,\n            end_y + offset_end\n        );\n        c.stroke();\n        // Inner line\n        c.strokeStyle = this.inner_color;\n        c.lineWidth = inner_width;\n        c.beginPath();\n        c.moveTo(start_x, start_y + offset_start);\n        c.bezierCurveTo(\n            start_x + cp_shift,\n            start_y + offset_start,\n            end_x - cp_shift,\n            end_y + offset_end,\n            end_x,\n            end_y + offset_end\n        );\n        c.stroke();\n    }\n});\nexport default Connector;\n"]}