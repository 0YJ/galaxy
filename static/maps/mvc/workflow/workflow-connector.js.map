{"version":3,"sources":["mvc/workflow/workflow-connector.js"],"names":["define","Connector","handle1","handle2","this","canvas","dragging","inner_color","outer_color","$","extend","prototype","connect","t1","t2","destroy","disconnect","attachable","destroyIfInvalid","redraw","canvas_container","createElement","append","relativeLeft","e","offset","left","relativeTop","top","start_x","element","start_y","canvas_min_x","Math","min","end_x","canvas_extra","max","canvas_max_x","canvas_min_y","end_y","canvas_max_y","cp_shift","canvas_left","canvas_top","canvas_height","style","start_offsets","getContext","c","end_offsets","isMappedOver","num_offsets","connector","i","outer_width","inner_width","length","draw_outlined_curve","offset_start","offset_end","lineCap","strokeStyle","lineWidth","beginPath","moveTo","stroke"],"mappings":"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","file":"../../../scripts/mvc/workflow/workflow-connector.js","sourcesContent":["define([], function(){\n    function Connector( handle1, handle2 ) {\n        this.canvas = null;\n        this.dragging = false;\n        this.inner_color = \"#FFFFFF\";\n        this.outer_color = \"#D8B365\";\n        if ( handle1 && handle2 ) {\n            this.connect( handle1, handle2 );\n        }\n    }\n    $.extend( Connector.prototype, {\n        connect: function ( t1, t2 ) {\n            this.handle1 = t1;\n            if ( this.handle1 ) {\n                this.handle1.connect( this );\n            }\n            this.handle2 = t2;\n            if ( this.handle2 ) {\n                this.handle2.connect( this );\n            }\n        },\n        destroy : function () {\n            if ( this.handle1 ) {\n                this.handle1.disconnect( this );\n            }\n            if ( this.handle2 ) {\n                this.handle2.disconnect( this );\n            }\n            $(this.canvas).remove();\n        },\n        destroyIfInvalid: function() {\n            if( this.handle1 && this.handle2 && ! this.handle2.attachable( this.handle1 ) ) {\n                this.destroy();\n            }\n        },\n        redraw : function () {\n            var canvas_container = $(\"#canvas-container\");\n            if ( ! this.canvas ) {\n                this.canvas = document.createElement( \"canvas\" );\n                canvas_container.append( $(this.canvas) );\n                if ( this.dragging ) {\n                    this.canvas.style.zIndex = \"300\";\n                }\n            }\n            var relativeLeft = function( e ) {\n                return $(e).offset().left - canvas_container.offset().left;\n            };\n            var relativeTop = function( e ) {\n                return $(e).offset().top - canvas_container.offset().top;\n            };\n            if (!this.handle1 || !this.handle2) {\n                return;\n            }\n            // Find the position of each handle\n            var start_x = relativeLeft( this.handle1.element ) + 5;\n            var start_y = relativeTop( this.handle1.element ) + 5;\n            var end_x = relativeLeft( this.handle2.element ) + 5;\n            var end_y = relativeTop( this.handle2.element ) + 5;\n            // Calculate canvas area\n            var canvas_extra = 100;\n            var canvas_min_x = Math.min( start_x, end_x );\n            var canvas_max_x = Math.max( start_x, end_x );\n            var canvas_min_y = Math.min( start_y, end_y );\n            var canvas_max_y = Math.max( start_y, end_y );\n            var cp_shift = Math.min( Math.max( Math.abs( canvas_max_y - canvas_min_y ) / 2, 100 ), 300 );\n            var canvas_left = canvas_min_x - canvas_extra;\n            var canvas_top = canvas_min_y - canvas_extra;\n            var canvas_width = canvas_max_x - canvas_min_x + 2 * canvas_extra;\n            var canvas_height = canvas_max_y - canvas_min_y + 2 * canvas_extra;\n            // Place the canvas\n            this.canvas.style.left = canvas_left + \"px\";\n            this.canvas.style.top = canvas_top + \"px\";\n            this.canvas.setAttribute( \"width\", canvas_width );\n            this.canvas.setAttribute( \"height\", canvas_height );\n            // Adjust points to be relative to the canvas\n            start_x -= canvas_left;\n            start_y -= canvas_top;\n            end_x -= canvas_left;\n            end_y -= canvas_top;\n            // Draw the line\n\n            var c = this.canvas.getContext(\"2d\"),\n                start_offsets = null,\n                end_offsets = null;\n            var num_offsets = 1;\n            if ( this.handle1 && this.handle1.isMappedOver() ) {\n                var start_offsets = [ -6, -3, 0, 3, 6 ];\n                num_offsets = 5;\n            } else {\n                var start_offsets = [ 0 ];\n            }\n            if ( this.handle2 && this.handle2.isMappedOver() ) {\n                var end_offsets = [ -6, -3, 0, 3, 6 ];\n                num_offsets = 5;\n            } else {\n                var end_offsets = [ 0 ];\n            }\n            var connector = this;\n            for( var i = 0; i < num_offsets; i++ ) {\n                var inner_width = 5,\n                    outer_width = 7;\n                if( start_offsets.length > 1 || end_offsets.length > 1 ) {\n                    // We have a multi-run, using many lines, make them small.\n                    inner_width = 1;\n                    outer_width = 3;\n                }\n                connector.draw_outlined_curve( start_x, start_y, end_x, end_y, cp_shift, inner_width, outer_width, start_offsets[ i % start_offsets.length ], end_offsets[ i % end_offsets.length ] );\n            }\n        },\n        draw_outlined_curve : function( start_x, start_y, end_x, end_y, cp_shift, inner_width, outer_width, offset_start, offset_end ) {\n            var offset_start = offset_start || 0;\n            var offset_end = offset_end || 0;\n            var c = this.canvas.getContext(\"2d\");\n            c.lineCap = \"round\";\n            c.strokeStyle = this.outer_color;\n            c.lineWidth = outer_width;\n            c.beginPath();\n            c.moveTo( start_x, start_y + offset_start );\n            c.bezierCurveTo( start_x + cp_shift, start_y + offset_start, end_x - cp_shift, end_y + offset_end, end_x, end_y + offset_end);\n            c.stroke();\n            // Inner line\n            c.strokeStyle = this.inner_color;\n            c.lineWidth = inner_width;\n            c.beginPath();\n            c.moveTo( start_x, start_y + offset_start );\n            c.bezierCurveTo( start_x + cp_shift, start_y + offset_start, end_x - cp_shift, end_y + offset_end, end_x, end_y + offset_end );\n            c.stroke();\n        }\n    });\n    return Connector;\n});"]}