{"version":3,"sources":["mvc/workflow/workflow-connector.js"],"names":["define","Connector","handle1","handle2","this","canvas","dragging","inner_color","outer_color","connect","$","extend","prototype","t1","t2","destroy","disconnect","remove","destroyIfInvalid","attachable","redraw","canvas_container","document","createElement","append","style","zIndex","relativeLeft","e","offset","left","relativeTop","top","start_x","element","start_y","end_x","end_y","canvas_min_x","Math","min","canvas_max_x","max","canvas_min_y","canvas_max_y","cp_shift","abs","canvas_left","canvas_top","canvas_width","canvas_height","setAttribute","start_offsets","getContext","end_offsets","num_offsets","isMappedOver","connector","i","inner_width","outer_width","length","draw_outlined_curve","offset_start","offset_end","c","lineCap","strokeStyle","lineWidth","beginPath","moveTo","bezierCurveTo","stroke"],"mappings":"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","file":"../../../scripts/mvc/workflow/workflow-connector.js","sourcesContent":["define([], function(){\n    function Connector( handle1, handle2 ) {\n        this.canvas = null;\n        this.dragging = false;\n        this.inner_color = \"#FFFFFF\";\n        this.outer_color = \"#D8B365\";\n        if ( handle1 && handle2 ) {\n            this.connect( handle1, handle2 );\n        }\n    }\n    $.extend( Connector.prototype, {\n        connect: function ( t1, t2 ) {\n            this.handle1 = t1;\n            if ( this.handle1 ) {\n                this.handle1.connect( this );\n            }\n            this.handle2 = t2;\n            if ( this.handle2 ) {\n                this.handle2.connect( this );\n            }\n        },\n        destroy : function () {\n            if ( this.handle1 ) {\n                this.handle1.disconnect( this );\n            }\n            if ( this.handle2 ) {\n                this.handle2.disconnect( this );\n            }\n            $(this.canvas).remove();\n        },\n        destroyIfInvalid: function() {\n            if( this.handle1 && this.handle2 && ! this.handle2.attachable( this.handle1 ) ) {\n                this.destroy();\n            }\n        },\n        redraw : function () {\n            var canvas_container = $(\"#canvas-container\");\n            if ( ! this.canvas ) {\n                this.canvas = document.createElement( \"canvas\" );\n                canvas_container.append( $(this.canvas) );\n                if ( this.dragging ) {\n                    this.canvas.style.zIndex = \"300\";\n                }\n            }\n            var relativeLeft = function( e ) {\n                return $(e).offset().left - canvas_container.offset().left;\n            };\n            var relativeTop = function( e ) {\n                return $(e).offset().top - canvas_container.offset().top;\n            };\n            if (!this.handle1 || !this.handle2) {\n                return;\n            }\n            // Find the position of each handle\n            var start_x = relativeLeft( this.handle1.element ) + 5;\n            var start_y = relativeTop( this.handle1.element ) + 5;\n            var end_x = relativeLeft( this.handle2.element ) + 5;\n            var end_y = relativeTop( this.handle2.element ) + 5;\n            // Calculate canvas area\n            var canvas_extra = 100;\n            var canvas_min_x = Math.min( start_x, end_x );\n            var canvas_max_x = Math.max( start_x, end_x );\n            var canvas_min_y = Math.min( start_y, end_y );\n            var canvas_max_y = Math.max( start_y, end_y );\n            var cp_shift = Math.min( Math.max( Math.abs( canvas_max_y - canvas_min_y ) / 2, 100 ), 300 );\n            var canvas_left = canvas_min_x - canvas_extra;\n            var canvas_top = canvas_min_y - canvas_extra;\n            var canvas_width = canvas_max_x - canvas_min_x + 2 * canvas_extra;\n            var canvas_height = canvas_max_y - canvas_min_y + 2 * canvas_extra;\n            // Place the canvas\n            this.canvas.style.left = canvas_left + \"px\";\n            this.canvas.style.top = canvas_top + \"px\";\n            this.canvas.setAttribute( \"width\", canvas_width );\n            this.canvas.setAttribute( \"height\", canvas_height );\n            // Adjust points to be relative to the canvas\n            start_x -= canvas_left;\n            start_y -= canvas_top;\n            end_x -= canvas_left;\n            end_y -= canvas_top;\n            // Draw the line\n\n            var c = this.canvas.getContext(\"2d\"),\n                start_offsets = null,\n                end_offsets = null;\n            var num_offsets = 1;\n            if ( this.handle1 && this.handle1.isMappedOver() ) {\n                var start_offsets = [ -6, -3, 0, 3, 6 ];\n                num_offsets = 5;\n            } else {\n                var start_offsets = [ 0 ];\n            }\n            if ( this.handle2 && this.handle2.isMappedOver() ) {\n                var end_offsets = [ -6, -3, 0, 3, 6 ];\n                num_offsets = 5;\n            } else {\n                var end_offsets = [ 0 ];\n            }\n            var connector = this;\n            for( var i = 0; i < num_offsets; i++ ) {\n                var inner_width = 5,\n                    outer_width = 7;\n                if( start_offsets.length > 1 || end_offsets.length > 1 ) {\n                    // We have a multi-run, using many lines, make them small.\n                    inner_width = 1;\n                    outer_width = 3;\n                }\n                connector.draw_outlined_curve( start_x, start_y, end_x, end_y, cp_shift, inner_width, outer_width, start_offsets[ i % start_offsets.length ], end_offsets[ i % end_offsets.length ] );\n            }\n        },\n        draw_outlined_curve : function( start_x, start_y, end_x, end_y, cp_shift, inner_width, outer_width, offset_start, offset_end ) {\n            var offset_start = offset_start || 0;\n            var offset_end = offset_end || 0;\n            var c = this.canvas.getContext(\"2d\");\n            c.lineCap = \"round\";\n            c.strokeStyle = this.outer_color;\n            c.lineWidth = outer_width;\n            c.beginPath();\n            c.moveTo( start_x, start_y + offset_start );\n            c.bezierCurveTo( start_x + cp_shift, start_y + offset_start, end_x - cp_shift, end_y + offset_end, end_x, end_y + offset_end);\n            c.stroke();\n            // Inner line\n            c.strokeStyle = this.inner_color;\n            c.lineWidth = inner_width;\n            c.beginPath();\n            c.moveTo( start_x, start_y + offset_start );\n            c.bezierCurveTo( start_x + cp_shift, start_y + offset_start, end_x - cp_shift, end_y + offset_end, end_x, end_y + offset_end );\n            c.stroke();\n        }\n    });\n    return Connector;\n});"]}