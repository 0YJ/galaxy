{"version":3,"sources":["mvc/base/controlled-fetch-collection.js"],"names":["_underscore","require","_backbone","_baseMvc","ControlledFetchCollection","_backbone2","default","Collection","extend","initialize","models","options","prototype","call","this","setOrder","order","silent","_setUpListeners","on","changed-order","sort","fetch","_buildFetchOptions","Galaxy","debug","self","_underscore2","clone","traditional","data","_buildFetchData","_buildFetchFilters","filters","isEmpty","_fetchFiltersToAjaxData","defaults","pick","_fetchParams","filterMap","q","qv","each","v","k","undefined","push","reset","allFetched","update_time","_baseMvc2","buildComparator","ascending","update_time-asc","create_time","create_time-asc","comparator","collection","comparators","PaginatedCollection","currentPage","getTotalItemCount","length","limitPerPage","getLastPage","Math","floor","getPageCount","getPageLimitOffset","pageNum","constrainPageNum","offset","max","min","fetchPage","limit","always","trigger","fetchCurrentPage","fetchPrevPage","fetchNextPage","InfinitelyScrollingCollection","limitPerFetch","limitOnFirstFetch","remove","fetchFirst","lastFetched","fetchMore","when","_postFetchMore","fetchedData","numFetched","isArray"],"mappings":"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","file":"../../../scripts/mvc/base/controlled-fetch-collection.js","sourcesContent":["import _ from \"libs/underscore\";\nimport Backbone from \"libs/backbone\";\nimport BASE_MVC from \"mvc/base-mvc\";\n\n//=============================================================================\n/**\n * A Collection that can be limited/offset/re-ordered/filtered.\n * @type {Backbone.Collection}\n */\nvar ControlledFetchCollection = Backbone.Collection.extend({\n    /** call setOrder on initialization to build the comparator based on options */\n    initialize: function(models, options) {\n        Backbone.Collection.prototype.initialize.call(this, models, options);\n        this.setOrder(options.order || this.order, { silent: true });\n    },\n\n    /** set up to track order changes and re-sort when changed */\n    _setUpListeners: function() {\n        return this.on({\n            \"changed-order\": this.sort\n        });\n    },\n\n    /** override to provide order and offsets based on instance vars, set limit if passed,\n     *  and set allFetched/fire 'all-fetched' when xhr returns\n     */\n    fetch: function(options) {\n        options = this._buildFetchOptions(options);\n        Galaxy.debug(\"fetch options:\", options);\n        return Backbone.Collection.prototype.fetch.call(this, options);\n    },\n\n    /** build ajax data/parameters from options */\n    _buildFetchOptions: function(options) {\n        // note: we normally want options passed in to override the defaults built here\n        // so most of these fns will generate defaults\n        options = _.clone(options) || {};\n        var self = this;\n\n        // jquery ajax option; allows multiple q/qv for filters (instead of 'q[]')\n        options.traditional = true;\n\n        // options.data\n        // we keep limit, offset, etc. in options *as well as move it into data* because:\n        // - it makes fetch calling convenient to add it to a single options map (instead of as mult. args)\n        // - it allows the std. event handlers (for fetch, etc.) to have access\n        //   to the pagination options too\n        //      (i.e. this.on( 'sync', function( options ){ if( options.limit ){ ... } }))\n        // however, when we send to xhr/jquery we copy them to data also so that they become API query params\n        options.data = options.data || self._buildFetchData(options);\n        Galaxy.debug(\"data:\", options.data);\n\n        // options.data.filters --> options.data.q, options.data.qv\n        var filters = this._buildFetchFilters(options);\n        Galaxy.debug(\"filters:\", filters);\n        if (!_.isEmpty(filters)) {\n            _.extend(options.data, this._fetchFiltersToAjaxData(filters));\n        }\n        Galaxy.debug(\"data:\", options.data);\n        return options;\n    },\n\n    /** Build the dictionary to send to fetch's XHR as data */\n    _buildFetchData: function(options) {\n        var defaults = {};\n        if (this.order) {\n            defaults.order = this.order;\n        }\n        return _.defaults(_.pick(options, this._fetchParams), defaults);\n    },\n\n    /** These attribute keys are valid params to fetch/API-index */\n    _fetchParams: [\n        /** model dependent string to control the order of models returned */\n        \"order\",\n        /** limit the number of models returned from a fetch */\n        \"limit\",\n        /** skip this number of models when fetching */\n        \"offset\",\n        /** what series of attributes to return (model dependent) */\n        \"view\",\n        /** individual keys to return for the models (see api/histories.index) */\n        \"keys\"\n    ],\n\n    /** add any needed filters here based on collection state */\n    _buildFetchFilters: function(options) {\n        // override\n        return _.clone(options.filters || {});\n    },\n\n    /** Convert dictionary filters to qqv style arrays */\n    _fetchFiltersToAjaxData: function(filters) {\n        // return as a map so ajax.data can extend from it\n        var filterMap = {\n            q: [],\n            qv: []\n        };\n        _.each(filters, function(v, k) {\n            // don't send if filter value is empty\n            if (v === undefined || v === \"\") {\n                return;\n            }\n            // json to python\n            if (v === true) {\n                v = \"True\";\n            }\n            if (v === false) {\n                v = \"False\";\n            }\n            if (v === null) {\n                v = \"None\";\n            }\n            // map to k/v arrays (q/qv)\n            filterMap.q.push(k);\n            filterMap.qv.push(v);\n        });\n        return filterMap;\n    },\n\n    /** override to reset allFetched flag to false */\n    reset: function(models, options) {\n        this.allFetched = false;\n        return Backbone.Collection.prototype.reset.call(this, models, options);\n    },\n\n    // ........................................................................ order\n    order: null,\n\n    /** @type {Object} map of collection available sorting orders containing comparator fns */\n    comparators: {\n        update_time: BASE_MVC.buildComparator(\"update_time\", {\n            ascending: false\n        }),\n        \"update_time-asc\": BASE_MVC.buildComparator(\"update_time\", {\n            ascending: true\n        }),\n        create_time: BASE_MVC.buildComparator(\"create_time\", {\n            ascending: false\n        }),\n        \"create_time-asc\": BASE_MVC.buildComparator(\"create_time\", {\n            ascending: true\n        })\n    },\n\n    /** set the order and comparator for this collection then sort with the new order\n     *  @event 'changed-order' passed the new order and the collection\n     */\n    setOrder: function(order, options) {\n        options = options || {};\n        var collection = this;\n        var comparator = collection.comparators[order];\n        if (_.isUndefined(comparator)) {\n            throw new Error(\"unknown order: \" + order);\n        }\n        // if( _.isUndefined( comparator ) ){ return; }\n        if (comparator === collection.comparator) {\n            return;\n        }\n\n        collection.order = order;\n        collection.comparator = comparator;\n\n        if (!options.silent) {\n            collection.trigger(\"changed-order\", options);\n        }\n        return collection;\n    }\n});\n\n//=============================================================================\n/**\n *\n */\nvar PaginatedCollection = ControlledFetchCollection.extend({\n    /** @type {Number} limit used for each page's fetch */\n    limitPerPage: 500,\n\n    initialize: function(models, options) {\n        ControlledFetchCollection.prototype.initialize.call(\n            this,\n            models,\n            options\n        );\n        this.currentPage = options.currentPage || 0;\n    },\n\n    getTotalItemCount: function() {\n        return this.length;\n    },\n\n    shouldPaginate: function() {\n        return this.getTotalItemCount() >= this.limitPerPage;\n    },\n\n    getLastPage: function() {\n        return Math.floor(this.getTotalItemCount() / this.limitPerPage);\n    },\n\n    getPageCount: function() {\n        return this.getLastPage() + 1;\n    },\n\n    getPageLimitOffset: function(pageNum) {\n        pageNum = this.constrainPageNum(pageNum);\n        return {\n            limit: this.limitPerPage,\n            offset: pageNum * this.limitPerPage\n        };\n    },\n\n    constrainPageNum: function(pageNum) {\n        return Math.max(0, Math.min(pageNum, this.getLastPage()));\n    },\n\n    /** fetch the next page of data */\n    fetchPage: function(pageNum, options) {\n        var self = this;\n        pageNum = self.constrainPageNum(pageNum);\n        self.currentPage = pageNum;\n        options = _.defaults(options || {}, self.getPageLimitOffset(pageNum));\n\n        self.trigger(\"fetching-more\");\n        return self.fetch(options).always(function() {\n            self.trigger(\"fetching-more-done\");\n        });\n    },\n\n    fetchCurrentPage: function(options) {\n        return this.fetchPage(this.currentPage, options);\n    },\n\n    fetchPrevPage: function(options) {\n        return this.fetchPage(this.currentPage - 1, options);\n    },\n\n    fetchNextPage: function(options) {\n        return this.fetchPage(this.currentPage + 1, options);\n    }\n});\n\n//=============================================================================\n/**\n * A Collection that will load more elements without reseting.\n */\nvar InfinitelyScrollingCollection = ControlledFetchCollection.extend({\n    /** @type {Number} limit used for the first fetch (or a reset) */\n    limitOnFirstFetch: null,\n    /** @type {Number} limit used for each subsequent fetch */\n    limitPerFetch: 100,\n\n    initialize: function(models, options) {\n        ControlledFetchCollection.prototype.initialize.call(\n            this,\n            models,\n            options\n        );\n        /** @type {Integer} number of contents to return from the first fetch */\n        this.limitOnFirstFetch =\n            options.limitOnFirstFetch || this.limitOnFirstFetch;\n        /** @type {Integer} limit for every fetch after the first */\n        this.limitPerFetch = options.limitPerFetch || this.limitPerFetch;\n        /** @type {Boolean} are all contents fetched? */\n        this.allFetched = false;\n        /** @type {Integer} what was the offset of the last content returned */\n        this.lastFetched = options.lastFetched || 0;\n    },\n\n    /** build ajax data/parameters from options */\n    _buildFetchOptions: function(options) {\n        // options (options for backbone.fetch and jquery.ajax generally)\n        // backbone option; false here to make fetching an addititive process\n        options.remove = options.remove || false;\n        return ControlledFetchCollection.prototype._buildFetchOptions.call(\n            this,\n            options\n        );\n    },\n\n    /** fetch the first 'page' of data */\n    fetchFirst: function(options) {\n        Galaxy.debug(\"ControlledFetchCollection.fetchFirst:\", options);\n        options = options ? _.clone(options) : {};\n        this.allFetched = false;\n        this.lastFetched = 0;\n        return this.fetchMore(\n            _.defaults(options, {\n                reset: true,\n                limit: this.limitOnFirstFetch\n            })\n        );\n    },\n\n    /** fetch the next page of data */\n    fetchMore: function(options) {\n        Galaxy.debug(\"ControlledFetchCollection.fetchMore:\", options);\n        options = _.clone(options || {});\n        var collection = this;\n\n        Galaxy.debug(\"fetchMore, options.reset:\", options.reset);\n        if (!options.reset && collection.allFetched) {\n            return jQuery.when();\n        }\n\n        // TODO: this fails in the edge case where\n        //  the first fetch offset === limit (limit 4, offset 4, collection.length 4)\n        if (options.reset) {\n            options.offset = 0;\n        } else if (options.offset === undefined) {\n            options.offset = collection.lastFetched;\n        }\n        var limit = (options.limit =\n            options.limit || collection.limitPerFetch || null);\n        Galaxy.debug(\"fetchMore, limit:\", limit, \"offset:\", options.offset);\n\n        collection.trigger(\"fetching-more\");\n        return (\n            collection\n                .fetch(options)\n                .always(function() {\n                    collection.trigger(\"fetching-more-done\");\n                })\n                // maintain allFetched flag and trigger if all were fetched this time\n                .done(function _postFetchMore(fetchedData) {\n                    var numFetched = _.isArray(fetchedData)\n                        ? fetchedData.length\n                        : 0;\n                    collection.lastFetched += numFetched;\n                    Galaxy.debug(\n                        \"fetchMore, lastFetched:\",\n                        collection.lastFetched\n                    );\n                    // anything less than a full page means we got all there is to get\n                    if (!limit || numFetched < limit) {\n                        collection.allFetched = true;\n                        collection.trigger(\"all-fetched\", this);\n                    }\n                })\n        );\n    },\n\n    /** fetch all the collection */\n    fetchAll: function(options) {\n        // whitelist options to prevent allowing limit/offset/filters\n        // (use vanilla fetch instead)\n        options = options || {};\n        var self = this;\n        options = _.pick(options, \"silent\");\n        options.filters = {};\n        return self.fetch(options).done(function() {\n            self.allFetched = true;\n            self.trigger(\"all-fetched\", self);\n        });\n    }\n});\n\n//==============================================================================\nexport default {\n    ControlledFetchCollection: ControlledFetchCollection,\n    PaginatedCollection: PaginatedCollection,\n    InfinitelyScrollingCollection: InfinitelyScrollingCollection\n};\n"]}