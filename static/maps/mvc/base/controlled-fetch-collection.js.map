{"version":3,"sources":["mvc/base/controlled-fetch-collection.js"],"names":["define","_","Backbone","BASE_MVC","ControlledFetchCollection","Collection","extend","prototype","setOrder","options","order","this","silent","_setUpListeners","on","changed-order","sort","Galaxy","debug","fetch","call","_buildFetchOptions","self","traditional","data","_buildFetchFilters","isEmpty","filters","_fetchFiltersToAjaxData","_buildFetchData","defaults","pick","_fetchParams","clone","filterMap","q","qv","each","v","push","k","reset","models","comparators","update_time","ascending","update_time-asc","buildComparator","create_time","create_time-asc","collection","comparator","isUndefined","Error","limitPerPage","initialize","currentPage","getTotalItemCount","PaginatedCollection","getLastPage","Math","floor","getPageCount","getPageLimitOffset","pageNum","constrainPageNum","offset","max","min","fetchPage","limit","always","trigger","fetchNextPage","limitOnFirstFetch","limitPerFetch","lastFetched","remove","allFetched","fetchFirst","fetchMore","jQuery","when","undefined","done","isArray","fetchedData","numFetched","fetchAll","InfinitelyScrollingCollection"],"mappings":"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","file":"../../../scripts/mvc/base/controlled-fetch-collection.js","sourcesContent":["define([\n    'libs/underscore',\n    'libs/backbone',\n    'mvc/base-mvc',\n], function( _, Backbone, BASE_MVC ){\n'use strict';\n\n//=============================================================================\n/**\n * A Collection that can be limited/offset/re-ordered/filtered.\n * @type {Backbone.Collection}\n */\nvar ControlledFetchCollection = Backbone.Collection.extend({\n\n    /** call setOrder on initialization to build the comparator based on options */\n    initialize : function( models, options ){\n        Backbone.Collection.prototype.initialize.call( this, models, options );\n        this.setOrder( options.order || this.order, { silent: true });\n    },\n\n    /** set up to track order changes and re-sort when changed */\n    _setUpListeners : function(){\n        return this.on({\n            'changed-order' : this.sort\n        });\n    },\n\n    /** override to provide order and offsets based on instance vars, set limit if passed,\n     *  and set allFetched/fire 'all-fetched' when xhr returns\n     */\n    fetch : function( options ){\n        options = this._buildFetchOptions( options );\n        Galaxy.debug( 'fetch options:', options );\n        return Backbone.Collection.prototype.fetch.call( this, options );\n    },\n\n    /** build ajax data/parameters from options */\n    _buildFetchOptions : function( options ){\n        // note: we normally want options passed in to override the defaults built here\n        // so most of these fns will generate defaults\n        options = _.clone( options ) || {};\n        var self = this;\n\n        // jquery ajax option; allows multiple q/qv for filters (instead of 'q[]')\n        options.traditional = true;\n\n        // options.data\n        // we keep limit, offset, etc. in options *as well as move it into data* because:\n        // - it makes fetch calling convenient to add it to a single options map (instead of as mult. args)\n        // - it allows the std. event handlers (for fetch, etc.) to have access\n        //   to the pagination options too\n        //      (i.e. this.on( 'sync', function( options ){ if( options.limit ){ ... } }))\n        // however, when we send to xhr/jquery we copy them to data also so that they become API query params\n        options.data = options.data || self._buildFetchData( options );\n        Galaxy.debug( 'data:', options.data );\n\n        // options.data.filters --> options.data.q, options.data.qv\n        var filters = this._buildFetchFilters( options );\n        Galaxy.debug( 'filters:', filters );\n        if( !_.isEmpty( filters ) ){\n            _.extend( options.data, this._fetchFiltersToAjaxData( filters ) );\n        }\n        Galaxy.debug( 'data:', options.data );\n        return options;\n    },\n\n    /** Build the dictionary to send to fetch's XHR as data */\n    _buildFetchData : function( options ){\n        var defaults = {};\n        if( this.order ){ defaults.order = this.order; }\n        return _.defaults( _.pick( options, this._fetchParams ), defaults );\n    },\n\n    /** These attribute keys are valid params to fetch/API-index */\n    _fetchParams : [\n        /** model dependent string to control the order of models returned */\n        'order',\n        /** limit the number of models returned from a fetch */\n        'limit',\n        /** skip this number of models when fetching */\n        'offset',\n        /** what series of attributes to return (model dependent) */\n        'view',\n        /** individual keys to return for the models (see api/histories.index) */\n        'keys'\n    ],\n\n    /** add any needed filters here based on collection state */\n    _buildFetchFilters : function( options ){\n        // override\n        return _.clone( options.filters || {} );\n    },\n\n    /** Convert dictionary filters to qqv style arrays */\n    _fetchFiltersToAjaxData : function( filters ){\n        // return as a map so ajax.data can extend from it\n        var filterMap = {\n            q  : [],\n            qv : []\n        };\n        _.each( filters, function( v, k ){\n            // don't send if filter value is empty\n            if( v === undefined || v === '' ){ return; }\n            // json to python\n            if( v === true ){ v = 'True'; }\n            if( v === false ){ v = 'False'; }\n            if( v === null ){ v = 'None'; }\n            // map to k/v arrays (q/qv)\n            filterMap.q.push( k );\n            filterMap.qv.push( v );\n        });\n        return filterMap;\n    },\n\n    /** override to reset allFetched flag to false */\n    reset : function( models, options ){\n        this.allFetched = false;\n        return Backbone.Collection.prototype.reset.call( this, models, options );\n    },\n\n    // ........................................................................ order\n    order : null,\n\n    /** @type {Object} map of collection available sorting orders containing comparator fns */\n    comparators : {\n        'update_time'       : BASE_MVC.buildComparator( 'update_time', { ascending: false }),\n        'update_time-asc'   : BASE_MVC.buildComparator( 'update_time', { ascending: true }),\n        'create_time'       : BASE_MVC.buildComparator( 'create_time', { ascending: false }),\n        'create_time-asc'   : BASE_MVC.buildComparator( 'create_time', { ascending: true }),\n    },\n\n    /** set the order and comparator for this collection then sort with the new order\n     *  @event 'changed-order' passed the new order and the collection\n     */\n    setOrder : function( order, options ){\n        options = options || {};\n        var collection = this;\n        var comparator = collection.comparators[ order ];\n        if( _.isUndefined( comparator ) ){ throw new Error( 'unknown order: ' + order ); }\n        // if( _.isUndefined( comparator ) ){ return; }\n        if( comparator === collection.comparator ){ return; }\n\n        collection.order = order;\n        collection.comparator = comparator;\n\n        if( !options.silent ){\n            collection.trigger( 'changed-order', options );\n        }\n        return collection;\n    },\n\n});\n\n\n//=============================================================================\n/**\n *\n */\nvar PaginatedCollection = ControlledFetchCollection.extend({\n\n    /** @type {Number} limit used for each page's fetch */\n    limitPerPage       : 500,\n\n    initialize : function( models, options ){\n        ControlledFetchCollection.prototype.initialize.call( this, models, options );\n        this.currentPage = options.currentPage || 0;\n    },\n\n    getTotalItemCount : function(){\n        return this.length;\n    },\n\n    shouldPaginate : function(){\n        return this.getTotalItemCount() >= this.limitPerPage;\n    },\n\n    getLastPage : function(){\n        return Math.floor( this.getTotalItemCount() / this.limitPerPage );\n    },\n\n    getPageCount : function(){\n        return this.getLastPage() + 1;\n    },\n\n    getPageLimitOffset : function( pageNum ){\n        pageNum = this.constrainPageNum( pageNum );\n        return {\n            limit : this.limitPerPage,\n            offset: pageNum * this.limitPerPage\n        };\n    },\n\n    constrainPageNum : function( pageNum ){\n        return Math.max( 0, Math.min( pageNum, this.getLastPage() ));\n    },\n\n    /** fetch the next page of data */\n    fetchPage : function( pageNum, options ){\n        var self = this;\n        pageNum = self.constrainPageNum( pageNum );\n        self.currentPage = pageNum;\n        options = _.defaults( options || {}, self.getPageLimitOffset( pageNum ) );\n\n        self.trigger( 'fetching-more' );\n        return self.fetch( options )\n            .always( function(){\n                self.trigger( 'fetching-more-done' );\n            });\n    },\n\n    fetchCurrentPage : function( options ){\n        return this.fetchPage( this.currentPage, options );\n    },\n\n    fetchPrevPage : function( options ){\n        return this.fetchPage( this.currentPage - 1, options );\n    },\n\n    fetchNextPage : function( options ){\n        return this.fetchPage( this.currentPage + 1, options );\n    },\n});\n\n\n//=============================================================================\n/**\n * A Collection that will load more elements without reseting.\n */\nvar InfinitelyScrollingCollection = ControlledFetchCollection.extend({\n\n    /** @type {Number} limit used for the first fetch (or a reset) */\n    limitOnFirstFetch   : null,\n    /** @type {Number} limit used for each subsequent fetch */\n    limitPerFetch       : 100,\n\n    initialize : function( models, options ){\n        ControlledFetchCollection.prototype.initialize.call( this, models, options );\n        /** @type {Integer} number of contents to return from the first fetch */\n        this.limitOnFirstFetch = options.limitOnFirstFetch || this.limitOnFirstFetch;\n        /** @type {Integer} limit for every fetch after the first */\n        this.limitPerFetch = options.limitPerFetch || this.limitPerFetch;\n        /** @type {Boolean} are all contents fetched? */\n        this.allFetched = false;\n        /** @type {Integer} what was the offset of the last content returned */\n        this.lastFetched = options.lastFetched || 0;\n    },\n\n    /** build ajax data/parameters from options */\n    _buildFetchOptions : function( options ){\n        // options (options for backbone.fetch and jquery.ajax generally)\n        // backbone option; false here to make fetching an addititive process\n        options.remove = options.remove || false;\n        return ControlledFetchCollection.prototype._buildFetchOptions.call( this, options );\n    },\n\n    /** fetch the first 'page' of data */\n    fetchFirst : function( options ){\n        Galaxy.debug( 'ControlledFetchCollection.fetchFirst:', options );\n        options = options? _.clone( options ) : {};\n        this.allFetched = false;\n        this.lastFetched = 0;\n        return this.fetchMore( _.defaults( options, {\n            reset : true,\n            limit : this.limitOnFirstFetch,\n        }));\n    },\n\n    /** fetch the next page of data */\n    fetchMore : function( options ){\n        Galaxy.debug( 'ControlledFetchCollection.fetchMore:', options );\n        options = _.clone( options || {} );\n        var collection = this;\n\n        Galaxy.debug( 'fetchMore, options.reset:', options.reset );\n        if( ( !options.reset && collection.allFetched ) ){\n            return jQuery.when();\n        }\n\n        // TODO: this fails in the edge case where\n        //  the first fetch offset === limit (limit 4, offset 4, collection.length 4)\n        if (options.reset){\n            options.offset = 0;\n        } else if (options.offset === undefined){\n            options.offset = collection.lastFetched;\n        }\n        var limit = options.limit = options.limit || collection.limitPerFetch || null;\n        Galaxy.debug( 'fetchMore, limit:', limit, 'offset:', options.offset );\n\n        collection.trigger( 'fetching-more' );\n        return collection.fetch( options )\n            .always( function(){\n                collection.trigger( 'fetching-more-done' );\n            })\n            // maintain allFetched flag and trigger if all were fetched this time\n            .done( function _postFetchMore( fetchedData ){\n                var numFetched = _.isArray( fetchedData )? fetchedData.length : 0;\n                collection.lastFetched += numFetched;\n                Galaxy.debug( 'fetchMore, lastFetched:', collection.lastFetched );\n                // anything less than a full page means we got all there is to get\n                if( !limit || numFetched < limit ){\n                    collection.allFetched = true;\n                    collection.trigger( 'all-fetched', this );\n                }\n            }\n        );\n    },\n\n    /** fetch all the collection */\n    fetchAll : function( options ){\n        // whitelist options to prevent allowing limit/offset/filters\n        // (use vanilla fetch instead)\n        options = options || {};\n        var self = this;\n        options = _.pick( options, 'silent' );\n        options.filters = {};\n        return self.fetch( options ).done( function( ){\n            self.allFetched = true;\n            self.trigger( 'all-fetched', self );\n        });\n    },\n});\n\n\n//==============================================================================\n    return {\n        ControlledFetchCollection     : ControlledFetchCollection,\n        PaginatedCollection           : PaginatedCollection,\n        InfinitelyScrollingCollection : InfinitelyScrollingCollection,\n    };\n});\n"]}