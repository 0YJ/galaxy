{"version":3,"sources":["mvc/dataset/dataset-model.js"],"names":["_states","require","_baseMvc","_localization","logNamespace","searchableMixin","_baseMvc2","default","SearchableModelMixin","DatasetAssociation","Backbone","Model","extend","LoggableMixin","mixin","_logNamespace","defaults","state","_states2","NEW","purged","accessible","data_type","file_ext","meta_files","misc_blurb","misc_info","tags","initialize","attributes","options","this","debug","get","set","NOT_VIEWABLE","urls","_generateUrls","_setUpListeners","id","purge","display","edit","download","_downloadQueryParameters","report_error","rerun","show_params","visualization","meta_download","value","key","Galaxy","root","each","on","currModel","newState","log","inReadyState","trigger","previous","toJSON","json","prototype","call","_","isDeletedOrPurged","ready","contains","READY_STATES","hasDetails","has","hasData","fetch","dataset","parse","response","parsed","create_time","update_time","Date","save","attrs","wait","isUndefined","delete","jQuery","when","deleted","undelete","xhr","ajax","url","message","status","hda","error","responseObj","messageBuriedInUnfortunatelyFormattedError","responseJSON","_localization2","responseText","indexOf","info","nameAndId","searchAliases","title","format","database","DatasetAssociationCollection","description","tag","toString","urlRoot","Collection","model","haveDetails","ajaxQueue","deferred","Deferred","item","startingLength","length","notReady","filter","content","ajaxFns","chain","reverse","curr","total","ajaxFn","always","responses","map","i","done","notify","matchesWhat","push","shift","resolve","matches","join"],"mappings":"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","file":"../../../scripts/mvc/dataset/dataset-model.js","sourcesContent":["import STATES from \"mvc/dataset/states\";\nimport BASE_MVC from \"mvc/base-mvc\";\nimport _l from \"utils/localization\";\n\nvar logNamespace = \"dataset\";\n//==============================================================================\nvar searchableMixin = BASE_MVC.SearchableModelMixin;\n/** @class base model for any DatasetAssociation (HDAs, LDDAs, DatasetCollectionDAs).\n *      No knowledge of what type (HDA/LDDA/DCDA) should be needed here.\n *  The DA's are made searchable (by attribute) by mixing in SearchableModelMixin.\n */\nvar DatasetAssociation = Backbone.Model.extend(BASE_MVC.LoggableMixin).extend(\n    BASE_MVC.mixin(\n        searchableMixin,\n        /** @lends DatasetAssociation.prototype */ {\n            _logNamespace: logNamespace,\n\n            /** default attributes for a model */\n            defaults: {\n                state: STATES.NEW,\n                deleted: false,\n                purged: false,\n                name: \"(unnamed dataset)\",\n                accessible: true,\n                // sniffed datatype (sam, tabular, bed, etc.)\n                data_type: \"\",\n                file_ext: \"\",\n                file_size: 0,\n\n                // array of associated file types (eg. [ 'bam_index', ... ])\n                meta_files: [],\n\n                misc_blurb: \"\",\n                misc_info: \"\",\n\n                tags: []\n                // do NOT default on annotation, as this default is valid and will be passed on 'save'\n                //  which is incorrect behavior when the model is only partially fetched (annos are not passed in summary data)\n                //annotation          : ''\n            },\n\n            /** instance vars and listeners */\n            initialize: function(attributes, options) {\n                this.debug(this + \"(Dataset).initialize\", attributes, options);\n\n                //!! this state is not in trans.app.model.Dataset.states - set it here -\n                if (!this.get(\"accessible\")) {\n                    this.set(\"state\", STATES.NOT_VIEWABLE);\n                }\n\n                /** Datasets rely/use some web controllers - have the model generate those URLs on startup */\n                this.urls = this._generateUrls();\n\n                this._setUpListeners();\n            },\n\n            /** returns misc. web urls for rendering things like re-run, display, etc. */\n            _generateUrls: function() {\n                var id = this.get(\"id\");\n                if (!id) {\n                    return {};\n                }\n                var urls = {\n                    purge: \"datasets/\" + id + \"/purge_async\",\n                    display: \"datasets/\" + id + \"/display/?preview=True\",\n                    edit: \"datasets/edit?dataset_id=\" + id,\n                    download:\n                        \"datasets/\" +\n                        id +\n                        \"/display\" +\n                        this._downloadQueryParameters(),\n                    report_error: \"dataset/errors?id=\" + id,\n                    rerun: \"tool_runner/rerun?id=\" + id,\n                    show_params: \"datasets/\" + id + \"/show_params\",\n                    visualization: \"visualization\",\n                    meta_download:\n                        \"dataset/get_metadata_file?hda_id=\" +\n                        id +\n                        \"&metadata_name=\"\n                };\n                _.each(urls, function(value, key) {\n                    urls[key] = Galaxy.root + value;\n                });\n                this.urls = urls;\n                return urls;\n            },\n\n            _downloadQueryParameters: function() {\n                return \"?to_ext=\" + this.get(\"file_ext\");\n            },\n\n            /** set up any event listeners\n     *  event: state:ready  fired when this DA moves into/is already in a ready state\n     */\n            _setUpListeners: function() {\n                // if the state has changed and the new state is a ready state, fire an event\n                this.on(\"change:state\", function(currModel, newState) {\n                    this.log(this + \" has changed state:\", currModel, newState);\n                    if (this.inReadyState()) {\n                        this.trigger(\n                            \"state:ready\",\n                            currModel,\n                            newState,\n                            this.previous(\"state\")\n                        );\n                    }\n                });\n                // the download url (currently) relies on having a correct file extension\n                this.on(\"change:id change:file_ext\", function(currModel) {\n                    this._generateUrls();\n                });\n            },\n\n            // ........................................................................ common queries\n            /** override to add urls */\n            toJSON: function() {\n                var json = Backbone.Model.prototype.toJSON.call(this);\n                //console.warn( 'returning json?' );\n                //return json;\n                return _.extend(json, {\n                    urls: this.urls\n                });\n            },\n\n            /** Is this dataset deleted or purged? */\n            isDeletedOrPurged: function() {\n                return this.get(\"deleted\") || this.get(\"purged\");\n            },\n\n            /** Is this dataset in a 'ready' state; where 'Ready' states are states where no\n     *      processing (for the ds) is left to do on the server.\n     */\n            inReadyState: function() {\n                var ready = _.contains(STATES.READY_STATES, this.get(\"state\"));\n                return this.isDeletedOrPurged() || ready;\n            },\n\n            /** Does this model already contain detailed data (as opposed to just summary level data)? */\n            hasDetails: function() {\n                // if it's inaccessible assume it has everything it needs\n                if (!this.get(\"accessible\")) {\n                    return true;\n                }\n                return this.has(\"annotation\");\n            },\n\n            /** Convenience function to match dataset.has_data. */\n            hasData: function() {\n                return this.get(\"file_size\") > 0;\n            },\n\n            // ........................................................................ ajax\n            fetch: function(options) {\n                var dataset = this;\n                return Backbone.Model.prototype.fetch\n                    .call(this, options)\n                    .always(function() {\n                        dataset._generateUrls();\n                    });\n            },\n\n            /** override to use actual Dates objects for create/update times */\n            parse: function(response, options) {\n                var parsed = Backbone.Model.prototype.parse.call(\n                    this,\n                    response,\n                    options\n                );\n                if (parsed.create_time) {\n                    parsed.create_time = new Date(parsed.create_time);\n                }\n                if (parsed.update_time) {\n                    parsed.update_time = new Date(parsed.update_time);\n                }\n                return parsed;\n            },\n\n            /** override to wait by default */\n            save: function(attrs, options) {\n                options = options || {};\n                options.wait = _.isUndefined(options.wait)\n                    ? true\n                    : options.wait;\n                return Backbone.Model.prototype.save.call(this, attrs, options);\n            },\n\n            //NOTE: subclasses of DA's will need to implement url and urlRoot in order to have these work properly\n            /** save this dataset, _Mark_ing it as deleted (just a flag) */\n            delete: function(options) {\n                if (this.get(\"deleted\")) {\n                    return jQuery.when();\n                }\n                return this.save({ deleted: true }, options);\n            },\n            /** save this dataset, _Mark_ing it as undeleted */\n            undelete: function(options) {\n                if (!this.get(\"deleted\") || this.get(\"purged\")) {\n                    return jQuery.when();\n                }\n                return this.save({ deleted: false }, options);\n            },\n\n            /** remove the file behind this dataset from the filesystem (if permitted) */\n            purge: function _purge(options) {\n                //TODO: use, override model.destroy, HDA.delete({ purge: true })\n                if (this.get(\"purged\")) {\n                    return jQuery.when();\n                }\n                options = options || {};\n                options.url = this.urls.purge;\n\n                //TODO: ideally this would be a DELETE call to the api\n                //  using purge async for now\n                var hda = this,\n                    xhr = jQuery.ajax(options);\n                xhr.done(function(message, status, responseObj) {\n                    hda.set({ deleted: true, purged: true });\n                });\n                xhr.fail(function(xhr, status, message) {\n                    // Exception messages are hidden within error page including:  '...not allowed in this Galaxy instance.'\n                    // unbury and re-add to xhr\n                    var error = _l(\"Unable to purge dataset\");\n                    var messageBuriedInUnfortunatelyFormattedError =\n                        \"Removal of datasets by users \" +\n                        \"is not allowed in this Galaxy instance\";\n                    if (xhr.responseJSON && xhr.responseJSON.error) {\n                        error = xhr.responseJSON.error;\n                    } else if (\n                        xhr.responseText.indexOf(\n                            messageBuriedInUnfortunatelyFormattedError\n                        ) !== -1\n                    ) {\n                        error = messageBuriedInUnfortunatelyFormattedError;\n                    }\n                    xhr.responseText = error;\n                    hda.trigger(\"error\", hda, xhr, options, _l(error), {\n                        error: error\n                    });\n                });\n                return xhr;\n            },\n\n            // ........................................................................ searching\n            /** what attributes of an HDA will be used in a text search */\n            searchAttributes: [\n                \"name\",\n                \"file_ext\",\n                \"genome_build\",\n                \"misc_blurb\",\n                \"misc_info\",\n                \"annotation\",\n                \"tags\"\n            ],\n\n            /** our attr keys don't often match the labels we display to the user - so, when using\n     *      attribute specifiers ('name=\"bler\"') in a term, allow passing in aliases for the\n     *      following attr keys.\n     */\n            searchAliases: {\n                title: \"name\",\n                format: \"file_ext\",\n                database: \"genome_build\",\n                blurb: \"misc_blurb\",\n                description: \"misc_blurb\",\n                info: \"misc_info\",\n                tag: \"tags\"\n            },\n\n            // ........................................................................ misc\n            /** String representation */\n            toString: function() {\n                var nameAndId = this.get(\"id\") || \"\";\n                if (this.get(\"name\")) {\n                    nameAndId = '\"' + this.get(\"name\") + '\",' + nameAndId;\n                }\n                return \"Dataset(\" + nameAndId + \")\";\n            }\n        }\n    )\n);\n\n//==============================================================================\n/** @class Backbone collection for dataset associations.\n */\nvar DatasetAssociationCollection = Backbone.Collection\n    .extend(BASE_MVC.LoggableMixin)\n    .extend(\n        /** @lends HistoryContents.prototype */ {\n            _logNamespace: logNamespace,\n\n            model: DatasetAssociation,\n\n            /** root api url */\n            urlRoot: Galaxy.root + \"api/datasets\",\n\n            /** url fn */\n            url: function() {\n                return this.urlRoot;\n            },\n\n            // ........................................................................ common queries\n            /** Get the ids of every item in this collection\n     *  @returns array of encoded ids\n     */\n            ids: function() {\n                return this.map(function(item) {\n                    return item.get(\"id\");\n                });\n            },\n\n            /** Get contents that are not ready\n     *  @returns array of content models\n     */\n            notReady: function() {\n                return this.filter(function(content) {\n                    return !content.inReadyState();\n                });\n            },\n\n            /** return true if any datasets don't have details */\n            haveDetails: function() {\n                return this.all(function(dataset) {\n                    return dataset.hasDetails();\n                });\n            },\n\n            // ........................................................................ ajax\n            /** using a queue, perform ajaxFn on each of the models in this collection */\n            ajaxQueue: function(ajaxFn, options) {\n                var deferred = jQuery.Deferred(),\n                    startingLength = this.length,\n                    responses = [];\n\n                if (!startingLength) {\n                    deferred.resolve([]);\n                    return deferred;\n                }\n\n                // use reverse order (stylistic choice)\n                var ajaxFns = this.chain()\n                    .reverse()\n                    .map(function(dataset, i) {\n                        return function() {\n                            var xhr = ajaxFn.call(dataset, options);\n                            // if successful, notify using the deferred to allow tracking progress\n                            xhr.done(function(response) {\n                                deferred.notify({\n                                    curr: i,\n                                    total: startingLength,\n                                    response: response,\n                                    model: dataset\n                                });\n                            });\n                            // (regardless of previous error or success) if not last ajax call, shift and call the next\n                            //  if last fn, resolve deferred\n                            xhr.always(function(response) {\n                                responses.push(response);\n                                if (ajaxFns.length) {\n                                    ajaxFns.shift()();\n                                } else {\n                                    deferred.resolve(responses);\n                                }\n                            });\n                        };\n                    })\n                    .value();\n                // start the queue\n                ajaxFns.shift()();\n\n                return deferred;\n            },\n\n            // ........................................................................ sorting/filtering\n            /** return a new collection of datasets whose attributes contain the substring matchesWhat */\n            matches: function(matchesWhat) {\n                return this.filter(function(dataset) {\n                    return dataset.matches(matchesWhat);\n                });\n            },\n\n            /** String representation. */\n            toString: function() {\n                return [\"DatasetAssociationCollection(\", this.length, \")\"].join(\n                    \"\"\n                );\n            }\n        }\n    );\n\n//==============================================================================\nexport default {\n    DatasetAssociation: DatasetAssociation,\n    DatasetAssociationCollection: DatasetAssociationCollection\n};\n"]}