{"version":3,"sources":["mvc/base-mvc.js"],"names":["LoggableMixin","logger","_logNamespace","_addLogging2","default","SessionStorageModel","_backbone2","Model","extend","initialize","initialAttrs","this","_checkEnabledSessionStorage","id","Error","existing","isNew","_read","clear","silent","save","_underscore2","defaults","on","length","alert","sync","method","model","options","returned","_create","_update","trigger","_delete","success","error","json","setItem","JSON","stringify","set","err","DOMException","navigator","userAgent","indexOf","parse","sessionStorage","removeItem","hasOwnProperty","toString","prototype","omit","_log","SearchableModelMixin","searchAttributes","searchAliases","attrKey","searchFor","attrVal","get","undefined","isArray","toLowerCase","_searchArrayAttribute","array","any","elem","search","filter","key","searchAttribute","matches","split","term","matchesAll","terms","match","s","all","replace","HiddenUntilActivatedViewMixin","$elementShown","$activator","showSpeed","HUAVOptions","$el","showFn","hasBeenShown","is","mixin","hidden","isHidden","ev","toggle","isFunction","onshowFirstTime","call","onshow","onhide","apply","arguments","DraggableViewMixin","attributes","draggable","$dragHandle","$","toggleDraggable","dragStartHandler","dragEndHandler","handle","draggableOn","draggableOff","bind","_dragStartHandler","_dragEndHandler","removeEventListener","attr","addEventListener","event","dataTransfer","effectAllowed","setData","toJSON","SelectableViewMixin","selectable","selected","$selector","_renderSelected","find","toggleClass","showSelector","speed","toggleSelector","hideSelector","fxSpeed","show","hide","select","toggleSelect","deselect","mixinHash1","propsHash","args","Array","slice","lastArg","pop","unshift","wrapTemplate","b","attribute_name","jsonNamespace","a","templateFn","template","join","view","templateVars","_l","buildComparator","ascending"],"mappings":"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","file":"../../scripts/mvc/base-mvc.js","sourcesContent":["import _ from \"libs/underscore\";\nimport Backbone from \"libs/backbone\";\nimport addLogging from \"utils/add-logging\";\nimport _l from \"utils/localization\";\n\n//==============================================================================\n/** @class Mixin to add logging capabilities to an object.\n *      Designed to allow switching an objects log output off/on at one central\n *      statement. Can be used with plain browser console (or something more\n *      complex like an AJAX logger).\n *  <br />NOTE: currently only uses the console.debug log function\n *  (as opposed to debug, error, warn, etc.)\n *  @name LoggableMixin\n *\n *  @example\n *  // Add to your models/views at the definition using chaining:\n *      var MyModel = Backbone.Model.extend( LoggableMixin ).extend({ // ... });\n *\n *  // or - more explicitly AFTER the definition:\n *      var MyModel = Backbone.Model.extend({\n *          logger  : console\n *          // ...\n *          this.log( '$#%& it! - broken already...' );\n *      })\n *      _.extend( MyModel.prototype, LoggableMixin )\n *\n */\nvar LoggableMixin = /** @lends LoggableMixin# */ {\n    // replace null with console (if available) to see all logs for a particular view/model\n    /** The logging object whose log function will be used to output\n     *      messages. Null will supress all logging. Commonly set to console.\n     */\n    logger: null,\n    /** @type {String} a namespace for filtering/focusing log output */\n    _logNamespace: \".\"\n};\naddLogging(LoggableMixin);\n\n//==============================================================================\n/** Backbone model that syncs to the browser's sessionStorage API.\n *      This all largely happens behind the scenes and no special calls are required.\n */\nvar SessionStorageModel = Backbone.Model.extend({\n    initialize: function(initialAttrs) {\n        // check for sessionStorage and error if no id is provided\n        this._checkEnabledSessionStorage();\n        if (!initialAttrs.id) {\n            throw new Error(\n                \"SessionStorageModel requires an id in the initial attributes\"\n            );\n        }\n        this.id = initialAttrs.id;\n\n        // load existing from storage (if any), clear any attrs set by bbone before init is called,\n        //  layer initial over existing and defaults, and save\n        var existing = !this.isNew() ? this._read(this) : {};\n        this.clear({ silent: true });\n        this.save(_.extend({}, this.defaults, existing, initialAttrs), {\n            silent: true\n        });\n\n        // save on any change to it immediately\n        this.on(\"change\", function() {\n            this.save();\n        });\n    },\n\n    _checkEnabledSessionStorage: function() {\n        try {\n            return window.sessionStorage.length >= 0;\n        } catch (err) {\n            alert(\"Please enable cookies in your browser for this Galaxy site\");\n            return false;\n        }\n    },\n\n    /** override of bbone sync to save to sessionStorage rather than REST\n     *      bbone options (success, errror, etc.) should still apply\n     */\n    sync: function(method, model, options) {\n        if (!options.silent) {\n            model.trigger(\"request\", model, {}, options);\n        }\n        var returned = {};\n        switch (method) {\n            case \"create\":\n                returned = this._create(model);\n                break;\n            case \"read\":\n                returned = this._read(model);\n                break;\n            case \"update\":\n                returned = this._update(model);\n                break;\n            case \"delete\":\n                returned = this._delete(model);\n                break;\n        }\n        if (returned !== undefined || returned !== null) {\n            if (options.success) {\n                options.success();\n            }\n        } else {\n            if (options.error) {\n                options.error();\n            }\n        }\n        return returned;\n    },\n\n    /** set storage to the stringified item */\n    _create: function(model) {\n        try {\n            var json = model.toJSON(),\n                set = sessionStorage.setItem(model.id, JSON.stringify(json));\n            return set === null ? set : json;\n            // DOMException is thrown in Safari if in private browsing mode and sessionStorage is attempted:\n            // http://stackoverflow.com/questions/14555347\n            // TODO: this could probably use a more general soln - like detecting priv. mode + safari => non-ajaxing Model\n        } catch (err) {\n            if (\n                !(\n                    err instanceof DOMException &&\n                    navigator.userAgent.indexOf(\"Safari\") > -1\n                )\n            ) {\n                throw err;\n            }\n        }\n        return null;\n    },\n\n    /** read and parse json from storage */\n    _read: function(model) {\n        return JSON.parse(sessionStorage.getItem(model.id));\n    },\n\n    /** set storage to the item (alias to create) */\n    _update: function(model) {\n        return model._create(model);\n    },\n\n    /** remove the item from storage */\n    _delete: function(model) {\n        return sessionStorage.removeItem(model.id);\n    },\n\n    /** T/F whether sessionStorage contains the model's id (data is present) */\n    isNew: function() {\n        return !sessionStorage.hasOwnProperty(this.id);\n    },\n\n    _log: function() {\n        return JSON.stringify(this.toJSON(), null, \"  \");\n    },\n    toString: function() {\n        return \"SessionStorageModel(\" + this.id + \")\";\n    }\n});\n(function() {\n    SessionStorageModel.prototype = _.omit(\n        SessionStorageModel.prototype,\n        \"url\",\n        \"urlRoot\"\n    );\n})();\n\n//==============================================================================\n/** Function that allows mixing of hashs into bbone MVC while showing the mixins first\n *      (before the more local class overrides/hash).\n *      Basically, a simple reversal of param order on _.defaults() - to show mixins in top of definition.\n *  @example:\n *      var NewModel = Something.extend( mixin( MyMixinA, MyMixinB, { ... myVars : ... }) );\n *\n *  NOTE: this does not combine any hashes (like events, etc.) and you're expected to handle that\n */\nfunction mixin(mixinHash1, /* mixinHash2, etc: ... variadic */ propsHash) {\n    var args = Array.prototype.slice.call(arguments, 0),\n        lastArg = args.pop();\n    args.unshift(lastArg);\n    return _.defaults.apply(_, args);\n}\n\n//==============================================================================\n/** A mixin for models that allow T/F/Matching to their attributes - useful when\n *      searching or filtering collections of models.\n * @example:\n *      see hda-model for searchAttribute and searchAliases definition examples.\n *      see history-contents.matches for how collections are filtered\n *      and see readonly-history-view.searchHdas for how user input is connected to the filtering\n */\nvar SearchableModelMixin = {\n    /** what attributes of an HDA will be used in a text search */\n    searchAttributes: [\n        // override\n    ],\n\n    /** our attr keys don't often match the labels we display to the user - so, when using\n     *      attribute specifiers ('name=\"bler\"') in a term, allow passing in aliases for the\n     *      following attr keys.\n     */\n    searchAliases: {\n        // override\n    },\n\n    /** search the attribute with key attrKey for the string searchFor; T/F if found */\n    searchAttribute: function(attrKey, searchFor) {\n        var attrVal = this.get(attrKey);\n        //this.debug( 'searchAttribute', attrKey, attrVal, searchFor );\n        // bail if empty searchFor or unsearchable values\n        if (!searchFor || (attrVal === undefined || attrVal === null)) {\n            return false;\n        }\n        // pass to sep. fn for deep search of array attributes\n        if (_.isArray(attrVal)) {\n            return this._searchArrayAttribute(attrVal, searchFor);\n        }\n        return (\n            attrVal\n                .toString()\n                .toLowerCase()\n                .indexOf(searchFor.toLowerCase()) !== -1\n        );\n    },\n\n    /** deep(er) search for array attributes; T/F if found */\n    _searchArrayAttribute: function(array, searchFor) {\n        //this.debug( '_searchArrayAttribute', array, searchFor );\n        searchFor = searchFor.toLowerCase();\n        //precondition: searchFor has already been validated as non-empty string\n        //precondition: assumes only 1 level array\n        //TODO: could possibly break up searchFor more (CSV...)\n        return _.any(array, function(elem) {\n            return (\n                elem\n                    .toString()\n                    .toLowerCase()\n                    .indexOf(searchFor.toLowerCase()) !== -1\n            );\n        });\n    },\n\n    /** search all searchAttributes for the string searchFor,\n     *      returning a list of keys of attributes that contain searchFor\n     */\n    search: function(searchFor) {\n        var model = this;\n        return _.filter(this.searchAttributes, function(key) {\n            return model.searchAttribute(key, searchFor);\n        });\n    },\n\n    /** alias of search, but returns a boolean; accepts attribute specifiers where\n     *      the attributes searched can be narrowed to a single attribute using\n     *      the form: matches( 'genome_build=hg19' )\n     *      (the attribute keys allowed can also be aliases to the true attribute key;\n     *          see searchAliases above)\n     *  @param {String} term   plain text or ATTR_SPECIFIER sep. key=val pair\n     *  @returns {Boolean} was term found in (any) attribute(s)\n     */\n    matches: function(term) {\n        var ATTR_SPECIFIER = \"=\",\n            split = term.split(ATTR_SPECIFIER);\n        // attribute is specified - search only that\n        if (split.length >= 2) {\n            var attrKey = split[0];\n            attrKey = this.searchAliases[attrKey] || attrKey;\n            return this.searchAttribute(attrKey, split[1]);\n        }\n        // no attribute is specified - search all attributes in searchAttributes\n        return !!this.search(term).length;\n    },\n\n    /** an implicit AND search for all terms; IOW, a model must match all terms given\n     *      where terms is a whitespace separated value string.\n     *      e.g. given terms of: 'blah bler database=hg19'\n     *          an HDA would have to have attributes containing blah AND bler AND a genome_build == hg19\n     *      To include whitespace in terms: wrap the term in double quotations (name=\"blah bler\").\n     */\n    matchesAll: function(terms) {\n        var model = this;\n        // break the terms up by whitespace and filter out the empty strings\n        terms = terms.match(/(\".*\"|\\w*=\".*\"|\\S*)/g).filter(function(s) {\n            return !!s;\n        });\n        return _.all(terms, function(term) {\n            term = term.replace(/\"/g, \"\");\n            return model.matches(term);\n        });\n    }\n};\n\n//==============================================================================\n/** A view that renders hidden and shows when some activator is clicked.\n *      options:\n *          showFn: the effect used to show/hide the View (defaults to jq.toggle)\n *          $elementShown: some jqObject (defaults to this.$el) to be shown/hidden\n *          onShowFirstTime: fn called the first time the view is shown\n *          onshow: fn called every time the view is shown\n *          onhide: fn called every time the view is hidden\n *      events:\n *          hiddenUntilActivated:shown (the view is passed as an arg)\n *          hiddenUntilActivated:hidden (the view is passed as an arg)\n *      instance vars:\n *          view.hidden {boolean} is the view in the hidden state\n */\nvar HiddenUntilActivatedViewMixin = /** @lends hiddenUntilActivatedMixin# */ {\n    //TODO: since this is a mixin, consider moving toggle, hidden into HUAVOptions\n\n    /** call this in your initialize to set up the mixin\n     *  @param {jQuery} $activator the 'button' that's clicked to show/hide the view\n     *  @param {Object} hash with mixin options\n     */\n    hiddenUntilActivated: function($activator, options) {\n        // call this in your view's initialize fn\n        options = options || {};\n        //TODO: flesh out options - show them all here\n        this.HUAVOptions = {\n            $elementShown: this.$el,\n            showFn: jQuery.prototype.toggle,\n            showSpeed: \"fast\"\n        };\n        _.extend(this.HUAVOptions, options || {});\n        /** has this been shown already (and onshowFirstTime called)? */\n        this.HUAVOptions.hasBeenShown = this.HUAVOptions.$elementShown.is(\n            \":visible\"\n        );\n        this.hidden = this.isHidden();\n\n        if ($activator) {\n            var mixin = this;\n            $activator.on(\"click\", function(ev) {\n                mixin.toggle(mixin.HUAVOptions.showSpeed);\n            });\n        }\n    },\n\n    //TODO:?? remove? use .hidden?\n    /** returns T/F if the view is hidden */\n    isHidden: function() {\n        return this.HUAVOptions.$elementShown.is(\":hidden\");\n    },\n\n    /** toggle the hidden state, show/hide $elementShown, call onshow/hide, trigger events */\n    toggle: function() {\n        //TODO: more specific name - toggle is too general\n        // can be called manually as well with normal toggle arguments\n        //TODO: better as a callback (when the show/hide is actually done)\n        // show\n        if (this.hidden) {\n            // fire the optional fns on the first/each showing - good for render()\n            if (!this.HUAVOptions.hasBeenShown) {\n                if (_.isFunction(this.HUAVOptions.onshowFirstTime)) {\n                    this.HUAVOptions.hasBeenShown = true;\n                    this.HUAVOptions.onshowFirstTime.call(this);\n                }\n            }\n            if (_.isFunction(this.HUAVOptions.onshow)) {\n                this.HUAVOptions.onshow.call(this);\n                this.trigger(\"hiddenUntilActivated:shown\", this);\n            }\n            this.hidden = false;\n\n            // hide\n        } else {\n            if (_.isFunction(this.HUAVOptions.onhide)) {\n                this.HUAVOptions.onhide.call(this);\n                this.trigger(\"hiddenUntilActivated:hidden\", this);\n            }\n            this.hidden = true;\n        }\n        return this.HUAVOptions.showFn.apply(\n            this.HUAVOptions.$elementShown,\n            arguments\n        );\n    }\n};\n\n//==============================================================================\n/** Mixin for views that can be dragged and dropped\n *      Allows for the drag behavior to be turned on/off, setting/removing jQuery event\n *          handlers each time.\n *      dataTransfer data is set to the JSON string of the view's model.toJSON\n *      Override '$dragHandle' to define the draggable DOM sub-element.\n */\nvar DraggableViewMixin = {\n    /** set up instance vars to track whether this view is currently draggable */\n    initialize: function(attributes) {\n        /** is the body of this hda view expanded/not? */\n        this.draggable = attributes.draggable || false;\n    },\n\n    /** what part of the view's DOM triggers the dragging */\n    $dragHandle: function() {\n        //TODO: make abstract/general - move this to listItem\n        // override to the element you want to be your view's handle\n        return this.$(\".title-bar\");\n    },\n\n    /** toggle whether this view is draggable */\n    toggleDraggable: function() {\n        if (this.draggable) {\n            this.draggableOff();\n        } else {\n            this.draggableOn();\n        }\n    },\n\n    /** allow the view to be dragged, set up event handlers */\n    draggableOn: function() {\n        this.draggable = true;\n        this.dragStartHandler = _.bind(this._dragStartHandler, this);\n        this.dragEndHandler = _.bind(this._dragEndHandler, this);\n\n        var handle = this.$dragHandle()\n            .attr(\"draggable\", true)\n            .get(0);\n        handle.addEventListener(\"dragstart\", this.dragStartHandler, false);\n        handle.addEventListener(\"dragend\", this.dragEndHandler, false);\n    },\n\n    /** turn of view dragging and remove event listeners */\n    draggableOff: function() {\n        this.draggable = false;\n        var handle = this.$dragHandle()\n            .attr(\"draggable\", false)\n            .get(0);\n        handle.removeEventListener(\"dragstart\", this.dragStartHandler, false);\n        handle.removeEventListener(\"dragend\", this.dragEndHandler, false);\n    },\n\n    /** sets the dataTransfer data to the model's toJSON\n     *  @fires draggable:dragstart (bbone event) which is passed the event and this view\n     */\n    _dragStartHandler: function(event) {\n        event.dataTransfer.effectAllowed = \"move\";\n        //ASSUMES: this.model\n        //TODO: all except IE: should be 'application/json', IE: must be 'text'\n        event.dataTransfer.setData(\"text\", JSON.stringify(this.model.toJSON()));\n        this.trigger(\"draggable:dragstart\", event, this);\n        return false;\n    },\n\n    /** handle the dragend\n     *  @fires draggable:dragend (bbone event) which is passed the event and this view\n     */\n    _dragEndHandler: function(event) {\n        this.trigger(\"draggable:dragend\", event, this);\n        return false;\n    }\n};\n\n//==============================================================================\n/** Mixin that allows a view to be selected (gen. from a list).\n *      Selection controls ($selector) may be hidden/shown/toggled.\n *          The bbone event 'selectable' is fired when the controls are shown/hidden (passed T/F).\n *      Default rendering is a font-awesome checkbox.\n *      Default selector is '.selector' within the view's $el.\n *      The bbone events 'selected' and 'de-selected' are fired when the $selector is clicked.\n *          Both events are passed the view and the (jQuery) event.\n */\nvar SelectableViewMixin = {\n    /** Set up instance state vars for whether the selector is shown and whether the view has been selected */\n    initialize: function(attributes) {\n        /** is the view currently in selection mode? */\n        this.selectable = attributes.selectable || false;\n        /** is the view currently selected? */\n        this.selected = attributes.selected || false;\n    },\n\n    /** $el sub-element where the selector is rendered and what can be clicked to select. */\n    $selector: function() {\n        return this.$(\".selector\");\n    },\n\n    /** How the selector is rendered - defaults to font-awesome checkbox */\n    _renderSelected: function() {\n        // override\n        this.$selector()\n            .find(\"span\")\n            .toggleClass(\"fa-check-square-o\", this.selected)\n            .toggleClass(\"fa-square-o\", !this.selected);\n    },\n\n    /** Toggle whether the selector is shown */\n    toggleSelector: function() {\n        //TODO: use this.selectable\n        if (!this.$selector().is(\":visible\")) {\n            this.showSelector();\n        } else {\n            this.hideSelector();\n        }\n    },\n\n    /** Display the selector control.\n     *  @param {Number} a jQuery fx speed\n     *  @fires: selectable which is passed true (IOW, the selector is shown) and the view\n     */\n    showSelector: function(speed) {\n        speed = speed !== undefined ? speed : this.fxSpeed;\n        // make sure selected state is represented properly\n        this.selectable = true;\n        this.trigger(\"selectable\", true, this);\n        this._renderSelected();\n        if (speed) {\n            this.$selector().show(speed);\n        } else {\n            this.$selector().show();\n        }\n    },\n\n    /** remove the selector control\n     *  @param {Number} a jQuery fx speed\n     *  @fires: selectable which is passed false (IOW, the selector is not shown) and the view\n     */\n    hideSelector: function(speed) {\n        speed = speed !== undefined ? speed : this.fxSpeed;\n        // reverse the process from showSelect\n        this.selectable = false;\n        this.trigger(\"selectable\", false, this);\n        if (speed) {\n            this.$selector().hide(speed);\n        } else {\n            this.$selector().hide();\n        }\n    },\n\n    /** Toggle whether the view is selected */\n    toggleSelect: function(event) {\n        if (this.selected) {\n            this.deselect(event);\n        } else {\n            this.select(event);\n        }\n    },\n\n    /** Select this view and re-render the selector control to show it\n     *  @param {Event} a jQuery event that caused the selection\n     *  @fires: selected which is passed the view and the DOM event that triggered it (optionally)\n     */\n    select: function(event) {\n        // switch icon, set selected, and trigger event\n        if (!this.selected) {\n            this.trigger(\"selected\", this, event);\n            this.selected = true;\n            this._renderSelected();\n        }\n        return false;\n    },\n\n    /** De-select this view and re-render the selector control to show it\n     *  @param {Event} a jQuery event that caused the selection\n     *  @fires: de-selected which is passed the view and the DOM event that triggered it (optionally)\n     */\n    deselect: function(event) {\n        // switch icon, set selected, and trigger event\n        if (this.selected) {\n            this.trigger(\"de-selected\", this, event);\n            this.selected = false;\n            this._renderSelected();\n        }\n        return false;\n    }\n};\n\n//==============================================================================\n/** Return an underscore template fn from an array of strings.\n *  @param {String[]} template      the template strings to compile into the underscore template fn\n *  @param {String} jsonNamespace   an optional namespace for the json data passed in (defaults to 'model')\n *  @returns {Function} the (wrapped) underscore template fn\n *      The function accepts:\n *\n *  The template strings can access:\n *      the json/model hash using model (\"<%- model.myAttr %>) using the jsonNamespace above\n *      _l: the localizer function\n *      view (if passed): ostensibly, the view using the template (handy for view instance vars)\n *      Because they're namespaced, undefined attributes will not throw an error.\n *\n *  @example:\n *      templateBler : BASE_MVC.wrapTemplate([\n *          '<div class=\"myclass <%- mynamespace.modelClass %>\">',\n *              '<span><% print( _l( mynamespace.message ) ); %>:<%= view.status %></span>'\n *          '</div>'\n *      ], 'mynamespace' )\n *\n *  Meant to be called in a View's definition in order to compile only once.\n *\n */\nfunction wrapTemplate(template, jsonNamespace) {\n    jsonNamespace = jsonNamespace || \"model\";\n    var templateFn = _.template(template.join(\"\"));\n    return function(json, view) {\n        var templateVars = { view: view || {}, _l: _l };\n        templateVars[jsonNamespace] = json || {};\n        return templateFn(templateVars);\n    };\n}\n\n//==============================================================================\n/** Return a comparator function for sorted Collections */\nfunction buildComparator(attribute_name, options) {\n    options = options || {};\n    var ascending = options.ascending ? 1 : -1;\n    return function __comparator(a, b) {\n        a = a.get(attribute_name);\n        b = b.get(attribute_name);\n        return (a < b ? -1 : a > b ? 1 : 0) * ascending;\n    };\n}\n\n//==============================================================================\nexport default {\n    LoggableMixin: LoggableMixin,\n    SessionStorageModel: SessionStorageModel,\n    mixin: mixin,\n    SearchableModelMixin: SearchableModelMixin,\n    HiddenUntilActivatedViewMixin: HiddenUntilActivatedViewMixin,\n    DraggableViewMixin: DraggableViewMixin,\n    SelectableViewMixin: SelectableViewMixin,\n    wrapTemplate: wrapTemplate,\n    buildComparator: buildComparator\n};\n"]}