{"version":3,"sources":["utils/localization.js"],"names":["define","localeStrings","hasOwnProperty","locale","navigator","language","userLanguage","toLowerCase","split","__root","localize","strToLocalize","cacheNonLocalized"],"mappings":"aAAAA,QACI,mBADJA,SACIC,GAQJ,GAAAA,EAAIA,eAAcC,UAAlB,CAEI,IAAAC,EAIgBF,oBAAhBA,UAA+B,UAFnBG,UAAUC,UAAYD,UAAUE,cAAgB,UAAWC,cAK3EN,EAAAA,EAAA,KAAAE,IAAAF,EAAA,KAAAE,EAAAK,MAAA,KAAA,KAAAP,EAAAQ,OAaI,IAAAC,EAAA,SAAAC,GAWA,OAAOV,EAAeU,IAAmBA,GAMzC,OAAAD,EAAAE,mBAAA,EAAOF","file":"../../scripts/utils/localization.js","sourcesContent":["define([\n    'i18n!nls/locale'\n], function( localeStrings ){\n\n// =============================================================================\n/** Simple string replacement localization. Language data from galaxy/scripts/nls */\n\n// support both requirejs and webpack from the same file\n// if loaded via webpack, it will be a different format than via requirejs - convert\nif( localeStrings.hasOwnProperty( '__root' ) ){\n    //console.debug( 'amdi18n+webpack localization for ' + locale + ' loaded' );\n    var locale = (\n        typeof navigator === 'undefined' ? '__root'\n            : ( navigator.language || navigator.userLanguage || '__root' ).toLowerCase()\n    );\n    localeStrings = localeStrings[ '__' + locale ] || localeStrings[ '__' + locale.split('-')[0] ] ||localeStrings.__root;\n\n// } else {\n//     console.debug( 'i18n+requirejs localization for ' + locale + ' loaded' );\n}\n// TODO: when this is no longer necessary remove this, i18n.js, and the resolveModule in config\n\n// -----------------------------------------------------------------------------\n/** Attempt to get a localized string for strToLocalize. If not found, return\n *      the original strToLocalize.\n * @param {String} strToLocalize the string to localize\n * @returns either the localized string if found or strToLocalize if not found\n */\nvar localize = function( strToLocalize ){\n    // console.debug( 'amdi18n.localize:', strToLocalize, '->', localeStrings[ strToLocalize ] || strToLocalize );\n\n    // //TODO: conditional compile on DEBUG flag\n    // // cache strings that need to be localized but haven't been?\n    // if( localize.cacheNonLocalized && !localeStrings.hasOwnProperty( strToLocalize ) ){\n    //     // console.debug( 'localization NOT found:', strToLocalize );\n    //     // add nonCached as hash directly to this function\n    //     localize.nonLocalized = localize.nonLocalized || {};\n    //     localize.nonLocalized[ locale ] = localize.nonLocalized[ locale ] || {};\n    //     localize.nonLocalized[ locale ][ strToLocalize ] = false;\n    // }\n\n    // return the localized version from the closure if it's there, the strToLocalize if not\n    return localeStrings[ strToLocalize ] || strToLocalize;\n};\nlocalize.cacheNonLocalized = false;\n\n\n// =============================================================================\n    return localize;\n});\n"]}