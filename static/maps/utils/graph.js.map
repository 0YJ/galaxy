{"version":3,"sources":["utils/graph.js"],"names":["define","matches","d","d2","k","hasOwnProperty","iterate","obj","propsOrFn","fn","undefined","props","_typeof","returned","index","key","call","value","Edge","source","target","data","self","this","Vertex","name","Graph","processFns","vertexLate","search","directed","exitTimes","vertex","prototype","toString","toJSON","json","eachEdge","edges","GraphSearch","graph","edge","from","_cache","start","vertices","_search","discovered","searchTree","Object","keys","map","_searchTree","BreadthFirstSearch","constructor","queue","length","shift","vertexEarly","adj","push","DepthFirstSearch","adjacent","sourceVertex","recurse","entryTimes","time","discoverAdjacentVertices","window","options","allowReflexiveEdges","numEdges","read","readNodesAndLinks","readVerticesAndEdges","nodes","node","createVertex","links","i","sourceName","createEdge","forEach","targetName","isReflexive","targetVertex","Array","concat","apply","eachVertex","eachAdjacent","print","console","log","strings","to","join","toNodesAndLinks","indeces","breadthFirstSearchTree","depthFirstSearchTree","weakComponents","undiscovered","searchGraph","components","undiscoveredVertex","filter","vertexName","hasBeenReversed","swap","weakComponentGraph","curr","reduction","component","randGraph","numVerts","Math","floor","random","range","randRange"],"mappings":"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","file":"../../scripts/utils/graph.js","sourcesContent":["define([\n],function(){\n/* ============================================================================\nTODO:\n\n============================================================================ */\n//TODO: go ahead and move to underscore...\n/** call fn on each key/value in d */\nfunction each( d, fn ){\n    for( var k in d ){\n        if( d.hasOwnProperty( k ) ){\n            fn( d[ k ], k, d );\n        }\n    }\n}\n\n/** copy key/values from d2 to d overwriting if present */\nfunction extend( d, d2 ){\n    for( var k in d2 ){\n        if( d2.hasOwnProperty( k ) ){\n            d[ k ] = d2[ k ];\n        }\n    }\n    return d;\n}\n\n/** deep equal of two dictionaries */\nfunction matches( d, d2 ){\n    for( var k in d2 ){\n        if( d2.hasOwnProperty( k ) ){\n            if( !d.hasOwnProperty( k ) || d[ k ] !== d2[ k ] ){\n                return false;\n            }\n        }\n    }\n    return true;\n}\n\n/** map key/values in obj\n *      if propsOrFn is an object, return only those k/v that match the object\n *      if propsOrFn is function, call the fn and returned the mapped values from it\n */\nfunction iterate( obj, propsOrFn ){\n    var fn =    typeof propsOrFn === 'function'? propsOrFn : undefined,\n        props = typeof propsOrFn === 'object'?   propsOrFn : undefined,\n        returned = [],\n        index = 0;\n    for( var key in obj ){\n        if( obj.hasOwnProperty( key ) ){\n            var value = obj[ key ];\n            if( fn ){\n                returned.push( fn.call( value, value, key, index ) );\n            } else if( props ){\n//TODO: break out to sep?\n                if( typeof value === 'object' && matches( value, props ) ){\n                    returned.push( value );\n                }\n            } else {\n                returned.push( value );\n            }\n            index += 1;\n        }\n    }\n    return returned;\n}\n\n\n// ============================================================================\n/** A graph edge containing the name/id of both source and target and optional data\n */\nfunction Edge( source, target, data ){\n    var self = this;\n    self.source = source !== undefined? source : null;\n    self.target = target !== undefined? target : null;\n    self.data = data || null;\n    //if( typeof data === 'object' ){\n    //    extend( self, data );\n    //}\n    return self;\n}\n/** String representation */\nEdge.prototype.toString = function(){\n    return this.source + '->' + this.target;\n};\n\n/** Return a plain object representing this edge */\nEdge.prototype.toJSON = function(){\n    //TODO: this is safe in most browsers (fns will be stripped) - alter tests to incorporate this in order to pass data\n    //return this;\n    var json = {\n        source : this.source,\n        target : this.target\n    };\n    if( this.data ){\n        json.data = this.data;\n    }\n    return json;\n};\n\n// ============================================================================\n/** A graph vertex with a (unique) name/id and optional data.\n *      A vertex contains a list of Edges (whose sources are this vertex) and maintains the degree.\n */\nfunction Vertex( name, data ){\n    var self = this;\n    self.name = name !== undefined? name : '(unnamed)';\n    self.data = data || null;\n    self.edges = {};\n    self.degree = 0;\n    return self;\n}\n\n/** String representation */\nVertex.prototype.toString = function(){\n    return 'Vertex(' + this.name + ')';\n};\n\n//TODO: better name w no collision for either this.eachEdge or this.edges\n/** Iterate over each edge from this vertex */\nVertex.prototype.eachEdge = function( propsOrFn ){\n    return iterate( this.edges, propsOrFn );\n};\n\n/** Return a plain object representing this vertex */\nVertex.prototype.toJSON = function(){\n    //return this;\n    return {\n        name : this.name,\n        data : this.data\n    };\n};\n\n\n// ============================================================================\n/** Base (abstract) class for Graph search algorithms.\n *      Pass in the graph to search\n *      and an optional dictionary containing the 3 vertex/edge processing fns listed below.\n */\nvar GraphSearch = function( graph, processFns ){\n    var self = this;\n    self.graph = graph;\n\n    self.processFns = processFns || {\n        vertexEarly : function( vertex, search ){\n            //console.debug( 'processing vertex:', vertex.name, vertex );\n        },\n        edge        : function( from, edge, search ){\n            //console.debug( this, 'edge:', from, edge, search );\n        },\n        vertexLate  : function( vertex, search ){\n            //console.debug( this, 'vertexLate:', vertex, search );\n        }\n    };\n\n    self._cache = {};\n    return self;\n};\n\n/** Search interface where start is the vertex (or the name/id of the vertex) to begin the search at\n *      This public interface caches searches and returns the cached version if it's already been done.\n */\nGraphSearch.prototype.search = function _search( start ){\n    var self = this;\n    if( start in self._cache ){ return self._cache[ start ]; }\n    if( !( start instanceof Vertex ) ){ start = self.graph.vertices[ start ]; }\n    return ( self._cache[ start.name ] = self._search( start ) );\n};\n\n/** Actual search (private) function (abstract here) */\nGraphSearch.prototype._search = function __search( start, search ){\n    search = search || {\n        discovered : {},\n        //parents : {},\n        edges : []\n    };\n    return search;\n};\n\n/** Searches graph from start and returns a search tree of the results */\nGraphSearch.prototype.searchTree = function _searchTree( start ){\n    return this._searchTree( this.search( start ) );\n};\n\n/** Helper fn that returns a graph (a search tree) based on the search object passed in (does not actually search) */\nGraphSearch.prototype._searchTree = function __searchTree( search ){\n    var self = this;\n    return new Graph( true, {\n        edges: search.edges,\n        vertices: Object.keys( search.discovered ).map( function( key ){\n            return self.graph.vertices[ key ].toJSON();\n        })\n    });\n};\n\n\n// ============================================================================\n/** Breadth first search algo.\n */\nvar BreadthFirstSearch = function( graph, processFns ){\n    var self = this;\n    GraphSearch.call( this, graph, processFns );\n    return self;\n};\nBreadthFirstSearch.prototype = new GraphSearch();\nBreadthFirstSearch.prototype.constructor = BreadthFirstSearch;\n\n/** (Private) implementation of BFS */\nBreadthFirstSearch.prototype._search = function __search( start, search ){\n    search = search || {\n        discovered : {},\n        //parents : {},\n        edges : []\n    };\n\n    var self = this,\n        queue = [];\n\n    function discoverAdjacent( adj, edge ){\n        var source = this;\n        if( self.processFns.edge ){ self.processFns.edge.call( self, source, edge, search ); }\n        if( !search.discovered[ adj.name ] ){\n            //console.debug( '\\t\\t\\t', adj.name, 'is undiscovered:', search.discovered[ adj.name ] );\n            search.discovered[ adj.name ] = true;\n            //search.parents[ adj.name ] = source;\n            search.edges.push({ source: source.name, target: adj.name });\n            //console.debug( '\\t\\t\\t queuing undiscovered: ', adj );\n            queue.push( adj );\n        }\n    }\n\n    //console.debug( 'BFS starting. start:', start );\n    search.discovered[ start.name ] = true;\n    queue.push( start );\n    while( queue.length ){\n        var vertex = queue.shift();\n        //console.debug( '\\t Queue is shifting. Current:', vertex, 'queue:', queue );\n        if( self.processFns.vertexEarly ){ self.processFns.vertexEarly.call( self, vertex, search ); }\n        self.graph.eachAdjacent( vertex, discoverAdjacent );\n        if( self.processFns.vertexLate ){ self.processFns.vertexLate.call( self, vertex, search ); }\n    }\n    //console.debug( 'search.edges:', JSON.stringify( search.edges ) );\n    return search;\n};\n\n\n// ============================================================================\n/** Depth first search algorithm.\n */\nvar DepthFirstSearch = function( graph, processFns ){\n    var self = this;\n    GraphSearch.call( this, graph, processFns );\n    return self;\n};\nDepthFirstSearch.prototype = new GraphSearch();\nDepthFirstSearch.prototype.constructor = DepthFirstSearch;\n\n/** (Private) implementation of DFS */\nDepthFirstSearch.prototype._search = function( start, search ){\n    //console.debug( 'depthFirstSearch:', start );\n    search = search || {\n        discovered : {},\n        //parents    : {},\n        edges      : [],\n        entryTimes : {},\n        exitTimes  : {}\n    };\n    var self = this,\n        time = 0;\n\n    // discover verts adjacent to the source (this):\n    //  processing each edge, saving the edge to the tree, and caching the reverse path with parents\n    function discoverAdjacentVertices( adjacent, edge ){\n        //console.debug( '\\t\\t adjacent:', adjacent, 'edge:', edge );\n        var sourceVertex = this;\n        if( self.processFns.edge ){ self.processFns.edge.call( self, sourceVertex, edge, search ); }\n        if( !search.discovered[ adjacent.name ] ){\n            //search.parents[ adjacent.name ] = sourceVertex;\n            search.edges.push({ source: sourceVertex.name, target: adjacent.name });\n            recurse( adjacent );\n        }\n    }\n\n    // use function stack for DFS stack process verts, times, and discover adjacent verts (recursing into them)\n    function recurse( vertex ){\n        //console.debug( '\\t recursing into: ', vertex );\n        search.discovered[ vertex.name ] = true;\n        if( self.processFns.vertexEarly ){ self.processFns.vertexEarly.call( self, vertex, search ); }\n        search.entryTimes[ vertex.name ] = time++;\n\n        self.graph.eachAdjacent( vertex, discoverAdjacentVertices );\n\n        if( self.processFns.vertexLate ){ self.processFns.vertexLate.call( self, vertex, search ); }\n        search.exitTimes[ vertex.name ] = time++;\n    }\n    // begin recursion with the desired start\n    recurse( start );\n\n    return search;\n};\n\n\n// ============================================================================\n/** A directed/non-directed graph object.\n */\nfunction Graph( directed, data, options ){\n//TODO: move directed to options\n    this.directed = directed || false;\n    return this.init( options ).read( data );\n}\nwindow.Graph = Graph;\n\n/** Set up options and instance variables */\nGraph.prototype.init = function( options ){\n    options = options || {};\n    var self = this;\n\n    self.allowReflexiveEdges = options.allowReflexiveEdges || false;\n\n    self.vertices = {};\n    self.numEdges = 0;\n    return self;\n};\n\n/** Read data from the plain object data - both in d3 form (nodes and links) or vertices and edges */\nGraph.prototype.read = function( data ){\n    if( !data ){ return this; }\n    var self = this;\n    if( data.hasOwnProperty( 'nodes' ) ){ return self.readNodesAndLinks( data ); }\n    if( data.hasOwnProperty( 'vertices' ) ){ return self.readVerticesAndEdges( data ); }\n    return self;\n};\n\n//TODO: the next two could be combined\n/** Create the graph using a list of nodes and a list of edges (where source and target are indeces into nodes) */\nGraph.prototype.readNodesAndLinks = function( data ){\n    if( !( data && data.hasOwnProperty( 'nodes' ) ) ){ return this; }\n    //console.debug( 'readNodesAndLinks:', data );\n    //console.debug( 'data:\\n' + JSON.stringify( data, null, '  ' ) );\n    var self = this;\n    data.nodes.forEach( function( node ){\n        self.createVertex( node.name, node.data );\n    });\n    //console.debug( JSON.stringify( self.vertices, null, '  ' ) );\n\n    ( data.links || [] ).forEach( function( edge, i ){\n        var sourceName = data.nodes[ edge.source ].name,\n            targetName = data.nodes[ edge.target ].name;\n        self.createEdge( sourceName, targetName, self.directed );\n    });\n    //self.print();\n    //console.debug( JSON.stringify( self.toNodesAndLinks(), null, '  ' ) );\n    return self;\n};\n\n/** Create the graph using a list of nodes and a list of edges (where source and target are names of nodes) */\nGraph.prototype.readVerticesAndEdges = function( data ){\n    if( !( data && data.hasOwnProperty( 'vertices' ) ) ){ return this; }\n    //console.debug( 'readVerticesAndEdges:', data );\n    //console.debug( 'data:\\n' + JSON.stringify( data, null, '  ' ) );\n    var self = this;\n    data.vertices.forEach( function( node ){\n        self.createVertex( node.name, node.data );\n    });\n    //console.debug( JSON.stringify( self.vertices, null, '  ' ) );\n\n    ( data.edges || [] ).forEach( function( edge, i ){\n        self.createEdge( edge.source, edge.target, self.directed );\n    });\n    //self.print();\n    //console.debug( JSON.stringify( self.toNodesAndLinks(), null, '  ' ) );\n    return self;\n};\n\n/** Return the vertex with name, creating it if necessary */\nGraph.prototype.createVertex = function( name, data ){\n    //console.debug( 'createVertex:', name, data );\n    if( this.vertices[ name ] ){ return this.vertices[ name ]; }\n    return ( this.vertices[ name ] = new Vertex( name, data ) );\n};\n\n/** Create an edge in vertex named sourceName to targetName (optionally adding data to it)\n *      If directed is false, create a second edge from targetName to sourceName.\n */\nGraph.prototype.createEdge = function( sourceName, targetName, directed, data ){\n    //note: allows multiple 'equivalent' edges (to/from same source/target)\n    //console.debug( 'createEdge:', source, target, directed );\n    var isReflexive = sourceName === targetName;\n    if( !this.allowReflexiveEdges && isReflexive ){ return null; }\n\n    sourceVertex = this.vertices[ sourceName ];\n    targetVertex = this.vertices[ targetName ];\n    //note: silently ignores edges from/to unknown vertices\n    if( !( sourceVertex && targetVertex ) ){ return null; }\n\n//TODO: prob. move to vertex\n    var self = this,\n        edge = new Edge( sourceName, targetName, data );\n    sourceVertex.edges[ targetName ] = edge;\n    sourceVertex.degree += 1;\n    self.numEdges += 1;\n    \n    //TODO:! don't like having duplicate edges for non-directed graphs\n    // mirror edges (reversing source and target) in non-directed graphs\n    //  but only if not reflexive\n    if( !isReflexive && !directed ){\n        // flip directed to prevent recursion loop\n        self.createEdge( targetName, sourceName, true );\n    }\n\n    return edge;\n};\n\n/** Walk over all the edges of the graph using the vertex.eachEdge iterator */\nGraph.prototype.edges = function( propsOrFn ){\n    return Array.prototype.concat.apply( [], this.eachVertex( function( vertex ){\n        return vertex.eachEdge( propsOrFn );\n    }));\n};\n\n/** Iterate over all the vertices in the graph */\nGraph.prototype.eachVertex = function( propsOrFn ){\n    return iterate( this.vertices, propsOrFn );\n};\n\n/** Return a list of the vertices adjacent to vertex */\nGraph.prototype.adjacent = function( vertex ){\n    var self = this;\n    return iterate( vertex.edges, function( edge ){\n        return self.vertices[ edge.target ];\n    });\n};\n\n/** Call fn on each vertex adjacent to vertex */\nGraph.prototype.eachAdjacent = function( vertex, fn ){\n    var self = this;\n    return iterate( vertex.edges, function( edge ){\n        var adj = self.vertices[ edge.target ];\n        return fn.call( vertex, adj, edge );\n    });\n};\n\n/** Print the graph to the console (debugging) */\nGraph.prototype.print = function(){\n    var self = this;\n    console.log( 'Graph has ' + Object.keys( self.vertices ).length + ' vertices' );\n    self.eachVertex( function( vertex ){\n        console.log( vertex.toString() );\n        vertex.eachEdge( function( edge ){\n            console.log( '\\t ' + edge );\n        });\n    });\n    return self;\n};\n\n/** Return a DOT format string of this graph */\nGraph.prototype.toDOT = function(){\n    var self = this,\n        strings = [];\n    strings.push( 'graph bler {' );\n    self.edges( function( edge ){\n        strings.push( '\\t' + edge.from + ' -- ' + edge.to + ';' );\n    });\n    strings.push( '}' );\n    return strings.join( '\\n' );\n};\n\n/** Return vertices and edges of this graph in d3 node/link format */\nGraph.prototype.toNodesAndLinks = function(){\n    var self = this,\n        indeces = {};\n    return {\n        nodes : self.eachVertex( function( vertex, key, i ){\n            indeces[ vertex.name ] = i;\n            return vertex.toJSON();\n        }),\n        links : self.edges( function( edge ){\n            var json = edge.toJSON();\n            json.source = indeces[ edge.source ];\n            json.target = indeces[ edge.target ];\n            return json;\n        })\n    };\n};\n\n/** Return vertices and edges of this graph where edges use the name/id as source and target */\nGraph.prototype.toVerticesAndEdges = function(){\n    var self = this;\n    return {\n        vertices : self.eachVertex( function( vertex, key ){\n            return vertex.toJSON();\n        }),\n        edges : self.edges( function( edge ){\n            return edge.toJSON();\n        })\n    };\n};\n\n/** Search this graph using BFS */\nGraph.prototype.breadthFirstSearch = function( start, processFns ){\n    return new BreadthFirstSearch( this ).search( start );\n};\n\n/** Return a searchtree of this graph using BFS */\nGraph.prototype.breadthFirstSearchTree = function( start, processFns ){\n    return new BreadthFirstSearch( this ).searchTree( start );\n};\n\n/** Search this graph using DFS */\nGraph.prototype.depthFirstSearch = function( start, processFns ){\n    return new DepthFirstSearch( this ).search( start );\n};\n\n/** Return a searchtree of this graph using DFS */\nGraph.prototype.depthFirstSearchTree = function( start, processFns ){\n    return new DepthFirstSearch( this ).searchTree( start );\n};\n\n\n//Graph.prototype.shortestPath = function( start, end ){\n//};\n//\n//Graph.prototype.articulationVertices = function(){\n//};\n//\n//Graph.prototype.isAcyclic = function(){\n//};\n//\n//Graph.prototype.isBipartite = function(){\n//};\n\n/** Return an array of weakly connected (no edges between) sub-graphs in this graph */\nGraph.prototype.weakComponents = function(){\n//TODO: alternately, instead of returning graph-like objects:\n//  - could simply decorate the vertices (vertex.component = componentIndex), or clone the graph and do that\n    var self = this,\n        searchGraph = this,\n        undiscovered,\n        components = [];\n\n    function getComponent( undiscoveredVertex ){\n//TODO: better interface on dfs (search v. searchTree)\n        var search = new DepthFirstSearch( searchGraph )._search( undiscoveredVertex );\n\n        // remove curr discovered from undiscovered\n        undiscovered = undiscovered.filter( function( name ){\n            return !( name in search.discovered );\n        });\n\n        return {\n            vertices : Object.keys( search.discovered ).map( function( vertexName ){\n                return self.vertices[ vertexName ].toJSON();\n            }),\n            edges : search.edges.map( function( edge ){\n                // restore any reversed edges\n                var hasBeenReversed = self.vertices[ edge.target ].edges[ edge.source ] !== undefined;\n                if( self.directed && hasBeenReversed ){\n                    var swap = edge.source;\n                    edge.source = edge.target;\n                    edge.target = swap;\n                }\n                return edge;\n            })\n        };\n    }\n\n    if( self.directed ){\n        // if directed - convert to undirected for search\n        searchGraph = new Graph( false, self.toNodesAndLinks() );\n    }\n    undiscovered = Object.keys( searchGraph.vertices );\n    //console.debug( '(initial) undiscovered:', undiscovered );\n    while( undiscovered.length ){\n        var undiscoveredVertex = searchGraph.vertices[ undiscovered.shift() ];\n        components.push( getComponent( undiscoveredVertex ) );\n        //console.debug( 'undiscovered now:', undiscovered );\n    }\n\n    //console.debug( 'components:\\n', JSON.stringify( components, null, '  ' ) );\n    return components;\n};\n\n/** Return a single graph containing the weakly connected components in this graph */\nGraph.prototype.weakComponentGraph = function(){\n    //note: although this can often look like the original graph - edges can be lost\n    var components = this.weakComponents();\n    return new Graph( this.directed, {\n        vertices : components.reduce( function( reduction, curr ){\n            return reduction.concat( curr.vertices );\n        }, [] ),\n        edges : components.reduce( function( reduction, curr ){\n            return reduction.concat( curr.edges );\n        }, [] )\n    });\n};\n\n/** Return an array of graphs of the weakly connected components in this graph */\nGraph.prototype.weakComponentGraphArray = function(){\n    //note: although this can often look like the original graph - edges can be lost\n    var graph = this;\n    return this.weakComponents().map( function( component ){\n        return new Graph( graph.directed, component );\n    });\n};\n\n\n// ============================================================================\n/** Create a random graph with numVerts vertices and numEdges edges (for testing)\n */\nfunction randGraph( directed, numVerts, numEdges ){\n    //console.debug( 'randGraph', directed, numVerts, numEdges );\n    var data = { nodes : [], links : [] };\n    function randRange( range ){\n        return Math.floor( Math.random() * range );\n    }\n    for( var i=0; i<numVerts; i++ ){\n        data.nodes.push({ name: i });\n    }\n    for( i=0; i<numEdges; i++ ){\n        data.links.push({\n            source : randRange( numVerts ),\n            target : randRange( numVerts )\n        });\n    }\n    //console.debug( JSON.stringify( data, null, '  ' ) );\n    return new Graph( directed, data );\n}\n\n\n// ============================================================================\n    return {\n        Vertex : Vertex,\n        Edge : Edge,\n        BreadthFirstSearch : BreadthFirstSearch,\n        DepthFirstSearch : DepthFirstSearch,\n        Graph : Graph,\n        randGraph : randGraph\n    };\n});\n"]}