{"version":3,"sources":["utils/graph.js"],"names":["define","matches","d","d2","k","hasOwnProperty","iterate","obj","propsOrFn","fn","undefined","props","_typeof","returned","index","key","call","value","Edge","source","target","data","self","this","Vertex","name","Graph","processFns","vertexLate","search","directed","exitTimes","vertex","randGraph","numVerts","numEdges","prototype","weakComponentGraph","Math","floor","random","range","nodes","links","i","vertices","components","edges","randRange","reduction","toString","toJSON","json","eachEdge","GraphSearch","graph","edge","from","_cache","start","_search","discovered","searchTree","Object","keys","map","_searchTree","BreadthFirstSearch","constructor","discoverAdjacent","adj","queue","length","shift","vertexEarly","push","DepthFirstSearch","adjacent","sourceVertex","recurse","entryTimes","time","discoverAdjacentVertices","window","options","allowReflexiveEdges","read","readNodesAndLinks","readVerticesAndEdges","node","createVertex","sourceName","createEdge","forEach","targetName","isReflexive","targetVertex","Array","concat","apply","eachVertex","eachAdjacent","print","console","log","strings","to","join","toNodesAndLinks","indeces","breadthFirstSearchTree","depthFirstSearchTree","weakComponents","undiscovered","searchGraph","undiscoveredVertex","filter","vertexName","hasBeenReversed","swap","curr","component"],"mappings":"kOAAAA,WACE,WAuBD,QAAAC,GAAAC,EAAAC,GAIG,IAAK,GAAIC,KAAKD,GAFlB,GAAAA,EAAAE,eAAAD,MACSH,EAAAA,eAAgBG,IAAAF,EAAAE,KAAAD,EAAAC,IAChB,OAASD,CAIL,QAAA,EAUb,QAASG,GAASC,EAAKC,GACnB,GAAIC,GAA6B,kBAAdD,GAA0BA,MAAYE,GACrDC,EAA6B,gBAArB,KAAOH,EAAP,YAAAI,QAAOJ,IAA0BA,MAAYE,GAF7DG,KACIC,EAAIL,CAAJ,KAAA,GACIE,KAAQJ,GADZ,GAEIM,EAAAA,eAFJE,GAAA,CAGID,GAAAA,GAHJP,EAAAQ,EAIKN,GACGF,EAAIF,KAAAA,EAAJW,KAAJC,EAA+BA,EAAAF,EAAAD,IACvBG,EAEkBD,gBAAlBH,KAAAA,EAAAA,YAAAA,QAAAA,KAA+BI,EAAOF,EAAKD,IAD/CD,EAEWF,KAAOM,GAGVJ,EAAAA,KAAAA,GAEPC,GALM,EAQPA,MAAAA,GAQZ,QAAAI,GAAAC,EAAAC,EAAAC,GAGI,GAAIC,GAAOC,IAKX,OANJD,GAAAH,WAAuBC,KAARD,EAAsBA,EAAA,KACjCG,EAAAF,WAAAV,KAAIY,EAAJF,EAAA,KACAE,EAAAA,KAAKH,GAASA,KAIdG,EA2BJ,QAASE,GAAQC,EAAMJ,GACnB,GAAIC,GAAOC,IAGXD,OAJJA,GAAAG,SAAAf,KAASc,EAAoBC,EAAA,YACzBH,EAAAD,KAAIC,GAAJ,KACAA,EAAAA,SACAA,EAAAA,OAAA,EACAA,EAwLI,QAAAI,GAAIJ,EAAKK,EAAWC,GACpBC,MAD4FN,MAAAO,SAAAA,IAAA,EAC5FD,KAAAA,KAAOE,GAAWC,KAAOP,GA+RhC,QAhDDQ,GAAAH,EAAAI,EAAAC,GAmDAT,QAAMU,GAAUC,GACZ,MAAAC,MAAAC,MAAAD,KAAAE,SAAAC,GAEA,IAAA,GAJJpB,IAAAqB,SAAAC,UAIIC,EAAO,EAAAA,EAAIlB,EAAYI,IACnBe,EAAAA,MAAAA,MAAWC,KAAAA,GAEV,KAAAF,EAAA,EAFUA,EAERT,EAH0BS,IAI7BG,EAAAA,MAAQD,MACJ3B,OAAA6B,EAAOC,GACV7B,OAFO4B,EAAAd,IAMhB,OAAA,IAAAR,GAAAI,EAAAT,GApgBCH,EAAAkB,UAAAc,SAAA,WACD,MAAA3B,MAAAJ,OAAA,KAAAI,KAAAH,QAMAF,EAAKkB,UAAUe,OAAS,WACpB,GAAAC,IACAjC,OAAAI,KAAAJ,OACAC,OAAIgC,KAAOhC,OAKPgC,OAHAhC,MAAAA,OAFOgC,EAAX/B,KAAAE,KAAAF,MAKI+B,GAmBR5B,EAAOY,UAAUc,SAAW,WAD5B,MAAA,UAAA3B,KAAAE,KAAA,KAKAD,EAAAY,UAAAiB,SAAA,SAAA7C,GACA,MAAAF,GAAAiB,KAAAwB,MAAAvC,IAMAgB,EAAOY,UAAUe,OAAS,WAA1B3B,OACIC,KAAAF,KAAAE,KACAJ,KAAOE,KAAAF,MAYX,IAAIiC,GAAc,SAAUC,EAAO5B,GAAnC,GAAI2B,GAAAA,IAgBAhC,OAfAA,GAAAiC,MAAIjC,EAGJA,EAAKK,WAAaA,IAAlBL,YAAKK,SAAaA,EAAcE,KAG3B2B,KAH2B,SAAAC,EAAAD,EAAA3B,KAM3BD,WAN2B,SAAAI,EAAAH,MAYhCP,EAAKoC,UAALpC,EAOJgC,GAAYlB,UAAUP,OAAS,SAAkB8B,GAAjDL,GAAAA,GAAAA,IACI,OAAAK,KAAIrC,GAAOoC,OAAXpC,EAAAoC,OAAAC,IACAA,YAAkBD,KAAQC,EAAArC,EAAAiC,MAAAV,SAAAc,IAAErC,EAAAoC,OAAYA,EAAQC,MAApBrC,EAAAsC,QAAAD,KAC+CL,EAAAlB,UAAAwB,QAAA,SAAAD,EAAA9B,GAM3EA,MALAA,GAAAA,IAJJgC,cAOAd,WAEuBO,EAAnBlB,UAAA0B,WAAA,SAAAH,GAKA,MAAApC,MAAOM,YAAPN,KAAAM,OAAA8B,KAIJL,EAAAA,UAAYlB,YAAZ,SAAmCP,GAC/B,GAAAP,GAAOC,IACV,OAFD,IAAAG,IAAA,GAQQqB,MAAOlB,EAAOkB,MAJtBF,SAAAkB,OAAAC,KAAAnC,EAAAgC,YAAAI,IAAA,SAAAlD,GACAuC,MAAYlB,GAAAA,MAAU8B,SAAcnD,GAAAoC,aAcpC,IAAIgB,GAAqB,SAAUZ,EAAO5B,GAH1C,GAAAL,GAAAC,IAMI,OALJ+B,GAAAtC,KAAAO,KAAAgC,EAAA5B,GAKWL,EAFP6C,GAAW/B,UAAX,GAAAkB,GACAA,EAAAA,UAAAc,YAA+BzC,EAGnCwC,EAAAA,UAAmB/B,QAAgBkB,SAAnCK,EAAA9B,GAcI,QAASwC,GAAkBC,EAAKd,GAHhC,GAAIlC,GAAOC,IACPgD,GAAAA,WADJf,MAAAlC,EAAAK,WAAA6B,KAAAxC,KAAAM,EAAAH,EAAAqC,EAAA3B,GAMSA,EAAOgC,WAAYS,EAAI7C,QAF5BI,EAAIV,WAAJmD,EAAA7C,OAAA,EAC4BH,EAAAA,MAAKK,MAAW6B,OAAKxC,EAArBS,KAAiCN,OAAjCmD,EAA+CzC,OAC3E0C,EAAK1C,KAAOgC,IAhBpBM,EAAAA,IAKQN,cAFRM,SAGQ,IAAA7C,GAAAC,KACAwB,IAgBC,KAFGlB,EAAAgC,WAAAF,EAAAlC,OAAA,EACA8C,EAAAA,KAAAA,GACHA,EAAAC,QAAA,CACJ,GAAAxC,GAAAuC,EAAAE,OAEDnD,GAAAK,WAAA+C,aAAApD,EAAAK,WAAA+C,YAAA1D,KAAAM,EAAAU,EAAAH,GACAA,EAAAA,MAAOgC,aAAkBpC,EAAS4C,GAClCE,EAAMI,WAAN/C,YAAAN,EAAAK,WAAAC,WAAAZ,KAAAM,EAAAU,EAAAH,GAGI,MAAAA,GAG4F,IAAA+C,GAAA,SAAArB,EAAA5B,GAC/F,GAAAL,GAAAC,IAED,OADA+B,GAAAtC,KAAAO,KAAAgC,EAAA5B,GACAL,EAuWI,OA3VRsD,GAAiBxC,UAAY,GAAIkB,GARjCsB,EAAAxC,UAAAgC,YAAAQ,EAGAA,EAAIA,UAAmBhB,QAAnBgB,SAAAA,EAA6BrB,GAczBR,QAAAA,GAHe8B,EAAArB,GAKfzB,GAAAA,GAAaR,IALjBD,GAAAK,WAAA6B,MAAAlC,EAAAK,WAAA6B,KAAAxC,KAAAM,EAAAwD,EAAAtB,EAAA3B,GAOIP,EAAOuC,WAAXgB,EAAApD,QAWQI,EAAOkB,MAAM4B,MAAOxD,OAAQ2D,EAAarD,KAAML,OAAQyD,EAASpD,OARxEsD,EAAAF,IAKI,QAAAE,GAASpD,GAAmFE,EAAAgC,WAAA7B,EAAAP,OAAA,EAC5FH,EAAKO,WAAOgC,aAAYgB,EAAnBlD,WAAoC+C,YAAA1D,KAAAM,EAAAU,EAAAH,GACrCA,EAAAmD,WAAAhD,EAAAP,MAAAwD,IAEAF,EAAAA,MAAAA,aAAA/C,EAAAkD,GAEP5D,EAAAK,WAAAC,YAAAN,EAAAK,WAAAC,WAAAZ,KAAAM,EAAAU,EAAAH,GAYGA,EAAOE,UAAWC,EAAOP,MAASwD,IA1CtC3B,EAAAA,IACAO,cAEJe,SACAA,cAUQ7C,aAPR6C,IAAAA,GAAAA,KACIK,EAAA,CA4BI,OAFAF,GAAApB,GAEA9B,GAQJsD,OAAAzD,MAAAA,EAGAA,EAAAU,UAAOP,KAAP,SAAAuD,GACHA,EAzCDA,KAyDI,IAAI9D,GAAOC,IARX,OAJJD,GAAA+D,oBAAAD,EAAAC,sBAAA,EAEA/D,EAAAuB,YACAvB,EAAAa,SAAA,EACIb,GAkBJI,EAAMU,UAAUkD,KAAO,SAAUjE,GAbjC,IAAAA,EAAA,MAAAE,KACAG,IAAAA,GAAMU,IACFgD,OAAAA,GAAAA,eAAqB,SAArB9D,EAAAiE,kBAAAlE,GACAA,EAAIC,eAAJ,YAAAA,EAAAkE,qBAAAnE,GAeOC,GATPI,EAAAU,UAAOd,kBAAP,SAAAD,GACH,IATDA,IAAAA,EAAAhB,eAAA,SAAA,MAAAkB,KAYAG,IAAAA,GAAMU,IA2BF,OA1BAf,GAAAqB,MAAKrB,QAAM,SAAAoE,GAAEnE,EAAAoE,aAAAD,EAAAhE,KAAAgE,EAAApE,SAEyBA,EAAAsB,WAAY4C,QAAAA,SAAmBlE,EAA/BuB,GAAwC,GAAA+C,GAAAtE,EAAAqB,MAAAc,EAAArC,QAAAM,KAC1EJ,EAAKhB,EAAAA,MAAgBmD,EAArBpC,QAAmCK,IAAEH,GAAAsE,WAAYJ,EAAAA,EAALlE,EAAPQ,YAuBlCR,GAhBPI,EAAAU,UAAOf,qBAAahB,SAALgB,GAAoC,IAAAA,IAAOA,EAAPhB,eAAA,YAAA,MAAAkB,KAEnD,IAAAD,GAAAC,IAWC,OAVDF,GAAAwB,SAAIvB,QAAJ,SAAAmE,GACApE,EAAKqB,aAAe+C,EAAAhE,KAAUgE,EAAMpE,SA0BlCA,EAAK0B,WAAc8C,QAAS,SAAUrC,EAAMZ,GArB9CtB,EAAED,WAAFmC,EAAqBqC,OAASrC,EAAApC,OAAgBwB,EAAGd,YAAjDR,GAQHI,EAlBDU,UAAAsD,aAAA,SAAAjE,EAAAJ,GAoBA,MAAAE,MAAAsB,SAAApB,GAAAF,KAAAsB,SAAApB,GACMW,KAAAA,SAAUoD,GAAAA,GAAhBhE,GAAuCC,EAAUJ,IAI7CK,EAAAU,UAAId,WAAJ,SAAAqE,EAAAG,EAAAhE,EAAAT,GAGC,GAAA0E,GAFDJ,IAAAG,CAGA,KAAAvE,KAAA8D,qBAAAU,EAAA,MAAA,KAKA,IAHAjB,aAAEvD,KAAcsB,SAAhB8C,GACIrE,aAAKsE,KAAAA,SAAiBzE,IAE1B2D,eAAAkB,aAAA,MAAA,KAGH,IAhBD1E,GAAAC,KAyCQiC,EAAO,GAAItC,GAAMyE,EAAYG,EAAYzE,EAbjDK,OAVAoD,cAAA/B,MAAA+C,GAAAtC,EACA9B,aAAMU,QAAUsD,EACZpE,EAAAa,UAAA,EADJ4D,GAAAjE,GAMAR,EAAAsE,WAAAE,EAAAH,GAAA,GAGMvD,GAIFV,EAAAU,UAAKW,MAAKsC,SAAAA,GAAsC,MAAAY,OAAA7D,UAAA8D,OAAAC,SAAA5E,KAAA6E,WAAA,SAAApE,GAAc,MAAAA,GAAAqB,SAAA7C,OAK9DkB,EAAAU,UAAO0C,WAAAA,SAAgBkB,GAAkB,MAAA1F,GAAOiB,KAAPsB,SAAArC,IAGzCkB,EAAAU,UAAId,SAAJ,SAAAU,GAAA,GAAAV,GACIkC,IACJsB,OAAAA,GAAAA,EAAoBgB,MAAAA,SAAetC,GACnCsB,MAAAA,GAAAA,SAAAtB,EAAApC,WAKAM,EAAAU,UAAAiE,aAAA,SAAArE,EAAAvB,GACA,GAAAa,GAAKyE,IACD,OAAAzF,GAAA0B,EAAAe,MAAA,SAAAS,GACAlC,GAAAA,GAAKsE,EAAAA,SAAYE,EAAjB1E,OACH,OAAAX,GAAAO,KAAAgB,EAAAsC,EAAAd,MAKL9B,EAAAU,UAAAkE,MAAA,WACA5E,GAAAA,GAAMU,IAQF,OAPAmE,SAAAC,IAAOP,aAAgBC,OAAOC,KAAO7E,EAAIuB,UAAKuD,OAAY,aACtD9E,EAAA8E,WAAOpE,SAAOqB,GACjBkD,QAFDC,IAAAxE,EAAAkB,YADJlB,EAAAqB,SAAA,SAAAG,GAmCY+C,QAAQC,IAAK,MAAQhD,OA3B7BlC,GAIJI,EAAAA,UAAMU,MAAUyC,WACZ,GAAAvD,GAAIA,KACJmF,IAMJ/E,OALQ+E,GAAA9B,KAAA,gBACHrD,EAFMyB,MAAP,SAAAS,GAFJiD,EAAA9B,KAAA,KAAAnB,EAAAC,KAAA,OAAAD,EAAAkD,GAAA,OAOAD,EAAA9B,KAAA,KACMvC,EAANuE,KAAgBN,OAIR3E,EAAAU,UAAAwE,gBAAO,WACV,GAAAtF,GAHDC,KAFJsF,IAqCI,QA7BJnE,MAAApB,EAAA8E,WAAA,SAAApE,EAAAjB,EAAA6B,GAEQtB,MADFc,GAAUkE,EAAQ7E,MAAAmB,EACTZ,EAAXmB,WAEA7B,MAAK8E,EAAAA,MAAY,SAAUpE,GACvBuE,GAAAA,GAAA/C,EAAaxB,QAGZ,OAFDA,GAAAA,OAAOqB,EAAUG,EAAUA,QACvB+C,EAAAA,OAAQC,EAAKhD,EAAbpC,QADJgC,MAQR1B,EAAAA,UAAMU,mBAAkB,WACpB,GAAAd,GAAIA,IAAJ,QAEAmF,SAAQ9B,EAAMyB,WAAd,SAAApE,EAAAjB,GACAO,MAAYU,GAAAmB,WAEXJ,MAFDzB,EAAAyB,MAAA,SAAAS,GAGAiD,MAAQ9B,GAARxB,aAMAzB,EAAAU,UAAId,mBAAJ,SAAAqC,EAAAhC,GAAA,MAAA,IACIkF,GADJtF,MAAAM,OAAA8B,IAKQjC,EAAAU,UAAA0E,uBAAA,SAAAnD,EAAAhC,GACH,MAAA,IAJEwC,GAAA5C,MAAAuC,WAAAH,IAQCP,EAAAA,UAAAA,iBAAcyD,SAAczF,EAA5BO,GACA,MAAA,IAAAiD,GAAArD,MAAAM,OAAA8B,IAkCZjC,EAAMU,UAAU2E,qBAAuB,SAAUpD,EAAOhC,GA7BxD,MAAA,IAAAiD,GAAArD,MAAAuC,WAAAH,IA+CAjC,EAAMU,UAAU4E,eAAiB,WA3B7B,GAgCIC,GAhCJ3F,EAAOC,KADX2F,EAAA3F,KAIAuB,IAgEI,KArCAxB,EAEI2F,WA+BAC,EAAc,GAAIxF,IAAO,EAAOJ,EAAKsF,oBA3B7CK,EAAAlD,OAAAC,KAAAkD,EAAArE,UA+BWoE,EAAazC,QAAQ,CA5BxB,GAAA2C,GAAAD,EAAArE,SAAAoE,EAAAxC,QACAwC,GAAAA,KAnCJ,SAAWrC,GAgCP,GAAI/C,GAAS,GAAI+C,GAAkBsC,GAActD,QAASuD,EAtBlE,OALIF,GAAWrC,EAAkBwC,OAAOtD,SAAYH,GADpD,QAAAlC,IAAAI,GAAAgC,eAOAhB,SAAAkB,OAAAC,KAAAnC,EAAAgC,YAAAI,IAAA,SAAAoD,GACA,MAAA/F,GAAAuB,SAAAwE,GAAAlE,WAEAJ,MAAAlB,EAAAkB,MAAAkB,IAAA,SAAAT,GAEA,GAAA8D,OAAA5G,KAAAY,EAAAuB,SAAAW,EAAApC,QAAA2B,MAAAS,EAAArC,OACA,IAAAG,EAAAQ,UAAAwF,EAAA,CACA,GAAAC,GAAA/D,EAAArC,MACAqC,GAAArC,OAAAqC,EAAApC,OA8BoBoC,EAAKpC,OAASmG,EA3B5BnF,MAAU4E,OAaOC,IAKXpE,MAAAA,IAIInB,EAAAU,UAAAC,mBAAA,WAEA,GAAAS,GAAAvB,KAAID,gBACA,OAAA,IAAAI,GAAAH,KAAAO,UACA0B,SAAAA,EAAKrC,OAASqC,SAAKpC,EAAnBoG,GACAhE,MAAAA,GAAKpC,OAALoG,EAAA3E,eAEJE,MAAAD,EAAOU,OAAP,SAAAP,EAAAuE,GACH,MATOvE,GAAAiD,OAAAsB,EAAAzE,eAeZmE,EAAAA,UAAAA,wBAAc,WAElBD,GAAAA,GAAAA,IACA,OAAA1F,MAAAyF,iBAAA/C,IAAA,SAAAwD,GACA,MAAOR,IAAAA,GAAAA,EAAazC,SAAQiD,OA8B3BjG,OAFDA,EAHJN,KAAAA,EAoCQiD,mBAAqBA,EA3B7BS,iBAAAA,EACAlD,MAAAA,EA6BQO,UAAYA","file":"../../scripts/utils/graph.js","sourcesContent":["define([\n],function(){\n/* ============================================================================\nTODO:\n\n============================================================================ */\n//TODO: go ahead and move to underscore...\n/** call fn on each key/value in d */\nfunction each( d, fn ){\n    for( var k in d ){\n        if( d.hasOwnProperty( k ) ){\n            fn( d[ k ], k, d );\n        }\n    }\n}\n\n/** copy key/values from d2 to d overwriting if present */\nfunction extend( d, d2 ){\n    for( var k in d2 ){\n        if( d2.hasOwnProperty( k ) ){\n            d[ k ] = d2[ k ];\n        }\n    }\n    return d;\n}\n\n/** deep equal of two dictionaries */\nfunction matches( d, d2 ){\n    for( var k in d2 ){\n        if( d2.hasOwnProperty( k ) ){\n            if( !d.hasOwnProperty( k ) || d[ k ] !== d2[ k ] ){\n                return false;\n            }\n        }\n    }\n    return true;\n}\n\n/** map key/values in obj\n *      if propsOrFn is an object, return only those k/v that match the object\n *      if propsOrFn is function, call the fn and returned the mapped values from it\n */\nfunction iterate( obj, propsOrFn ){\n    var fn =    typeof propsOrFn === 'function'? propsOrFn : undefined,\n        props = typeof propsOrFn === 'object'?   propsOrFn : undefined,\n        returned = [],\n        index = 0;\n    for( var key in obj ){\n        if( obj.hasOwnProperty( key ) ){\n            var value = obj[ key ];\n            if( fn ){\n                returned.push( fn.call( value, value, key, index ) );\n            } else if( props ){\n//TODO: break out to sep?\n                if( typeof value === 'object' && matches( value, props ) ){\n                    returned.push( value );\n                }\n            } else {\n                returned.push( value );\n            }\n            index += 1;\n        }\n    }\n    return returned;\n}\n\n\n// ============================================================================\n/** A graph edge containing the name/id of both source and target and optional data\n */\nfunction Edge( source, target, data ){\n    var self = this;\n    self.source = source !== undefined? source : null;\n    self.target = target !== undefined? target : null;\n    self.data = data || null;\n    //if( typeof data === 'object' ){\n    //    extend( self, data );\n    //}\n    return self;\n}\n/** String representation */\nEdge.prototype.toString = function(){\n    return this.source + '->' + this.target;\n};\n\n/** Return a plain object representing this edge */\nEdge.prototype.toJSON = function(){\n    //TODO: this is safe in most browsers (fns will be stripped) - alter tests to incorporate this in order to pass data\n    //return this;\n    var json = {\n        source : this.source,\n        target : this.target\n    };\n    if( this.data ){\n        json.data = this.data;\n    }\n    return json;\n};\n\n// ============================================================================\n/** A graph vertex with a (unique) name/id and optional data.\n *      A vertex contains a list of Edges (whose sources are this vertex) and maintains the degree.\n */\nfunction Vertex( name, data ){\n    var self = this;\n    self.name = name !== undefined? name : '(unnamed)';\n    self.data = data || null;\n    self.edges = {};\n    self.degree = 0;\n    return self;\n}\n\n/** String representation */\nVertex.prototype.toString = function(){\n    return 'Vertex(' + this.name + ')';\n};\n\n//TODO: better name w no collision for either this.eachEdge or this.edges\n/** Iterate over each edge from this vertex */\nVertex.prototype.eachEdge = function( propsOrFn ){\n    return iterate( this.edges, propsOrFn );\n};\n\n/** Return a plain object representing this vertex */\nVertex.prototype.toJSON = function(){\n    //return this;\n    return {\n        name : this.name,\n        data : this.data\n    };\n};\n\n\n// ============================================================================\n/** Base (abstract) class for Graph search algorithms.\n *      Pass in the graph to search\n *      and an optional dictionary containing the 3 vertex/edge processing fns listed below.\n */\nvar GraphSearch = function( graph, processFns ){\n    var self = this;\n    self.graph = graph;\n\n    self.processFns = processFns || {\n        vertexEarly : function( vertex, search ){\n            //console.debug( 'processing vertex:', vertex.name, vertex );\n        },\n        edge        : function( from, edge, search ){\n            //console.debug( this, 'edge:', from, edge, search );\n        },\n        vertexLate  : function( vertex, search ){\n            //console.debug( this, 'vertexLate:', vertex, search );\n        }\n    };\n\n    self._cache = {};\n    return self;\n};\n\n/** Search interface where start is the vertex (or the name/id of the vertex) to begin the search at\n *      This public interface caches searches and returns the cached version if it's already been done.\n */\nGraphSearch.prototype.search = function _search( start ){\n    var self = this;\n    if( start in self._cache ){ return self._cache[ start ]; }\n    if( !( start instanceof Vertex ) ){ start = self.graph.vertices[ start ]; }\n    return ( self._cache[ start.name ] = self._search( start ) );\n};\n\n/** Actual search (private) function (abstract here) */\nGraphSearch.prototype._search = function __search( start, search ){\n    search = search || {\n        discovered : {},\n        //parents : {},\n        edges : []\n    };\n    return search;\n};\n\n/** Searches graph from start and returns a search tree of the results */\nGraphSearch.prototype.searchTree = function _searchTree( start ){\n    return this._searchTree( this.search( start ) );\n};\n\n/** Helper fn that returns a graph (a search tree) based on the search object passed in (does not actually search) */\nGraphSearch.prototype._searchTree = function __searchTree( search ){\n    var self = this;\n    return new Graph( true, {\n        edges: search.edges,\n        vertices: Object.keys( search.discovered ).map( function( key ){\n            return self.graph.vertices[ key ].toJSON();\n        })\n    });\n};\n\n\n// ============================================================================\n/** Breadth first search algo.\n */\nvar BreadthFirstSearch = function( graph, processFns ){\n    var self = this;\n    GraphSearch.call( this, graph, processFns );\n    return self;\n};\nBreadthFirstSearch.prototype = new GraphSearch();\nBreadthFirstSearch.prototype.constructor = BreadthFirstSearch;\n\n/** (Private) implementation of BFS */\nBreadthFirstSearch.prototype._search = function __search( start, search ){\n    search = search || {\n        discovered : {},\n        //parents : {},\n        edges : []\n    };\n\n    var self = this,\n        queue = [];\n\n    function discoverAdjacent( adj, edge ){\n        var source = this;\n        if( self.processFns.edge ){ self.processFns.edge.call( self, source, edge, search ); }\n        if( !search.discovered[ adj.name ] ){\n            //console.debug( '\\t\\t\\t', adj.name, 'is undiscovered:', search.discovered[ adj.name ] );\n            search.discovered[ adj.name ] = true;\n            //search.parents[ adj.name ] = source;\n            search.edges.push({ source: source.name, target: adj.name });\n            //console.debug( '\\t\\t\\t queuing undiscovered: ', adj );\n            queue.push( adj );\n        }\n    }\n\n    //console.debug( 'BFS starting. start:', start );\n    search.discovered[ start.name ] = true;\n    queue.push( start );\n    while( queue.length ){\n        var vertex = queue.shift();\n        //console.debug( '\\t Queue is shifting. Current:', vertex, 'queue:', queue );\n        if( self.processFns.vertexEarly ){ self.processFns.vertexEarly.call( self, vertex, search ); }\n        self.graph.eachAdjacent( vertex, discoverAdjacent );\n        if( self.processFns.vertexLate ){ self.processFns.vertexLate.call( self, vertex, search ); }\n    }\n    //console.debug( 'search.edges:', JSON.stringify( search.edges ) );\n    return search;\n};\n\n\n// ============================================================================\n/** Depth first search algorithm.\n */\nvar DepthFirstSearch = function( graph, processFns ){\n    var self = this;\n    GraphSearch.call( this, graph, processFns );\n    return self;\n};\nDepthFirstSearch.prototype = new GraphSearch();\nDepthFirstSearch.prototype.constructor = DepthFirstSearch;\n\n/** (Private) implementation of DFS */\nDepthFirstSearch.prototype._search = function( start, search ){\n    //console.debug( 'depthFirstSearch:', start );\n    search = search || {\n        discovered : {},\n        //parents    : {},\n        edges      : [],\n        entryTimes : {},\n        exitTimes  : {}\n    };\n    var self = this,\n        time = 0;\n\n    // discover verts adjacent to the source (this):\n    //  processing each edge, saving the edge to the tree, and caching the reverse path with parents\n    function discoverAdjacentVertices( adjacent, edge ){\n        //console.debug( '\\t\\t adjacent:', adjacent, 'edge:', edge );\n        var sourceVertex = this;\n        if( self.processFns.edge ){ self.processFns.edge.call( self, sourceVertex, edge, search ); }\n        if( !search.discovered[ adjacent.name ] ){\n            //search.parents[ adjacent.name ] = sourceVertex;\n            search.edges.push({ source: sourceVertex.name, target: adjacent.name });\n            recurse( adjacent );\n        }\n    }\n\n    // use function stack for DFS stack process verts, times, and discover adjacent verts (recursing into them)\n    function recurse( vertex ){\n        //console.debug( '\\t recursing into: ', vertex );\n        search.discovered[ vertex.name ] = true;\n        if( self.processFns.vertexEarly ){ self.processFns.vertexEarly.call( self, vertex, search ); }\n        search.entryTimes[ vertex.name ] = time++;\n\n        self.graph.eachAdjacent( vertex, discoverAdjacentVertices );\n\n        if( self.processFns.vertexLate ){ self.processFns.vertexLate.call( self, vertex, search ); }\n        search.exitTimes[ vertex.name ] = time++;\n    }\n    // begin recursion with the desired start\n    recurse( start );\n\n    return search;\n};\n\n\n// ============================================================================\n/** A directed/non-directed graph object.\n */\nfunction Graph( directed, data, options ){\n//TODO: move directed to options\n    this.directed = directed || false;\n    return this.init( options ).read( data );\n}\nwindow.Graph = Graph;\n\n/** Set up options and instance variables */\nGraph.prototype.init = function( options ){\n    options = options || {};\n    var self = this;\n\n    self.allowReflexiveEdges = options.allowReflexiveEdges || false;\n\n    self.vertices = {};\n    self.numEdges = 0;\n    return self;\n};\n\n/** Read data from the plain object data - both in d3 form (nodes and links) or vertices and edges */\nGraph.prototype.read = function( data ){\n    if( !data ){ return this; }\n    var self = this;\n    if( data.hasOwnProperty( 'nodes' ) ){ return self.readNodesAndLinks( data ); }\n    if( data.hasOwnProperty( 'vertices' ) ){ return self.readVerticesAndEdges( data ); }\n    return self;\n};\n\n//TODO: the next two could be combined\n/** Create the graph using a list of nodes and a list of edges (where source and target are indeces into nodes) */\nGraph.prototype.readNodesAndLinks = function( data ){\n    if( !( data && data.hasOwnProperty( 'nodes' ) ) ){ return this; }\n    //console.debug( 'readNodesAndLinks:', data );\n    //console.debug( 'data:\\n' + JSON.stringify( data, null, '  ' ) );\n    var self = this;\n    data.nodes.forEach( function( node ){\n        self.createVertex( node.name, node.data );\n    });\n    //console.debug( JSON.stringify( self.vertices, null, '  ' ) );\n\n    ( data.links || [] ).forEach( function( edge, i ){\n        var sourceName = data.nodes[ edge.source ].name,\n            targetName = data.nodes[ edge.target ].name;\n        self.createEdge( sourceName, targetName, self.directed );\n    });\n    //self.print();\n    //console.debug( JSON.stringify( self.toNodesAndLinks(), null, '  ' ) );\n    return self;\n};\n\n/** Create the graph using a list of nodes and a list of edges (where source and target are names of nodes) */\nGraph.prototype.readVerticesAndEdges = function( data ){\n    if( !( data && data.hasOwnProperty( 'vertices' ) ) ){ return this; }\n    //console.debug( 'readVerticesAndEdges:', data );\n    //console.debug( 'data:\\n' + JSON.stringify( data, null, '  ' ) );\n    var self = this;\n    data.vertices.forEach( function( node ){\n        self.createVertex( node.name, node.data );\n    });\n    //console.debug( JSON.stringify( self.vertices, null, '  ' ) );\n\n    ( data.edges || [] ).forEach( function( edge, i ){\n        self.createEdge( edge.source, edge.target, self.directed );\n    });\n    //self.print();\n    //console.debug( JSON.stringify( self.toNodesAndLinks(), null, '  ' ) );\n    return self;\n};\n\n/** Return the vertex with name, creating it if necessary */\nGraph.prototype.createVertex = function( name, data ){\n    //console.debug( 'createVertex:', name, data );\n    if( this.vertices[ name ] ){ return this.vertices[ name ]; }\n    return ( this.vertices[ name ] = new Vertex( name, data ) );\n};\n\n/** Create an edge in vertex named sourceName to targetName (optionally adding data to it)\n *      If directed is false, create a second edge from targetName to sourceName.\n */\nGraph.prototype.createEdge = function( sourceName, targetName, directed, data ){\n    //note: allows multiple 'equivalent' edges (to/from same source/target)\n    //console.debug( 'createEdge:', source, target, directed );\n    var isReflexive = sourceName === targetName;\n    if( !this.allowReflexiveEdges && isReflexive ){ return null; }\n\n    sourceVertex = this.vertices[ sourceName ];\n    targetVertex = this.vertices[ targetName ];\n    //note: silently ignores edges from/to unknown vertices\n    if( !( sourceVertex && targetVertex ) ){ return null; }\n\n//TODO: prob. move to vertex\n    var self = this,\n        edge = new Edge( sourceName, targetName, data );\n    sourceVertex.edges[ targetName ] = edge;\n    sourceVertex.degree += 1;\n    self.numEdges += 1;\n    \n    //TODO:! don't like having duplicate edges for non-directed graphs\n    // mirror edges (reversing source and target) in non-directed graphs\n    //  but only if not reflexive\n    if( !isReflexive && !directed ){\n        // flip directed to prevent recursion loop\n        self.createEdge( targetName, sourceName, true );\n    }\n\n    return edge;\n};\n\n/** Walk over all the edges of the graph using the vertex.eachEdge iterator */\nGraph.prototype.edges = function( propsOrFn ){\n    return Array.prototype.concat.apply( [], this.eachVertex( function( vertex ){\n        return vertex.eachEdge( propsOrFn );\n    }));\n};\n\n/** Iterate over all the vertices in the graph */\nGraph.prototype.eachVertex = function( propsOrFn ){\n    return iterate( this.vertices, propsOrFn );\n};\n\n/** Return a list of the vertices adjacent to vertex */\nGraph.prototype.adjacent = function( vertex ){\n    var self = this;\n    return iterate( vertex.edges, function( edge ){\n        return self.vertices[ edge.target ];\n    });\n};\n\n/** Call fn on each vertex adjacent to vertex */\nGraph.prototype.eachAdjacent = function( vertex, fn ){\n    var self = this;\n    return iterate( vertex.edges, function( edge ){\n        var adj = self.vertices[ edge.target ];\n        return fn.call( vertex, adj, edge );\n    });\n};\n\n/** Print the graph to the console (debugging) */\nGraph.prototype.print = function(){\n    var self = this;\n    console.log( 'Graph has ' + Object.keys( self.vertices ).length + ' vertices' );\n    self.eachVertex( function( vertex ){\n        console.log( vertex.toString() );\n        vertex.eachEdge( function( edge ){\n            console.log( '\\t ' + edge );\n        });\n    });\n    return self;\n};\n\n/** Return a DOT format string of this graph */\nGraph.prototype.toDOT = function(){\n    var self = this,\n        strings = [];\n    strings.push( 'graph bler {' );\n    self.edges( function( edge ){\n        strings.push( '\\t' + edge.from + ' -- ' + edge.to + ';' );\n    });\n    strings.push( '}' );\n    return strings.join( '\\n' );\n};\n\n/** Return vertices and edges of this graph in d3 node/link format */\nGraph.prototype.toNodesAndLinks = function(){\n    var self = this,\n        indeces = {};\n    return {\n        nodes : self.eachVertex( function( vertex, key, i ){\n            indeces[ vertex.name ] = i;\n            return vertex.toJSON();\n        }),\n        links : self.edges( function( edge ){\n            var json = edge.toJSON();\n            json.source = indeces[ edge.source ];\n            json.target = indeces[ edge.target ];\n            return json;\n        })\n    };\n};\n\n/** Return vertices and edges of this graph where edges use the name/id as source and target */\nGraph.prototype.toVerticesAndEdges = function(){\n    var self = this;\n    return {\n        vertices : self.eachVertex( function( vertex, key ){\n            return vertex.toJSON();\n        }),\n        edges : self.edges( function( edge ){\n            return edge.toJSON();\n        })\n    };\n};\n\n/** Search this graph using BFS */\nGraph.prototype.breadthFirstSearch = function( start, processFns ){\n    return new BreadthFirstSearch( this ).search( start );\n};\n\n/** Return a searchtree of this graph using BFS */\nGraph.prototype.breadthFirstSearchTree = function( start, processFns ){\n    return new BreadthFirstSearch( this ).searchTree( start );\n};\n\n/** Search this graph using DFS */\nGraph.prototype.depthFirstSearch = function( start, processFns ){\n    return new DepthFirstSearch( this ).search( start );\n};\n\n/** Return a searchtree of this graph using DFS */\nGraph.prototype.depthFirstSearchTree = function( start, processFns ){\n    return new DepthFirstSearch( this ).searchTree( start );\n};\n\n\n//Graph.prototype.shortestPath = function( start, end ){\n//};\n//\n//Graph.prototype.articulationVertices = function(){\n//};\n//\n//Graph.prototype.isAcyclic = function(){\n//};\n//\n//Graph.prototype.isBipartite = function(){\n//};\n\n/** Return an array of weakly connected (no edges between) sub-graphs in this graph */\nGraph.prototype.weakComponents = function(){\n//TODO: alternately, instead of returning graph-like objects:\n//  - could simply decorate the vertices (vertex.component = componentIndex), or clone the graph and do that\n    var self = this,\n        searchGraph = this,\n        undiscovered,\n        components = [];\n\n    function getComponent( undiscoveredVertex ){\n//TODO: better interface on dfs (search v. searchTree)\n        var search = new DepthFirstSearch( searchGraph )._search( undiscoveredVertex );\n\n        // remove curr discovered from undiscovered\n        undiscovered = undiscovered.filter( function( name ){\n            return !( name in search.discovered );\n        });\n\n        return {\n            vertices : Object.keys( search.discovered ).map( function( vertexName ){\n                return self.vertices[ vertexName ].toJSON();\n            }),\n            edges : search.edges.map( function( edge ){\n                // restore any reversed edges\n                var hasBeenReversed = self.vertices[ edge.target ].edges[ edge.source ] !== undefined;\n                if( self.directed && hasBeenReversed ){\n                    var swap = edge.source;\n                    edge.source = edge.target;\n                    edge.target = swap;\n                }\n                return edge;\n            })\n        };\n    }\n\n    if( self.directed ){\n        // if directed - convert to undirected for search\n        searchGraph = new Graph( false, self.toNodesAndLinks() );\n    }\n    undiscovered = Object.keys( searchGraph.vertices );\n    //console.debug( '(initial) undiscovered:', undiscovered );\n    while( undiscovered.length ){\n        var undiscoveredVertex = searchGraph.vertices[ undiscovered.shift() ];\n        components.push( getComponent( undiscoveredVertex ) );\n        //console.debug( 'undiscovered now:', undiscovered );\n    }\n\n    //console.debug( 'components:\\n', JSON.stringify( components, null, '  ' ) );\n    return components;\n};\n\n/** Return a single graph containing the weakly connected components in this graph */\nGraph.prototype.weakComponentGraph = function(){\n    //note: although this can often look like the original graph - edges can be lost\n    var components = this.weakComponents();\n    return new Graph( this.directed, {\n        vertices : components.reduce( function( reduction, curr ){\n            return reduction.concat( curr.vertices );\n        }, [] ),\n        edges : components.reduce( function( reduction, curr ){\n            return reduction.concat( curr.edges );\n        }, [] )\n    });\n};\n\n/** Return an array of graphs of the weakly connected components in this graph */\nGraph.prototype.weakComponentGraphArray = function(){\n    //note: although this can often look like the original graph - edges can be lost\n    var graph = this;\n    return this.weakComponents().map( function( component ){\n        return new Graph( graph.directed, component );\n    });\n};\n\n\n// ============================================================================\n/** Create a random graph with numVerts vertices and numEdges edges (for testing)\n */\nfunction randGraph( directed, numVerts, numEdges ){\n    //console.debug( 'randGraph', directed, numVerts, numEdges );\n    var data = { nodes : [], links : [] };\n    function randRange( range ){\n        return Math.floor( Math.random() * range );\n    }\n    for( var i=0; i<numVerts; i++ ){\n        data.nodes.push({ name: i });\n    }\n    for( i=0; i<numEdges; i++ ){\n        data.links.push({\n            source : randRange( numVerts ),\n            target : randRange( numVerts )\n        });\n    }\n    //console.debug( JSON.stringify( data, null, '  ' ) );\n    return new Graph( directed, data );\n}\n\n\n// ============================================================================\n    return {\n        Vertex : Vertex,\n        Edge : Edge,\n        BreadthFirstSearch : BreadthFirstSearch,\n        DepthFirstSearch : DepthFirstSearch,\n        Graph : Graph,\n        randGraph : randGraph\n    };\n});\n"]}