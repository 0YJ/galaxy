{"version":3,"sources":["utils/graph.js"],"names":["define","matches","d","d2","k","hasOwnProperty","iterate","obj","propsOrFn","fn","undefined","props","returned","index","key","value","push","call","Edge","source","target","data","self","this","Vertex","name","edges","degree","Graph","directed","options","init","read","randGraph","numVerts","numEdges","randRange","range","Math","floor","random","nodes","links","i","prototype","toString","toJSON","json","eachEdge","GraphSearch","graph","processFns","vertexEarly","vertex","search","edge","from","vertexLate","_cache","start","vertices","_search","discovered","searchTree","_searchTree","Object","keys","map","BreadthFirstSearch","constructor","discoverAdjacent","adj","queue","length","shift","eachAdjacent","DepthFirstSearch","discoverAdjacentVertices","adjacent","sourceVertex","recurse","entryTimes","time","exitTimes","window","allowReflexiveEdges","readNodesAndLinks","readVerticesAndEdges","forEach","node","createVertex","sourceName","targetName","createEdge","isReflexive","targetVertex","Array","concat","apply","eachVertex","print","console","log","toDOT","strings","to","join","toNodesAndLinks","indeces","toVerticesAndEdges","breadthFirstSearch","breadthFirstSearchTree","depthFirstSearch","depthFirstSearchTree","weakComponents","undiscovered","searchGraph","components","undiscoveredVertex","filter","vertexName","hasBeenReversed","swap","weakComponentGraph","reduce","reduction","curr","weakComponentGraphArray","component"],"mappings":"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","file":"../../scripts/utils/graph.js","sourcesContent":["define([\n],function(){\n/* ============================================================================\nTODO:\n\n============================================================================ */\n//TODO: go ahead and move to underscore...\n/** call fn on each key/value in d */\nfunction each( d, fn ){\n    for( var k in d ){\n        if( d.hasOwnProperty( k ) ){\n            fn( d[ k ], k, d );\n        }\n    }\n}\n\n/** copy key/values from d2 to d overwriting if present */\nfunction extend( d, d2 ){\n    for( var k in d2 ){\n        if( d2.hasOwnProperty( k ) ){\n            d[ k ] = d2[ k ];\n        }\n    }\n    return d;\n}\n\n/** deep equal of two dictionaries */\nfunction matches( d, d2 ){\n    for( var k in d2 ){\n        if( d2.hasOwnProperty( k ) ){\n            if( !d.hasOwnProperty( k ) || d[ k ] !== d2[ k ] ){\n                return false;\n            }\n        }\n    }\n    return true;\n}\n\n/** map key/values in obj\n *      if propsOrFn is an object, return only those k/v that match the object\n *      if propsOrFn is function, call the fn and returned the mapped values from it\n */\nfunction iterate( obj, propsOrFn ){\n    var fn =    typeof propsOrFn === 'function'? propsOrFn : undefined,\n        props = typeof propsOrFn === 'object'?   propsOrFn : undefined,\n        returned = [],\n        index = 0;\n    for( var key in obj ){\n        if( obj.hasOwnProperty( key ) ){\n            var value = obj[ key ];\n            if( fn ){\n                returned.push( fn.call( value, value, key, index ) );\n            } else if( props ){\n//TODO: break out to sep?\n                if( typeof value === 'object' && matches( value, props ) ){\n                    returned.push( value );\n                }\n            } else {\n                returned.push( value );\n            }\n            index += 1;\n        }\n    }\n    return returned;\n}\n\n\n// ============================================================================\n/** A graph edge containing the name/id of both source and target and optional data\n */\nfunction Edge( source, target, data ){\n    var self = this;\n    self.source = source !== undefined? source : null;\n    self.target = target !== undefined? target : null;\n    self.data = data || null;\n    //if( typeof data === 'object' ){\n    //    extend( self, data );\n    //}\n    return self;\n}\n/** String representation */\nEdge.prototype.toString = function(){\n    return this.source + '->' + this.target;\n};\n\n/** Return a plain object representing this edge */\nEdge.prototype.toJSON = function(){\n    //TODO: this is safe in most browsers (fns will be stripped) - alter tests to incorporate this in order to pass data\n    //return this;\n    var json = {\n        source : this.source,\n        target : this.target\n    };\n    if( this.data ){\n        json.data = this.data;\n    }\n    return json;\n};\n\n// ============================================================================\n/** A graph vertex with a (unique) name/id and optional data.\n *      A vertex contains a list of Edges (whose sources are this vertex) and maintains the degree.\n */\nfunction Vertex( name, data ){\n    var self = this;\n    self.name = name !== undefined? name : '(unnamed)';\n    self.data = data || null;\n    self.edges = {};\n    self.degree = 0;\n    return self;\n}\n\n/** String representation */\nVertex.prototype.toString = function(){\n    return 'Vertex(' + this.name + ')';\n};\n\n//TODO: better name w no collision for either this.eachEdge or this.edges\n/** Iterate over each edge from this vertex */\nVertex.prototype.eachEdge = function( propsOrFn ){\n    return iterate( this.edges, propsOrFn );\n};\n\n/** Return a plain object representing this vertex */\nVertex.prototype.toJSON = function(){\n    //return this;\n    return {\n        name : this.name,\n        data : this.data\n    };\n};\n\n\n// ============================================================================\n/** Base (abstract) class for Graph search algorithms.\n *      Pass in the graph to search\n *      and an optional dictionary containing the 3 vertex/edge processing fns listed below.\n */\nvar GraphSearch = function( graph, processFns ){\n    var self = this;\n    self.graph = graph;\n\n    self.processFns = processFns || {\n        vertexEarly : function( vertex, search ){\n            //console.debug( 'processing vertex:', vertex.name, vertex );\n        },\n        edge        : function( from, edge, search ){\n            //console.debug( this, 'edge:', from, edge, search );\n        },\n        vertexLate  : function( vertex, search ){\n            //console.debug( this, 'vertexLate:', vertex, search );\n        }\n    };\n\n    self._cache = {};\n    return self;\n};\n\n/** Search interface where start is the vertex (or the name/id of the vertex) to begin the search at\n *      This public interface caches searches and returns the cached version if it's already been done.\n */\nGraphSearch.prototype.search = function _search( start ){\n    var self = this;\n    if( start in self._cache ){ return self._cache[ start ]; }\n    if( !( start instanceof Vertex ) ){ start = self.graph.vertices[ start ]; }\n    return ( self._cache[ start.name ] = self._search( start ) );\n};\n\n/** Actual search (private) function (abstract here) */\nGraphSearch.prototype._search = function __search( start, search ){\n    search = search || {\n        discovered : {},\n        //parents : {},\n        edges : []\n    };\n    return search;\n};\n\n/** Searches graph from start and returns a search tree of the results */\nGraphSearch.prototype.searchTree = function _searchTree( start ){\n    return this._searchTree( this.search( start ) );\n};\n\n/** Helper fn that returns a graph (a search tree) based on the search object passed in (does not actually search) */\nGraphSearch.prototype._searchTree = function __searchTree( search ){\n    var self = this;\n    return new Graph( true, {\n        edges: search.edges,\n        vertices: Object.keys( search.discovered ).map( function( key ){\n            return self.graph.vertices[ key ].toJSON();\n        })\n    });\n};\n\n\n// ============================================================================\n/** Breadth first search algo.\n */\nvar BreadthFirstSearch = function( graph, processFns ){\n    var self = this;\n    GraphSearch.call( this, graph, processFns );\n    return self;\n};\nBreadthFirstSearch.prototype = new GraphSearch();\nBreadthFirstSearch.prototype.constructor = BreadthFirstSearch;\n\n/** (Private) implementation of BFS */\nBreadthFirstSearch.prototype._search = function __search( start, search ){\n    search = search || {\n        discovered : {},\n        //parents : {},\n        edges : []\n    };\n\n    var self = this,\n        queue = [];\n\n    function discoverAdjacent( adj, edge ){\n        var source = this;\n        if( self.processFns.edge ){ self.processFns.edge.call( self, source, edge, search ); }\n        if( !search.discovered[ adj.name ] ){\n            //console.debug( '\\t\\t\\t', adj.name, 'is undiscovered:', search.discovered[ adj.name ] );\n            search.discovered[ adj.name ] = true;\n            //search.parents[ adj.name ] = source;\n            search.edges.push({ source: source.name, target: adj.name });\n            //console.debug( '\\t\\t\\t queuing undiscovered: ', adj );\n            queue.push( adj );\n        }\n    }\n\n    //console.debug( 'BFS starting. start:', start );\n    search.discovered[ start.name ] = true;\n    queue.push( start );\n    while( queue.length ){\n        var vertex = queue.shift();\n        //console.debug( '\\t Queue is shifting. Current:', vertex, 'queue:', queue );\n        if( self.processFns.vertexEarly ){ self.processFns.vertexEarly.call( self, vertex, search ); }\n        self.graph.eachAdjacent( vertex, discoverAdjacent );\n        if( self.processFns.vertexLate ){ self.processFns.vertexLate.call( self, vertex, search ); }\n    }\n    //console.debug( 'search.edges:', JSON.stringify( search.edges ) );\n    return search;\n};\n\n\n// ============================================================================\n/** Depth first search algorithm.\n */\nvar DepthFirstSearch = function( graph, processFns ){\n    var self = this;\n    GraphSearch.call( this, graph, processFns );\n    return self;\n};\nDepthFirstSearch.prototype = new GraphSearch();\nDepthFirstSearch.prototype.constructor = DepthFirstSearch;\n\n/** (Private) implementation of DFS */\nDepthFirstSearch.prototype._search = function( start, search ){\n    //console.debug( 'depthFirstSearch:', start );\n    search = search || {\n        discovered : {},\n        //parents    : {},\n        edges      : [],\n        entryTimes : {},\n        exitTimes  : {}\n    };\n    var self = this,\n        time = 0;\n\n    // discover verts adjacent to the source (this):\n    //  processing each edge, saving the edge to the tree, and caching the reverse path with parents\n    function discoverAdjacentVertices( adjacent, edge ){\n        //console.debug( '\\t\\t adjacent:', adjacent, 'edge:', edge );\n        var sourceVertex = this;\n        if( self.processFns.edge ){ self.processFns.edge.call( self, sourceVertex, edge, search ); }\n        if( !search.discovered[ adjacent.name ] ){\n            //search.parents[ adjacent.name ] = sourceVertex;\n            search.edges.push({ source: sourceVertex.name, target: adjacent.name });\n            recurse( adjacent );\n        }\n    }\n\n    // use function stack for DFS stack process verts, times, and discover adjacent verts (recursing into them)\n    function recurse( vertex ){\n        //console.debug( '\\t recursing into: ', vertex );\n        search.discovered[ vertex.name ] = true;\n        if( self.processFns.vertexEarly ){ self.processFns.vertexEarly.call( self, vertex, search ); }\n        search.entryTimes[ vertex.name ] = time++;\n\n        self.graph.eachAdjacent( vertex, discoverAdjacentVertices );\n\n        if( self.processFns.vertexLate ){ self.processFns.vertexLate.call( self, vertex, search ); }\n        search.exitTimes[ vertex.name ] = time++;\n    }\n    // begin recursion with the desired start\n    recurse( start );\n\n    return search;\n};\n\n\n// ============================================================================\n/** A directed/non-directed graph object.\n */\nfunction Graph( directed, data, options ){\n//TODO: move directed to options\n    this.directed = directed || false;\n    return this.init( options ).read( data );\n}\nwindow.Graph = Graph;\n\n/** Set up options and instance variables */\nGraph.prototype.init = function( options ){\n    options = options || {};\n    var self = this;\n\n    self.allowReflexiveEdges = options.allowReflexiveEdges || false;\n\n    self.vertices = {};\n    self.numEdges = 0;\n    return self;\n};\n\n/** Read data from the plain object data - both in d3 form (nodes and links) or vertices and edges */\nGraph.prototype.read = function( data ){\n    if( !data ){ return this; }\n    var self = this;\n    if( data.hasOwnProperty( 'nodes' ) ){ return self.readNodesAndLinks( data ); }\n    if( data.hasOwnProperty( 'vertices' ) ){ return self.readVerticesAndEdges( data ); }\n    return self;\n};\n\n//TODO: the next two could be combined\n/** Create the graph using a list of nodes and a list of edges (where source and target are indeces into nodes) */\nGraph.prototype.readNodesAndLinks = function( data ){\n    if( !( data && data.hasOwnProperty( 'nodes' ) ) ){ return this; }\n    //console.debug( 'readNodesAndLinks:', data );\n    //console.debug( 'data:\\n' + JSON.stringify( data, null, '  ' ) );\n    var self = this;\n    data.nodes.forEach( function( node ){\n        self.createVertex( node.name, node.data );\n    });\n    //console.debug( JSON.stringify( self.vertices, null, '  ' ) );\n\n    ( data.links || [] ).forEach( function( edge, i ){\n        var sourceName = data.nodes[ edge.source ].name,\n            targetName = data.nodes[ edge.target ].name;\n        self.createEdge( sourceName, targetName, self.directed );\n    });\n    //self.print();\n    //console.debug( JSON.stringify( self.toNodesAndLinks(), null, '  ' ) );\n    return self;\n};\n\n/** Create the graph using a list of nodes and a list of edges (where source and target are names of nodes) */\nGraph.prototype.readVerticesAndEdges = function( data ){\n    if( !( data && data.hasOwnProperty( 'vertices' ) ) ){ return this; }\n    //console.debug( 'readVerticesAndEdges:', data );\n    //console.debug( 'data:\\n' + JSON.stringify( data, null, '  ' ) );\n    var self = this;\n    data.vertices.forEach( function( node ){\n        self.createVertex( node.name, node.data );\n    });\n    //console.debug( JSON.stringify( self.vertices, null, '  ' ) );\n\n    ( data.edges || [] ).forEach( function( edge, i ){\n        self.createEdge( edge.source, edge.target, self.directed );\n    });\n    //self.print();\n    //console.debug( JSON.stringify( self.toNodesAndLinks(), null, '  ' ) );\n    return self;\n};\n\n/** Return the vertex with name, creating it if necessary */\nGraph.prototype.createVertex = function( name, data ){\n    //console.debug( 'createVertex:', name, data );\n    if( this.vertices[ name ] ){ return this.vertices[ name ]; }\n    return ( this.vertices[ name ] = new Vertex( name, data ) );\n};\n\n/** Create an edge in vertex named sourceName to targetName (optionally adding data to it)\n *      If directed is false, create a second edge from targetName to sourceName.\n */\nGraph.prototype.createEdge = function( sourceName, targetName, directed, data ){\n    //note: allows multiple 'equivalent' edges (to/from same source/target)\n    //console.debug( 'createEdge:', source, target, directed );\n    var isReflexive = sourceName === targetName;\n    if( !this.allowReflexiveEdges && isReflexive ){ return null; }\n\n    sourceVertex = this.vertices[ sourceName ];\n    targetVertex = this.vertices[ targetName ];\n    //note: silently ignores edges from/to unknown vertices\n    if( !( sourceVertex && targetVertex ) ){ return null; }\n\n//TODO: prob. move to vertex\n    var self = this,\n        edge = new Edge( sourceName, targetName, data );\n    sourceVertex.edges[ targetName ] = edge;\n    sourceVertex.degree += 1;\n    self.numEdges += 1;\n    \n    //TODO:! don't like having duplicate edges for non-directed graphs\n    // mirror edges (reversing source and target) in non-directed graphs\n    //  but only if not reflexive\n    if( !isReflexive && !directed ){\n        // flip directed to prevent recursion loop\n        self.createEdge( targetName, sourceName, true );\n    }\n\n    return edge;\n};\n\n/** Walk over all the edges of the graph using the vertex.eachEdge iterator */\nGraph.prototype.edges = function( propsOrFn ){\n    return Array.prototype.concat.apply( [], this.eachVertex( function( vertex ){\n        return vertex.eachEdge( propsOrFn );\n    }));\n};\n\n/** Iterate over all the vertices in the graph */\nGraph.prototype.eachVertex = function( propsOrFn ){\n    return iterate( this.vertices, propsOrFn );\n};\n\n/** Return a list of the vertices adjacent to vertex */\nGraph.prototype.adjacent = function( vertex ){\n    var self = this;\n    return iterate( vertex.edges, function( edge ){\n        return self.vertices[ edge.target ];\n    });\n};\n\n/** Call fn on each vertex adjacent to vertex */\nGraph.prototype.eachAdjacent = function( vertex, fn ){\n    var self = this;\n    return iterate( vertex.edges, function( edge ){\n        var adj = self.vertices[ edge.target ];\n        return fn.call( vertex, adj, edge );\n    });\n};\n\n/** Print the graph to the console (debugging) */\nGraph.prototype.print = function(){\n    var self = this;\n    console.log( 'Graph has ' + Object.keys( self.vertices ).length + ' vertices' );\n    self.eachVertex( function( vertex ){\n        console.log( vertex.toString() );\n        vertex.eachEdge( function( edge ){\n            console.log( '\\t ' + edge );\n        });\n    });\n    return self;\n};\n\n/** Return a DOT format string of this graph */\nGraph.prototype.toDOT = function(){\n    var self = this,\n        strings = [];\n    strings.push( 'graph bler {' );\n    self.edges( function( edge ){\n        strings.push( '\\t' + edge.from + ' -- ' + edge.to + ';' );\n    });\n    strings.push( '}' );\n    return strings.join( '\\n' );\n};\n\n/** Return vertices and edges of this graph in d3 node/link format */\nGraph.prototype.toNodesAndLinks = function(){\n    var self = this,\n        indeces = {};\n    return {\n        nodes : self.eachVertex( function( vertex, key, i ){\n            indeces[ vertex.name ] = i;\n            return vertex.toJSON();\n        }),\n        links : self.edges( function( edge ){\n            var json = edge.toJSON();\n            json.source = indeces[ edge.source ];\n            json.target = indeces[ edge.target ];\n            return json;\n        })\n    };\n};\n\n/** Return vertices and edges of this graph where edges use the name/id as source and target */\nGraph.prototype.toVerticesAndEdges = function(){\n    var self = this;\n    return {\n        vertices : self.eachVertex( function( vertex, key ){\n            return vertex.toJSON();\n        }),\n        edges : self.edges( function( edge ){\n            return edge.toJSON();\n        })\n    };\n};\n\n/** Search this graph using BFS */\nGraph.prototype.breadthFirstSearch = function( start, processFns ){\n    return new BreadthFirstSearch( this ).search( start );\n};\n\n/** Return a searchtree of this graph using BFS */\nGraph.prototype.breadthFirstSearchTree = function( start, processFns ){\n    return new BreadthFirstSearch( this ).searchTree( start );\n};\n\n/** Search this graph using DFS */\nGraph.prototype.depthFirstSearch = function( start, processFns ){\n    return new DepthFirstSearch( this ).search( start );\n};\n\n/** Return a searchtree of this graph using DFS */\nGraph.prototype.depthFirstSearchTree = function( start, processFns ){\n    return new DepthFirstSearch( this ).searchTree( start );\n};\n\n\n//Graph.prototype.shortestPath = function( start, end ){\n//};\n//\n//Graph.prototype.articulationVertices = function(){\n//};\n//\n//Graph.prototype.isAcyclic = function(){\n//};\n//\n//Graph.prototype.isBipartite = function(){\n//};\n\n/** Return an array of weakly connected (no edges between) sub-graphs in this graph */\nGraph.prototype.weakComponents = function(){\n//TODO: alternately, instead of returning graph-like objects:\n//  - could simply decorate the vertices (vertex.component = componentIndex), or clone the graph and do that\n    var self = this,\n        searchGraph = this,\n        undiscovered,\n        components = [];\n\n    function getComponent( undiscoveredVertex ){\n//TODO: better interface on dfs (search v. searchTree)\n        var search = new DepthFirstSearch( searchGraph )._search( undiscoveredVertex );\n\n        // remove curr discovered from undiscovered\n        undiscovered = undiscovered.filter( function( name ){\n            return !( name in search.discovered );\n        });\n\n        return {\n            vertices : Object.keys( search.discovered ).map( function( vertexName ){\n                return self.vertices[ vertexName ].toJSON();\n            }),\n            edges : search.edges.map( function( edge ){\n                // restore any reversed edges\n                var hasBeenReversed = self.vertices[ edge.target ].edges[ edge.source ] !== undefined;\n                if( self.directed && hasBeenReversed ){\n                    var swap = edge.source;\n                    edge.source = edge.target;\n                    edge.target = swap;\n                }\n                return edge;\n            })\n        };\n    }\n\n    if( self.directed ){\n        // if directed - convert to undirected for search\n        searchGraph = new Graph( false, self.toNodesAndLinks() );\n    }\n    undiscovered = Object.keys( searchGraph.vertices );\n    //console.debug( '(initial) undiscovered:', undiscovered );\n    while( undiscovered.length ){\n        var undiscoveredVertex = searchGraph.vertices[ undiscovered.shift() ];\n        components.push( getComponent( undiscoveredVertex ) );\n        //console.debug( 'undiscovered now:', undiscovered );\n    }\n\n    //console.debug( 'components:\\n', JSON.stringify( components, null, '  ' ) );\n    return components;\n};\n\n/** Return a single graph containing the weakly connected components in this graph */\nGraph.prototype.weakComponentGraph = function(){\n    //note: although this can often look like the original graph - edges can be lost\n    var components = this.weakComponents();\n    return new Graph( this.directed, {\n        vertices : components.reduce( function( reduction, curr ){\n            return reduction.concat( curr.vertices );\n        }, [] ),\n        edges : components.reduce( function( reduction, curr ){\n            return reduction.concat( curr.edges );\n        }, [] )\n    });\n};\n\n/** Return an array of graphs of the weakly connected components in this graph */\nGraph.prototype.weakComponentGraphArray = function(){\n    //note: although this can often look like the original graph - edges can be lost\n    var graph = this;\n    return this.weakComponents().map( function( component ){\n        return new Graph( graph.directed, component );\n    });\n};\n\n\n// ============================================================================\n/** Create a random graph with numVerts vertices and numEdges edges (for testing)\n */\nfunction randGraph( directed, numVerts, numEdges ){\n    //console.debug( 'randGraph', directed, numVerts, numEdges );\n    var data = { nodes : [], links : [] };\n    function randRange( range ){\n        return Math.floor( Math.random() * range );\n    }\n    for( var i=0; i<numVerts; i++ ){\n        data.nodes.push({ name: i });\n    }\n    for( i=0; i<numEdges; i++ ){\n        data.links.push({\n            source : randRange( numVerts ),\n            target : randRange( numVerts )\n        });\n    }\n    //console.debug( JSON.stringify( data, null, '  ' ) );\n    return new Graph( directed, data );\n}\n\n\n// ============================================================================\n    return {\n        Vertex : Vertex,\n        Edge : Edge,\n        BreadthFirstSearch : BreadthFirstSearch,\n        DepthFirstSearch : DepthFirstSearch,\n        Graph : Graph,\n        randGraph : randGraph\n    };\n});\n"]}