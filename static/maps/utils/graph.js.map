{"version":3,"sources":["utils/graph.js"],"names":["define","matches","d2","hasOwnProperty","d","k","iterate","obj","propsOrFn","fn","undefined","props","_typeof","returned","index","key","value","call","push","Edge","source","target","data","self","this","Vertex","name","json","edges","degree","recurse","options","directed","search","init","read","prototype","toJSON","toString","eachEdge","GraphSearch","graph","processFns","vertexEarly","vertex","from","edge","vertexLate","start","_cache","vertices","_search","discovered","_searchTree","Graph","Object","map","BreadthFirstSearch","constructor","queue","length","adj","DepthFirstSearch","entryTimes","adjacent","sourceVertex","time","discoverAdjacentVertices","exitTimes","window","allowReflexiveEdges","numEdges","readNodesAndLinks","readVerticesAndEdges","nodes","forEach","node","links","i","sourceName","targetName","createEdge","isReflexive","targetVertex","Array","concat","apply","eachVertex","eachAdjacent","print","console","keys","log","strings","to","join","indeces","toVerticesAndEdges","breadthFirstSearch","breadthFirstSearchTree","searchTree","depthFirstSearch","depthFirstSearchTree","weakComponents","undiscovered","searchGraph","components","toNodesAndLinks","undiscoveredVertex","shift","filter","vertexName","swap","hasBeenReversed","getComponent","weakComponentGraph","reduce","reduction","curr","weakComponentGraphArray","randGraph","numVerts","component","randRange","range"],"mappings":"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","file":"../../scripts/utils/graph.js","sourcesContent":["define([], function() {\n    /* ============================================================================\nTODO:\n\n============================================================================ */\n    //TODO: go ahead and move to underscore...\n    /** call fn on each key/value in d */\n    function each(d, fn) {\n        for (var k in d) {\n            if (d.hasOwnProperty(k)) {\n                fn(d[k], k, d);\n            }\n        }\n    }\n\n    /** copy key/values from d2 to d overwriting if present */\n    function extend(d, d2) {\n        for (var k in d2) {\n            if (d2.hasOwnProperty(k)) {\n                d[k] = d2[k];\n            }\n        }\n        return d;\n    }\n\n    /** deep equal of two dictionaries */\n    function matches(d, d2) {\n        for (var k in d2) {\n            if (d2.hasOwnProperty(k)) {\n                if (!d.hasOwnProperty(k) || d[k] !== d2[k]) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    /** map key/values in obj\n *      if propsOrFn is an object, return only those k/v that match the object\n *      if propsOrFn is function, call the fn and returned the mapped values from it\n */\n    function iterate(obj, propsOrFn) {\n        var fn = typeof propsOrFn === \"function\" ? propsOrFn : undefined,\n            props = typeof propsOrFn === \"object\" ? propsOrFn : undefined,\n            returned = [],\n            index = 0;\n        for (var key in obj) {\n            if (obj.hasOwnProperty(key)) {\n                var value = obj[key];\n                if (fn) {\n                    returned.push(fn.call(value, value, key, index));\n                } else if (props) {\n                    //TODO: break out to sep?\n                    if (typeof value === \"object\" && matches(value, props)) {\n                        returned.push(value);\n                    }\n                } else {\n                    returned.push(value);\n                }\n                index += 1;\n            }\n        }\n        return returned;\n    }\n\n    // ============================================================================\n    /** A graph edge containing the name/id of both source and target and optional data\n */\n    function Edge(source, target, data) {\n        var self = this;\n        self.source = source !== undefined ? source : null;\n        self.target = target !== undefined ? target : null;\n        self.data = data || null;\n        //if( typeof data === 'object' ){\n        //    extend( self, data );\n        //}\n        return self;\n    }\n    /** String representation */\n    Edge.prototype.toString = function() {\n        return this.source + \"->\" + this.target;\n    };\n\n    /** Return a plain object representing this edge */\n    Edge.prototype.toJSON = function() {\n        //TODO: this is safe in most browsers (fns will be stripped) - alter tests to incorporate this in order to pass data\n        //return this;\n        var json = {\n            source: this.source,\n            target: this.target\n        };\n        if (this.data) {\n            json.data = this.data;\n        }\n        return json;\n    };\n\n    // ============================================================================\n    /** A graph vertex with a (unique) name/id and optional data.\n *      A vertex contains a list of Edges (whose sources are this vertex) and maintains the degree.\n */\n    function Vertex(name, data) {\n        var self = this;\n        self.name = name !== undefined ? name : \"(unnamed)\";\n        self.data = data || null;\n        self.edges = {};\n        self.degree = 0;\n        return self;\n    }\n\n    /** String representation */\n    Vertex.prototype.toString = function() {\n        return \"Vertex(\" + this.name + \")\";\n    };\n\n    //TODO: better name w no collision for either this.eachEdge or this.edges\n    /** Iterate over each edge from this vertex */\n    Vertex.prototype.eachEdge = function(propsOrFn) {\n        return iterate(this.edges, propsOrFn);\n    };\n\n    /** Return a plain object representing this vertex */\n    Vertex.prototype.toJSON = function() {\n        //return this;\n        return {\n            name: this.name,\n            data: this.data\n        };\n    };\n\n    // ============================================================================\n    /** Base (abstract) class for Graph search algorithms.\n *      Pass in the graph to search\n *      and an optional dictionary containing the 3 vertex/edge processing fns listed below.\n */\n    var GraphSearch = function(graph, processFns) {\n        var self = this;\n        self.graph = graph;\n\n        self.processFns = processFns || {\n            vertexEarly: function(vertex, search) {\n                //console.debug( 'processing vertex:', vertex.name, vertex );\n            },\n            edge: function(from, edge, search) {\n                //console.debug( this, 'edge:', from, edge, search );\n            },\n            vertexLate: function(vertex, search) {\n                //console.debug( this, 'vertexLate:', vertex, search );\n            }\n        };\n\n        self._cache = {};\n        return self;\n    };\n\n    /** Search interface where start is the vertex (or the name/id of the vertex) to begin the search at\n *      This public interface caches searches and returns the cached version if it's already been done.\n */\n    GraphSearch.prototype.search = function _search(start) {\n        var self = this;\n        if (start in self._cache) {\n            return self._cache[start];\n        }\n        if (!(start instanceof Vertex)) {\n            start = self.graph.vertices[start];\n        }\n        return (self._cache[start.name] = self._search(start));\n    };\n\n    /** Actual search (private) function (abstract here) */\n    GraphSearch.prototype._search = function __search(start, search) {\n        search = search || {\n            discovered: {},\n            //parents : {},\n            edges: []\n        };\n        return search;\n    };\n\n    /** Searches graph from start and returns a search tree of the results */\n    GraphSearch.prototype.searchTree = function _searchTree(start) {\n        return this._searchTree(this.search(start));\n    };\n\n    /** Helper fn that returns a graph (a search tree) based on the search object passed in (does not actually search) */\n    GraphSearch.prototype._searchTree = function __searchTree(search) {\n        var self = this;\n        return new Graph(true, {\n            edges: search.edges,\n            vertices: Object.keys(search.discovered).map(function(key) {\n                return self.graph.vertices[key].toJSON();\n            })\n        });\n    };\n\n    // ============================================================================\n    /** Breadth first search algo.\n */\n    var BreadthFirstSearch = function(graph, processFns) {\n        var self = this;\n        GraphSearch.call(this, graph, processFns);\n        return self;\n    };\n    BreadthFirstSearch.prototype = new GraphSearch();\n    BreadthFirstSearch.prototype.constructor = BreadthFirstSearch;\n\n    /** (Private) implementation of BFS */\n    BreadthFirstSearch.prototype._search = function __search(start, search) {\n        search = search || {\n            discovered: {},\n            //parents : {},\n            edges: []\n        };\n\n        var self = this,\n            queue = [];\n\n        function discoverAdjacent(adj, edge) {\n            var source = this;\n            if (self.processFns.edge) {\n                self.processFns.edge.call(self, source, edge, search);\n            }\n            if (!search.discovered[adj.name]) {\n                //console.debug( '\\t\\t\\t', adj.name, 'is undiscovered:', search.discovered[ adj.name ] );\n                search.discovered[adj.name] = true;\n                //search.parents[ adj.name ] = source;\n                search.edges.push({ source: source.name, target: adj.name });\n                //console.debug( '\\t\\t\\t queuing undiscovered: ', adj );\n                queue.push(adj);\n            }\n        }\n\n        //console.debug( 'BFS starting. start:', start );\n        search.discovered[start.name] = true;\n        queue.push(start);\n        while (queue.length) {\n            var vertex = queue.shift();\n            //console.debug( '\\t Queue is shifting. Current:', vertex, 'queue:', queue );\n            if (self.processFns.vertexEarly) {\n                self.processFns.vertexEarly.call(self, vertex, search);\n            }\n            self.graph.eachAdjacent(vertex, discoverAdjacent);\n            if (self.processFns.vertexLate) {\n                self.processFns.vertexLate.call(self, vertex, search);\n            }\n        }\n        //console.debug( 'search.edges:', JSON.stringify( search.edges ) );\n        return search;\n    };\n\n    // ============================================================================\n    /** Depth first search algorithm.\n */\n    var DepthFirstSearch = function(graph, processFns) {\n        var self = this;\n        GraphSearch.call(this, graph, processFns);\n        return self;\n    };\n    DepthFirstSearch.prototype = new GraphSearch();\n    DepthFirstSearch.prototype.constructor = DepthFirstSearch;\n\n    /** (Private) implementation of DFS */\n    DepthFirstSearch.prototype._search = function(start, search) {\n        //console.debug( 'depthFirstSearch:', start );\n        search = search || {\n            discovered: {},\n            //parents    : {},\n            edges: [],\n            entryTimes: {},\n            exitTimes: {}\n        };\n        var self = this,\n            time = 0;\n\n        // discover verts adjacent to the source (this):\n        //  processing each edge, saving the edge to the tree, and caching the reverse path with parents\n        function discoverAdjacentVertices(adjacent, edge) {\n            //console.debug( '\\t\\t adjacent:', adjacent, 'edge:', edge );\n            var sourceVertex = this;\n            if (self.processFns.edge) {\n                self.processFns.edge.call(self, sourceVertex, edge, search);\n            }\n            if (!search.discovered[adjacent.name]) {\n                //search.parents[ adjacent.name ] = sourceVertex;\n                search.edges.push({\n                    source: sourceVertex.name,\n                    target: adjacent.name\n                });\n                recurse(adjacent);\n            }\n        }\n\n        // use function stack for DFS stack process verts, times, and discover adjacent verts (recursing into them)\n        function recurse(vertex) {\n            //console.debug( '\\t recursing into: ', vertex );\n            search.discovered[vertex.name] = true;\n            if (self.processFns.vertexEarly) {\n                self.processFns.vertexEarly.call(self, vertex, search);\n            }\n            search.entryTimes[vertex.name] = time++;\n\n            self.graph.eachAdjacent(vertex, discoverAdjacentVertices);\n\n            if (self.processFns.vertexLate) {\n                self.processFns.vertexLate.call(self, vertex, search);\n            }\n            search.exitTimes[vertex.name] = time++;\n        }\n        // begin recursion with the desired start\n        recurse(start);\n\n        return search;\n    };\n\n    // ============================================================================\n    /** A directed/non-directed graph object.\n */\n    function Graph(directed, data, options) {\n        //TODO: move directed to options\n        this.directed = directed || false;\n        return this.init(options).read(data);\n    }\n    window.Graph = Graph;\n\n    /** Set up options and instance variables */\n    Graph.prototype.init = function(options) {\n        options = options || {};\n        var self = this;\n\n        self.allowReflexiveEdges = options.allowReflexiveEdges || false;\n\n        self.vertices = {};\n        self.numEdges = 0;\n        return self;\n    };\n\n    /** Read data from the plain object data - both in d3 form (nodes and links) or vertices and edges */\n    Graph.prototype.read = function(data) {\n        if (!data) {\n            return this;\n        }\n        var self = this;\n        if (data.hasOwnProperty(\"nodes\")) {\n            return self.readNodesAndLinks(data);\n        }\n        if (data.hasOwnProperty(\"vertices\")) {\n            return self.readVerticesAndEdges(data);\n        }\n        return self;\n    };\n\n    //TODO: the next two could be combined\n    /** Create the graph using a list of nodes and a list of edges (where source and target are indeces into nodes) */\n    Graph.prototype.readNodesAndLinks = function(data) {\n        if (!(data && data.hasOwnProperty(\"nodes\"))) {\n            return this;\n        }\n        //console.debug( 'readNodesAndLinks:', data );\n        //console.debug( 'data:\\n' + JSON.stringify( data, null, '  ' ) );\n        var self = this;\n        data.nodes.forEach(function(node) {\n            self.createVertex(node.name, node.data);\n        });\n        //console.debug( JSON.stringify( self.vertices, null, '  ' ) );\n\n        (data.links || []).forEach(function(edge, i) {\n            var sourceName = data.nodes[edge.source].name,\n                targetName = data.nodes[edge.target].name;\n            self.createEdge(sourceName, targetName, self.directed);\n        });\n        //self.print();\n        //console.debug( JSON.stringify( self.toNodesAndLinks(), null, '  ' ) );\n        return self;\n    };\n\n    /** Create the graph using a list of nodes and a list of edges (where source and target are names of nodes) */\n    Graph.prototype.readVerticesAndEdges = function(data) {\n        if (!(data && data.hasOwnProperty(\"vertices\"))) {\n            return this;\n        }\n        //console.debug( 'readVerticesAndEdges:', data );\n        //console.debug( 'data:\\n' + JSON.stringify( data, null, '  ' ) );\n        var self = this;\n        data.vertices.forEach(function(node) {\n            self.createVertex(node.name, node.data);\n        });\n        //console.debug( JSON.stringify( self.vertices, null, '  ' ) );\n\n        (data.edges || []).forEach(function(edge, i) {\n            self.createEdge(edge.source, edge.target, self.directed);\n        });\n        //self.print();\n        //console.debug( JSON.stringify( self.toNodesAndLinks(), null, '  ' ) );\n        return self;\n    };\n\n    /** Return the vertex with name, creating it if necessary */\n    Graph.prototype.createVertex = function(name, data) {\n        //console.debug( 'createVertex:', name, data );\n        if (this.vertices[name]) {\n            return this.vertices[name];\n        }\n        return (this.vertices[name] = new Vertex(name, data));\n    };\n\n    /** Create an edge in vertex named sourceName to targetName (optionally adding data to it)\n *      If directed is false, create a second edge from targetName to sourceName.\n */\n    Graph.prototype.createEdge = function(\n        sourceName,\n        targetName,\n        directed,\n        data\n    ) {\n        //note: allows multiple 'equivalent' edges (to/from same source/target)\n        //console.debug( 'createEdge:', source, target, directed );\n        var isReflexive = sourceName === targetName;\n        if (!this.allowReflexiveEdges && isReflexive) {\n            return null;\n        }\n\n        var sourceVertex = this.vertices[sourceName];\n        var targetVertex = this.vertices[targetName];\n        //note: silently ignores edges from/to unknown vertices\n        if (!(sourceVertex && targetVertex)) {\n            return null;\n        }\n\n        //TODO: prob. move to vertex\n        var self = this,\n            edge = new Edge(sourceName, targetName, data);\n        sourceVertex.edges[targetName] = edge;\n        sourceVertex.degree += 1;\n        self.numEdges += 1;\n\n        //TODO:! don't like having duplicate edges for non-directed graphs\n        // mirror edges (reversing source and target) in non-directed graphs\n        //  but only if not reflexive\n        if (!isReflexive && !directed) {\n            // flip directed to prevent recursion loop\n            self.createEdge(targetName, sourceName, true);\n        }\n\n        return edge;\n    };\n\n    /** Walk over all the edges of the graph using the vertex.eachEdge iterator */\n    Graph.prototype.edges = function(propsOrFn) {\n        return Array.prototype.concat.apply(\n            [],\n            this.eachVertex(function(vertex) {\n                return vertex.eachEdge(propsOrFn);\n            })\n        );\n    };\n\n    /** Iterate over all the vertices in the graph */\n    Graph.prototype.eachVertex = function(propsOrFn) {\n        return iterate(this.vertices, propsOrFn);\n    };\n\n    /** Return a list of the vertices adjacent to vertex */\n    Graph.prototype.adjacent = function(vertex) {\n        var self = this;\n        return iterate(vertex.edges, function(edge) {\n            return self.vertices[edge.target];\n        });\n    };\n\n    /** Call fn on each vertex adjacent to vertex */\n    Graph.prototype.eachAdjacent = function(vertex, fn) {\n        var self = this;\n        return iterate(vertex.edges, function(edge) {\n            var adj = self.vertices[edge.target];\n            return fn.call(vertex, adj, edge);\n        });\n    };\n\n    /** Print the graph to the console (debugging) */\n    Graph.prototype.print = function() {\n        var self = this;\n        console.log(\n            \"Graph has \" + Object.keys(self.vertices).length + \" vertices\"\n        );\n        self.eachVertex(function(vertex) {\n            console.log(vertex.toString());\n            vertex.eachEdge(function(edge) {\n                console.log(\"\\t \" + edge);\n            });\n        });\n        return self;\n    };\n\n    /** Return a DOT format string of this graph */\n    Graph.prototype.toDOT = function() {\n        var self = this,\n            strings = [];\n        strings.push(\"graph bler {\");\n        self.edges(function(edge) {\n            strings.push(\"\\t\" + edge.from + \" -- \" + edge.to + \";\");\n        });\n        strings.push(\"}\");\n        return strings.join(\"\\n\");\n    };\n\n    /** Return vertices and edges of this graph in d3 node/link format */\n    Graph.prototype.toNodesAndLinks = function() {\n        var self = this,\n            indeces = {};\n        return {\n            nodes: self.eachVertex(function(vertex, key, i) {\n                indeces[vertex.name] = i;\n                return vertex.toJSON();\n            }),\n            links: self.edges(function(edge) {\n                var json = edge.toJSON();\n                json.source = indeces[edge.source];\n                json.target = indeces[edge.target];\n                return json;\n            })\n        };\n    };\n\n    /** Return vertices and edges of this graph where edges use the name/id as source and target */\n    Graph.prototype.toVerticesAndEdges = function() {\n        var self = this;\n        return {\n            vertices: self.eachVertex(function(vertex, key) {\n                return vertex.toJSON();\n            }),\n            edges: self.edges(function(edge) {\n                return edge.toJSON();\n            })\n        };\n    };\n\n    /** Search this graph using BFS */\n    Graph.prototype.breadthFirstSearch = function(start, processFns) {\n        return new BreadthFirstSearch(this).search(start);\n    };\n\n    /** Return a searchtree of this graph using BFS */\n    Graph.prototype.breadthFirstSearchTree = function(start, processFns) {\n        return new BreadthFirstSearch(this).searchTree(start);\n    };\n\n    /** Search this graph using DFS */\n    Graph.prototype.depthFirstSearch = function(start, processFns) {\n        return new DepthFirstSearch(this).search(start);\n    };\n\n    /** Return a searchtree of this graph using DFS */\n    Graph.prototype.depthFirstSearchTree = function(start, processFns) {\n        return new DepthFirstSearch(this).searchTree(start);\n    };\n\n    //Graph.prototype.shortestPath = function( start, end ){\n    //};\n    //\n    //Graph.prototype.articulationVertices = function(){\n    //};\n    //\n    //Graph.prototype.isAcyclic = function(){\n    //};\n    //\n    //Graph.prototype.isBipartite = function(){\n    //};\n\n    /** Return an array of weakly connected (no edges between) sub-graphs in this graph */\n    Graph.prototype.weakComponents = function() {\n        //TODO: alternately, instead of returning graph-like objects:\n        //  - could simply decorate the vertices (vertex.component = componentIndex), or clone the graph and do that\n        var self = this,\n            searchGraph = this,\n            undiscovered,\n            components = [];\n\n        function getComponent(undiscoveredVertex) {\n            //TODO: better interface on dfs (search v. searchTree)\n            var search = new DepthFirstSearch(searchGraph)._search(\n                undiscoveredVertex\n            );\n\n            // remove curr discovered from undiscovered\n            undiscovered = undiscovered.filter(function(name) {\n                return !(name in search.discovered);\n            });\n\n            return {\n                vertices: Object.keys(search.discovered).map(function(\n                    vertexName\n                ) {\n                    return self.vertices[vertexName].toJSON();\n                }),\n                edges: search.edges.map(function(edge) {\n                    // restore any reversed edges\n                    var hasBeenReversed =\n                        self.vertices[edge.target].edges[edge.source] !==\n                        undefined;\n                    if (self.directed && hasBeenReversed) {\n                        var swap = edge.source;\n                        edge.source = edge.target;\n                        edge.target = swap;\n                    }\n                    return edge;\n                })\n            };\n        }\n\n        if (self.directed) {\n            // if directed - convert to undirected for search\n            searchGraph = new Graph(false, self.toNodesAndLinks());\n        }\n        undiscovered = Object.keys(searchGraph.vertices);\n        //console.debug( '(initial) undiscovered:', undiscovered );\n        while (undiscovered.length) {\n            var undiscoveredVertex = searchGraph.vertices[undiscovered.shift()];\n            components.push(getComponent(undiscoveredVertex));\n            //console.debug( 'undiscovered now:', undiscovered );\n        }\n\n        //console.debug( 'components:\\n', JSON.stringify( components, null, '  ' ) );\n        return components;\n    };\n\n    /** Return a single graph containing the weakly connected components in this graph */\n    Graph.prototype.weakComponentGraph = function() {\n        //note: although this can often look like the original graph - edges can be lost\n        var components = this.weakComponents();\n        return new Graph(this.directed, {\n            vertices: components.reduce(function(reduction, curr) {\n                return reduction.concat(curr.vertices);\n            }, []),\n            edges: components.reduce(function(reduction, curr) {\n                return reduction.concat(curr.edges);\n            }, [])\n        });\n    };\n\n    /** Return an array of graphs of the weakly connected components in this graph */\n    Graph.prototype.weakComponentGraphArray = function() {\n        //note: although this can often look like the original graph - edges can be lost\n        var graph = this;\n        return this.weakComponents().map(function(component) {\n            return new Graph(graph.directed, component);\n        });\n    };\n\n    // ============================================================================\n    /** Create a random graph with numVerts vertices and numEdges edges (for testing)\n */\n    function randGraph(directed, numVerts, numEdges) {\n        //console.debug( 'randGraph', directed, numVerts, numEdges );\n        var data = { nodes: [], links: [] };\n        function randRange(range) {\n            return Math.floor(Math.random() * range);\n        }\n        for (var i = 0; i < numVerts; i++) {\n            data.nodes.push({ name: i });\n        }\n        for (i = 0; i < numEdges; i++) {\n            data.links.push({\n                source: randRange(numVerts),\n                target: randRange(numVerts)\n            });\n        }\n        //console.debug( JSON.stringify( data, null, '  ' ) );\n        return new Graph(directed, data);\n    }\n\n    // ============================================================================\n    return {\n        Vertex: Vertex,\n        Edge: Edge,\n        BreadthFirstSearch: BreadthFirstSearch,\n        DepthFirstSearch: DepthFirstSearch,\n        Graph: Graph,\n        randGraph: randGraph\n    };\n});\n"]}