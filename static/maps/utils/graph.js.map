{"version":3,"sources":["utils/graph.js"],"names":["matches","d","d2","k","hasOwnProperty","extend","iterate","fn","propsOrFn","undefined","props","_typeof","returned","index","key","obj","value","push","call","Edge","source","target","data","self","this","name","json","degree","processFns","options","search","exitTimes","vertex","init","read","prototype","toString","Vertex","eachEdge","edges","toJSON","graph","vertexEarly","edge","from","vertexLate","_cache","GraphSearch","start","vertices","_search","discovered","searchTree","_searchTree","keys","map","Graph","BreadthFirstSearch","constructor","queue","shift","__search","adj","DepthFirstSearch","discoverAdjacentVertices","adjacent","sourceVertex","time","recurse","allowReflexiveEdges","numEdges","directed","readNodesAndLinks","readVerticesAndEdges","nodes","forEach","node","createVertex","links","i","targetName","createEdge","sourceName","isReflexive","targetVertex","Array","concat","apply","eachVertex","eachAdjacent","print","console","Object","length","log","strings","to","join","indeces","toNodesAndLinks","breadthFirstSearchTree","breadthFirstSearch","weakComponents","undiscovered","searchGraph","components","undiscoveredVertex","filter","vertexName","hasBeenReversed","swap","getComponent","weakComponentGraph","reduce","reduction","curr","component","randGraph","randRange","range","Math","floor","random","numVerts"],"mappings":"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","file":"../../scripts/utils/graph.js","sourcesContent":["/* ============================================================================\nTODO:\n\n============================================================================ */\n//TODO: go ahead and move to underscore...\n/** call fn on each key/value in d */\nfunction each(d, fn) {\n    for (var k in d) {\n        if (d.hasOwnProperty(k)) {\n            fn(d[k], k, d);\n        }\n    }\n}\n\n/** copy key/values from d2 to d overwriting if present */\nfunction extend(d, d2) {\n    for (var k in d2) {\n        if (d2.hasOwnProperty(k)) {\n            d[k] = d2[k];\n        }\n    }\n    return d;\n}\n\n/** deep equal of two dictionaries */\nfunction matches(d, d2) {\n    for (var k in d2) {\n        if (d2.hasOwnProperty(k)) {\n            if (!d.hasOwnProperty(k) || d[k] !== d2[k]) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n\n/** map key/values in obj\n *      if propsOrFn is an object, return only those k/v that match the object\n *      if propsOrFn is function, call the fn and returned the mapped values from it\n */\nfunction iterate(obj, propsOrFn) {\n    var fn = typeof propsOrFn === \"function\" ? propsOrFn : undefined;\n    var props = typeof propsOrFn === \"object\" ? propsOrFn : undefined;\n    var returned = [];\n    var index = 0;\n    for (var key in obj) {\n        if (obj.hasOwnProperty(key)) {\n            var value = obj[key];\n            if (fn) {\n                returned.push(fn.call(value, value, key, index));\n            } else if (props) {\n                //TODO: break out to sep?\n                if (typeof value === \"object\" && matches(value, props)) {\n                    returned.push(value);\n                }\n            } else {\n                returned.push(value);\n            }\n            index += 1;\n        }\n    }\n    return returned;\n}\n\n// ============================================================================\n/** A graph edge containing the name/id of both source and target and optional data\n */\nfunction Edge(source, target, data) {\n    var self = this;\n    self.source = source !== undefined ? source : null;\n    self.target = target !== undefined ? target : null;\n    self.data = data || null;\n    //if( typeof data === 'object' ){\n    //    extend( self, data );\n    //}\n    return self;\n}\n/** String representation */\nEdge.prototype.toString = function() {\n    return this.source + \"->\" + this.target;\n};\n\n/** Return a plain object representing this edge */\nEdge.prototype.toJSON = function() {\n    //TODO: this is safe in most browsers (fns will be stripped) - alter tests to incorporate this in order to pass data\n    //return this;\n    var json = {\n        source: this.source,\n        target: this.target\n    };\n    if (this.data) {\n        json.data = this.data;\n    }\n    return json;\n};\n\n// ============================================================================\n/** A graph vertex with a (unique) name/id and optional data.\n *      A vertex contains a list of Edges (whose sources are this vertex) and maintains the degree.\n */\nfunction Vertex(name, data) {\n    var self = this;\n    self.name = name !== undefined ? name : \"(unnamed)\";\n    self.data = data || null;\n    self.edges = {};\n    self.degree = 0;\n    return self;\n}\n\n/** String representation */\nVertex.prototype.toString = function() {\n    return \"Vertex(\" + this.name + \")\";\n};\n\n//TODO: better name w no collision for either this.eachEdge or this.edges\n/** Iterate over each edge from this vertex */\nVertex.prototype.eachEdge = function(propsOrFn) {\n    return iterate(this.edges, propsOrFn);\n};\n\n/** Return a plain object representing this vertex */\nVertex.prototype.toJSON = function() {\n    //return this;\n    return {\n        name: this.name,\n        data: this.data\n    };\n};\n\n// ============================================================================\n/** Base (abstract) class for Graph search algorithms.\n *      Pass in the graph to search\n *      and an optional dictionary containing the 3 vertex/edge processing fns listed below.\n */\nvar GraphSearch = function(graph, processFns) {\n    var self = this;\n    self.graph = graph;\n\n    self.processFns = processFns || {\n        vertexEarly: function(vertex, search) {\n            //console.debug( 'processing vertex:', vertex.name, vertex );\n        },\n        edge: function(from, edge, search) {\n            //console.debug( this, 'edge:', from, edge, search );\n        },\n        vertexLate: function(vertex, search) {\n            //console.debug( this, 'vertexLate:', vertex, search );\n        }\n    };\n\n    self._cache = {};\n    return self;\n};\n\n/** Search interface where start is the vertex (or the name/id of the vertex) to begin the search at\n *      This public interface caches searches and returns the cached version if it's already been done.\n */\nGraphSearch.prototype.search = function _search(start) {\n    var self = this;\n    if (start in self._cache) {\n        return self._cache[start];\n    }\n    if (!(start instanceof Vertex)) {\n        start = self.graph.vertices[start];\n    }\n    return (self._cache[start.name] = self._search(start));\n};\n\n/** Actual search (private) function (abstract here) */\nGraphSearch.prototype._search = function __search(start, search) {\n    search = search || {\n        discovered: {},\n        //parents : {},\n        edges: []\n    };\n    return search;\n};\n\n/** Searches graph from start and returns a search tree of the results */\nGraphSearch.prototype.searchTree = function _searchTree(start) {\n    return this._searchTree(this.search(start));\n};\n\n/** Helper fn that returns a graph (a search tree) based on the search object passed in (does not actually search) */\nGraphSearch.prototype._searchTree = function __searchTree(search) {\n    var self = this;\n    return new Graph(true, {\n        edges: search.edges,\n        vertices: Object.keys(search.discovered).map(function(key) {\n            return self.graph.vertices[key].toJSON();\n        })\n    });\n};\n\n// ============================================================================\n/** Breadth first search algo.\n */\nvar BreadthFirstSearch = function(graph, processFns) {\n    var self = this;\n    GraphSearch.call(this, graph, processFns);\n    return self;\n};\nBreadthFirstSearch.prototype = new GraphSearch();\nBreadthFirstSearch.prototype.constructor = BreadthFirstSearch;\n\n/** (Private) implementation of BFS */\nBreadthFirstSearch.prototype._search = function __search(start, search) {\n    search = search || {\n        discovered: {},\n        //parents : {},\n        edges: []\n    };\n\n    var self = this;\n    var queue = [];\n\n    function discoverAdjacent(adj, edge) {\n        var source = this;\n        if (self.processFns.edge) {\n            self.processFns.edge.call(self, source, edge, search);\n        }\n        if (!search.discovered[adj.name]) {\n            //console.debug( '\\t\\t\\t', adj.name, 'is undiscovered:', search.discovered[ adj.name ] );\n            search.discovered[adj.name] = true;\n            //search.parents[ adj.name ] = source;\n            search.edges.push({ source: source.name, target: adj.name });\n            //console.debug( '\\t\\t\\t queuing undiscovered: ', adj );\n            queue.push(adj);\n        }\n    }\n\n    //console.debug( 'BFS starting. start:', start );\n    search.discovered[start.name] = true;\n    queue.push(start);\n    while (queue.length) {\n        var vertex = queue.shift();\n        //console.debug( '\\t Queue is shifting. Current:', vertex, 'queue:', queue );\n        if (self.processFns.vertexEarly) {\n            self.processFns.vertexEarly.call(self, vertex, search);\n        }\n        self.graph.eachAdjacent(vertex, discoverAdjacent);\n        if (self.processFns.vertexLate) {\n            self.processFns.vertexLate.call(self, vertex, search);\n        }\n    }\n    //console.debug( 'search.edges:', JSON.stringify( search.edges ) );\n    return search;\n};\n\n// ============================================================================\n/** Depth first search algorithm.\n */\nvar DepthFirstSearch = function(graph, processFns) {\n    var self = this;\n    GraphSearch.call(this, graph, processFns);\n    return self;\n};\nDepthFirstSearch.prototype = new GraphSearch();\nDepthFirstSearch.prototype.constructor = DepthFirstSearch;\n\n/** (Private) implementation of DFS */\nDepthFirstSearch.prototype._search = function(start, search) {\n    //console.debug( 'depthFirstSearch:', start );\n    search = search || {\n        discovered: {},\n        //parents    : {},\n        edges: [],\n        entryTimes: {},\n        exitTimes: {}\n    };\n    var self = this;\n    var time = 0;\n\n    // discover verts adjacent to the source (this):\n    //  processing each edge, saving the edge to the tree, and caching the reverse path with parents\n    function discoverAdjacentVertices(adjacent, edge) {\n        //console.debug( '\\t\\t adjacent:', adjacent, 'edge:', edge );\n        var sourceVertex = this;\n        if (self.processFns.edge) {\n            self.processFns.edge.call(self, sourceVertex, edge, search);\n        }\n        if (!search.discovered[adjacent.name]) {\n            //search.parents[ adjacent.name ] = sourceVertex;\n            search.edges.push({\n                source: sourceVertex.name,\n                target: adjacent.name\n            });\n            recurse(adjacent);\n        }\n    }\n\n    // use function stack for DFS stack process verts, times, and discover adjacent verts (recursing into them)\n    function recurse(vertex) {\n        //console.debug( '\\t recursing into: ', vertex );\n        search.discovered[vertex.name] = true;\n        if (self.processFns.vertexEarly) {\n            self.processFns.vertexEarly.call(self, vertex, search);\n        }\n        search.entryTimes[vertex.name] = time++;\n\n        self.graph.eachAdjacent(vertex, discoverAdjacentVertices);\n\n        if (self.processFns.vertexLate) {\n            self.processFns.vertexLate.call(self, vertex, search);\n        }\n        search.exitTimes[vertex.name] = time++;\n    }\n    // begin recursion with the desired start\n    recurse(start);\n\n    return search;\n};\n\n// ============================================================================\n/** A directed/non-directed graph object.\n */\nfunction Graph(directed, data, options) {\n    //TODO: move directed to options\n    this.directed = directed || false;\n    return this.init(options).read(data);\n}\nwindow.Graph = Graph;\n\n/** Set up options and instance variables */\nGraph.prototype.init = function(options) {\n    options = options || {};\n    var self = this;\n\n    self.allowReflexiveEdges = options.allowReflexiveEdges || false;\n\n    self.vertices = {};\n    self.numEdges = 0;\n    return self;\n};\n\n/** Read data from the plain object data - both in d3 form (nodes and links) or vertices and edges */\nGraph.prototype.read = function(data) {\n    if (!data) {\n        return this;\n    }\n    var self = this;\n    if (data.hasOwnProperty(\"nodes\")) {\n        return self.readNodesAndLinks(data);\n    }\n    if (data.hasOwnProperty(\"vertices\")) {\n        return self.readVerticesAndEdges(data);\n    }\n    return self;\n};\n\n//TODO: the next two could be combined\n/** Create the graph using a list of nodes and a list of edges (where source and target are indeces into nodes) */\nGraph.prototype.readNodesAndLinks = function(data) {\n    if (!(data && data.hasOwnProperty(\"nodes\"))) {\n        return this;\n    }\n    //console.debug( 'readNodesAndLinks:', data );\n    //console.debug( 'data:\\n' + JSON.stringify( data, null, '  ' ) );\n    var self = this;\n    data.nodes.forEach(function(node) {\n        self.createVertex(node.name, node.data);\n    });\n    //console.debug( JSON.stringify( self.vertices, null, '  ' ) );\n\n    (data.links || []).forEach(function(edge, i) {\n        var sourceName = data.nodes[edge.source].name;\n        var targetName = data.nodes[edge.target].name;\n        self.createEdge(sourceName, targetName, self.directed);\n    });\n    //self.print();\n    //console.debug( JSON.stringify( self.toNodesAndLinks(), null, '  ' ) );\n    return self;\n};\n\n/** Create the graph using a list of nodes and a list of edges (where source and target are names of nodes) */\nGraph.prototype.readVerticesAndEdges = function(data) {\n    if (!(data && data.hasOwnProperty(\"vertices\"))) {\n        return this;\n    }\n    //console.debug( 'readVerticesAndEdges:', data );\n    //console.debug( 'data:\\n' + JSON.stringify( data, null, '  ' ) );\n    var self = this;\n    data.vertices.forEach(function(node) {\n        self.createVertex(node.name, node.data);\n    });\n    //console.debug( JSON.stringify( self.vertices, null, '  ' ) );\n\n    (data.edges || []).forEach(function(edge, i) {\n        self.createEdge(edge.source, edge.target, self.directed);\n    });\n    //self.print();\n    //console.debug( JSON.stringify( self.toNodesAndLinks(), null, '  ' ) );\n    return self;\n};\n\n/** Return the vertex with name, creating it if necessary */\nGraph.prototype.createVertex = function(name, data) {\n    //console.debug( 'createVertex:', name, data );\n    if (this.vertices[name]) {\n        return this.vertices[name];\n    }\n    return (this.vertices[name] = new Vertex(name, data));\n};\n\n/** Create an edge in vertex named sourceName to targetName (optionally adding data to it)\n *      If directed is false, create a second edge from targetName to sourceName.\n */\nGraph.prototype.createEdge = function(sourceName, targetName, directed, data) {\n    //note: allows multiple 'equivalent' edges (to/from same source/target)\n    //console.debug( 'createEdge:', source, target, directed );\n    var isReflexive = sourceName === targetName;\n    if (!this.allowReflexiveEdges && isReflexive) {\n        return null;\n    }\n\n    var sourceVertex = this.vertices[sourceName];\n    var targetVertex = this.vertices[targetName];\n    //note: silently ignores edges from/to unknown vertices\n    if (!(sourceVertex && targetVertex)) {\n        return null;\n    }\n\n    //TODO: prob. move to vertex\n    var self = this;\n\n    var edge = new Edge(sourceName, targetName, data);\n    sourceVertex.edges[targetName] = edge;\n    sourceVertex.degree += 1;\n    self.numEdges += 1;\n\n    //TODO:! don't like having duplicate edges for non-directed graphs\n    // mirror edges (reversing source and target) in non-directed graphs\n    //  but only if not reflexive\n    if (!isReflexive && !directed) {\n        // flip directed to prevent recursion loop\n        self.createEdge(targetName, sourceName, true);\n    }\n\n    return edge;\n};\n\n/** Walk over all the edges of the graph using the vertex.eachEdge iterator */\nGraph.prototype.edges = function(propsOrFn) {\n    return Array.prototype.concat.apply(\n        [],\n        this.eachVertex(function(vertex) {\n            return vertex.eachEdge(propsOrFn);\n        })\n    );\n};\n\n/** Iterate over all the vertices in the graph */\nGraph.prototype.eachVertex = function(propsOrFn) {\n    return iterate(this.vertices, propsOrFn);\n};\n\n/** Return a list of the vertices adjacent to vertex */\nGraph.prototype.adjacent = function(vertex) {\n    var self = this;\n    return iterate(vertex.edges, function(edge) {\n        return self.vertices[edge.target];\n    });\n};\n\n/** Call fn on each vertex adjacent to vertex */\nGraph.prototype.eachAdjacent = function(vertex, fn) {\n    var self = this;\n    return iterate(vertex.edges, function(edge) {\n        var adj = self.vertices[edge.target];\n        return fn.call(vertex, adj, edge);\n    });\n};\n\n/** Print the graph to the console (debugging) */\nGraph.prototype.print = function() {\n    var self = this;\n    console.log(\"Graph has \" + Object.keys(self.vertices).length + \" vertices\");\n    self.eachVertex(function(vertex) {\n        console.log(vertex.toString());\n        vertex.eachEdge(function(edge) {\n            console.log(\"\\t \" + edge);\n        });\n    });\n    return self;\n};\n\n/** Return a DOT format string of this graph */\nGraph.prototype.toDOT = function() {\n    var self = this;\n    var strings = [];\n    strings.push(\"graph bler {\");\n    self.edges(function(edge) {\n        strings.push(\"\\t\" + edge.from + \" -- \" + edge.to + \";\");\n    });\n    strings.push(\"}\");\n    return strings.join(\"\\n\");\n};\n\n/** Return vertices and edges of this graph in d3 node/link format */\nGraph.prototype.toNodesAndLinks = function() {\n    var self = this;\n    var indeces = {};\n    return {\n        nodes: self.eachVertex(function(vertex, key, i) {\n            indeces[vertex.name] = i;\n            return vertex.toJSON();\n        }),\n        links: self.edges(function(edge) {\n            var json = edge.toJSON();\n            json.source = indeces[edge.source];\n            json.target = indeces[edge.target];\n            return json;\n        })\n    };\n};\n\n/** Return vertices and edges of this graph where edges use the name/id as source and target */\nGraph.prototype.toVerticesAndEdges = function() {\n    var self = this;\n    return {\n        vertices: self.eachVertex(function(vertex, key) {\n            return vertex.toJSON();\n        }),\n        edges: self.edges(function(edge) {\n            return edge.toJSON();\n        })\n    };\n};\n\n/** Search this graph using BFS */\nGraph.prototype.breadthFirstSearch = function(start, processFns) {\n    return new BreadthFirstSearch(this).search(start);\n};\n\n/** Return a searchtree of this graph using BFS */\nGraph.prototype.breadthFirstSearchTree = function(start, processFns) {\n    return new BreadthFirstSearch(this).searchTree(start);\n};\n\n/** Search this graph using DFS */\nGraph.prototype.depthFirstSearch = function(start, processFns) {\n    return new DepthFirstSearch(this).search(start);\n};\n\n/** Return a searchtree of this graph using DFS */\nGraph.prototype.depthFirstSearchTree = function(start, processFns) {\n    return new DepthFirstSearch(this).searchTree(start);\n};\n\n//Graph.prototype.shortestPath = function( start, end ){\n//};\n//\n//Graph.prototype.articulationVertices = function(){\n//};\n//\n//Graph.prototype.isAcyclic = function(){\n//};\n//\n//Graph.prototype.isBipartite = function(){\n//};\n\n/** Return an array of weakly connected (no edges between) sub-graphs in this graph */\nGraph.prototype.weakComponents = function() {\n    //TODO: alternately, instead of returning graph-like objects:\n    //  - could simply decorate the vertices (vertex.component = componentIndex), or clone the graph and do that\n    var self = this;\n\n    var searchGraph = this;\n    var undiscovered;\n    var components = [];\n\n    function getComponent(undiscoveredVertex) {\n        //TODO: better interface on dfs (search v. searchTree)\n        var search = new DepthFirstSearch(searchGraph)._search(\n            undiscoveredVertex\n        );\n\n        // remove curr discovered from undiscovered\n        undiscovered = undiscovered.filter(function(name) {\n            return !(name in search.discovered);\n        });\n\n        return {\n            vertices: Object.keys(search.discovered).map(function(vertexName) {\n                return self.vertices[vertexName].toJSON();\n            }),\n            edges: search.edges.map(function(edge) {\n                // restore any reversed edges\n                var hasBeenReversed =\n                    self.vertices[edge.target].edges[edge.source] !== undefined;\n                if (self.directed && hasBeenReversed) {\n                    var swap = edge.source;\n                    edge.source = edge.target;\n                    edge.target = swap;\n                }\n                return edge;\n            })\n        };\n    }\n\n    if (self.directed) {\n        // if directed - convert to undirected for search\n        searchGraph = new Graph(false, self.toNodesAndLinks());\n    }\n    undiscovered = Object.keys(searchGraph.vertices);\n    //console.debug( '(initial) undiscovered:', undiscovered );\n    while (undiscovered.length) {\n        var undiscoveredVertex = searchGraph.vertices[undiscovered.shift()];\n        components.push(getComponent(undiscoveredVertex));\n        //console.debug( 'undiscovered now:', undiscovered );\n    }\n\n    //console.debug( 'components:\\n', JSON.stringify( components, null, '  ' ) );\n    return components;\n};\n\n/** Return a single graph containing the weakly connected components in this graph */\nGraph.prototype.weakComponentGraph = function() {\n    //note: although this can often look like the original graph - edges can be lost\n    var components = this.weakComponents();\n    return new Graph(this.directed, {\n        vertices: components.reduce(function(reduction, curr) {\n            return reduction.concat(curr.vertices);\n        }, []),\n        edges: components.reduce(function(reduction, curr) {\n            return reduction.concat(curr.edges);\n        }, [])\n    });\n};\n\n/** Return an array of graphs of the weakly connected components in this graph */\nGraph.prototype.weakComponentGraphArray = function() {\n    //note: although this can often look like the original graph - edges can be lost\n    var graph = this;\n    return this.weakComponents().map(function(component) {\n        return new Graph(graph.directed, component);\n    });\n};\n\n// ============================================================================\n/** Create a random graph with numVerts vertices and numEdges edges (for testing)\n */\nfunction randGraph(directed, numVerts, numEdges) {\n    //console.debug( 'randGraph', directed, numVerts, numEdges );\n    var data = { nodes: [], links: [] };\n    function randRange(range) {\n        return Math.floor(Math.random() * range);\n    }\n    for (var i = 0; i < numVerts; i++) {\n        data.nodes.push({ name: i });\n    }\n    for (i = 0; i < numEdges; i++) {\n        data.links.push({\n            source: randRange(numVerts),\n            target: randRange(numVerts)\n        });\n    }\n    //console.debug( JSON.stringify( data, null, '  ' ) );\n    return new Graph(directed, data);\n}\n\n// ============================================================================\nexport default {\n    Vertex: Vertex,\n    Edge: Edge,\n    BreadthFirstSearch: BreadthFirstSearch,\n    DepthFirstSearch: DepthFirstSearch,\n    Graph: Graph,\n    randGraph: randGraph\n};\n"]}