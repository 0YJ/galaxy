{"version":3,"sources":["utils/metrics-logger.js"],"names":["define","MetricsLogger","options","self","this","userId","window","bootstrapped","user","id","consoleLogger","LoggingCache","prototype","_init","ALL","LOG","DEBUG","INFO","WARN","ERROR","defaultOptions","NONE","consoleLevel","defaultNamespace","consoleNamespaceWhitelist","clientPrefix","addTime","cacheKeyPrefix","postUrl","undefined","delayPostInMs","onServerResponse","k","hasOwnProperty","_parseLevel","logLevel","_sending","_waiting","_postSize","postSize","_initCache","cache","key","maxSize","err","type","_typeof","level","upper","Error","emit","namespace","logArguments","_emitToConsole","_addToCache","arguments","_buildEntry","entry","toISOString","jQuery","entries","time","Date","fail","_postCache","count","entriesLength","length","postData","getPingData","stringify","post","always","xhr","status","message","maxCacheSize","whitelist","responseJSON","responseText","done","_delayPost","setTimeout","indexOf","args","call","unshift","info","apply","error","warn","debug","log","Array","slice","localStorage","removeItem","getItem","_cache","_fetchAndParse","metric","METRIC","_unparseAndStore","JSON","_initStorage","_hasStorage","e","empty","add","overage","splice","push","parse","setItem","get","remove","removed","print","console"],"mappings":"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","file":"../../scripts/utils/metrics-logger.js","sourcesContent":["define([], function() {\n    /*global window, jQuery, console */\n    /*=============================================================================\nTODO:\n    while anon: logs saved to 'logs-null' - this will never post\n        unless we manually do so at/after login\n        OR prepend when userId and localStorage has 'logs-null'\n    wire up _delayPost and test\n\n=============================================================================*/\n    /** @class MetricsLogger\n *\n *  Object to cache, output, and post log/metric messages to the server.\n *  Meant to be attached to the Galaxy object.\n *\n *  Log from objects by either attaching logger directly:\n *      panel.logger.metric( 'user dataset deletion', panel.user.id, hda.toJSON() )\n *  or using the LoggableMixin or addLogging function:\n *      MyBackboneModel.extend( LoggableMixin ).extend({ ... })\n *      addLogging( MyBackboneModel, 'my-backbone-model' )\n *\n *  Log from templates by calling directly from Galaxy object:\n *      Galaxy.logger.metric( 'template loaded', { ownedByUser : true });\n *\n *  If you attempt to log an un-serializable object (circular reference, window, etc.),\n *  that entry will not be cached (or sent). If you set consoleLevel and consoleLogger\n *  appropriately, a warning will be shown when this happens:\n *      > panel.metric( 'something weird with window', { window : window })\n *      !'Metrics logger could not stringify logArguments: ...'\n */\n    function MetricsLogger(options) {\n        options = options || {};\n        var self = this;\n\n        ///** get the current user's id from bootstrapped data or options */\n        self.userId =\n            window.bootstrapped && window.bootstrapped.user\n                ? window.bootstrapped.user.id\n                : null;\n        self.userId = self.userId || options.userId || null;\n\n        /** the (optional) console to emit logs to */\n        self.consoleLogger = options.consoleLogger || null;\n\n        self._init(options);\n        return self;\n    }\n\n    //----------------------------------------------------------------------------- defaults and constants\n    // see: python std lib, logging\n    MetricsLogger.ALL = 0;\n    MetricsLogger.LOG = 0;\n    MetricsLogger.DEBUG = 10;\n    MetricsLogger.INFO = 20;\n    MetricsLogger.WARN = 30;\n    MetricsLogger.ERROR = 40;\n    // metrics levels here?\n    //MetricsLogger.MinorEvent  = 45;\n    //MetricsLogger.MajorEvent  = 50;\n    MetricsLogger.METRIC = 50;\n    MetricsLogger.NONE = 100;\n\n    /** default options - override these through the constructor */\n    MetricsLogger.defaultOptions = {\n        /** if an incoming message has a level >= this, it will be cached - can also be a string (e.g. 'debug') */\n        logLevel: MetricsLogger.NONE,\n        /** if an incoming message has a level >= this, it will be output to the console */\n        consoleLevel: MetricsLogger.NONE,\n        /** the default 'namespace' or label associated with an incoming message (if none is passed) */\n        defaultNamespace: \"Galaxy\",\n        /** the namespaces output to the console (all namespaces will be output if this is falsy)\n     *  note: applies only to the console (not the event/metrics log/cache)\n     */\n        consoleNamespaceWhitelist: null,\n        /** the prefix attached to client-side logs to distinguish them in the metrics db */\n        clientPrefix: \"client.\",\n\n        /** the maximum number of messages the cache should hold; if exceeded older messages are removed first */\n        maxCacheSize: 3000,\n        /** the number of messages accumulate before posting to the server; should be <= maxCacheSize */\n        postSize: 1000,\n        /** T/F whether to add a timestamp to incoming cached messages */\n        addTime: true,\n        /** string to prefix to userid for cache web storage */\n        cacheKeyPrefix: \"logs-\",\n\n        /** the relative url to post messages to */\n        postUrl: \"/api/metrics\",\n        /** delay before trying post again after two failures */\n        delayPostInMs: 1000 * 60 * 10,\n\n        /** an (optional) function that should return an object; used to send additional data with the metrics */\n        getPingData: undefined,\n        /** an (optional) function that will handle the servers response after successfully posting messages */\n        onServerResponse: undefined\n    };\n\n    //----------------------------------------------------------------------------- set up\n    /** initialize the logger with options, set up instance vars and cache, and add onpageunload to window */\n    MetricsLogger.prototype._init = function _init(options) {\n        var self = this;\n        self.options = {};\n        for (var k in MetricsLogger.defaultOptions) {\n            if (MetricsLogger.defaultOptions.hasOwnProperty(k)) {\n                self.options[k] = options.hasOwnProperty(k)\n                    ? options[k]\n                    : MetricsLogger.defaultOptions[k];\n            }\n        }\n        self.options.logLevel = self._parseLevel(self.options.logLevel);\n        self.options.consoleLevel = self._parseLevel(self.options.consoleLevel);\n        //self._emitToConsole( 'debug', 'MetricsLogger', 'MetricsLogger.options:', self.options );\n\n        /** is the logger currently sending? */\n        self._sending = false;\n        /** the setTimeout id if the logger POST has failed more than once */\n        self._waiting = null;\n        /** the current number of entries to send in a POST */\n        self._postSize = self.options.postSize;\n\n        self._initCache();\n\n        return self;\n    };\n\n    /** initialize the cache */\n    MetricsLogger.prototype._initCache = function _initCache() {\n        try {\n            this.cache = new LoggingCache({\n                maxSize: this.options.maxCacheSize,\n                key: this.options.cacheKeyPrefix + this.userId\n            });\n        } catch (err) {\n            this._emitToConsole(\"warn\", \"MetricsLogger\", [\n                \"Could not intitialize logging cache:\",\n                err\n            ]);\n            this.options.logLevel = MetricsLogger.NONE;\n        }\n    };\n\n    /** return the numeric log level if level in 'none, debug, log, info, warn, error' */\n    MetricsLogger.prototype._parseLevel = function _parseLevel(level) {\n        var type = typeof level;\n        if (type === \"number\") {\n            return level;\n        }\n        if (type === \"string\") {\n            var upper = level.toUpperCase();\n            if (MetricsLogger.hasOwnProperty(upper)) {\n                return MetricsLogger[upper];\n            }\n        }\n        throw new Error(\"Unknown log level: \" + level);\n    };\n\n    //----------------------------------------------------------------------------- main entry point\n    /** record a log/message's arguments to the cache and/or the console based on level and namespace */\n    MetricsLogger.prototype.emit = function emit(\n        level,\n        namespace,\n        logArguments\n    ) {\n        //this._emitToConsole( 'debug', 'MetricsLogger', [ 'emit:', level, namespace, logArguments ]);\n        var self = this;\n        namespace = namespace || self.options.defaultNamespace;\n        if (!level || !logArguments) {\n            return self;\n        }\n        // add to cache if proper level\n        //TODO: respect do not track?\n        //if( !navigator.doNotTrack && level >= self.options.logLevel ){\n        level = self._parseLevel(level);\n        if (level >= self.options.logLevel) {\n            self._addToCache(level, namespace, logArguments);\n        }\n        // also emit to consoleLogger if proper level for that\n        if (self.consoleLogger && level >= self.options.consoleLevel) {\n            self._emitToConsole(level, namespace, logArguments);\n        }\n        return self;\n    };\n\n    //----------------------------------------------------------------------------- cache\n    /** add a message to the cache and if messages.length is high enough post them to the server */\n    MetricsLogger.prototype._addToCache = function _addToCache(\n        level,\n        namespace,\n        logArguments\n    ) {\n        this._emitToConsole(\"debug\", \"MetricsLogger\", [\n            \"_addToCache:\",\n            arguments,\n            this.options.addTime,\n            this.cache.length()\n        ]);\n        //this._emitToConsole( 'debug', 'MetricsLogger', [ '\\t logArguments:', logArguments ]);\n        var self = this;\n        // try add to the cache and if we've got _postSize number of entries, attempt to post them to the server\n        try {\n            var newLength = self.cache.add(\n                self._buildEntry(level, namespace, logArguments)\n            );\n            if (newLength >= self._postSize) {\n                self._postCache();\n            }\n            // discard entry if an error occurs, but warn if level set to do so\n        } catch (err) {\n            self._emitToConsole(\"warn\", \"MetricsLogger\", [\n                \"Metrics logger could not stringify logArguments:\",\n                namespace,\n                logArguments\n            ]);\n            self._emitToConsole(\"error\", \"MetricsLogger\", [err]);\n        }\n        return self;\n    };\n\n    /** build a log cache entry object from the given level, namespace, and arguments (optionally adding timestamp */\n    MetricsLogger.prototype._buildEntry = function _buildEntry(\n        level,\n        namespace,\n        logArguments\n    ) {\n        this._emitToConsole(\"debug\", \"MetricsLogger\", [\n            \"_buildEntry:\",\n            arguments\n        ]);\n        var entry = {\n            level: level,\n            namespace: this.options.clientPrefix + namespace,\n            args: logArguments\n        };\n        if (this.options.addTime) {\n            entry.time = new Date().toISOString();\n        }\n        return entry;\n    };\n\n    /** post _postSize messages from the cache to the server, removing them if successful\n *      if the post fails, wait until maxCacheSize is accumulated instead and try again then\n *      in addition to the messages from the cache ('metrics'), any info from getPingData (if set) will be sent\n *      onServerResponse will be called (if set) with any response from the server\n */\n    MetricsLogger.prototype._postCache = function _postCache(options) {\n        options = options || {};\n        this._emitToConsole(\"info\", \"MetricsLogger\", [\n            \"_postCache\",\n            options,\n            this._postSize\n        ]);\n\n        // short circuit if we're already sending\n        if (!this.options.postUrl || this._sending) {\n            return jQuery.when({});\n        }\n\n        var self = this,\n            postSize = options.count || self._postSize,\n            // do not splice - remove after *successful* post\n            entries = self.cache.get(postSize),\n            entriesLength = entries.length,\n            // use the optional getPingData to add any extra info we may want to send\n            postData =\n                typeof self.options.getPingData === \"function\"\n                    ? self.options.getPingData()\n                    : {};\n        //console.debug( postSize, entriesLength );\n\n        // add the metrics and send\n        postData.metrics = JSON.stringify(entries);\n        //console.debug( postData.metrics );\n        self._sending = true;\n        return jQuery\n            .post(self.options.postUrl, postData)\n            .always(function() {\n                self._sending = false;\n            })\n            .fail(function(xhr, status, message) {\n                // if we failed the previous time, set the next post target to the max num of entries\n                self._postSize = self.options.maxCacheSize;\n                //TODO:??\n                // log this failure to explain any gap in metrics\n                self.emit(\"error\", \"MetricsLogger\", [\n                    \"_postCache error:\",\n                    xhr.readyState,\n                    xhr.status,\n                    xhr.responseJSON || xhr.responseText\n                ]);\n                //TODO: still doesn't solve the problem that when cache == max, post will be tried on every emit\n                //TODO: see _delayPost\n            })\n            .done(function(response) {\n                if (typeof self.options.onServerResponse === \"function\") {\n                    self.options.onServerResponse(response);\n                }\n                // only remove if post successful\n                self.cache.remove(entriesLength);\n                //console.debug( 'removed entries:', entriesLength, 'size now:', self.cache.length() );\n                // if we succeeded, reset the post target to the normal num of entries\n                self._postSize = self.options.postSize;\n            });\n        // return the xhr promise\n    };\n\n    /** set _waiting to true and, after delayPostInMs, set it back to false */\n    MetricsLogger.prototype._delayPost = function _delayPost() {\n        //TODO: this won't work between pages\n        var self = this;\n        self._waiting = setTimeout(function() {\n            self._waiting = null;\n        }, self.options.delayPostInMs);\n    };\n\n    //----------------------------------------------------------------------------- console\n    /** output message to console based on level and consoleLogger type */\n    MetricsLogger.prototype._emitToConsole = function _emitToConsole(\n        level,\n        namespace,\n        logArguments\n    ) {\n        //console.debug( '_emitToConsole:', level, namespace, logArguments );\n        var self = this,\n            whitelist = self.options.consoleNamespaceWhitelist;\n        if (!self.consoleLogger) {\n            return self;\n        }\n        // if a whitelist for namespaces is set, bail if this namespace is not in the list\n        if (whitelist && whitelist.indexOf(namespace) === -1) {\n            return self;\n        }\n\n        var args = Array.prototype.slice.call(logArguments, 0);\n        args.unshift(namespace);\n        //TODO: script location and/or source maps?\n        //TODO: branch on navigator.userAgent == AIIEEE - it only has log\n        if (\n            level >= MetricsLogger.METRIC &&\n            typeof self.consoleLogger.info === \"function\"\n        ) {\n            return self.consoleLogger.info.apply(self.consoleLogger, args);\n        } else if (\n            level >= MetricsLogger.ERROR &&\n            typeof self.consoleLogger.error === \"function\"\n        ) {\n            return self.consoleLogger.error.apply(self.consoleLogger, args);\n        } else if (\n            level >= MetricsLogger.WARN &&\n            typeof self.consoleLogger.warn === \"function\"\n        ) {\n            self.consoleLogger.warn.apply(self.consoleLogger, args);\n        } else if (\n            level >= MetricsLogger.INFO &&\n            typeof self.consoleLogger.info === \"function\"\n        ) {\n            self.consoleLogger.info.apply(self.consoleLogger, args);\n        } else if (\n            level >= MetricsLogger.DEBUG &&\n            typeof self.consoleLogger.debug === \"function\"\n        ) {\n            self.consoleLogger.debug.apply(self.consoleLogger, args);\n        } else if (typeof self.consoleLogger.log === \"function\") {\n            self.consoleLogger.log.apply(self.consoleLogger, args);\n        }\n        return self;\n    };\n\n    //----------------------------------------------------------------------------- shortcuts\n    // generic functions when logging from non-namespaced object (e.g. templates)\n    /** log to default namespace */\n    MetricsLogger.prototype.log = function log() {\n        this.emit(\n            1,\n            this.options.defaultNamespace,\n            Array.prototype.slice.call(arguments, 0)\n        );\n    };\n\n    /** debug to default namespace */\n    MetricsLogger.prototype.debug = function debug() {\n        this.emit(\n            MetricsLogger.DEBUG,\n            this.options.defaultNamespace,\n            Array.prototype.slice.call(arguments, 0)\n        );\n    };\n\n    /** info to default namespace */\n    MetricsLogger.prototype.info = function info() {\n        this.emit(\n            MetricsLogger.INFO,\n            this.options.defaultNamespace,\n            Array.prototype.slice.call(arguments, 0)\n        );\n    };\n\n    /** warn to default namespace */\n    MetricsLogger.prototype.warn = function warn() {\n        this.emit(\n            MetricsLogger.WARN,\n            this.options.defaultNamespace,\n            Array.prototype.slice.call(arguments, 0)\n        );\n    };\n\n    /** error to default namespace */\n    MetricsLogger.prototype.error = function error() {\n        this.emit(\n            MetricsLogger.ERROR,\n            this.options.defaultNamespace,\n            Array.prototype.slice.call(arguments, 0)\n        );\n    };\n\n    /** metric to default namespace */\n    MetricsLogger.prototype.metric = function metric() {\n        this.emit(\n            MetricsLogger.METRIC,\n            this.options.defaultNamespace,\n            Array.prototype.slice.call(arguments, 0)\n        );\n    };\n\n    /* ============================================================================\nTODO:\n    need a performance pass - the JSON un/parsing is a bit much\n\n============================================================================ */\n    /** @class LoggingCache\n *  Simple implementation of cache wrapping an array.\n *\n *  Formats an entry before it's cached and only keeps options.maxSize number\n *  of entries. Older entries are deleted first.\n */\n    function LoggingCache(options) {\n        var self = this;\n        return self._init(options || {});\n    }\n\n    /** default options */\n    LoggingCache.defaultOptions = {\n        /** maximum number of entries to keep before discarding oldest */\n        maxSize: 5000\n    };\n\n    /** initialize with options */\n    LoggingCache.prototype._init = function _init(options) {\n        if (!this._hasStorage()) {\n            //TODO: fall back to jstorage\n            throw new Error(\"LoggingCache needs localStorage\");\n        }\n        if (!options.key) {\n            throw new Error(\"LoggingCache needs key for localStorage\");\n        }\n        this.key = options.key;\n        this._initStorage();\n\n        this.maxSize = options.maxSize || LoggingCache.defaultOptions.maxSize;\n        return this;\n    };\n\n    /** tests for localStorage fns */\n    LoggingCache.prototype._hasStorage = function _hasStorage() {\n        //TODO: modernizr\n        var test = \"test\";\n        try {\n            localStorage.setItem(test, test);\n            localStorage.removeItem(test);\n            return true;\n        } catch (e) {\n            return false;\n        }\n    };\n\n    /** if no localStorage set for key, initialize to empty array */\n    LoggingCache.prototype._initStorage = function _initStorage() {\n        if (localStorage.getItem(this.key) === null) {\n            return this.empty();\n        }\n        return this;\n    };\n\n    /** add an entry to the cache, removing the oldest beforehand if size >= maxSize */\n    LoggingCache.prototype.add = function add(entry) {\n        var self = this,\n            _cache = self._fetchAndParse(),\n            overage = _cache.length + 1 - self.maxSize;\n        if (overage > 0) {\n            _cache.splice(0, overage);\n        }\n        _cache.push(entry);\n        self._unparseAndStore(_cache);\n        return _cache.length;\n    };\n\n    /** get the entries from localStorage and parse them */\n    LoggingCache.prototype._fetchAndParse = function _fetchAndParse() {\n        var self = this;\n        return JSON.parse(localStorage.getItem(self.key));\n    };\n\n    /** stringify the entries and put them in localStorage */\n    LoggingCache.prototype._unparseAndStore = function _unparseAndStore(\n        entries\n    ) {\n        var self = this;\n        return localStorage.setItem(self.key, JSON.stringify(entries));\n    };\n\n    ///** process the entry before caching */\n    //LoggingCache.prototype._preprocessEntry = function _preprocessEntry( entry ){\n    //    return JSON.stringify( entry );\n    //};\n\n    /** return the length --- oh, getters where are you? */\n    LoggingCache.prototype.length = function length() {\n        return this._fetchAndParse().length;\n    };\n\n    /** get count number of entries starting with the oldest */\n    LoggingCache.prototype.get = function get(count) {\n        return this._fetchAndParse().slice(0, count);\n    };\n\n    /** remove count number of entries starting with the oldest */\n    LoggingCache.prototype.remove = function remove(count) {\n        var _cache = this._fetchAndParse(),\n            removed = _cache.splice(0, count);\n        this._unparseAndStore(_cache);\n        return removed;\n    };\n\n    /** empty/clear the entire cache */\n    LoggingCache.prototype.empty = function empty() {\n        localStorage.setItem(this.key, \"[]\");\n        return this;\n    };\n\n    /** stringify count number of entries (but do not remove) */\n    LoggingCache.prototype.stringify = function stringify(count) {\n        return JSON.stringify(this.get(count));\n    };\n\n    /** outputs entire cache to console */\n    LoggingCache.prototype.print = function print() {\n        // popup? (really, carl? a popup?) - easier to copy/paste\n        console.log(JSON.stringify(this._fetchAndParse(), null, \"  \"));\n    };\n\n    //=============================================================================\n    return {\n        MetricsLogger: MetricsLogger,\n        LoggingCache: LoggingCache\n    };\n});\n"]}