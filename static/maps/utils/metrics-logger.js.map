{"version":3,"sources":["utils/metrics-logger.js"],"names":["define","MetricsLogger","options","self","this","userId","window","bootstrapped","user","id","consoleLogger","_init","LoggingCache","ALL","LOG","DEBUG","INFO","WARN","ERROR","METRIC","NONE","defaultOptions","logLevel","consoleLevel","defaultNamespace","consoleNamespaceWhitelist","clientPrefix","maxCacheSize","postSize","addTime","cacheKeyPrefix","postUrl","delayPostInMs","getPingData","undefined","onServerResponse","prototype","k","hasOwnProperty","_parseLevel","_sending","_waiting","_postSize","_initCache","cache","maxSize","key","err","_emitToConsole","level","type","upper","toUpperCase","Error","emit","namespace","logArguments","_addToCache","arguments","length","add","_buildEntry","_postCache","entry","args","time","Date","toISOString","jQuery","when","count","entries","get","entriesLength","postData","metrics","JSON","stringify","post","always","fail","xhr","status","message","readyState","responseJSON","responseText","done","response","remove","_delayPost","setTimeout","whitelist","indexOf","Array","slice","call","unshift","info","apply","error","warn","debug","log","metric","_hasStorage","_initStorage","localStorage","setItem","removeItem","e","getItem","empty","_cache","_fetchAndParse","overage","splice","push","_unparseAndStore","parse","removed","print","console"],"mappings":"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","file":"../../scripts/utils/metrics-logger.js","sourcesContent":["define([\n], function(){\n/*global window, jQuery, console */\n/*=============================================================================\nTODO:\n    while anon: logs saved to 'logs-null' - this will never post\n        unless we manually do so at/after login\n        OR prepend when userId and localStorage has 'logs-null'\n    wire up _delayPost and test\n\n=============================================================================*/\n/** @class MetricsLogger\n *\n *  Object to cache, output, and post log/metric messages to the server.\n *  Meant to be attached to the Galaxy object.\n *\n *  Log from objects by either attaching logger directly:\n *      panel.logger.metric( 'user dataset deletion', panel.user.id, hda.toJSON() )\n *  or using the LoggableMixin or addLogging function:\n *      MyBackboneModel.extend( LoggableMixin ).extend({ ... })\n *      addLogging( MyBackboneModel, 'my-backbone-model' )\n *\n *  Log from templates by calling directly from Galaxy object:\n *      Galaxy.logger.metric( 'template loaded', { ownedByUser : true });\n *\n *  If you attempt to log an un-serializable object (circular reference, window, etc.),\n *  that entry will not be cached (or sent). If you set consoleLevel and consoleLogger\n *  appropriately, a warning will be shown when this happens:\n *      > panel.metric( 'something weird with window', { window : window })\n *      !'Metrics logger could not stringify logArguments: ...'\n */\nfunction MetricsLogger( options ){\n    options = options || {};\n    var self = this;\n\n    ///** get the current user's id from bootstrapped data or options */\n    self.userId = ( window.bootstrapped && window.bootstrapped.user )? window.bootstrapped.user.id: null;\n    self.userId = self.userId || options.userId || null;\n\n    /** the (optional) console to emit logs to */\n    self.consoleLogger = options.consoleLogger || null;\n\n    self._init( options );\n    return self;\n}\n\n//----------------------------------------------------------------------------- defaults and constants\n// see: python std lib, logging\nMetricsLogger.ALL   =  0;\nMetricsLogger.LOG   =  0;\nMetricsLogger.DEBUG = 10;\nMetricsLogger.INFO  = 20;\nMetricsLogger.WARN  = 30;\nMetricsLogger.ERROR = 40;\n// metrics levels here?\n//MetricsLogger.MinorEvent  = 45;\n//MetricsLogger.MajorEvent  = 50;\nMetricsLogger.METRIC = 50;\nMetricsLogger.NONE = 100;\n\n/** default options - override these through the constructor */\nMetricsLogger.defaultOptions = {\n    /** if an incoming message has a level >= this, it will be cached - can also be a string (e.g. 'debug') */\n    logLevel            : MetricsLogger.NONE,\n    /** if an incoming message has a level >= this, it will be output to the console */\n    consoleLevel        : MetricsLogger.NONE,\n    /** the default 'namespace' or label associated with an incoming message (if none is passed) */\n    defaultNamespace    : 'Galaxy',\n    /** the namespaces output to the console (all namespaces will be output if this is falsy)\n     *  note: applies only to the console (not the event/metrics log/cache)\n     */\n    consoleNamespaceWhitelist : null,\n    /** the prefix attached to client-side logs to distinguish them in the metrics db */\n    clientPrefix        : 'client.',\n\n    /** the maximum number of messages the cache should hold; if exceeded older messages are removed first */\n    maxCacheSize        : 3000,\n    /** the number of messages accumulate before posting to the server; should be <= maxCacheSize */\n    postSize            : 1000,\n    /** T/F whether to add a timestamp to incoming cached messages */\n    addTime             : true,\n    /** string to prefix to userid for cache web storage */\n    cacheKeyPrefix      : 'logs-',\n\n    /** the relative url to post messages to */\n    postUrl             : '/api/metrics',\n    /** delay before trying post again after two failures */\n    delayPostInMs       : 1000 * 60 * 10,\n\n    /** an (optional) function that should return an object; used to send additional data with the metrics */\n    getPingData         : undefined,\n    /** an (optional) function that will handle the servers response after successfully posting messages */\n    onServerResponse    : undefined\n};\n\n//----------------------------------------------------------------------------- set up\n/** initialize the logger with options, set up instance vars and cache, and add onpageunload to window */\nMetricsLogger.prototype._init = function _init( options ){\n    var self = this;\n    self.options = {};\n    for( var k in MetricsLogger.defaultOptions ){\n        if( MetricsLogger.defaultOptions.hasOwnProperty( k ) ){\n            self.options[ k ] = ( options.hasOwnProperty( k ) )?( options[ k ] ):( MetricsLogger.defaultOptions[ k ] );\n        }\n    }\n    self.options.logLevel = self._parseLevel( self.options.logLevel );\n    self.options.consoleLevel = self._parseLevel( self.options.consoleLevel );\n    //self._emitToConsole( 'debug', 'MetricsLogger', 'MetricsLogger.options:', self.options );\n\n    /** is the logger currently sending? */\n    self._sending = false;\n    /** the setTimeout id if the logger POST has failed more than once */\n    self._waiting = null;\n    /** the current number of entries to send in a POST */\n    self._postSize = self.options.postSize;\n\n    self._initCache();\n\n    return self;\n};\n\n/** initialize the cache */\nMetricsLogger.prototype._initCache = function _initCache(){\n    try {\n        this.cache = new LoggingCache({\n            maxSize : this.options.maxCacheSize,\n            key     : this.options.cacheKeyPrefix + this.userId\n        });\n    } catch( err ){\n        this._emitToConsole( 'warn', 'MetricsLogger', [ 'Could not intitialize logging cache:', err ] );\n        this.options.logLevel = MetricsLogger.NONE;\n    }\n};\n\n/** return the numeric log level if level in 'none, debug, log, info, warn, error' */\nMetricsLogger.prototype._parseLevel = function _parseLevel( level ){\n    var type = typeof level;\n    if( type === 'number' ){ return level; }\n    if( type === 'string' ){\n        var upper = level.toUpperCase();\n        if( MetricsLogger.hasOwnProperty( upper ) ){\n            return MetricsLogger[ upper ];\n        }\n    }\n    throw new Error( 'Unknown log level: ' + level );\n};\n\n\n//----------------------------------------------------------------------------- main entry point\n/** record a log/message's arguments to the cache and/or the console based on level and namespace */\nMetricsLogger.prototype.emit = function emit( level, namespace, logArguments ){\n    //this._emitToConsole( 'debug', 'MetricsLogger', [ 'emit:', level, namespace, logArguments ]);\n    var self = this;\n    namespace = namespace || self.options.defaultNamespace;\n    if( !level || !logArguments ){\n        return self;\n    }\n    // add to cache if proper level\n    //TODO: respect do not track?\n    //if( !navigator.doNotTrack && level >= self.options.logLevel ){\n    level = self._parseLevel( level );\n    if( level >= self.options.logLevel ){\n        self._addToCache( level, namespace, logArguments );\n    }\n    // also emit to consoleLogger if proper level for that\n    if( self.consoleLogger && level >= self.options.consoleLevel ){\n        self._emitToConsole( level, namespace, logArguments );\n    }\n    return self;\n};\n\n//----------------------------------------------------------------------------- cache\n/** add a message to the cache and if messages.length is high enough post them to the server */\nMetricsLogger.prototype._addToCache = function _addToCache( level, namespace, logArguments ){\n    this._emitToConsole( 'debug', 'MetricsLogger',\n        [ '_addToCache:', arguments, this.options.addTime, this.cache.length() ]);\n    //this._emitToConsole( 'debug', 'MetricsLogger', [ '\\t logArguments:', logArguments ]);\n    var self = this;\n    // try add to the cache and if we've got _postSize number of entries, attempt to post them to the server\n    try {\n        var newLength = self.cache.add( self._buildEntry( level, namespace, logArguments ) );\n        if( newLength >= self._postSize ){\n            self._postCache();\n        }\n    // discard entry if an error occurs, but warn if level set to do so\n    } catch( err ){\n        self._emitToConsole( 'warn', 'MetricsLogger',\n            [ 'Metrics logger could not stringify logArguments:', namespace, logArguments ] );\n        self._emitToConsole( 'error', 'MetricsLogger', [ err ] );\n\n    }\n    return self;\n};\n\n/** build a log cache entry object from the given level, namespace, and arguments (optionally adding timestamp */\nMetricsLogger.prototype._buildEntry = function _buildEntry( level, namespace, logArguments ){\n    this._emitToConsole( 'debug', 'MetricsLogger', [ '_buildEntry:', arguments ]);\n    var entry = {\n            level       : level,\n            namespace   : this.options.clientPrefix + namespace,\n            args        : logArguments\n        };\n    if( this.options.addTime ){\n        entry.time = new Date().toISOString();\n    }\n    return entry;\n};\n\n/** post _postSize messages from the cache to the server, removing them if successful\n *      if the post fails, wait until maxCacheSize is accumulated instead and try again then\n *      in addition to the messages from the cache ('metrics'), any info from getPingData (if set) will be sent\n *      onServerResponse will be called (if set) with any response from the server\n */\nMetricsLogger.prototype._postCache = function _postCache( options ){\n    options = options || {};\n    this._emitToConsole( 'info', 'MetricsLogger', [ '_postCache', options, this._postSize ]);\n\n    // short circuit if we're already sending\n    if( !this.options.postUrl || this._sending ){\n        return jQuery.when({});\n    }\n\n    var self = this,\n        postSize = options.count || self._postSize,\n        // do not splice - remove after *successful* post\n        entries = self.cache.get( postSize ),\n        entriesLength = entries.length,\n        // use the optional getPingData to add any extra info we may want to send\n        postData = ( typeof self.options.getPingData === 'function' )?( self.options.getPingData() ):( {} );\n    //console.debug( postSize, entriesLength );\n\n    // add the metrics and send\n    postData.metrics = JSON.stringify( entries );\n    //console.debug( postData.metrics );\n    self._sending = true;\n    return jQuery.post( self.options.postUrl, postData )\n        .always( function(){\n            self._sending = false;\n        })\n        .fail( function( xhr, status, message ){\n            // if we failed the previous time, set the next post target to the max num of entries\n            self._postSize = self.options.maxCacheSize;\n//TODO:??\n            // log this failure to explain any gap in metrics\n            self.emit( 'error', 'MetricsLogger', [ '_postCache error:',\n                xhr.readyState, xhr.status, xhr.responseJSON || xhr.responseText ]);\n//TODO: still doesn't solve the problem that when cache == max, post will be tried on every emit\n//TODO: see _delayPost\n        })\n        .done( function( response ){\n            if( typeof self.options.onServerResponse === 'function' ){\n                self.options.onServerResponse( response );\n            }\n            // only remove if post successful\n            self.cache.remove( entriesLength );\n            //console.debug( 'removed entries:', entriesLength, 'size now:', self.cache.length() );\n            // if we succeeded, reset the post target to the normal num of entries\n            self._postSize = self.options.postSize;\n        });\n    // return the xhr promise\n};\n\n/** set _waiting to true and, after delayPostInMs, set it back to false */\nMetricsLogger.prototype._delayPost = function _delayPost(){\n//TODO: this won't work between pages\n    var self = this;\n    self._waiting = setTimeout( function(){\n        self._waiting = null;\n    }, self.options.delayPostInMs );\n};\n\n\n//----------------------------------------------------------------------------- console\n/** output message to console based on level and consoleLogger type */\nMetricsLogger.prototype._emitToConsole = function _emitToConsole( level, namespace, logArguments ){\n    //console.debug( '_emitToConsole:', level, namespace, logArguments );\n    var self = this,\n        whitelist = self.options.consoleNamespaceWhitelist;\n    if( !self.consoleLogger ){ return self; }\n    // if a whitelist for namespaces is set, bail if this namespace is not in the list\n    if( whitelist && whitelist.indexOf( namespace ) === -1 ){\n        return self;\n    }\n\n    var args = Array.prototype.slice.call( logArguments, 0 );\n    args.unshift( namespace );\n//TODO: script location and/or source maps?\n//TODO: branch on navigator.userAgent == AIIEEE - it only has log\n    if(        level >= MetricsLogger.METRIC && typeof( self.consoleLogger.info ) === 'function' ){\n        return self.consoleLogger.info.apply( self.consoleLogger, args );\n\n    } else if( level >= MetricsLogger.ERROR && typeof( self.consoleLogger.error ) === 'function' ){\n        return self.consoleLogger.error.apply( self.consoleLogger, args );\n    } else if( level >= MetricsLogger.WARN && typeof( self.consoleLogger.warn ) === 'function' ){\n        self.consoleLogger.warn.apply( self.consoleLogger, args );\n    } else if( level >= MetricsLogger.INFO && typeof( self.consoleLogger.info ) === 'function' ){\n        self.consoleLogger.info.apply( self.consoleLogger, args );\n    } else if( level >= MetricsLogger.DEBUG && typeof( self.consoleLogger.debug ) === 'function' ){\n        self.consoleLogger.debug.apply( self.consoleLogger, args );\n    } else if( typeof( self.consoleLogger.log ) === 'function' ){\n        self.consoleLogger.log.apply( self.consoleLogger, args );\n    }\n    return self;\n};\n\n//----------------------------------------------------------------------------- shortcuts\n// generic functions when logging from non-namespaced object (e.g. templates)\n/** log to default namespace */\nMetricsLogger.prototype.log = function log(){\n    this.emit( 1, this.options.defaultNamespace,\n        Array.prototype.slice.call( arguments, 0 ) );\n};\n\n/** debug to default namespace */\nMetricsLogger.prototype.debug = function debug(){\n    this.emit( MetricsLogger.DEBUG, this.options.defaultNamespace,\n        Array.prototype.slice.call( arguments, 0 ) );\n};\n\n/** info to default namespace */\nMetricsLogger.prototype.info = function info(){\n    this.emit( MetricsLogger.INFO, this.options.defaultNamespace,\n        Array.prototype.slice.call( arguments, 0 ) );\n};\n\n/** warn to default namespace */\nMetricsLogger.prototype.warn = function warn(){\n    this.emit( MetricsLogger.WARN, this.options.defaultNamespace,\n        Array.prototype.slice.call( arguments, 0 ) );\n};\n\n/** error to default namespace */\nMetricsLogger.prototype.error = function error(){\n    this.emit( MetricsLogger.ERROR, this.options.defaultNamespace,\n        Array.prototype.slice.call( arguments, 0 ) );\n};\n\n/** metric to default namespace */\nMetricsLogger.prototype.metric = function metric(){\n    this.emit( MetricsLogger.METRIC, this.options.defaultNamespace,\n        Array.prototype.slice.call( arguments, 0 ) );\n};\n\n\n/* ============================================================================\nTODO:\n    need a performance pass - the JSON un/parsing is a bit much\n\n============================================================================ */\n/** @class LoggingCache\n *  Simple implementation of cache wrapping an array.\n *\n *  Formats an entry before it's cached and only keeps options.maxSize number\n *  of entries. Older entries are deleted first.\n */\nfunction LoggingCache( options ){\n    var self = this;\n    return self._init( options || {} );\n}\n\n/** default options */\nLoggingCache.defaultOptions = {\n    /** maximum number of entries to keep before discarding oldest */\n    maxSize     : 5000\n};\n\n/** initialize with options */\nLoggingCache.prototype._init = function _init( options ){\n    if( !this._hasStorage() ){\n        //TODO: fall back to jstorage\n        throw new Error( 'LoggingCache needs localStorage' );\n    }\n    if( !options.key ){\n        throw new Error( 'LoggingCache needs key for localStorage' );\n    }\n    this.key = options.key;\n    this._initStorage();\n\n    this.maxSize = options.maxSize || LoggingCache.defaultOptions.maxSize;\n    return this;\n};\n\n/** tests for localStorage fns */\nLoggingCache.prototype._hasStorage = function _hasStorage(){\n//TODO: modernizr\n    var test = 'test';\n    try {\n        localStorage.setItem( test, test );\n        localStorage.removeItem( test );\n        return true;\n    } catch( e ){\n        return false;\n    }\n};\n\n/** if no localStorage set for key, initialize to empty array */\nLoggingCache.prototype._initStorage = function _initStorage(){\n    if( localStorage.getItem( this.key ) === null ){\n        return this.empty();\n    }\n    return this;\n};\n\n/** add an entry to the cache, removing the oldest beforehand if size >= maxSize */\nLoggingCache.prototype.add = function add( entry ){\n    var self = this,\n        _cache = self._fetchAndParse(),\n        overage = ( _cache.length + 1 ) - self.maxSize;\n    if( overage > 0 ){\n        _cache.splice( 0, overage );\n    }\n    _cache.push( entry );\n    self._unparseAndStore( _cache );\n    return _cache.length;\n};\n\n/** get the entries from localStorage and parse them */\nLoggingCache.prototype._fetchAndParse = function _fetchAndParse(){\n    var self = this;\n    return JSON.parse( localStorage.getItem( self.key ) );\n};\n\n/** stringify the entries and put them in localStorage */\nLoggingCache.prototype._unparseAndStore = function _unparseAndStore( entries ){\n    var self = this;\n    return localStorage.setItem( self.key, JSON.stringify( entries ) );\n};\n\n///** process the entry before caching */\n//LoggingCache.prototype._preprocessEntry = function _preprocessEntry( entry ){\n//    return JSON.stringify( entry );\n//};\n\n/** return the length --- oh, getters where are you? */\nLoggingCache.prototype.length = function length(){\n    return this._fetchAndParse().length;\n};\n\n/** get count number of entries starting with the oldest */\nLoggingCache.prototype.get = function get( count ){\n    return this._fetchAndParse().slice( 0, count );\n};\n\n/** remove count number of entries starting with the oldest */\nLoggingCache.prototype.remove = function remove( count ){\n    var _cache = this._fetchAndParse(),\n        removed = _cache.splice( 0, count );\n    this._unparseAndStore( _cache );\n    return removed;\n};\n\n/** empty/clear the entire cache */\nLoggingCache.prototype.empty = function empty(){\n    localStorage.setItem( this.key, '[]' );\n    return this;\n};\n\n/** stringify count number of entries (but do not remove) */\nLoggingCache.prototype.stringify = function stringify( count ){\n    return JSON.stringify( this.get( count ) );\n};\n\n/** outputs entire cache to console */\nLoggingCache.prototype.print = function print(){\n    // popup? (really, carl? a popup?) - easier to copy/paste\n    console.log( JSON.stringify( this._fetchAndParse(), null, '  ' ) );\n};\n\n\n//=============================================================================\n    return {\n        MetricsLogger  : MetricsLogger,\n        LoggingCache   : LoggingCache\n    };\n});\n"]}