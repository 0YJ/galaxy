{"version":3,"sources":["utils/metrics-logger.js"],"names":["MetricsLogger","options","self","this","userId","window","bootstrapped","user","id","consoleLogger","LoggingCache","_init","ALL","LOG","INFO","ERROR","METRIC","NONE","consoleLevel","defaultOptions","logLevel","maxCacheSize","postSize","addTime","cacheKeyPrefix","postUrl","delayPostInMs","undefined","getPingData","hasOwnProperty","k","onServerResponse","_parseLevel","_waiting","_initCache","_postSize","maxSize","key","err","_emitToConsole","prototype","level","type","_typeof","upper","Error","emit","logArguments","namespace","defaultNamespace","_addToCache","arguments","cache","length","add","_postCache","entry","clientPrefix","_buildEntry","time","Date","toISOString","postData","entriesLength","metrics","stringify","jQuery","when","xhr","status","message","entries","get","_sending","post","always","_delayPost","fail","readyState","responseJSON","responseText","done","response","remove","args","unshift","whitelist","consoleNamespaceWhitelist","indexOf","call","info","apply","error","warn","DEBUG","debug","log","Array","_hasStorage","_initStorage","slice","test","WARN","_cache","splice","overage","_unparseAndStore","_fetchAndParse","count","removed","localStorage","setItem","removeItem","push","JSON","parse","getItem","empty","print","console"],"mappings":"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","file":"../../scripts/utils/metrics-logger.js","sourcesContent":["/*global window, jQuery, console */\n/*=============================================================================\nTODO:\n    while anon: logs saved to 'logs-null' - this will never post\n        unless we manually do so at/after login\n        OR prepend when userId and localStorage has 'logs-null'\n    wire up _delayPost and test\n\n=============================================================================*/\n/** @class MetricsLogger\n *\n *  Object to cache, output, and post log/metric messages to the server.\n *  Meant to be attached to the Galaxy object.\n *\n *  Log from objects by either attaching logger directly:\n *      panel.logger.metric( 'user dataset deletion', panel.user.id, hda.toJSON() )\n *  or using the LoggableMixin or addLogging function:\n *      MyBackboneModel.extend( LoggableMixin ).extend({ ... })\n *      addLogging( MyBackboneModel, 'my-backbone-model' )\n *\n *  Log from templates by calling directly from Galaxy object:\n *      Galaxy.logger.metric( 'template loaded', { ownedByUser : true });\n *\n *  If you attempt to log an un-serializable object (circular reference, window, etc.),\n *  that entry will not be cached (or sent). If you set consoleLevel and consoleLogger\n *  appropriately, a warning will be shown when this happens:\n *      > panel.metric( 'something weird with window', { window : window })\n *      !'Metrics logger could not stringify logArguments: ...'\n */\nfunction MetricsLogger(options) {\n    options = options || {};\n    var self = this;\n\n    ///** get the current user's id from bootstrapped data or options */\n    self.userId =\n        window.bootstrapped && window.bootstrapped.user\n            ? window.bootstrapped.user.id\n            : null;\n    self.userId = self.userId || options.userId || null;\n\n    /** the (optional) console to emit logs to */\n    self.consoleLogger = options.consoleLogger || null;\n\n    self._init(options);\n    return self;\n}\n\n//----------------------------------------------------------------------------- defaults and constants\n// see: python std lib, logging\nMetricsLogger.ALL = 0;\nMetricsLogger.LOG = 0;\nMetricsLogger.DEBUG = 10;\nMetricsLogger.INFO = 20;\nMetricsLogger.WARN = 30;\nMetricsLogger.ERROR = 40;\n// metrics levels here?\n//MetricsLogger.MinorEvent  = 45;\n//MetricsLogger.MajorEvent  = 50;\nMetricsLogger.METRIC = 50;\nMetricsLogger.NONE = 100;\n\n/** default options - override these through the constructor */\nMetricsLogger.defaultOptions = {\n    /** if an incoming message has a level >= this, it will be cached - can also be a string (e.g. 'debug') */\n    logLevel: MetricsLogger.NONE,\n    /** if an incoming message has a level >= this, it will be output to the console */\n    consoleLevel: MetricsLogger.NONE,\n    /** the default 'namespace' or label associated with an incoming message (if none is passed) */\n    defaultNamespace: \"Galaxy\",\n    /** the namespaces output to the console (all namespaces will be output if this is falsy)\n     *  note: applies only to the console (not the event/metrics log/cache)\n     */\n    consoleNamespaceWhitelist: null,\n    /** the prefix attached to client-side logs to distinguish them in the metrics db */\n    clientPrefix: \"client.\",\n\n    /** the maximum number of messages the cache should hold; if exceeded older messages are removed first */\n    maxCacheSize: 3000,\n    /** the number of messages accumulate before posting to the server; should be <= maxCacheSize */\n    postSize: 1000,\n    /** T/F whether to add a timestamp to incoming cached messages */\n    addTime: true,\n    /** string to prefix to userid for cache web storage */\n    cacheKeyPrefix: \"logs-\",\n\n    /** the relative url to post messages to */\n    postUrl: \"/api/metrics\",\n    /** delay before trying post again after two failures */\n    delayPostInMs: 1000 * 60 * 10,\n\n    /** an (optional) function that should return an object; used to send additional data with the metrics */\n    getPingData: undefined,\n    /** an (optional) function that will handle the servers response after successfully posting messages */\n    onServerResponse: undefined\n};\n\n//----------------------------------------------------------------------------- set up\n/** initialize the logger with options, set up instance vars and cache, and add onpageunload to window */\nMetricsLogger.prototype._init = function _init(options) {\n    var self = this;\n    self.options = {};\n    for (var k in MetricsLogger.defaultOptions) {\n        if (MetricsLogger.defaultOptions.hasOwnProperty(k)) {\n            self.options[k] = options.hasOwnProperty(k)\n                ? options[k]\n                : MetricsLogger.defaultOptions[k];\n        }\n    }\n    self.options.logLevel = self._parseLevel(self.options.logLevel);\n    self.options.consoleLevel = self._parseLevel(self.options.consoleLevel);\n    //self._emitToConsole( 'debug', 'MetricsLogger', 'MetricsLogger.options:', self.options );\n\n    /** is the logger currently sending? */\n    self._sending = false;\n    /** the setTimeout id if the logger POST has failed more than once */\n    self._waiting = null;\n    /** the current number of entries to send in a POST */\n    self._postSize = self.options.postSize;\n\n    self._initCache();\n\n    return self;\n};\n\n/** initialize the cache */\nMetricsLogger.prototype._initCache = function _initCache() {\n    try {\n        this.cache = new LoggingCache({\n            maxSize: this.options.maxCacheSize,\n            key: this.options.cacheKeyPrefix + this.userId\n        });\n    } catch (err) {\n        this._emitToConsole(\"warn\", \"MetricsLogger\", [\n            \"Could not intitialize logging cache:\",\n            err\n        ]);\n        this.options.logLevel = MetricsLogger.NONE;\n    }\n};\n\n/** return the numeric log level if level in 'none, debug, log, info, warn, error' */\nMetricsLogger.prototype._parseLevel = function _parseLevel(level) {\n    var type = typeof level;\n    if (type === \"number\") {\n        return level;\n    }\n    if (type === \"string\") {\n        var upper = level.toUpperCase();\n        if (MetricsLogger.hasOwnProperty(upper)) {\n            return MetricsLogger[upper];\n        }\n    }\n    throw new Error(`Unknown log level: ${level}`);\n};\n\n//----------------------------------------------------------------------------- main entry point\n/** record a log/message's arguments to the cache and/or the console based on level and namespace */\nMetricsLogger.prototype.emit = function emit(level, namespace, logArguments) {\n    //this._emitToConsole( 'debug', 'MetricsLogger', [ 'emit:', level, namespace, logArguments ]);\n    var self = this;\n    namespace = namespace || self.options.defaultNamespace;\n    if (!level || !logArguments) {\n        return self;\n    }\n    // add to cache if proper level\n    //TODO: respect do not track?\n    //if( !navigator.doNotTrack && level >= self.options.logLevel ){\n    level = self._parseLevel(level);\n    if (level >= self.options.logLevel) {\n        self._addToCache(level, namespace, logArguments);\n    }\n    // also emit to consoleLogger if proper level for that\n    if (self.consoleLogger && level >= self.options.consoleLevel) {\n        self._emitToConsole(level, namespace, logArguments);\n    }\n    return self;\n};\n\n//----------------------------------------------------------------------------- cache\n/** add a message to the cache and if messages.length is high enough post them to the server */\nMetricsLogger.prototype._addToCache = function _addToCache(\n    level,\n    namespace,\n    logArguments\n) {\n    this._emitToConsole(\"debug\", \"MetricsLogger\", [\n        \"_addToCache:\",\n        arguments,\n        this.options.addTime,\n        this.cache.length()\n    ]);\n    //this._emitToConsole( 'debug', 'MetricsLogger', [ '\\t logArguments:', logArguments ]);\n    var self = this;\n    // try add to the cache and if we've got _postSize number of entries, attempt to post them to the server\n    try {\n        var newLength = self.cache.add(\n            self._buildEntry(level, namespace, logArguments)\n        );\n        if (newLength >= self._postSize) {\n            self._postCache();\n        }\n        // discard entry if an error occurs, but warn if level set to do so\n    } catch (err) {\n        self._emitToConsole(\"warn\", \"MetricsLogger\", [\n            \"Metrics logger could not stringify logArguments:\",\n            namespace,\n            logArguments\n        ]);\n        self._emitToConsole(\"error\", \"MetricsLogger\", [err]);\n    }\n    return self;\n};\n\n/** build a log cache entry object from the given level, namespace, and arguments (optionally adding timestamp */\nMetricsLogger.prototype._buildEntry = function _buildEntry(\n    level,\n    namespace,\n    logArguments\n) {\n    this._emitToConsole(\"debug\", \"MetricsLogger\", [\"_buildEntry:\", arguments]);\n    var entry = {\n        level: level,\n        namespace: this.options.clientPrefix + namespace,\n        args: logArguments\n    };\n    if (this.options.addTime) {\n        entry.time = new Date().toISOString();\n    }\n    return entry;\n};\n\n/** post _postSize messages from the cache to the server, removing them if successful\n *      if the post fails, wait until maxCacheSize is accumulated instead and try again then\n *      in addition to the messages from the cache ('metrics'), any info from getPingData (if set) will be sent\n *      onServerResponse will be called (if set) with any response from the server\n */\nMetricsLogger.prototype._postCache = function _postCache(options) {\n    options = options || {};\n    this._emitToConsole(\"info\", \"MetricsLogger\", [\n        \"_postCache\",\n        options,\n        this._postSize\n    ]);\n\n    // short circuit if we're already sending\n    if (!this.options.postUrl || this._sending) {\n        return jQuery.when({});\n    }\n\n    var self = this;\n    var postSize = options.count || self._postSize;\n\n    var // do not splice - remove after *successful* post\n    entries = self.cache.get(postSize);\n\n    var entriesLength = entries.length;\n\n    var // use the optional getPingData to add any extra info we may want to send\n    postData =\n        typeof self.options.getPingData === \"function\"\n            ? self.options.getPingData()\n            : {};\n\n    //console.debug( postSize, entriesLength );\n\n    // add the metrics and send\n    postData.metrics = JSON.stringify(entries);\n    //console.debug( postData.metrics );\n    self._sending = true;\n    return jQuery\n        .post(self.options.postUrl, postData)\n        .always(() => {\n            self._sending = false;\n        })\n        .fail((xhr, status, message) => {\n            // if we failed the previous time, set the next post target to the max num of entries\n            self._postSize = self.options.maxCacheSize;\n            //TODO:??\n            // log this failure to explain any gap in metrics\n            self.emit(\"error\", \"MetricsLogger\", [\n                \"_postCache error:\",\n                xhr.readyState,\n                xhr.status,\n                xhr.responseJSON || xhr.responseText\n            ]);\n            //TODO: still doesn't solve the problem that when cache == max, post will be tried on every emit\n            //TODO: see _delayPost\n        })\n        .done(response => {\n            if (typeof self.options.onServerResponse === \"function\") {\n                self.options.onServerResponse(response);\n            }\n            // only remove if post successful\n            self.cache.remove(entriesLength);\n            //console.debug( 'removed entries:', entriesLength, 'size now:', self.cache.length() );\n            // if we succeeded, reset the post target to the normal num of entries\n            self._postSize = self.options.postSize;\n        });\n    // return the xhr promise\n};\n\n/** set _waiting to true and, after delayPostInMs, set it back to false */\nMetricsLogger.prototype._delayPost = function _delayPost() {\n    //TODO: this won't work between pages\n    var self = this;\n    self._waiting = setTimeout(() => {\n        self._waiting = null;\n    }, self.options.delayPostInMs);\n};\n\n//----------------------------------------------------------------------------- console\n/** output message to console based on level and consoleLogger type */\nMetricsLogger.prototype._emitToConsole = function _emitToConsole(\n    level,\n    namespace,\n    logArguments\n) {\n    //console.debug( '_emitToConsole:', level, namespace, logArguments );\n    var self = this;\n\n    var whitelist = self.options.consoleNamespaceWhitelist;\n    if (!self.consoleLogger) {\n        return self;\n    }\n    // if a whitelist for namespaces is set, bail if this namespace is not in the list\n    if (whitelist && whitelist.indexOf(namespace) === -1) {\n        return self;\n    }\n\n    var args = Array.prototype.slice.call(logArguments, 0);\n    args.unshift(namespace);\n    //TODO: script location and/or source maps?\n    //TODO: branch on navigator.userAgent == AIIEEE - it only has log\n    if (\n        level >= MetricsLogger.METRIC &&\n        typeof self.consoleLogger.info === \"function\"\n    ) {\n        return self.consoleLogger.info.apply(self.consoleLogger, args);\n    } else if (\n        level >= MetricsLogger.ERROR &&\n        typeof self.consoleLogger.error === \"function\"\n    ) {\n        return self.consoleLogger.error.apply(self.consoleLogger, args);\n    } else if (\n        level >= MetricsLogger.WARN &&\n        typeof self.consoleLogger.warn === \"function\"\n    ) {\n        self.consoleLogger.warn.apply(self.consoleLogger, args);\n    } else if (\n        level >= MetricsLogger.INFO &&\n        typeof self.consoleLogger.info === \"function\"\n    ) {\n        self.consoleLogger.info.apply(self.consoleLogger, args);\n    } else if (\n        level >= MetricsLogger.DEBUG &&\n        typeof self.consoleLogger.debug === \"function\"\n    ) {\n        self.consoleLogger.debug.apply(self.consoleLogger, args);\n    } else if (typeof self.consoleLogger.log === \"function\") {\n        self.consoleLogger.log.apply(self.consoleLogger, args);\n    }\n    return self;\n};\n\n//----------------------------------------------------------------------------- shortcuts\n// generic functions when logging from non-namespaced object (e.g. templates)\n/** log to default namespace */\nMetricsLogger.prototype.log = function log() {\n    this.emit(\n        1,\n        this.options.defaultNamespace,\n        Array.prototype.slice.call(arguments, 0)\n    );\n};\n\n/** debug to default namespace */\nMetricsLogger.prototype.debug = function debug() {\n    this.emit(\n        MetricsLogger.DEBUG,\n        this.options.defaultNamespace,\n        Array.prototype.slice.call(arguments, 0)\n    );\n};\n\n/** info to default namespace */\nMetricsLogger.prototype.info = function info() {\n    this.emit(\n        MetricsLogger.INFO,\n        this.options.defaultNamespace,\n        Array.prototype.slice.call(arguments, 0)\n    );\n};\n\n/** warn to default namespace */\nMetricsLogger.prototype.warn = function warn() {\n    this.emit(\n        MetricsLogger.WARN,\n        this.options.defaultNamespace,\n        Array.prototype.slice.call(arguments, 0)\n    );\n};\n\n/** error to default namespace */\nMetricsLogger.prototype.error = function error() {\n    this.emit(\n        MetricsLogger.ERROR,\n        this.options.defaultNamespace,\n        Array.prototype.slice.call(arguments, 0)\n    );\n};\n\n/** metric to default namespace */\nMetricsLogger.prototype.metric = function metric() {\n    this.emit(\n        MetricsLogger.METRIC,\n        this.options.defaultNamespace,\n        Array.prototype.slice.call(arguments, 0)\n    );\n};\n\n/* ============================================================================\nTODO:\n    need a performance pass - the JSON un/parsing is a bit much\n\n============================================================================ */\n/** @class LoggingCache\n *  Simple implementation of cache wrapping an array.\n *\n *  Formats an entry before it's cached and only keeps options.maxSize number\n *  of entries. Older entries are deleted first.\n */\nfunction LoggingCache(options) {\n    var self = this;\n    return self._init(options || {});\n}\n\n/** default options */\nLoggingCache.defaultOptions = {\n    /** maximum number of entries to keep before discarding oldest */\n    maxSize: 5000\n};\n\n/** initialize with options */\nLoggingCache.prototype._init = function _init(options) {\n    if (!this._hasStorage()) {\n        //TODO: fall back to jstorage\n        throw new Error(\"LoggingCache needs localStorage\");\n    }\n    if (!options.key) {\n        throw new Error(\"LoggingCache needs key for localStorage\");\n    }\n    this.key = options.key;\n    this._initStorage();\n\n    this.maxSize = options.maxSize || LoggingCache.defaultOptions.maxSize;\n    return this;\n};\n\n/** tests for localStorage fns */\nLoggingCache.prototype._hasStorage = function _hasStorage() {\n    //TODO: modernizr\n    var test = \"test\";\n    try {\n        localStorage.setItem(test, test);\n        localStorage.removeItem(test);\n        return true;\n    } catch (e) {\n        return false;\n    }\n};\n\n/** if no localStorage set for key, initialize to empty array */\nLoggingCache.prototype._initStorage = function _initStorage() {\n    if (localStorage.getItem(this.key) === null) {\n        return this.empty();\n    }\n    return this;\n};\n\n/** add an entry to the cache, removing the oldest beforehand if size >= maxSize */\nLoggingCache.prototype.add = function add(entry) {\n    var self = this;\n    var _cache = self._fetchAndParse();\n    var overage = _cache.length + 1 - self.maxSize;\n    if (overage > 0) {\n        _cache.splice(0, overage);\n    }\n    _cache.push(entry);\n    self._unparseAndStore(_cache);\n    return _cache.length;\n};\n\n/** get the entries from localStorage and parse them */\nLoggingCache.prototype._fetchAndParse = function _fetchAndParse() {\n    var self = this;\n    return JSON.parse(localStorage.getItem(self.key));\n};\n\n/** stringify the entries and put them in localStorage */\nLoggingCache.prototype._unparseAndStore = function _unparseAndStore(entries) {\n    var self = this;\n    return localStorage.setItem(self.key, JSON.stringify(entries));\n};\n\n///** process the entry before caching */\n//LoggingCache.prototype._preprocessEntry = function _preprocessEntry( entry ){\n//    return JSON.stringify( entry );\n//};\n\n/** return the length --- oh, getters where are you? */\nLoggingCache.prototype.length = function length() {\n    return this._fetchAndParse().length;\n};\n\n/** get count number of entries starting with the oldest */\nLoggingCache.prototype.get = function get(count) {\n    return this._fetchAndParse().slice(0, count);\n};\n\n/** remove count number of entries starting with the oldest */\nLoggingCache.prototype.remove = function remove(count) {\n    var _cache = this._fetchAndParse();\n    var removed = _cache.splice(0, count);\n    this._unparseAndStore(_cache);\n    return removed;\n};\n\n/** empty/clear the entire cache */\nLoggingCache.prototype.empty = function empty() {\n    localStorage.setItem(this.key, \"[]\");\n    return this;\n};\n\n/** stringify count number of entries (but do not remove) */\nLoggingCache.prototype.stringify = function stringify(count) {\n    return JSON.stringify(this.get(count));\n};\n\n/** outputs entire cache to console */\nLoggingCache.prototype.print = function print() {\n    // popup? (really, carl? a popup?) - easier to copy/paste\n    console.log(JSON.stringify(this._fetchAndParse(), null, \"  \"));\n};\n\n//=============================================================================\nexport default {\n    MetricsLogger: MetricsLogger,\n    LoggingCache: LoggingCache\n};\n"]}