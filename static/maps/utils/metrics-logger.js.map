{"version":3,"sources":["utils/metrics-logger.js"],"names":["MetricsLogger","options","self","this","userId","window","bootstrapped","user","id","consoleLogger","LoggingCache","_init","ALL","LOG","INFO","ERROR","METRIC","NONE","consoleLevel","defaultOptions","logLevel","maxCacheSize","postSize","addTime","cacheKeyPrefix","postUrl","delayPostInMs","undefined","getPingData","hasOwnProperty","k","onServerResponse","_parseLevel","_waiting","_initCache","_postSize","maxSize","key","err","_emitToConsole","prototype","level","type","_typeof","upper","Error","emit","logArguments","namespace","defaultNamespace","_addToCache","arguments","cache","length","add","_postCache","entry","clientPrefix","_buildEntry","time","Date","toISOString","entriesLength","postData","_sending","jQuery","post","count","entries","get","response","metrics","JSON","stringify","always","_delayPost","xhr","readyState","status","responseJSON","responseText","done","remove","args","call","warn","consoleNamespaceWhitelist","debug","Array","slice","info","apply","error","WARN","DEBUG","log","empty","overage","_cache","splice","removed","_initStorage","_hasStorage","localStorage","e","getItem","_fetchAndParse","push","_unparseAndStore","parse","setItem","print","console"],"mappings":"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","file":"../../scripts/utils/metrics-logger.js","sourcesContent":["/*global window, jQuery, console */\n/*=============================================================================\nTODO:\n    while anon: logs saved to 'logs-null' - this will never post\n        unless we manually do so at/after login\n        OR prepend when userId and localStorage has 'logs-null'\n    wire up _delayPost and test\n\n=============================================================================*/\n/** @class MetricsLogger\n *\n *  Object to cache, output, and post log/metric messages to the server.\n *  Meant to be attached to the Galaxy object.\n *\n *  Log from objects by either attaching logger directly:\n *      panel.logger.metric( 'user dataset deletion', panel.user.id, hda.toJSON() )\n *  or using the LoggableMixin or addLogging function:\n *      MyBackboneModel.extend( LoggableMixin ).extend({ ... })\n *      addLogging( MyBackboneModel, 'my-backbone-model' )\n *\n *  Log from templates by calling directly from Galaxy object:\n *      Galaxy.logger.metric( 'template loaded', { ownedByUser : true });\n *\n *  If you attempt to log an un-serializable object (circular reference, window, etc.),\n *  that entry will not be cached (or sent). If you set consoleLevel and consoleLogger\n *  appropriately, a warning will be shown when this happens:\n *      > panel.metric( 'something weird with window', { window : window })\n *      !'Metrics logger could not stringify logArguments: ...'\n */\nfunction MetricsLogger(options) {\n    options = options || {};\n    var self = this;\n\n    ///** get the current user's id from bootstrapped data or options */\n    self.userId =\n        window.bootstrapped && window.bootstrapped.user\n            ? window.bootstrapped.user.id\n            : null;\n    self.userId = self.userId || options.userId || null;\n\n    /** the (optional) console to emit logs to */\n    self.consoleLogger = options.consoleLogger || null;\n\n    self._init(options);\n    return self;\n}\n\n//----------------------------------------------------------------------------- defaults and constants\n// see: python std lib, logging\nMetricsLogger.ALL = 0;\nMetricsLogger.LOG = 0;\nMetricsLogger.DEBUG = 10;\nMetricsLogger.INFO = 20;\nMetricsLogger.WARN = 30;\nMetricsLogger.ERROR = 40;\n// metrics levels here?\n//MetricsLogger.MinorEvent  = 45;\n//MetricsLogger.MajorEvent  = 50;\nMetricsLogger.METRIC = 50;\nMetricsLogger.NONE = 100;\n\n/** default options - override these through the constructor */\nMetricsLogger.defaultOptions = {\n    /** if an incoming message has a level >= this, it will be cached - can also be a string (e.g. 'debug') */\n    logLevel: MetricsLogger.NONE,\n    /** if an incoming message has a level >= this, it will be output to the console */\n    consoleLevel: MetricsLogger.NONE,\n    /** the default 'namespace' or label associated with an incoming message (if none is passed) */\n    defaultNamespace: \"Galaxy\",\n    /** the namespaces output to the console (all namespaces will be output if this is falsy)\n     *  note: applies only to the console (not the event/metrics log/cache)\n     */\n    consoleNamespaceWhitelist: null,\n    /** the prefix attached to client-side logs to distinguish them in the metrics db */\n    clientPrefix: \"client.\",\n\n    /** the maximum number of messages the cache should hold; if exceeded older messages are removed first */\n    maxCacheSize: 3000,\n    /** the number of messages accumulate before posting to the server; should be <= maxCacheSize */\n    postSize: 1000,\n    /** T/F whether to add a timestamp to incoming cached messages */\n    addTime: true,\n    /** string to prefix to userid for cache web storage */\n    cacheKeyPrefix: \"logs-\",\n\n    /** the relative url to post messages to */\n    postUrl: \"/api/metrics\",\n    /** delay before trying post again after two failures */\n    delayPostInMs: 1000 * 60 * 10,\n\n    /** an (optional) function that should return an object; used to send additional data with the metrics */\n    getPingData: undefined,\n    /** an (optional) function that will handle the servers response after successfully posting messages */\n    onServerResponse: undefined\n};\n\n//----------------------------------------------------------------------------- set up\n/** initialize the logger with options, set up instance vars and cache, and add onpageunload to window */\nMetricsLogger.prototype._init = function _init(options) {\n    var self = this;\n    self.options = {};\n    for (var k in MetricsLogger.defaultOptions) {\n        if (MetricsLogger.defaultOptions.hasOwnProperty(k)) {\n            self.options[k] = options.hasOwnProperty(k)\n                ? options[k]\n                : MetricsLogger.defaultOptions[k];\n        }\n    }\n    self.options.logLevel = self._parseLevel(self.options.logLevel);\n    self.options.consoleLevel = self._parseLevel(self.options.consoleLevel);\n    //self._emitToConsole( 'debug', 'MetricsLogger', 'MetricsLogger.options:', self.options );\n\n    /** is the logger currently sending? */\n    self._sending = false;\n    /** the setTimeout id if the logger POST has failed more than once */\n    self._waiting = null;\n    /** the current number of entries to send in a POST */\n    self._postSize = self.options.postSize;\n\n    self._initCache();\n\n    return self;\n};\n\n/** initialize the cache */\nMetricsLogger.prototype._initCache = function _initCache() {\n    try {\n        this.cache = new LoggingCache({\n            maxSize: this.options.maxCacheSize,\n            key: this.options.cacheKeyPrefix + this.userId\n        });\n    } catch (err) {\n        this._emitToConsole(\"warn\", \"MetricsLogger\", [\n            \"Could not intitialize logging cache:\",\n            err\n        ]);\n        this.options.logLevel = MetricsLogger.NONE;\n    }\n};\n\n/** return the numeric log level if level in 'none, debug, log, info, warn, error' */\nMetricsLogger.prototype._parseLevel = function _parseLevel(level) {\n    var type = typeof level;\n    if (type === \"number\") {\n        return level;\n    }\n    if (type === \"string\") {\n        var upper = level.toUpperCase();\n        if (MetricsLogger.hasOwnProperty(upper)) {\n            return MetricsLogger[upper];\n        }\n    }\n    throw new Error(\"Unknown log level: \" + level);\n};\n\n//----------------------------------------------------------------------------- main entry point\n/** record a log/message's arguments to the cache and/or the console based on level and namespace */\nMetricsLogger.prototype.emit = function emit(level, namespace, logArguments) {\n    //this._emitToConsole( 'debug', 'MetricsLogger', [ 'emit:', level, namespace, logArguments ]);\n    var self = this;\n    namespace = namespace || self.options.defaultNamespace;\n    if (!level || !logArguments) {\n        return self;\n    }\n    // add to cache if proper level\n    //TODO: respect do not track?\n    //if( !navigator.doNotTrack && level >= self.options.logLevel ){\n    level = self._parseLevel(level);\n    if (level >= self.options.logLevel) {\n        self._addToCache(level, namespace, logArguments);\n    }\n    // also emit to consoleLogger if proper level for that\n    if (self.consoleLogger && level >= self.options.consoleLevel) {\n        self._emitToConsole(level, namespace, logArguments);\n    }\n    return self;\n};\n\n//----------------------------------------------------------------------------- cache\n/** add a message to the cache and if messages.length is high enough post them to the server */\nMetricsLogger.prototype._addToCache = function _addToCache(\n    level,\n    namespace,\n    logArguments\n) {\n    this._emitToConsole(\"debug\", \"MetricsLogger\", [\n        \"_addToCache:\",\n        arguments,\n        this.options.addTime,\n        this.cache.length()\n    ]);\n    //this._emitToConsole( 'debug', 'MetricsLogger', [ '\\t logArguments:', logArguments ]);\n    var self = this;\n    // try add to the cache and if we've got _postSize number of entries, attempt to post them to the server\n    try {\n        var newLength = self.cache.add(\n            self._buildEntry(level, namespace, logArguments)\n        );\n        if (newLength >= self._postSize) {\n            self._postCache();\n        }\n        // discard entry if an error occurs, but warn if level set to do so\n    } catch (err) {\n        self._emitToConsole(\"warn\", \"MetricsLogger\", [\n            \"Metrics logger could not stringify logArguments:\",\n            namespace,\n            logArguments\n        ]);\n        self._emitToConsole(\"error\", \"MetricsLogger\", [err]);\n    }\n    return self;\n};\n\n/** build a log cache entry object from the given level, namespace, and arguments (optionally adding timestamp */\nMetricsLogger.prototype._buildEntry = function _buildEntry(\n    level,\n    namespace,\n    logArguments\n) {\n    this._emitToConsole(\"debug\", \"MetricsLogger\", [\"_buildEntry:\", arguments]);\n    var entry = {\n        level: level,\n        namespace: this.options.clientPrefix + namespace,\n        args: logArguments\n    };\n    if (this.options.addTime) {\n        entry.time = new Date().toISOString();\n    }\n    return entry;\n};\n\n/** post _postSize messages from the cache to the server, removing them if successful\n *      if the post fails, wait until maxCacheSize is accumulated instead and try again then\n *      in addition to the messages from the cache ('metrics'), any info from getPingData (if set) will be sent\n *      onServerResponse will be called (if set) with any response from the server\n */\nMetricsLogger.prototype._postCache = function _postCache(options) {\n    options = options || {};\n    this._emitToConsole(\"info\", \"MetricsLogger\", [\n        \"_postCache\",\n        options,\n        this._postSize\n    ]);\n\n    // short circuit if we're already sending\n    if (!this.options.postUrl || this._sending) {\n        return jQuery.when({});\n    }\n\n    var self = this,\n        postSize = options.count || self._postSize,\n        // do not splice - remove after *successful* post\n        entries = self.cache.get(postSize),\n        entriesLength = entries.length,\n        // use the optional getPingData to add any extra info we may want to send\n        postData =\n            typeof self.options.getPingData === \"function\"\n                ? self.options.getPingData()\n                : {};\n    //console.debug( postSize, entriesLength );\n\n    // add the metrics and send\n    postData.metrics = JSON.stringify(entries);\n    //console.debug( postData.metrics );\n    self._sending = true;\n    return jQuery\n        .post(self.options.postUrl, postData)\n        .always(function() {\n            self._sending = false;\n        })\n        .fail(function(xhr, status, message) {\n            // if we failed the previous time, set the next post target to the max num of entries\n            self._postSize = self.options.maxCacheSize;\n            //TODO:??\n            // log this failure to explain any gap in metrics\n            self.emit(\"error\", \"MetricsLogger\", [\n                \"_postCache error:\",\n                xhr.readyState,\n                xhr.status,\n                xhr.responseJSON || xhr.responseText\n            ]);\n            //TODO: still doesn't solve the problem that when cache == max, post will be tried on every emit\n            //TODO: see _delayPost\n        })\n        .done(function(response) {\n            if (typeof self.options.onServerResponse === \"function\") {\n                self.options.onServerResponse(response);\n            }\n            // only remove if post successful\n            self.cache.remove(entriesLength);\n            //console.debug( 'removed entries:', entriesLength, 'size now:', self.cache.length() );\n            // if we succeeded, reset the post target to the normal num of entries\n            self._postSize = self.options.postSize;\n        });\n    // return the xhr promise\n};\n\n/** set _waiting to true and, after delayPostInMs, set it back to false */\nMetricsLogger.prototype._delayPost = function _delayPost() {\n    //TODO: this won't work between pages\n    var self = this;\n    self._waiting = setTimeout(function() {\n        self._waiting = null;\n    }, self.options.delayPostInMs);\n};\n\n//----------------------------------------------------------------------------- console\n/** output message to console based on level and consoleLogger type */\nMetricsLogger.prototype._emitToConsole = function _emitToConsole(\n    level,\n    namespace,\n    logArguments\n) {\n    //console.debug( '_emitToConsole:', level, namespace, logArguments );\n    var self = this,\n        whitelist = self.options.consoleNamespaceWhitelist;\n    if (!self.consoleLogger) {\n        return self;\n    }\n    // if a whitelist for namespaces is set, bail if this namespace is not in the list\n    if (whitelist && whitelist.indexOf(namespace) === -1) {\n        return self;\n    }\n\n    var args = Array.prototype.slice.call(logArguments, 0);\n    args.unshift(namespace);\n    //TODO: script location and/or source maps?\n    //TODO: branch on navigator.userAgent == AIIEEE - it only has log\n    if (\n        level >= MetricsLogger.METRIC &&\n        typeof self.consoleLogger.info === \"function\"\n    ) {\n        return self.consoleLogger.info.apply(self.consoleLogger, args);\n    } else if (\n        level >= MetricsLogger.ERROR &&\n        typeof self.consoleLogger.error === \"function\"\n    ) {\n        return self.consoleLogger.error.apply(self.consoleLogger, args);\n    } else if (\n        level >= MetricsLogger.WARN &&\n        typeof self.consoleLogger.warn === \"function\"\n    ) {\n        self.consoleLogger.warn.apply(self.consoleLogger, args);\n    } else if (\n        level >= MetricsLogger.INFO &&\n        typeof self.consoleLogger.info === \"function\"\n    ) {\n        self.consoleLogger.info.apply(self.consoleLogger, args);\n    } else if (\n        level >= MetricsLogger.DEBUG &&\n        typeof self.consoleLogger.debug === \"function\"\n    ) {\n        self.consoleLogger.debug.apply(self.consoleLogger, args);\n    } else if (typeof self.consoleLogger.log === \"function\") {\n        self.consoleLogger.log.apply(self.consoleLogger, args);\n    }\n    return self;\n};\n\n//----------------------------------------------------------------------------- shortcuts\n// generic functions when logging from non-namespaced object (e.g. templates)\n/** log to default namespace */\nMetricsLogger.prototype.log = function log() {\n    this.emit(\n        1,\n        this.options.defaultNamespace,\n        Array.prototype.slice.call(arguments, 0)\n    );\n};\n\n/** debug to default namespace */\nMetricsLogger.prototype.debug = function debug() {\n    this.emit(\n        MetricsLogger.DEBUG,\n        this.options.defaultNamespace,\n        Array.prototype.slice.call(arguments, 0)\n    );\n};\n\n/** info to default namespace */\nMetricsLogger.prototype.info = function info() {\n    this.emit(\n        MetricsLogger.INFO,\n        this.options.defaultNamespace,\n        Array.prototype.slice.call(arguments, 0)\n    );\n};\n\n/** warn to default namespace */\nMetricsLogger.prototype.warn = function warn() {\n    this.emit(\n        MetricsLogger.WARN,\n        this.options.defaultNamespace,\n        Array.prototype.slice.call(arguments, 0)\n    );\n};\n\n/** error to default namespace */\nMetricsLogger.prototype.error = function error() {\n    this.emit(\n        MetricsLogger.ERROR,\n        this.options.defaultNamespace,\n        Array.prototype.slice.call(arguments, 0)\n    );\n};\n\n/** metric to default namespace */\nMetricsLogger.prototype.metric = function metric() {\n    this.emit(\n        MetricsLogger.METRIC,\n        this.options.defaultNamespace,\n        Array.prototype.slice.call(arguments, 0)\n    );\n};\n\n/* ============================================================================\nTODO:\n    need a performance pass - the JSON un/parsing is a bit much\n\n============================================================================ */\n/** @class LoggingCache\n *  Simple implementation of cache wrapping an array.\n *\n *  Formats an entry before it's cached and only keeps options.maxSize number\n *  of entries. Older entries are deleted first.\n */\nfunction LoggingCache(options) {\n    var self = this;\n    return self._init(options || {});\n}\n\n/** default options */\nLoggingCache.defaultOptions = {\n    /** maximum number of entries to keep before discarding oldest */\n    maxSize: 5000\n};\n\n/** initialize with options */\nLoggingCache.prototype._init = function _init(options) {\n    if (!this._hasStorage()) {\n        //TODO: fall back to jstorage\n        throw new Error(\"LoggingCache needs localStorage\");\n    }\n    if (!options.key) {\n        throw new Error(\"LoggingCache needs key for localStorage\");\n    }\n    this.key = options.key;\n    this._initStorage();\n\n    this.maxSize = options.maxSize || LoggingCache.defaultOptions.maxSize;\n    return this;\n};\n\n/** tests for localStorage fns */\nLoggingCache.prototype._hasStorage = function _hasStorage() {\n    //TODO: modernizr\n    var test = \"test\";\n    try {\n        localStorage.setItem(test, test);\n        localStorage.removeItem(test);\n        return true;\n    } catch (e) {\n        return false;\n    }\n};\n\n/** if no localStorage set for key, initialize to empty array */\nLoggingCache.prototype._initStorage = function _initStorage() {\n    if (localStorage.getItem(this.key) === null) {\n        return this.empty();\n    }\n    return this;\n};\n\n/** add an entry to the cache, removing the oldest beforehand if size >= maxSize */\nLoggingCache.prototype.add = function add(entry) {\n    var self = this,\n        _cache = self._fetchAndParse(),\n        overage = _cache.length + 1 - self.maxSize;\n    if (overage > 0) {\n        _cache.splice(0, overage);\n    }\n    _cache.push(entry);\n    self._unparseAndStore(_cache);\n    return _cache.length;\n};\n\n/** get the entries from localStorage and parse them */\nLoggingCache.prototype._fetchAndParse = function _fetchAndParse() {\n    var self = this;\n    return JSON.parse(localStorage.getItem(self.key));\n};\n\n/** stringify the entries and put them in localStorage */\nLoggingCache.prototype._unparseAndStore = function _unparseAndStore(entries) {\n    var self = this;\n    return localStorage.setItem(self.key, JSON.stringify(entries));\n};\n\n///** process the entry before caching */\n//LoggingCache.prototype._preprocessEntry = function _preprocessEntry( entry ){\n//    return JSON.stringify( entry );\n//};\n\n/** return the length --- oh, getters where are you? */\nLoggingCache.prototype.length = function length() {\n    return this._fetchAndParse().length;\n};\n\n/** get count number of entries starting with the oldest */\nLoggingCache.prototype.get = function get(count) {\n    return this._fetchAndParse().slice(0, count);\n};\n\n/** remove count number of entries starting with the oldest */\nLoggingCache.prototype.remove = function remove(count) {\n    var _cache = this._fetchAndParse(),\n        removed = _cache.splice(0, count);\n    this._unparseAndStore(_cache);\n    return removed;\n};\n\n/** empty/clear the entire cache */\nLoggingCache.prototype.empty = function empty() {\n    localStorage.setItem(this.key, \"[]\");\n    return this;\n};\n\n/** stringify count number of entries (but do not remove) */\nLoggingCache.prototype.stringify = function stringify(count) {\n    return JSON.stringify(this.get(count));\n};\n\n/** outputs entire cache to console */\nLoggingCache.prototype.print = function print() {\n    // popup? (really, carl? a popup?) - easier to copy/paste\n    console.log(JSON.stringify(this._fetchAndParse(), null, \"  \"));\n};\n\n//=============================================================================\nexport default {\n    MetricsLogger: MetricsLogger,\n    LoggingCache: LoggingCache\n};\n"]}