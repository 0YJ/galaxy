{"version":3,"sources":["utils/metrics-logger.js"],"names":["define","MetricsLogger","options","self","this","userId","window","bootstrapped","user","id","consoleLogger","_init","maxSize","ALL","LOG","DEBUG","METRIC","NONE","logLevel","consoleLevel","defaultNamespace","consoleNamespaceWhitelist","clientPrefix","postSize","addTime","cacheKeyPrefix","delayPostInMs","undefined","onServerResponse","prototype","defaultOptions","hasOwnProperty","k","_parseLevel","_sending","_waiting","_postSize","_initCache","cache","LoggingCache","key","level","type","_typeof","upper","Error","emit","namespace","logArguments","_addToCache","_emitToConsole","arguments","length","add","_buildEntry","_postCache","err","entry","time","toISOString","postUrl","jQuery","count","entries","get","entriesLength","postData","getPingData","metrics","JSON","stringify","always","xhr","status","message","maxCacheSize","responseJSON","responseText","done","response","remove","_delayPost","whitelist","indexOf","args","Array","slice","call","unshift","info","apply","error","warn","INFO","debug","log","ERROR","metric","_initStorage","localStorage","_hasStorage","setItem","e","getItem","_cache","_unparseAndStore","_fetchAndParse","overage","push","parse","removed","splice","empty","console"],"mappings":"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","file":"../../scripts/utils/metrics-logger.js","sourcesContent":["define([\n], function(){\n/*global window, jQuery, console */\n/*=============================================================================\nTODO:\n    while anon: logs saved to 'logs-null' - this will never post\n        unless we manually do so at/after login\n        OR prepend when userId and localStorage has 'logs-null'\n    wire up _delayPost and test\n\n=============================================================================*/\n/** @class MetricsLogger\n *\n *  Object to cache, output, and post log/metric messages to the server.\n *  Meant to be attached to the Galaxy object.\n *\n *  Log from objects by either attaching logger directly:\n *      panel.logger.metric( 'user dataset deletion', panel.user.id, hda.toJSON() )\n *  or using the LoggableMixin or addLogging function:\n *      MyBackboneModel.extend( LoggableMixin ).extend({ ... })\n *      addLogging( MyBackboneModel, 'my-backbone-model' )\n *\n *  Log from templates by calling directly from Galaxy object:\n *      Galaxy.logger.metric( 'template loaded', { ownedByUser : true });\n *\n *  If you attempt to log an un-serializable object (circular reference, window, etc.),\n *  that entry will not be cached (or sent). If you set consoleLevel and consoleLogger\n *  appropriately, a warning will be shown when this happens:\n *      > panel.metric( 'something weird with window', { window : window })\n *      !'Metrics logger could not stringify logArguments: ...'\n */\nfunction MetricsLogger( options ){\n    options = options || {};\n    var self = this;\n\n    ///** get the current user's id from bootstrapped data or options */\n    self.userId = ( window.bootstrapped && window.bootstrapped.user )? window.bootstrapped.user.id: null;\n    self.userId = self.userId || options.userId || null;\n\n    /** the (optional) console to emit logs to */\n    self.consoleLogger = options.consoleLogger || null;\n\n    self._init( options );\n    return self;\n}\n\n//----------------------------------------------------------------------------- defaults and constants\n// see: python std lib, logging\nMetricsLogger.ALL   =  0;\nMetricsLogger.LOG   =  0;\nMetricsLogger.DEBUG = 10;\nMetricsLogger.INFO  = 20;\nMetricsLogger.WARN  = 30;\nMetricsLogger.ERROR = 40;\n// metrics levels here?\n//MetricsLogger.MinorEvent  = 45;\n//MetricsLogger.MajorEvent  = 50;\nMetricsLogger.METRIC = 50;\nMetricsLogger.NONE = 100;\n\n/** default options - override these through the constructor */\nMetricsLogger.defaultOptions = {\n    /** if an incoming message has a level >= this, it will be cached - can also be a string (e.g. 'debug') */\n    logLevel            : MetricsLogger.NONE,\n    /** if an incoming message has a level >= this, it will be output to the console */\n    consoleLevel        : MetricsLogger.NONE,\n    /** the default 'namespace' or label associated with an incoming message (if none is passed) */\n    defaultNamespace    : 'Galaxy',\n    /** the namespaces output to the console (all namespaces will be output if this is falsy)\n     *  note: applies only to the console (not the event/metrics log/cache)\n     */\n    consoleNamespaceWhitelist : null,\n    /** the prefix attached to client-side logs to distinguish them in the metrics db */\n    clientPrefix        : 'client.',\n\n    /** the maximum number of messages the cache should hold; if exceeded older messages are removed first */\n    maxCacheSize        : 3000,\n    /** the number of messages accumulate before posting to the server; should be <= maxCacheSize */\n    postSize            : 1000,\n    /** T/F whether to add a timestamp to incoming cached messages */\n    addTime             : true,\n    /** string to prefix to userid for cache web storage */\n    cacheKeyPrefix      : 'logs-',\n\n    /** the relative url to post messages to */\n    postUrl             : '/api/metrics',\n    /** delay before trying post again after two failures */\n    delayPostInMs       : 1000 * 60 * 10,\n\n    /** an (optional) function that should return an object; used to send additional data with the metrics */\n    getPingData         : undefined,\n    /** an (optional) function that will handle the servers response after successfully posting messages */\n    onServerResponse    : undefined\n};\n\n//----------------------------------------------------------------------------- set up\n/** initialize the logger with options, set up instance vars and cache, and add onpageunload to window */\nMetricsLogger.prototype._init = function _init( options ){\n    var self = this;\n    self.options = {};\n    for( var k in MetricsLogger.defaultOptions ){\n        if( MetricsLogger.defaultOptions.hasOwnProperty( k ) ){\n            self.options[ k ] = ( options.hasOwnProperty( k ) )?( options[ k ] ):( MetricsLogger.defaultOptions[ k ] );\n        }\n    }\n    self.options.logLevel = self._parseLevel( self.options.logLevel );\n    self.options.consoleLevel = self._parseLevel( self.options.consoleLevel );\n    //self._emitToConsole( 'debug', 'MetricsLogger', 'MetricsLogger.options:', self.options );\n\n    /** is the logger currently sending? */\n    self._sending = false;\n    /** the setTimeout id if the logger POST has failed more than once */\n    self._waiting = null;\n    /** the current number of entries to send in a POST */\n    self._postSize = self.options.postSize;\n\n    self._initCache();\n\n    return self;\n};\n\n/** initialize the cache */\nMetricsLogger.prototype._initCache = function _initCache(){\n    try {\n        this.cache = new LoggingCache({\n            maxSize : this.options.maxCacheSize,\n            key     : this.options.cacheKeyPrefix + this.userId\n        });\n    } catch( err ){\n        this._emitToConsole( 'warn', 'MetricsLogger', [ 'Could not intitialize logging cache:', err ] );\n        this.options.logLevel = MetricsLogger.NONE;\n    }\n};\n\n/** return the numeric log level if level in 'none, debug, log, info, warn, error' */\nMetricsLogger.prototype._parseLevel = function _parseLevel( level ){\n    var type = typeof level;\n    if( type === 'number' ){ return level; }\n    if( type === 'string' ){\n        var upper = level.toUpperCase();\n        if( MetricsLogger.hasOwnProperty( upper ) ){\n            return MetricsLogger[ upper ];\n        }\n    }\n    throw new Error( 'Unknown log level: ' + level );\n};\n\n\n//----------------------------------------------------------------------------- main entry point\n/** record a log/message's arguments to the cache and/or the console based on level and namespace */\nMetricsLogger.prototype.emit = function emit( level, namespace, logArguments ){\n    //this._emitToConsole( 'debug', 'MetricsLogger', [ 'emit:', level, namespace, logArguments ]);\n    var self = this;\n    namespace = namespace || self.options.defaultNamespace;\n    if( !level || !logArguments ){\n        return self;\n    }\n    // add to cache if proper level\n    //TODO: respect do not track?\n    //if( !navigator.doNotTrack && level >= self.options.logLevel ){\n    level = self._parseLevel( level );\n    if( level >= self.options.logLevel ){\n        self._addToCache( level, namespace, logArguments );\n    }\n    // also emit to consoleLogger if proper level for that\n    if( self.consoleLogger && level >= self.options.consoleLevel ){\n        self._emitToConsole( level, namespace, logArguments );\n    }\n    return self;\n};\n\n//----------------------------------------------------------------------------- cache\n/** add a message to the cache and if messages.length is high enough post them to the server */\nMetricsLogger.prototype._addToCache = function _addToCache( level, namespace, logArguments ){\n    this._emitToConsole( 'debug', 'MetricsLogger',\n        [ '_addToCache:', arguments, this.options.addTime, this.cache.length() ]);\n    //this._emitToConsole( 'debug', 'MetricsLogger', [ '\\t logArguments:', logArguments ]);\n    var self = this;\n    // try add to the cache and if we've got _postSize number of entries, attempt to post them to the server\n    try {\n        var newLength = self.cache.add( self._buildEntry( level, namespace, logArguments ) );\n        if( newLength >= self._postSize ){\n            self._postCache();\n        }\n    // discard entry if an error occurs, but warn if level set to do so\n    } catch( err ){\n        self._emitToConsole( 'warn', 'MetricsLogger',\n            [ 'Metrics logger could not stringify logArguments:', namespace, logArguments ] );\n        self._emitToConsole( 'error', 'MetricsLogger', [ err ] );\n\n    }\n    return self;\n};\n\n/** build a log cache entry object from the given level, namespace, and arguments (optionally adding timestamp */\nMetricsLogger.prototype._buildEntry = function _buildEntry( level, namespace, logArguments ){\n    this._emitToConsole( 'debug', 'MetricsLogger', [ '_buildEntry:', arguments ]);\n    var entry = {\n            level       : level,\n            namespace   : this.options.clientPrefix + namespace,\n            args        : logArguments\n        };\n    if( this.options.addTime ){\n        entry.time = new Date().toISOString();\n    }\n    return entry;\n};\n\n/** post _postSize messages from the cache to the server, removing them if successful\n *      if the post fails, wait until maxCacheSize is accumulated instead and try again then\n *      in addition to the messages from the cache ('metrics'), any info from getPingData (if set) will be sent\n *      onServerResponse will be called (if set) with any response from the server\n */\nMetricsLogger.prototype._postCache = function _postCache( options ){\n    options = options || {};\n    this._emitToConsole( 'info', 'MetricsLogger', [ '_postCache', options, this._postSize ]);\n\n    // short circuit if we're already sending\n    if( !this.options.postUrl || this._sending ){\n        return jQuery.when({});\n    }\n\n    var self = this,\n        postSize = options.count || self._postSize,\n        // do not splice - remove after *successful* post\n        entries = self.cache.get( postSize ),\n        entriesLength = entries.length,\n        // use the optional getPingData to add any extra info we may want to send\n        postData = ( typeof self.options.getPingData === 'function' )?( self.options.getPingData() ):( {} );\n    //console.debug( postSize, entriesLength );\n\n    // add the metrics and send\n    postData.metrics = JSON.stringify( entries );\n    //console.debug( postData.metrics );\n    self._sending = true;\n    return jQuery.post( self.options.postUrl, postData )\n        .always( function(){\n            self._sending = false;\n        })\n        .fail( function( xhr, status, message ){\n            // if we failed the previous time, set the next post target to the max num of entries\n            self._postSize = self.options.maxCacheSize;\n//TODO:??\n            // log this failure to explain any gap in metrics\n            self.emit( 'error', 'MetricsLogger', [ '_postCache error:',\n                xhr.readyState, xhr.status, xhr.responseJSON || xhr.responseText ]);\n//TODO: still doesn't solve the problem that when cache == max, post will be tried on every emit\n//TODO: see _delayPost\n        })\n        .done( function( response ){\n            if( typeof self.options.onServerResponse === 'function' ){\n                self.options.onServerResponse( response );\n            }\n            // only remove if post successful\n            self.cache.remove( entriesLength );\n            //console.debug( 'removed entries:', entriesLength, 'size now:', self.cache.length() );\n            // if we succeeded, reset the post target to the normal num of entries\n            self._postSize = self.options.postSize;\n        });\n    // return the xhr promise\n};\n\n/** set _waiting to true and, after delayPostInMs, set it back to false */\nMetricsLogger.prototype._delayPost = function _delayPost(){\n//TODO: this won't work between pages\n    var self = this;\n    self._waiting = setTimeout( function(){\n        self._waiting = null;\n    }, self.options.delayPostInMs );\n};\n\n\n//----------------------------------------------------------------------------- console\n/** output message to console based on level and consoleLogger type */\nMetricsLogger.prototype._emitToConsole = function _emitToConsole( level, namespace, logArguments ){\n    //console.debug( '_emitToConsole:', level, namespace, logArguments );\n    var self = this,\n        whitelist = self.options.consoleNamespaceWhitelist;\n    if( !self.consoleLogger ){ return self; }\n    // if a whitelist for namespaces is set, bail if this namespace is not in the list\n    if( whitelist && whitelist.indexOf( namespace ) === -1 ){\n        return self;\n    }\n\n    var args = Array.prototype.slice.call( logArguments, 0 );\n    args.unshift( namespace );\n//TODO: script location and/or source maps?\n//TODO: branch on navigator.userAgent == AIIEEE - it only has log\n    if(        level >= MetricsLogger.METRIC && typeof( self.consoleLogger.info ) === 'function' ){\n        return self.consoleLogger.info.apply( self.consoleLogger, args );\n\n    } else if( level >= MetricsLogger.ERROR && typeof( self.consoleLogger.error ) === 'function' ){\n        return self.consoleLogger.error.apply( self.consoleLogger, args );\n    } else if( level >= MetricsLogger.WARN && typeof( self.consoleLogger.warn ) === 'function' ){\n        self.consoleLogger.warn.apply( self.consoleLogger, args );\n    } else if( level >= MetricsLogger.INFO && typeof( self.consoleLogger.info ) === 'function' ){\n        self.consoleLogger.info.apply( self.consoleLogger, args );\n    } else if( level >= MetricsLogger.DEBUG && typeof( self.consoleLogger.debug ) === 'function' ){\n        self.consoleLogger.debug.apply( self.consoleLogger, args );\n    } else if( typeof( self.consoleLogger.log ) === 'function' ){\n        self.consoleLogger.log.apply( self.consoleLogger, args );\n    }\n    return self;\n};\n\n//----------------------------------------------------------------------------- shortcuts\n// generic functions when logging from non-namespaced object (e.g. templates)\n/** log to default namespace */\nMetricsLogger.prototype.log = function log(){\n    this.emit( 1, this.options.defaultNamespace,\n        Array.prototype.slice.call( arguments, 0 ) );\n};\n\n/** debug to default namespace */\nMetricsLogger.prototype.debug = function debug(){\n    this.emit( MetricsLogger.DEBUG, this.options.defaultNamespace,\n        Array.prototype.slice.call( arguments, 0 ) );\n};\n\n/** info to default namespace */\nMetricsLogger.prototype.info = function info(){\n    this.emit( MetricsLogger.INFO, this.options.defaultNamespace,\n        Array.prototype.slice.call( arguments, 0 ) );\n};\n\n/** warn to default namespace */\nMetricsLogger.prototype.warn = function warn(){\n    this.emit( MetricsLogger.WARN, this.options.defaultNamespace,\n        Array.prototype.slice.call( arguments, 0 ) );\n};\n\n/** error to default namespace */\nMetricsLogger.prototype.error = function error(){\n    this.emit( MetricsLogger.ERROR, this.options.defaultNamespace,\n        Array.prototype.slice.call( arguments, 0 ) );\n};\n\n/** metric to default namespace */\nMetricsLogger.prototype.metric = function metric(){\n    this.emit( MetricsLogger.METRIC, this.options.defaultNamespace,\n        Array.prototype.slice.call( arguments, 0 ) );\n};\n\n\n/* ============================================================================\nTODO:\n    need a performance pass - the JSON un/parsing is a bit much\n\n============================================================================ */\n/** @class LoggingCache\n *  Simple implementation of cache wrapping an array.\n *\n *  Formats an entry before it's cached and only keeps options.maxSize number\n *  of entries. Older entries are deleted first.\n */\nfunction LoggingCache( options ){\n    var self = this;\n    return self._init( options || {} );\n}\n\n/** default options */\nLoggingCache.defaultOptions = {\n    /** maximum number of entries to keep before discarding oldest */\n    maxSize     : 5000\n};\n\n/** initialize with options */\nLoggingCache.prototype._init = function _init( options ){\n    if( !this._hasStorage() ){\n        //TODO: fall back to jstorage\n        throw new Error( 'LoggingCache needs localStorage' );\n    }\n    if( !options.key ){\n        throw new Error( 'LoggingCache needs key for localStorage' );\n    }\n    this.key = options.key;\n    this._initStorage();\n\n    this.maxSize = options.maxSize || LoggingCache.defaultOptions.maxSize;\n    return this;\n};\n\n/** tests for localStorage fns */\nLoggingCache.prototype._hasStorage = function _hasStorage(){\n//TODO: modernizr\n    var test = 'test';\n    try {\n        localStorage.setItem( test, test );\n        localStorage.removeItem( test );\n        return true;\n    } catch( e ){\n        return false;\n    }\n};\n\n/** if no localStorage set for key, initialize to empty array */\nLoggingCache.prototype._initStorage = function _initStorage(){\n    if( localStorage.getItem( this.key ) === null ){\n        return this.empty();\n    }\n    return this;\n};\n\n/** add an entry to the cache, removing the oldest beforehand if size >= maxSize */\nLoggingCache.prototype.add = function add( entry ){\n    var self = this,\n        _cache = self._fetchAndParse(),\n        overage = ( _cache.length + 1 ) - self.maxSize;\n    if( overage > 0 ){\n        _cache.splice( 0, overage );\n    }\n    _cache.push( entry );\n    self._unparseAndStore( _cache );\n    return _cache.length;\n};\n\n/** get the entries from localStorage and parse them */\nLoggingCache.prototype._fetchAndParse = function _fetchAndParse(){\n    var self = this;\n    return JSON.parse( localStorage.getItem( self.key ) );\n};\n\n/** stringify the entries and put them in localStorage */\nLoggingCache.prototype._unparseAndStore = function _unparseAndStore( entries ){\n    var self = this;\n    return localStorage.setItem( self.key, JSON.stringify( entries ) );\n};\n\n///** process the entry before caching */\n//LoggingCache.prototype._preprocessEntry = function _preprocessEntry( entry ){\n//    return JSON.stringify( entry );\n//};\n\n/** return the length --- oh, getters where are you? */\nLoggingCache.prototype.length = function length(){\n    return this._fetchAndParse().length;\n};\n\n/** get count number of entries starting with the oldest */\nLoggingCache.prototype.get = function get( count ){\n    return this._fetchAndParse().slice( 0, count );\n};\n\n/** remove count number of entries starting with the oldest */\nLoggingCache.prototype.remove = function remove( count ){\n    var _cache = this._fetchAndParse(),\n        removed = _cache.splice( 0, count );\n    this._unparseAndStore( _cache );\n    return removed;\n};\n\n/** empty/clear the entire cache */\nLoggingCache.prototype.empty = function empty(){\n    localStorage.setItem( this.key, '[]' );\n    return this;\n};\n\n/** stringify count number of entries (but do not remove) */\nLoggingCache.prototype.stringify = function stringify( count ){\n    return JSON.stringify( this.get( count ) );\n};\n\n/** outputs entire cache to console */\nLoggingCache.prototype.print = function print(){\n    // popup? (really, carl? a popup?) - easier to copy/paste\n    console.log( JSON.stringify( this._fetchAndParse(), null, '  ' ) );\n};\n\n\n//=============================================================================\n    return {\n        MetricsLogger  : MetricsLogger,\n        LoggingCache   : LoggingCache\n    };\n});\n"]}