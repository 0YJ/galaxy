{"version":3,"sources":["libs/jquery/jquery.event.drop.js"],"names":["$","fn","drop","str","arg","opts","type","isFunction","indexOf","this","bind","trigger","multi","Infinity","isNaN","delay","tolerance","mode","$event","event","$special","special","targets","datakey","noBubble","add","obj","data","related","remove","setup","active","anyactive","winner","location","push","teardown","removeData","element","grep","target","handler","dd","$targets","filter","each","droppable","drag","hijack","timer","tolerate","clearTimeout","propagates","locate","elem","index","$elem","posi","offset","height","outerHeight","width","outerWidth","top","left","right","bottom","contains","test","modes","intersect","proxy","pageX","pageY","overlap","apply","arguments","Math","max","min","fit","middle","sort","a","b","i","drp","drg","arr","len","ia","x","end","interactions","length","xy","call","last","setTimeout","dropinit","dropstart","dropend","jQuery"],"mappings":"CASC,SAAUA,GAKXA,EAAEC,GAAGC,KAAO,SAAUC,EAAKC,EAAKC,GAE/B,GAAIC,GAAqB,gBAAPH,GAAkBA,EAAM,GAE1CF,EAAKD,EAAEO,WAAYJ,GAAQA,EAAMH,EAAEO,WAAYH,GAAQA,EAAM,IAO7D,OAL8B,KAAzBE,EAAKE,QAAQ,UACjBF,EAAO,OAAQA,GAEhBD,GAASF,GAAOF,EAAKG,EAAMC,OAEpBJ,EAAKQ,KAAKC,KAAMJ,EAAMD,EAAMJ,GAAOQ,KAAKE,QAASL,IAKzDN,EAAEE,KAAO,SAAUG,GAClBA,EAAOA,MAEPH,EAAKU,OAAuB,IAAfP,EAAKO,MAAiBC,EAAAA,GACnB,IAAfR,EAAKO,MAAkB,EAAKE,MAAOT,EAAKO,OAAuBV,EAAKU,MAAlBP,EAAKO,MACxDV,EAAKa,MAAQV,EAAKU,OAASb,EAAKa,MAChCb,EAAKc,UAAYhB,EAAEO,WAAYF,EAAKW,WAAcX,EAAKW,UACnC,OAAnBX,EAAKW,UAAqB,KAAOd,EAAKc,UACvCd,EAAKe,KAAOZ,EAAKY,MAAQf,EAAKe,MAAQ,YAIvC,IAAIC,GAASlB,EAAEmB,MACfC,EAAWF,EAAOG,QAElBnB,EAAOF,EAAEmB,MAAME,QAAQnB,MAGtBU,MAAO,EACPG,MAAO,GACPE,KAAM,UAGNK,WAGAC,QAAS,WAGTC,UAAU,EAGVC,IAAK,SAAUC,GAEH1B,EAAE2B,KAAMlB,KAAMP,EAAKqB,SAEzBK,SAAW,GAIjBC,OAAQ,WACP7B,EAAE2B,KAAMlB,KAAMP,EAAKqB,SAAUK,SAAW,GAIzCE,MAAO,WAEN,IAAK9B,EAAE2B,KAAMlB,KAAMP,EAAKqB,SAAxB,CAGA,GAAII,IACHC,QAAS,EACTG,UACAC,UAAW,EACXC,OAAQ,EACRC,YAGDlC,GAAE2B,KAAMlB,KAAMP,EAAKqB,QAASI,GAE5BzB,EAAKoB,QAAQa,KAAM1B,QAIpB2B,SAAU,WAGT,KAFWpC,EAAE2B,KAAMlB,KAAMP,EAAKqB,cAEpBK,QAAV,CAGA5B,EAAEqC,WAAY5B,KAAMP,EAAKqB,QAEzB,IAAIe,GAAU7B,IAEdP,GAAKoB,QAAUtB,EAAEuC,KAAMrC,EAAKoB,QAAS,SAAUkB,GAC9C,MAASA,KAAWF,MAKtBG,QAAS,SAAUtB,EAAOuB,GAEzB,GAAaC,EAEb,IAAMD,EAGN,OAASvB,EAAMb,MAEd,IAAK,YACL,IAAK,aAEJqC,EAAY3C,EAAGE,EAAKoB,SACG,gBAAXoB,GAAGxC,OACdyC,EAAWA,EAASC,OAAQF,EAAGxC,OAEhCyC,EAASE,KAAK,WACb,GAAIlB,GAAO3B,EAAE2B,KAAMlB,KAAMP,EAAKqB,QAC9BI,GAAKI,UACLJ,EAAKK,UAAY,EACjBL,EAAKM,OAAS,IAGfS,EAAGI,UAAYH,EAEfvB,EAAS2B,KAAKC,OAAQ7B,EAAO,WAAYuB,EACzC,MAED,KAAK,YACL,IAAK,YACJxC,EAAKiB,MAAQA,EACPjB,EAAK+C,OAEV/C,EAAKgD,SAAUR,EAChB,MAED,KAAK,UACL,IAAK,WACJxC,EAAK+C,MAAQE,aAAcjD,EAAK+C,OAC3BP,EAAGU,aACPhC,EAAS2B,KAAKC,OAAQ7B,EAAO,OAAQuB,GACrCtB,EAAS2B,KAAKC,OAAQ7B,EAAO,UAAWuB,MAQ5CW,OAAQ,SAAUC,EAAMC,GACvB,GAAI5B,GAAO3B,EAAE2B,KAAM2B,EAAMpD,EAAKqB,SAC9BiC,EAAQxD,EAAGsD,GACXG,EAAOD,EAAME,aACbC,EAASH,EAAMI,cACfC,EAAQL,EAAMM,aACd5B,GACCoB,KAAMA,EACNO,MAAOA,EACPF,OAAQA,EACRI,IAAKN,EAAKM,IACVC,KAAMP,EAAKO,KACXC,MAAOR,EAAKO,KAAOH,EACnBK,OAAQT,EAAKM,IAAMJ,EAQpB,OALKhC,KACJA,EAAKO,SAAWA,EAChBP,EAAK4B,MAAQA,EACb5B,EAAK2B,KAAOA,GAENpB,GAIRiC,SAAU,SAAU3B,EAAQ4B,GAC3B,OAAWA,EAAK,IAAMA,EAAKJ,OAAUxB,EAAOwB,OAAUI,EAAK,IAAMA,EAAKH,QAAWzB,EAAOyB,QAClFG,EAAK,IAAMA,EAAKL,MAASvB,EAAOuB,MAASK,EAAK,IAAMA,EAAKF,SAAY1B,EAAO0B,QAInFG,OAECC,UAAa,SAAUnD,EAAOoD,EAAO/B,GACpC,MAAO/B,MAAK0D,SAAU3B,GAAUrB,EAAMqD,MAAOrD,EAAMsD,QAClD,IAAMhE,KAAK4D,MAAMK,QAAQC,MAAOlE,KAAMmE,YAGxCF,QAAW,SAAUvD,EAAOoD,EAAO/B,GAElC,MAAOqC,MAAKC,IAAK,EAAGD,KAAKE,IAAKvC,EAAO0B,OAAQK,EAAML,QAAWW,KAAKC,IAAKtC,EAAOuB,IAAKQ,EAAMR,MACvFc,KAAKC,IAAK,EAAGD,KAAKE,IAAKvC,EAAOyB,MAAOM,EAAMN,OAAUY,KAAKC,IAAKtC,EAAOwB,KAAMO,EAAMP,QAGtFgB,IAAO,SAAU7D,EAAOoD,EAAO/B,GAC9B,MAAO/B,MAAK0D,SAAU3B,EAAQ+B,GAAU,EAAI,GAG7CU,OAAU,SAAU9D,EAAOoD,EAAO/B,GACjC,MAAO/B,MAAK0D,SAAU3B,GAAU+B,EAAMP,KAAqB,GAAdO,EAAMV,MAAYU,EAAMR,IAAqB,GAAfQ,EAAMZ,SAAkB,EAAI,IAKzGuB,KAAM,SAAUC,EAAGC,GAClB,MAASA,GAAEnD,OAASkD,EAAElD,QAAckD,EAAE5B,MAAQ6B,EAAE7B,OAIjDL,SAAU,SAAUR,GAEnB,GAAI2C,GAAGC,EAAKC,EAAK5D,EAAM6D,EAAKC,EAAKnC,EAE1BoC,EAAPC,EAAI,EAAOC,EAAMlD,EAAGmD,aAAaC,OAEjCC,GAAO7F,EAAKiB,MAAMqD,MAAOtE,EAAKiB,MAAMsD,OAEpCzD,EAAYd,EAAKc,WAAad,EAAKmE,MAAOnE,EAAKe,KAE/C,IAAG,GAAKyE,EAAKhD,EAAGmD,aAAaF,GAAI,CAEhC,IAAMD,EACL,MAEDA,GAAGxF,QAEHsF,KACAC,EAAMC,EAAG5C,UAAUgD,OAEd9E,IACJuE,EAAMrF,EAAKmD,OAAQqC,EAAGnB,QAEvBc,EAAI,CAEJ,IAAG,GAAK/B,EAAOoC,EAAG5C,UAAUuC,GAAI,CAG/B,GAFA1D,EAAO3B,EAAE2B,KAAM2B,EAAMpD,EAAKqB,WAC1B+D,EAAM3D,EAAKO,UACC,QAEZP,GAAKM,OAASjB,EAAYA,EAAUgF,KAAM9F,EAAMA,EAAKiB,MAAOoE,EAAKD,GAE9DpF,EAAKiE,SAAUmB,EAAKS,GAAO,EAAI,EAClCP,EAAIrD,KAAMR,YACC0D,EAAII,EAEhBD,GAAIN,KAAMhF,EAAKgF,MAEfG,EAAI,CAEJ,KAAQ1D,EAAO6D,EAAKH,MAEd1D,EAAKM,QAAUyD,EAAGxF,KAAK4F,OAAS5F,EAAKU,OAEnCe,EAAKI,OAAO4D,IAAOhE,EAAKK,aAEiD,IAAzEZ,EAAS2B,KAAKC,OAAQ9C,EAAKiB,MAAO,YAAauB,EAAIiD,EAAGhE,EAAK2B,MAAO,IACtE3B,EAAKI,OAAO4D,GAAK,EACjBhE,EAAKK,WAAa,GAIlBL,EAAKM,OAAS,GAGXN,EAAKM,QACTyD,EAAGxF,KAAKiC,KAAMR,EAAK2B,OAGX3B,EAAKI,OAAO4D,IAAwB,GAAlBhE,EAAKK,YAEhCZ,EAAS2B,KAAKC,OAAQ9C,EAAKiB,MAAO,UAAWuB,EAAIiD,EAAGhE,EAAK2B,MACzD3B,EAAKI,OAAO4D,GAAK,EACjBhE,EAAKK,WAAa,YAERqD,EAAII,YACLE,EAAIC,EAEX1F,GAAK+F,MAAQF,EAAG,IAAM7F,EAAK+F,KAAKzB,OAASuB,EAAG,IAAM7F,EAAK+F,KAAKxB,YACzDvE,GAAK+C,MAEZ/C,EAAK+C,MAAQiD,WAAW,WACvBhG,EAAKgD,SAAUR,IACbxC,EAAKa,OAETb,EAAK+F,KAAO/F,EAAKiB,OAMnBC,GAAS+E,SAAW/E,EAASgF,UAAYhF,EAASiF,QAAUnG,GAEzDoG","file":"../../../scripts/libs/jquery/jquery.event.drop.js","sourcesContent":["/*! \n * jquery.event.drop - v 2.2\n * Copyright (c) 2010 Three Dub Media - http://threedubmedia.com\n * Open Source MIT License - http://threedubmedia.com/code/license\n */\n// Created: 2008-06-04 \n// Updated: 2012-05-21\n// REQUIRES: jquery 1.7.x, event.drag 2.2\n\n;(function($){ // secure $ jQuery alias\n\n// Events: drop, dropstart, dropend\n\n// add the jquery instance method\n$.fn.drop = function( str, arg, opts ){\n\t// figure out the event type\n\tvar type = typeof str == \"string\" ? str : \"\",\n\t// figure out the event handler...\n\tfn = $.isFunction( str ) ? str : $.isFunction( arg ) ? arg : null;\n\t// fix the event type\n\tif ( type.indexOf(\"drop\") !== 0 ) \n\t\ttype = \"drop\"+ type;\n\t// were options passed\n\topts = ( str == fn ? arg : opts ) || {};\n\t// trigger or bind event handler\n\treturn fn ? this.bind( type, opts, fn ) : this.trigger( type );\n};\n\n// DROP MANAGEMENT UTILITY\n// returns filtered drop target elements, caches their positions\n$.drop = function( opts ){ \n\topts = opts || {};\n\t// safely set new options...\n\tdrop.multi = opts.multi === true ? Infinity : \n\t\topts.multi === false ? 1 : !isNaN( opts.multi ) ? opts.multi : drop.multi;\n\tdrop.delay = opts.delay || drop.delay;\n\tdrop.tolerance = $.isFunction( opts.tolerance ) ? opts.tolerance : \n\t\topts.tolerance === null ? null : drop.tolerance;\n\tdrop.mode = opts.mode || drop.mode || 'intersect';\n};\n\n// local refs (increase compression)\nvar $event = $.event, \n$special = $event.special,\n// configure the drop special event\ndrop = $.event.special.drop = {\n\n\t// these are the default settings\n\tmulti: 1, // allow multiple drop winners per dragged element\n\tdelay: 20, // async timeout delay\n\tmode: 'overlap', // drop tolerance mode\n\t\t\n\t// internal cache\n\ttargets: [], \n\t\n\t// the key name for stored drop data\n\tdatakey: \"dropdata\",\n\t\t\n\t// prevent bubbling for better performance\n\tnoBubble: true,\n\t\n\t// count bound related events\n\tadd: function( obj ){ \n\t\t// read the interaction data\n\t\tvar data = $.data( this, drop.datakey );\n\t\t// count another realted event\n\t\tdata.related += 1;\n\t},\n\t\n\t// forget unbound related events\n\tremove: function(){\n\t\t$.data( this, drop.datakey ).related -= 1;\n\t},\n\t\n\t// configure the interactions\n\tsetup: function(){\n\t\t// check for related events\n\t\tif ( $.data( this, drop.datakey ) ) \n\t\t\treturn;\n\t\t// initialize the drop element data\n\t\tvar data = { \n\t\t\trelated: 0,\n\t\t\tactive: [],\n\t\t\tanyactive: 0,\n\t\t\twinner: 0,\n\t\t\tlocation: {}\n\t\t};\n\t\t// store the drop data on the element\n\t\t$.data( this, drop.datakey, data );\n\t\t// store the drop target in internal cache\n\t\tdrop.targets.push( this );\n\t},\n\t\n\t// destroy the configure interaction\t\n\tteardown: function(){ \n\t\tvar data = $.data( this, drop.datakey ) || {};\n\t\t// check for related events\n\t\tif ( data.related ) \n\t\t\treturn;\n\t\t// remove the stored data\n\t\t$.removeData( this, drop.datakey );\n\t\t// reference the targeted element\n\t\tvar element = this;\n\t\t// remove from the internal cache\n\t\tdrop.targets = $.grep( drop.targets, function( target ){ \n\t\t\treturn ( target !== element ); \n\t\t});\n\t},\n\t\n\t// shared event handler\n\thandler: function( event, dd ){ \n\t\t// local vars\n\t\tvar results, $targets;\n\t\t// make sure the right data is available\n\t\tif ( !dd ) \n\t\t\treturn;\n\t\t// handle various events\n\t\tswitch ( event.type ){\n\t\t\t// draginit, from $.event.special.drag\n\t\t\tcase 'mousedown': // DROPINIT >>\n\t\t\tcase 'touchstart': // DROPINIT >>\n\t\t\t\t// collect and assign the drop targets\n\t\t\t\t$targets =  $( drop.targets );\n\t\t\t\tif ( typeof dd.drop == \"string\" )\n\t\t\t\t\t$targets = $targets.filter( dd.drop );\n\t\t\t\t// reset drop data winner properties\n\t\t\t\t$targets.each(function(){\n\t\t\t\t\tvar data = $.data( this, drop.datakey );\n\t\t\t\t\tdata.active = [];\n\t\t\t\t\tdata.anyactive = 0;\n\t\t\t\t\tdata.winner = 0;\n\t\t\t\t});\n\t\t\t\t// set available target elements\n\t\t\t\tdd.droppable = $targets;\n\t\t\t\t// activate drop targets for the initial element being dragged\n\t\t\t\t$special.drag.hijack( event, \"dropinit\", dd ); \n\t\t\t\tbreak;\n\t\t\t// drag, from $.event.special.drag\n\t\t\tcase 'mousemove': // TOLERATE >>\n\t\t\tcase 'touchmove': // TOLERATE >>\n\t\t\t\tdrop.event = event; // store the mousemove event\n\t\t\t\tif ( !drop.timer )\n\t\t\t\t\t// monitor drop targets\n\t\t\t\t\tdrop.tolerate( dd ); \n\t\t\t\tbreak;\n\t\t\t// dragend, from $.event.special.drag\n\t\t\tcase 'mouseup': // DROP >> DROPEND >>\n\t\t\tcase 'touchend': // DROP >> DROPEND >>\n\t\t\t\tdrop.timer = clearTimeout( drop.timer ); // delete timer\t\n\t\t\t\tif ( dd.propagates ){\n\t\t\t\t\t$special.drag.hijack( event, \"drop\", dd ); \n\t\t\t\t\t$special.drag.hijack( event, \"dropend\", dd ); \n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t\t\n\t\t}\n\t},\n\t\t\n\t// returns the location positions of an element\n\tlocate: function( elem, index ){ \n\t\tvar data = $.data( elem, drop.datakey ),\n\t\t$elem = $( elem ), \n\t\tposi = $elem.offset() || {}, \n\t\theight = $elem.outerHeight(), \n\t\twidth = $elem.outerWidth(),\n\t\tlocation = { \n\t\t\telem: elem, \n\t\t\twidth: width, \n\t\t\theight: height,\n\t\t\ttop: posi.top, \n\t\t\tleft: posi.left, \n\t\t\tright: posi.left + width, \n\t\t\tbottom: posi.top + height\n\t\t};\n\t\t// drag elements might not have dropdata\n\t\tif ( data ){\n\t\t\tdata.location = location;\n\t\t\tdata.index = index;\n\t\t\tdata.elem = elem;\n\t\t}\n\t\treturn location;\n\t},\n\t\n\t// test the location positions of an element against another OR an X,Y coord\n\tcontains: function( target, test ){ // target { location } contains test [x,y] or { location }\n\t\treturn ( ( test[0] || test.left ) >= target.left && ( test[0] || test.right ) <= target.right\n\t\t\t&& ( test[1] || test.top ) >= target.top && ( test[1] || test.bottom ) <= target.bottom ); \n\t},\n\t\n\t// stored tolerance modes\n\tmodes: { // fn scope: \"$.event.special.drop\" object \n\t\t// target with mouse wins, else target with most overlap wins\n\t\t'intersect': function( event, proxy, target ){\n\t\t\treturn this.contains( target, [ event.pageX, event.pageY ] ) ? // check cursor\n\t\t\t\t1e9 : this.modes.overlap.apply( this, arguments ); // check overlap\n\t\t},\n\t\t// target with most overlap wins\t\n\t\t'overlap': function( event, proxy, target ){\n\t\t\t// calculate the area of overlap...\n\t\t\treturn Math.max( 0, Math.min( target.bottom, proxy.bottom ) - Math.max( target.top, proxy.top ) )\n\t\t\t\t* Math.max( 0, Math.min( target.right, proxy.right ) - Math.max( target.left, proxy.left ) );\n\t\t},\n\t\t// proxy is completely contained within target bounds\t\n\t\t'fit': function( event, proxy, target ){\n\t\t\treturn this.contains( target, proxy ) ? 1 : 0;\n\t\t},\n\t\t// center of the proxy is contained within target bounds\t\n\t\t'middle': function( event, proxy, target ){\n\t\t\treturn this.contains( target, [ proxy.left + proxy.width * .5, proxy.top + proxy.height * .5 ] ) ? 1 : 0;\n\t\t}\n\t},\t\n\t\n\t// sort drop target cache by by winner (dsc), then index (asc)\n\tsort: function( a, b ){\n\t\treturn ( b.winner - a.winner ) || ( a.index - b.index );\n\t},\n\t\t\n\t// async, recursive tolerance execution\n\ttolerate: function( dd ){\t\t\n\t\t// declare local refs\n\t\tvar i, drp, drg, data, arr, len, elem,\n\t\t// interaction iteration variables\n\t\tx = 0, ia, end = dd.interactions.length,\n\t\t// determine the mouse coords\n\t\txy = [ drop.event.pageX, drop.event.pageY ],\n\t\t// custom or stored tolerance fn\n\t\ttolerance = drop.tolerance || drop.modes[ drop.mode ];\n\t\t// go through each passed interaction...\n\t\tdo if ( ia = dd.interactions[x] ){\n\t\t\t// check valid interaction\n\t\t\tif ( !ia )\n\t\t\t\treturn; \n\t\t\t// initialize or clear the drop data\n\t\t\tia.drop = [];\n\t\t\t// holds the drop elements\n\t\t\tarr = []; \n\t\t\tlen = ia.droppable.length;\n\t\t\t// determine the proxy location, if needed\n\t\t\tif ( tolerance )\n\t\t\t\tdrg = drop.locate( ia.proxy ); \n\t\t\t// reset the loop\n\t\t\ti = 0;\n\t\t\t// loop each stored drop target\n\t\t\tdo if ( elem = ia.droppable[i] ){ \n\t\t\t\tdata = $.data( elem, drop.datakey );\n\t\t\t\tdrp = data.location;\n\t\t\t\tif ( !drp ) continue;\n\t\t\t\t// find a winner: tolerance function is defined, call it\n\t\t\t\tdata.winner = tolerance ? tolerance.call( drop, drop.event, drg, drp ) \n\t\t\t\t\t// mouse position is always the fallback\n\t\t\t\t\t: drop.contains( drp, xy ) ? 1 : 0; \n\t\t\t\tarr.push( data );\t\n\t\t\t} while ( ++i < len ); // loop \n\t\t\t// sort the drop targets\n\t\t\tarr.sort( drop.sort );\t\t\t\n\t\t\t// reset the loop\n\t\t\ti = 0;\n\t\t\t// loop through all of the targets again\n\t\t\tdo if ( data = arr[ i ] ){\n\t\t\t\t// winners...\n\t\t\t\tif ( data.winner && ia.drop.length < drop.multi ){\n\t\t\t\t\t// new winner... dropstart\n\t\t\t\t\tif ( !data.active[x] && !data.anyactive ){\n\t\t\t\t\t\t// check to make sure that this is not prevented\n\t\t\t\t\t\tif ( $special.drag.hijack( drop.event, \"dropstart\", dd, x, data.elem )[0] !== false ){ \t\n\t\t\t\t\t\t\tdata.active[x] = 1;\n\t\t\t\t\t\t\tdata.anyactive += 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// if false, it is not a winner\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tdata.winner = 0;\n\t\t\t\t\t}\n\t\t\t\t\t// if it is still a winner\n\t\t\t\t\tif ( data.winner )\n\t\t\t\t\t\tia.drop.push( data.elem );\n\t\t\t\t}\n\t\t\t\t// losers... \n\t\t\t\telse if ( data.active[x] && data.anyactive == 1 ){\n\t\t\t\t\t// former winner... dropend\n\t\t\t\t\t$special.drag.hijack( drop.event, \"dropend\", dd, x, data.elem ); \n\t\t\t\t\tdata.active[x] = 0;\n\t\t\t\t\tdata.anyactive -= 1;\n\t\t\t\t}\n\t\t\t} while ( ++i < len ); // loop \t\t\n\t\t} while ( ++x < end ) // loop\n\t\t// check if the mouse is still moving or is idle\n\t\tif ( drop.last && xy[0] == drop.last.pageX && xy[1] == drop.last.pageY ) \n\t\t\tdelete drop.timer; // idle, don't recurse\n\t\telse  // recurse\n\t\t\tdrop.timer = setTimeout(function(){ \n\t\t\t\tdrop.tolerate( dd ); \n\t\t\t}, drop.delay );\n\t\t// remember event, to compare idleness\n\t\tdrop.last = drop.event; \n\t}\n\t\n};\n\n// share the same special event configuration with related events...\n$special.dropinit = $special.dropstart = $special.dropend = drop;\n\n})(jQuery); // confine scope\t"]}