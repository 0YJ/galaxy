{"version":3,"sources":["libs/bbi/spans.js"],"names":["define","Range","min","max","this","_min","_max","_Compound","ranges","sorted","sort","_rangeOrder","merged","current","shift","forEach","range","push","_ranges","union","s0","s1","Array","insertRange","intersection","r0","r1","l0","length","l1","i0","i1","or","lapMin","Math","lapMax","coverage","s","tot","rl","ri","r","rangeOrder","a","b","prototype","contains","pos","isContiguous","_pushRanges","toString","lower_bound","m","floor","lb","splice","ub","rangeOver"],"mappings":"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","file":"../../../scripts/libs/bbi/spans.js","sourcesContent":["/* -*- mode: javascript; c-basic-offset: 4; indent-tabs-mode: nil -*- */\n\n//\n// Dalliance Genome Explorer\n// (c) Thomas Down 2006-2010\n//\n// spans.js: JavaScript Intset/Location port.\n//\n\ndefine([], function() {\n\n\"use strict\";\n\n\nfunction Range(min, max)\n{\n    if (typeof(min) != 'number' || typeof(max) != 'number')\n        throw 'Bad range ' + min + ',' + max;\n    this._min = min;\n    this._max = max;\n}\n\nRange.prototype.min = function() {\n    return this._min;\n}\n\nRange.prototype.max = function() {\n    return this._max;\n}\n\nRange.prototype.contains = function(pos) {\n    return pos >= this._min && pos <= this._max;\n}\n\nRange.prototype.isContiguous = function() {\n    return true;\n}\n\nRange.prototype.ranges = function() {\n    return [this];\n}\n\nRange.prototype._pushRanges = function(ranges) {\n    ranges.push(this);\n}\n\nRange.prototype.toString = function() {\n    return '[' + this._min + '-' + this._max + ']';\n}\n\nfunction _Compound(ranges) {\n    // given: a set of unsorted possibly overlapping ranges\n    // sort the input ranges\n    var sorted = ranges.sort(_rangeOrder);\n    // merge overlaps between adjacent ranges\n    var merged = [];\n    var current = sorted.shift();\n    sorted.forEach(function(range) {\n        if (range._min <= current._max) {\n            if (range._max > current._max) {\n                current._max = range._max;\n            }\n        }\n        else {\n            merged.push(current);\n            current = range;\n        }\n    });\n    merged.push(current);\n    this._ranges = merged;\n}\n\n_Compound.prototype.min = function() {\n    return this._ranges[0].min();\n}\n\n_Compound.prototype.max = function() {\n    return this._ranges[this._ranges.length - 1].max();\n}\n\n// returns the index of the first range that is not less than pos\n_Compound.prototype.lower_bound = function(pos) {\n    // first check if pos is out of range\n    var r = this.ranges();\n    if (pos > this.max()) return r.length;\n    if (pos < this.min()) return 0;\n    // do a binary search\n    var a=0, b=r.length - 1;\n    while (a <= b) {\n        var m = Math.floor((a+b)/2);\n        if (pos > r[m]._max) {\n            a = m+1;\n        }\n        else if (pos < r[m]._min) {\n            b = m-1;\n        }\n        else {\n            return m;\n        }\n    }\n    return a;\n}\n\n_Compound.prototype.contains = function(pos) {\n    var lb = this.lower_bound(pos);\n    if (lb < this._ranges.length && this._ranges[lb].contains(pos)) {\n        return true;\n    }\n    return false;\n}\n\n_Compound.prototype.insertRange = function(range) {\n    var lb = this.lower_bound(range._min);\n    if (lb === this._ranges.length) { // range follows this\n        this._ranges.push(range);\n        return;\n    }\n\n    var r = this.ranges();\n    if (range._max < r[lb]._min) { // range preceeds lb\n        this._ranges.splice(lb,0,range);\n        return;\n    }\n\n    // range overlaps lb (at least)\n    if (r[lb]._min < range._min) range._min = r[lb]._min;\n    var ub = lb+1;\n    while (ub < r.length && r[ub]._min <= range._max) {\n        ub++;\n    }\n    ub--;\n    // ub is the upper bound of the new range\n    if (r[ub]._max > range._max) range._max = r[ub]._max;\n\n    // splice range into this._ranges\n    this._ranges.splice(lb,ub-lb+1,range);\n    return;\n}\n\n_Compound.prototype.isContiguous = function() {\n    return this._ranges.length > 1;\n}\n\n_Compound.prototype.ranges = function() {\n    return this._ranges;\n}\n\n_Compound.prototype._pushRanges = function(ranges) {\n    for (var ri = 0; ri < this._ranges.length; ++ri)\n        ranges.push(this._ranges[ri]);\n}\n\n_Compound.prototype.toString = function() {\n    var s = '';\n    for (var r = 0; r < this._ranges.length; ++r) {\n        if (r>0) {\n            s = s + ',';\n        }\n        s = s + this._ranges[r].toString();\n    }\n    return s;\n}\n\nfunction union(s0, s1) {\n    if (! (s0 instanceof _Compound)) {\n        if (! (s0 instanceof Array))\n            s0 = [s0];\n        s0 = new _Compound(s0);\n    }\n\n    if (s1)\n        s0.insertRange(s1);\n\n    return s0;\n}\n\nfunction intersection(s0, s1) {\n    var r0 = s0.ranges();\n    var r1 = s1.ranges();\n    var l0 = r0.length, l1 = r1.length;\n    var i0 = 0, i1 = 0;\n    var or = [];\n\n    while (i0 < l0 && i1 < l1) {\n        var s0 = r0[i0], s1 = r1[i1];\n        var lapMin = Math.max(s0.min(), s1.min());\n        var lapMax = Math.min(s0.max(), s1.max());\n        if (lapMax >= lapMin) {\n            or.push(new Range(lapMin, lapMax));\n        }\n        if (s0.max() > s1.max()) {\n            ++i1;\n        } else {\n            ++i0;\n        }\n    }\n\n    if (or.length == 0) {\n        return null; // FIXME\n    } else if (or.length == 1) {\n        return or[0];\n    } else {\n        return new _Compound(or);\n    }\n}\n\nfunction coverage(s) {\n    var tot = 0;\n    var rl = s.ranges();\n    for (var ri = 0; ri < rl.length; ++ri) {\n        var r = rl[ri];\n        tot += (r.max() - r.min() + 1);\n    }\n    return tot;\n}\n\n\n\nfunction rangeOrder(a, b)\n{\n    if (a.min() < b.min()) {\n        return -1;\n    } else if (a.min() > b.min()) {\n        return 1;\n    } else if (a.max() < b.max()) {\n        return -1;\n    } else if (b.max() > a.max()) {\n        return 1;\n    } else {\n        return 0;\n    }\n}\n\nfunction _rangeOrder(a, b)\n{\n    if (a._min < b._min) {\n        return -1;\n    } else if (a._min > b._min) {\n        return 1;\n    } else if (a._max < b._max) {\n        return -1;\n    } else if (b._max > a._max) {\n        return 1;\n    } else {\n        return 0;\n    }\n}\n\nreturn {\n        Range: Range,\n        union: union,\n        intersection: intersection,\n        coverage: coverage,\n        rangeOver: rangeOrder,\n        _rangeOrder: _rangeOrder\n};\n});\n"]}