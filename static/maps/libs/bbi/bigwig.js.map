{"version":3,"sources":["libs/bbi/bigwig.js"],"names":["define","spans","jszlib","DASFeature","DASGroup","id","this","readInt","ba","offset","read","url","start","size","Math","pow","$","ajax","type","dataType","timeout","beforeSend","xhrObj","setRequestHeader","xhrFields","responseType","bwg_readOffset","o","M1","M2","M3","M4","BigWig","BigWigView","bwg","cirTreeOffset","cirTreeLength","isSummary","makeBwg","promise","Deferred","when","then","result","resolve","header","Uint8Array","sa","Int16Array","la","Int32Array","magic","BIG_WIG_MAGIC","BIG_BED_MAGIC","BIG_WIG_MAGIC_BE","BIG_BED_MAGIC_BE","toString","version","numZoomLevels","chromTreeOffset","unzoomedDataOffset","unzoomedIndexOffset","fieldCount","definedFieldCount","asOffset","totalSummaryOffset","uncompressBufSize","extHeaderOffset","zoomLevels","zl","zlReduction","zlData","zlIndex","push","reduction","dataOffset","indexOffset","readChromTree","getAutoSQL","as","schema","BBIExtraIndex","bbi","field","Range","union","intersection","jszlib_inflate_buffer","inflateBuffer","arrayCopy","BED_COLOR_REGEXP","RegExp","prototype","thisB","chromsToIDs","idsToChroms","maxID","udo","bpt","keySize","bptReadNode","nodeType","cnt","n","childOffset","key","ki","charCode","String","fromCharCode","chromId","indexOf","substr","max","readWigData","chrName","min","chr","undefined","readWigDataById","cirHeader","cirBlockSize","blocksToFetch","outstanding","filter","Date","now","fmin","fmax","toks","cirFobRecur","level","instrument","console","log","length","cachedCirRoot","cirFobRecur2","fetchFeatures","maxCirBlockSpan","i","blockSpan","fetchRanges","ranges","r","fr","cirFobStartFetch","attempts","resultBuffer","contains","cirBlockData","isLeaf","lo","startChrom","startBase","endChrom","endBase","blockOffset","blockSize","recurOffsets","sort","b0","b1","features","createFeature","opts","f","_chromId","segment","k","tramp","block","data","parseFeatures","splice","fetchStart","fetchSize","bi","fb","tmp","buffer","fa","Float32Array","itemCount","byteLength","end","validCnt","maxVal","sumData","summaryOpts","score","maxScore","blockStart","itemStep","itemSpan","blockType","Error","dfc","rest","ch","bedColumns","featureOpts","split","label","parseInt","isNaN","orientation","color","test","itemRgb","col","fields","name","thickStart","thickEnd","blockCount","blockSizes","blockStarts","exonFrames","grp","notes","groups","geneId","geneName","geneName2","gg","extend","spanList","b","bmin","bmax","span","tsList","s","ts","codingRegion","tl","tlList","readingFrame","tlOffset","index","readframe","brf","readframeExplicit","getFirstAdjacent","pos","dir","callback","getFirstAdjacentById","slice","fetch","blockToFetch","bestBlockChr","bestBlockOffset","chrx","bestFeature","bestChr","bestPos","fi","exec","bestRecur","view","range","getUnzoomedView","getZoomedView","unzoomedView","cirLen","z","zh","_tsFetch","zoom","topLevelReductionCache","c","feats","thresholdSearch","referencePoint","threshold","fbThresholdSearchRecur","candidates","c1","c2","d","chrOrd","candidate","rp","fromRef","initialChr","chrId","header_re","field_re","headerMatch","declType","comment","substring","m","getExtraIndices","extraIndexCount","extraIndexListOffset","eil","indices","ii","eiType","eiFieldCount","eiOffset","eiField","lookup","nodeOffset","valSize","node","Uint16Array","Uint32Array","lastChildOffset","localeCompare"],"mappings":"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","file":"../../../scripts/libs/bbi/bigwig.js","sourcesContent":["//\n// Author: Jeremy Goecks\n//\n// Modified from:\n//\n// Dalliance Genome Explorer\n// (c) Thomas Down 2006-2010\n//\n// bigwig.js: indexed binary WIG (and BED) files\n//\n\n// Requirements:\n//  * jquery and ajax-native plugin for reading binary data, jquery for promises\n//  * spans for working working with genomic intervals\n//  * jszlib for decompression.\ndefine([\"libs/bbi/spans\", \"libs/bbi/jszlib\", \"libs/bbi/jquery-ajax-native\"], function(spans, jszlib) {\n    \"use strict\";\n\n    // -- Copied from das.js --\n\n    function DASFeature() {\n    }\n\n    function DASGroup(id) {\n        if (id)\n        this.id = id;\n    }\n\n    // -- End copy --\n\n    // -- Copied from bin.js --\n\n    function readInt(ba, offset) {\n        return (ba[offset + 3] << 24) | (ba[offset + 2] << 16) | (ba[offset + 1] << 8) | (ba[offset]);\n    }\n\n    // -- End copy --\n\n    // Some globals.\n    var Range = spans.Range;\n    var union = spans.union;\n    var intersection = spans.intersection;\n\n    var jszlib_inflate_buffer = jszlib.inflateBuffer;\n    var arrayCopy = jszlib.arrayCopy;\n\n    var BIG_WIG_MAGIC = 0x888FFC26;\n    var BIG_WIG_MAGIC_BE = 0x26FC8F88;\n    var BIG_BED_MAGIC = 0x8789F2EB;\n    var BIG_BED_MAGIC_BE = 0xEBF28987;\n\n\n    var BIG_WIG_TYPE_GRAPH = 1;\n    var BIG_WIG_TYPE_VSTEP = 2;\n    var BIG_WIG_TYPE_FSTEP = 3;\n\n    var M1 = 256;\n    var M2 = 256*256;\n    var M3 = 256*256*256;\n    var M4 = 256*256*256*256;\n\n    var BED_COLOR_REGEXP = new RegExp(\"^[0-9]+,[0-9]+,[0-9]+\");\n\n    /**\n     * Read binary data from a URL using HTTP Range header. Requires jQuery and ajax-native plugin.\n     */\n    function read(url, start, size) {\n        // Taken from bin.js:\n        // This may be necessary for Safari:\n        //   if ((isSafari || this.opts.salt) && url.indexOf('?') < 0) {\n        //       url = url + '?salt=' + b64_sha1('' + Date.now() + ',' + (++seed));\n        //   }\n\n        var chunkSizeLimit = Math.pow(10, 6); // 1 MB\n        if(size > chunkSizeLimit) {\n            // TODO: raise error.\n        }\n\n        // Read data from remote file.\n        return $.ajax({\n            type: 'GET',\n            dataType: 'native',\n            url: url,\n            // Potential timeout on first request to catch mixed-content errors on Chromium.\n            timeout: 5000,\n            beforeSend: function(xhrObj) {\n                // (size - 1) because range is inclusive.\n                xhrObj.setRequestHeader(\"Range\", \"bytes=\" + start + \"-\" + (start + (size - 1)));\n            },\n            xhrFields: {\n                responseType: 'arraybuffer'\n            }\n        });\n    }\n\n    function bwg_readOffset(ba, o) {\n        var offset = ba[o] + ba[o+1]*M1 + ba[o+2]*M2 + ba[o+3]*M3 + ba[o+4]*M4;\n        return offset;\n    }\n\n    function BigWig() {\n    }\n\n    /**\n     * Read the chromosome B+ tree header.\n     */\n    BigWig.prototype.readChromTree = function() {\n        var thisB = this;\n        this.chromsToIDs = {};\n        this.idsToChroms = {};\n        this.maxID = 0;\n\n        var udo = this.unzoomedDataOffset;\n        var eb = (udo - this.chromTreeOffset) & 3;\n        udo = udo + 4 - eb;\n\n        // Read and parse the chrom tree, return the promise so that subsequent actions can be taken.\n        return $.when(read(this.url, this.chromTreeOffset, udo - this.chromTreeOffset)).then(function(bpt) {\n            var ba = new Uint8Array(bpt);\n            var sa = new Int16Array(bpt);\n            var la = new Int32Array(bpt);\n            var bptMagic = la[0];\n            var blockSize = la[1];\n            var keySize = la[2];\n            var valSize = la[3];\n            var itemCount = bwg_readOffset(ba, 16);\n            var rootNodeOffset = 32;\n\n            var bptReadNode = function(offset) {\n                var nodeType = ba[offset];\n                var cnt = sa[(offset/2) + 1];\n                offset += 4;\n                for (var n = 0; n < cnt; ++n) {\n                    if (nodeType === 0) {\n                        offset += keySize;\n                        var childOffset = bwg_readOffset(ba, offset);\n                        offset += 8;\n                        childOffset -= thisB.chromTreeOffset;\n                        bptReadNode(childOffset);\n                    } else {\n                        var key = '';\n                        for (var ki = 0; ki < keySize; ++ki) {\n                            var charCode = ba[offset++];\n                            if (charCode !== 0) {\n                                key += String.fromCharCode(charCode);\n                            }\n                        }\n                        var chromId = (ba[offset+3]<<24) | (ba[offset+2]<<16) | (ba[offset+1]<<8) | (ba[offset+0]);\n                        var chromSize = (ba[offset + 7]<<24) | (ba[offset+6]<<16) | (ba[offset+5]<<8) | (ba[offset+4]);\n                        offset += 8;\n\n                        thisB.chromsToIDs[key] = chromId;\n                        if (key.indexOf('chr') === 0) {\n                            thisB.chromsToIDs[key.substr(3)] = chromId;\n                        }\n                        thisB.idsToChroms[chromId] = key;\n                        thisB.maxID = Math.max(thisB.maxID, chromId);\n                    }\n                }\n            };\n            bptReadNode(rootNodeOffset);\n        });\n    }\n\n    function BigWigView(bwg, cirTreeOffset, cirTreeLength, isSummary) {\n        this.bwg = bwg;\n        this.cirTreeOffset = cirTreeOffset;\n        this.cirTreeLength = cirTreeLength;\n        this.isSummary = isSummary;\n    }\n\n\n\n    BigWigView.prototype.readWigData = function(chrName, min, max) {\n        var chr = this.bwg.chromsToIDs[chrName],\n            rval;\n        if (chr === undefined) {\n            // Not an error because some .bwgs won't have data for all chromosomes.\n            rval = [];\n        } else {\n            rval = this.readWigDataById(chr, min, max);\n        }\n\n        return rval;\n    };\n\n    BigWigView.prototype.readWigDataById = function(chr, min, max) {\n        var thisB = this,\n            promise = $.Deferred();\n\n        // Read the R-tree index header and then read data again.\n        if (!this.cirHeader) {\n            $.when(read(thisB.bwg.url, this.cirTreeOffset, 48)).then(function(result) {\n                thisB.cirHeader = result;\n                var la = new Int32Array(thisB.cirHeader);\n                thisB.cirBlockSize = la[1];\n                $.when(thisB.readWigDataById(chr, min, max)).then(function(result) {\n                    promise.resolve(result);\n                });\n            });\n            return promise;\n        }\n\n        var blocksToFetch = [];\n        var outstanding = 0;\n\n        var beforeBWG = Date.now();\n\n        var filter = function(chromId, fmin, fmax, toks) {\n            return ((chr < 0 || chromId == chr) && fmin <= max && fmax >= min);\n        };\n\n        var cirFobRecur = function(offset, level) {\n            if (thisB.bwg.instrument)\n            console.log('level=' + level + '; offset=' + offset + '; time=' + (Date.now()|0));\n\n            outstanding += offset.length;\n\n            if (offset.length == 1 && offset[0] - thisB.cirTreeOffset == 48 && thisB.cachedCirRoot) {\n                cirFobRecur2(thisB.cachedCirRoot, 0, level);\n                --outstanding;\n                if (outstanding === 0) {\n                    $.when(thisB.fetchFeatures(filter, blocksToFetch)).then(function(result) {\n                        promise.resolve(result);\n                    });\n                }\n                return;\n            }\n\n            var maxCirBlockSpan = 4 +  (thisB.cirBlockSize * 32);   // Upper bound on size, based on a completely full leaf node.\n            var spans;\n            for (var i = 0; i < offset.length; ++i) {\n                var blockSpan = new Range(offset[i], offset[i] + maxCirBlockSpan);\n                spans = spans ? union(spans, blockSpan) : blockSpan;\n            }\n\n            var fetchRanges = spans.ranges();\n            for (var r = 0; r < fetchRanges.length; ++r) {\n                var fr = fetchRanges[r];\n                cirFobStartFetch(offset, fr, level);\n            }\n        };\n\n        var cirFobStartFetch = function(offset, fr, level, attempts) {\n            var length = fr.max() - fr.min();\n            $.when(read(thisB.bwg.url, fr.min(), fr.max() - fr.min())).then(function(resultBuffer) {\n                for (var i = 0; i < offset.length; ++i) {\n                    if (fr.contains(offset[i])) {\n                        cirFobRecur2(resultBuffer, offset[i] - fr.min(), level);\n\n                        if (offset[i] - thisB.cirTreeOffset == 48 && offset[i] - fr.min() === 0)\n                            thisB.cachedCirRoot = resultBuffer;\n\n                        --outstanding;\n                        if (outstanding === 0) {\n                            $.when(thisB.fetchFeatures(filter, blocksToFetch)).then(function(result) {\n                                promise.resolve(result);\n                            });\n                        }\n                    }\n                }\n            });\n        };\n\n        var cirFobRecur2 = function(cirBlockData, offset, level) {\n            var ba = new Uint8Array(cirBlockData);\n            var sa = new Int16Array(cirBlockData);\n            var la = new Int32Array(cirBlockData);\n\n            var isLeaf = ba[offset];\n            var cnt = sa[offset/2 + 1];\n            offset += 4;\n\n            if (isLeaf !== 0) {\n                for (var i = 0; i < cnt; ++i) {\n                    var lo = offset/4;\n                    var startChrom = la[lo];\n                    var startBase = la[lo + 1];\n                    var endChrom = la[lo + 2];\n                    var endBase = la[lo + 3];\n                    var blockOffset = bwg_readOffset(ba, offset+16);\n                    var blockSize = bwg_readOffset(ba, offset+24);\n                    if (((chr < 0 || startChrom < chr) || (startChrom == chr && startBase <= max)) &&\n                    ((chr < 0 || endChrom   > chr) || (endChrom == chr && endBase >= min)))\n                    {\n                        blocksToFetch.push({offset: blockOffset, size: blockSize});\n                    }\n                    offset += 32;\n                }\n            } else {\n                var recurOffsets = [];\n                for (var i = 0; i < cnt; ++i) {\n                    var lo = offset/4;\n                    var startChrom = la[lo];\n                    var startBase = la[lo + 1];\n                    var endChrom = la[lo + 2];\n                    var endBase = la[lo + 3];\n                    var blockOffset = bwg_readOffset(ba, offset+16);\n                    if ((chr < 0 || startChrom < chr || (startChrom == chr && startBase <= max)) &&\n                    (chr < 0 || endChrom   > chr || (endChrom == chr && endBase >= min)))\n                    {\n                        recurOffsets.push(blockOffset);\n                    }\n                    offset += 24;\n                }\n                if (recurOffsets.length > 0) {\n                    cirFobRecur(recurOffsets, level + 1);\n                }\n            }\n        };\n\n        cirFobRecur([thisB.cirTreeOffset + 48], 1);\n        return promise;\n    };\n\n    /**\n     * Fetch data for a set of blocks. Returns a promise that resolves to fetched data.\n     */\n    BigWigView.prototype.fetchFeatures = function(filter, blocksToFetch) {\n        var thisB = this,\n            promise = $.Deferred();\n\n        blocksToFetch.sort(function(b0, b1) {\n            return (b0.offset|0) - (b1.offset|0);\n        });\n\n        if (blocksToFetch.length === 0) {\n            return [];\n        } else {\n            var features = [];\n            var createFeature = function(chr, fmin, fmax, opts) {\n                if (!opts) {\n                    opts = {};\n                }\n\n                var f = new DASFeature();\n                f._chromId = chr;\n                f.segment = thisB.bwg.idsToChroms[chr];\n                f.min = fmin;\n                f.max = fmax;\n                f.type = thisB.bwg.type;\n\n                for (var k in opts) {\n                    f[k] = opts[k];\n                }\n\n                features.push(f);\n            };\n\n            // Recursive function to read blocks of data.\n            var tramp = function() {\n                if (blocksToFetch.length === 0) {\n                    var afterBWG = Date.now();\n                    // dlog('BWG fetch took ' + (afterBWG - beforeBWG) + 'ms');\n                    return promise.resolve(features);\n                }\n                else {\n                    var block = blocksToFetch[0];\n                    if (block.data) {\n                        thisB.parseFeatures(block.data, createFeature, filter);\n                        blocksToFetch.splice(0, 1);\n                        tramp();\n                    }\n                    else {\n                        var fetchStart = block.offset;\n                        var fetchSize = block.size;\n                        var bi = 1;\n                        while (bi < blocksToFetch.length && blocksToFetch[bi].offset == (fetchStart + fetchSize)) {\n                            fetchSize += blocksToFetch[bi].size;\n                            ++bi;\n                        }\n\n                        $.when(read(thisB.bwg.url, fetchStart, fetchSize)).then(function(result) {\n                            var offset = 0;\n                            var bi = 0;\n                            while (offset < fetchSize) {\n                                var fb = blocksToFetch[bi];\n\n                                var data;\n                                if (thisB.bwg.uncompressBufSize > 0) {\n                                    data = jszlib_inflate_buffer(result, offset + 2, fb.size - 2);\n                                } else {\n                                    var tmp = new Uint8Array(fb.size);    // FIXME is this really the best we can do?\n                                    arrayCopy(new Uint8Array(result, offset, fb.size), 0, tmp, 0, fb.size);\n                                    data = tmp.buffer;\n                                }\n                                fb.data = data;\n\n                                offset += fb.size;\n                                ++bi;\n                            }\n                            tramp();\n                        });\n                    }\n                }\n            };\n            tramp();\n        }\n\n        return promise;\n    };\n\n    BigWigView.prototype.parseFeatures = function(data, createFeature, filter) {\n        var ba = new Uint8Array(data);\n\n        if (this.isSummary) {\n            var sa = new Int16Array(data);\n            var la = new Int32Array(data);\n            var fa = new Float32Array(data);\n\n            var itemCount = data.byteLength/32;\n            for (var i = 0; i < itemCount; ++i) {\n                var chromId =   la[(i*8)];\n                var start =     la[(i*8)+1];\n                var end =       la[(i*8)+2];\n                var validCnt =  la[(i*8)+3];\n                var minVal    = fa[(i*8)+4];\n                var maxVal    = fa[(i*8)+5];\n                var sumData   = fa[(i*8)+6];\n                var sumSqData = fa[(i*8)+7];\n\n                if (filter(chromId, start + 1, end)) {\n                    var summaryOpts = {type: 'bigwig', score: sumData/validCnt, maxScore: maxVal};\n                    if (this.bwg.type == 'bigbed') {\n                        summaryOpts.type = 'density';\n                    }\n                    createFeature(chromId, start + 1, end, summaryOpts);\n                }\n            }\n        }\n        else if (this.bwg.type == 'bigwig') {\n            var sa = new Int16Array(data);\n            var la = new Int32Array(data);\n            var fa = new Float32Array(data);\n\n            var chromId = la[0];\n            var blockStart = la[1];\n            var blockEnd = la[2];\n            var itemStep = la[3];\n            var itemSpan = la[4];\n            var blockType = ba[20];\n            var itemCount = sa[11];\n\n            if (blockType == BIG_WIG_TYPE_FSTEP) {\n                for (var i = 0; i < itemCount; ++i) {\n                    var score = fa[i + 6];\n                    var fmin = blockStart + (i*itemStep) + 1, fmax = blockStart + (i*itemStep) + itemSpan;\n                    if (filter(chromId, fmin, fmax))\n                    createFeature(chromId, fmin, fmax, {score: score});\n                }\n            } else if (blockType == BIG_WIG_TYPE_VSTEP) {\n                for (var i = 0; i < itemCount; ++i) {\n                    var start = la[(i*2) + 6] + 1;\n                    var end = start + itemSpan - 1;\n                    var score = fa[(i*2) + 7];\n                    if (filter(chromId, start, end))\n                    createFeature(chromId, start, end, {score: score});\n                }\n            } else if (blockType == BIG_WIG_TYPE_GRAPH) {\n                for (var i = 0; i < itemCount; ++i) {\n                    var start = la[(i*3) + 6] + 1;\n                    var end   = la[(i*3) + 7];\n                    var score = fa[(i*3) + 8];\n                    if (start > end) {\n                        start = end;\n                    }\n                    if (filter(chromId, start, end))\n                    createFeature(chromId, start, end, {score: score});\n                }\n            } else {\n                console.log('Currently not handling bwgType=' + blockType);\n            }\n        } else if (this.bwg.type == 'bigbed') {\n            var offset = 0;\n            var dfc = this.bwg.definedFieldCount;\n            var schema = this.bwg.schema;\n\n            while (offset < ba.length) {\n                var chromId = (ba[offset+3]<<24) | (ba[offset+2]<<16) | (ba[offset+1]<<8) | (ba[offset+0]);\n                var start = (ba[offset+7]<<24) | (ba[offset+6]<<16) | (ba[offset+5]<<8) | (ba[offset+4]);\n                var end = (ba[offset+11]<<24) | (ba[offset+10]<<16) | (ba[offset+9]<<8) | (ba[offset+8]);\n                offset += 12;\n                var rest = '';\n                while (true) {\n                    var ch = ba[offset++];\n                    if (ch != 0) {\n                        rest += String.fromCharCode(ch);\n                    } else {\n                        break;\n                    }\n                }\n\n                var featureOpts = {};\n\n                var bedColumns;\n                if (rest.length > 0) {\n                    bedColumns = rest.split('\\t');\n                } else {\n                    bedColumns = [];\n                }\n                if (bedColumns.length > 0 && dfc > 3) {\n                    featureOpts.label = bedColumns[0];\n                }\n                if (bedColumns.length > 1 && dfc > 4) {\n                    var score = parseInt(bedColumns[1]);\n                    if (!isNaN(score))\n                    featureOpts.score = score;\n                }\n                if (bedColumns.length > 2 && dfc > 5) {\n                    featureOpts.orientation = bedColumns[2];\n                }\n                if (bedColumns.length > 5 && dfc > 8) {\n                    var color = bedColumns[5];\n                    if (BED_COLOR_REGEXP.test(color)) {\n                        featureOpts.itemRgb = 'rgb(' + color + ')';\n                    }\n                }\n\n                if (bedColumns.length > dfc-3 && schema) {\n                    for (var col = dfc - 3; col < bedColumns.length; ++col) {\n                        featureOpts[schema.fields[col+3].name] = bedColumns[col];\n                    }\n                }\n\n                if (filter(chromId, start + 1, end, bedColumns)) {\n                    if (dfc < 12) {\n                        createFeature(chromId, start + 1, end, featureOpts);\n                    } else {\n                        // TODO: add block starts, sizes, thick start, thick end to feature.\n                        var thickStart = bedColumns[3]|0;\n                        var thickEnd   = bedColumns[4]|0;\n                        var blockCount = bedColumns[6]|0;\n                        var blockSizes = bedColumns[7].split(',');\n                        var blockStarts = bedColumns[8].split(',');\n\n                        if (featureOpts.exonFrames) {\n                            var exonFrames = featureOpts.exonFrames.split(',');\n                            featureOpts.exonFrames = undefined;\n                        }\n\n                        featureOpts.type = 'transcript'\n                        var grp = new DASGroup();\n                        for (var k in featureOpts) {\n                            grp[k] = featureOpts[k];\n                        }\n                        grp.id = bedColumns[0];\n                        grp.segment = this.bwg.idsToChroms[chromId];\n                        grp.min = start + 1;\n                        grp.max = end;\n                        grp.notes = [];\n                        featureOpts.groups = [grp];\n\n                        // Moving towards using bigGenePred model, but will\n                        // still support old Dalliance-style BED12+gene-name for the\n                        // foreseeable future.\n                        if (bedColumns.length > 9) {\n                            var geneId = featureOpts.geneName || bedColumns[9];\n                            var geneName = geneId;\n                            if (bedColumns.length > 10) {\n                                geneName = bedColumns[10];\n                            }\n                            if (featureOpts.geneName2)\n                            geneName = featureOpts.geneName2;\n\n                            var gg = $.extend({}, grp);\n                            gg.id = geneId;\n                            gg.label = geneName;\n                            gg.type = 'gene';\n                            featureOpts.groups.push(gg);\n                        }\n\n                        var spanList = [];\n                        for (var b = 0; b < blockCount; ++b) {\n                            var bmin = (blockStarts[b]|0) + start;\n                            var bmax = bmin + (blockSizes[b]|0);\n                            var span = new Range(bmin, bmax);\n                            spanList.push(span);\n                        }\n                        var spans = union(spanList);\n\n                        var tsList = spans.ranges();\n                        for (var s = 0; s < tsList.length; ++s) {\n                            var ts = tsList[s];\n                            createFeature(chromId, ts.min() + 1, ts.max(), featureOpts);\n                        }\n\n                        if (thickEnd > thickStart) {\n                            var codingRegion = (featureOpts.orientation == '+') ?\n                            new Range(thickStart, thickEnd + 3) :\n                            new Range(thickStart - 3, thickEnd);\n                            // +/- 3 to account for stop codon\n\n                            var tl = intersection(spans, codingRegion);\n                            if (tl) {\n                                featureOpts.type = 'translation';\n                                var tlList = tl.ranges();\n                                var readingFrame = 0;\n\n                                var tlOffset = 0;\n                                while (tlList[0].min() > tsList[tlOffset].max())\n                                tlOffset++;\n\n                                for (var s = 0; s < tlList.length; ++s) {\n                                    // Record reading frame for every exon\n                                    var index = s;\n                                    if (featureOpts.orientation == '-')\n                                    index = tlList.length - s - 1;\n                                    var ts = tlList[index];\n                                    featureOpts.readframe = readingFrame;\n                                    if (exonFrames) {\n                                        var brf = parseInt(exonFrames[index + tlOffset]);\n                                        if (typeof(brf) === 'number' && brf >= 0 && brf <= 2) {\n                                            featureOpts.readframe = brf;\n                                            featureOpts.readframeExplicit = true;\n                                        }\n                                    }\n                                    var length = ts.max() - ts.min();\n                                    readingFrame = (readingFrame + length) % 3;\n                                    createFeature(chromId, ts.min() + 1, ts.max(), featureOpts);\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        } else {\n            throw Error(\"Don't know what to do with \" + this.bwg.type);\n        }\n    }\n\n    //\n    // nasty cut/paste, should roll back in!\n    //\n\n    BigWigView.prototype.getFirstAdjacent = function(chrName, pos, dir, callback) {\n        var chr = this.bwg.chromsToIDs[chrName];\n        if (chr === undefined) {\n            // Not an error because some .bwgs won't have data for all chromosomes.\n            return callback([]);\n        } else {\n            this.getFirstAdjacentById(chr, pos, dir, callback);\n        }\n    }\n\n    BigWigView.prototype.getFirstAdjacentById = function(chr, pos, dir, callback) {\n        var thisB = this;\n        if (!this.cirHeader) {\n            this.bwg.data.slice(this.cirTreeOffset, 48).fetch(function(result) {\n                thisB.cirHeader = result;\n                var la = new Int32Array(thisB.cirHeader);\n                thisB.cirBlockSize = la[1];\n                thisB.getFirstAdjacentById(chr, pos, dir, callback);\n            });\n            return;\n        }\n\n        var blockToFetch = null;\n        var bestBlockChr = -1;\n        var bestBlockOffset = -1;\n\n        var outstanding = 0;\n\n        var beforeBWG = Date.now();\n\n        var cirFobRecur = function(offset, level) {\n            outstanding += offset.length;\n\n            var maxCirBlockSpan = 4 +  (thisB.cirBlockSize * 32);   // Upper bound on size, based on a completely full leaf node.\n            var spans;\n            for (var i = 0; i < offset.length; ++i) {\n                var blockSpan = new Range(offset[i], offset[i] + maxCirBlockSpan);\n                spans = spans ? union(spans, blockSpan) : blockSpan;\n            }\n\n            var fetchRanges = spans.ranges();\n            for (var r = 0; r < fetchRanges.length; ++r) {\n                var fr = fetchRanges[r];\n                cirFobStartFetch(offset, fr, level);\n            }\n        }\n\n        var cirFobStartFetch = function(offset, fr, level, attempts) {\n            var length = fr.max() - fr.min();\n            thisB.bwg.data.slice(fr.min(), fr.max() - fr.min()).fetch(function(resultBuffer) {\n                for (var i = 0; i < offset.length; ++i) {\n                    if (fr.contains(offset[i])) {\n                        cirFobRecur2(resultBuffer, offset[i] - fr.min(), level);\n                        --outstanding;\n                        if (outstanding == 0) {\n                            if (!blockToFetch) {\n                                if (dir > 0 && (chr != 0 || pos > 0)) {\n                                    return thisB.getFirstAdjacentById(0, 0, dir, callback);\n                                } else if (dir < 0 && (chr != thisB.bwg.maxID || pos < 1000000000)) {\n                                    return thisB.getFirstAdjacentById(thisB.bwg.maxID, 1000000000, dir, callback);\n                                }\n                                return callback([]);\n                            }\n\n                            thisB.fetchFeatures(function(chrx, fmin, fmax, toks) {\n                                return (dir < 0 && (chrx < chr || fmax < pos)) || (dir > 0 && (chrx > chr || fmin > pos));\n                            }, [blockToFetch], function(features) {\n                                var bestFeature = null;\n                                var bestChr = -1;\n                                var bestPos = -1;\n                                for (var fi = 0; fi < features.length; ++fi) {\n                                    var f = features[fi];\n                                    var chrx = f._chromId, fmin = f.min, fmax = f.max;\n                                    if (bestFeature == null || ((dir < 0) && (chrx > bestChr || fmax > bestPos)) || ((dir > 0) && (chrx < bestChr || fmin < bestPos))) {\n                                        bestFeature = f;\n                                        bestPos = (dir < 0) ? fmax : fmin;\n                                        bestChr = chrx;\n                                    }\n                                }\n\n                                if (bestFeature != null)\n                                return callback([bestFeature]);\n                                else\n                                return callback([]);\n                            });\n                        }\n                    }\n                }\n            });\n        }\n\n        var cirFobRecur2 = function(cirBlockData, offset, level) {\n            var ba = new Uint8Array(cirBlockData);\n            var sa = new Int16Array(cirBlockData);\n            var la = new Int32Array(cirBlockData);\n\n            var isLeaf = ba[offset];\n            var cnt = sa[offset/2 + 1];\n            offset += 4;\n\n            if (isLeaf != 0) {\n                for (var i = 0; i < cnt; ++i) {\n                    var lo = offset/4;\n                    var startChrom = la[lo];\n                    var startBase = la[lo + 1];\n                    var endChrom = la[lo + 2];\n                    var endBase = la[lo + 3];\n                    var blockOffset = bwg_readOffset(ba, offset+16);\n                    var blockSize = bwg_readOffset(ba, offset+24);\n                    if ((dir < 0 && ((startChrom < chr || (startChrom == chr && startBase <= pos)))) ||\n                    (dir > 0 && ((endChrom > chr || (endChrom == chr && endBase >= pos)))))\n                    {\n                        // console.log('Got an interesting block: startBase=' + startChrom + ':' + startBase + '; endBase=' + endChrom + ':' + endBase + '; offset=' + blockOffset + '; size=' + blockSize);\n                        if (/_random/.exec(thisB.bwg.idsToChroms[startChrom])) {\n                            // dlog('skipping random: ' + thisB.bwg.idsToChroms[startChrom]);\n                        } else if (blockToFetch == null || ((dir < 0) && (endChrom > bestBlockChr || (endChrom == bestBlockChr && endBase > bestBlockOffset)) ||\n                        (dir > 0) && (startChrom < bestBlockChr || (startChrom == bestBlockChr && startBase < bestBlockOffset))))\n                        {\n                            //                        dlog('best is: startBase=' + startChrom + ':' + startBase + '; endBase=' + endChrom + ':' + endBase + '; offset=' + blockOffset + '; size=' + blockSize);\n                            blockToFetch = {offset: blockOffset, size: blockSize};\n                            bestBlockOffset = (dir < 0) ? endBase : startBase;\n                            bestBlockChr = (dir < 0) ? endChrom : startChrom;\n                        }\n                    }\n                    offset += 32;\n                }\n            } else {\n                var bestRecur = -1;\n                var bestPos = -1;\n                var bestChr = -1;\n                for (var i = 0; i < cnt; ++i) {\n                    var lo = offset/4;\n                    var startChrom = la[lo];\n                    var startBase = la[lo + 1];\n                    var endChrom = la[lo + 2];\n                    var endBase = la[lo + 3];\n                    var blockOffset = (la[lo + 4]<<32) | (la[lo + 5]);\n                    if ((dir < 0 && ((startChrom < chr || (startChrom == chr && startBase <= pos)) &&\n                    (endChrom   >= chr))) ||\n                    (dir > 0 && ((endChrom > chr || (endChrom == chr && endBase >= pos)) &&\n                    (startChrom <= chr))))\n                    {\n                        if (bestRecur < 0 || endBase > bestPos) {\n                            bestRecur = blockOffset;\n                            bestPos = (dir < 0) ? endBase : startBase;\n                            bestChr = (dir < 0) ? endChrom : startChrom;\n                        }\n                    }\n                    offset += 24;\n                }\n                if (bestRecur >= 0) {\n                    cirFobRecur([bestRecur], level + 1);\n                }\n            }\n        };\n\n\n        cirFobRecur([thisB.cirTreeOffset + 48], 1);\n    }\n\n    /**\n    * Automatically choose a zoom level and return data from that level.\n    */\n    BigWig.prototype.readWigData = function(chrName, min, max) {\n        // Maximum number of data points to return when reading a bigwig. This is used\n        // to choose the appropriate level. One data point ~= 25-65 bytes.\n        // FIXME: For targeted sequencing, data points returned is going to be much lower,\n        // so this will need to be tuned appropriately.\n        var MAX_DATA_POINTS = 25000;\n\n        var range = max - min,\n        view;\n        // If no zooming needed or available (common in bigbed), use unzoomed view.\n        if (range <= MAX_DATA_POINTS || this.zoomLevels.length === 0) {\n            view = this.getUnzoomedView();\n        }\n        else {\n            // Find reasonable zoom level. Reduction is the # of bases represented\n            // by each data point at that level.\n            for (var i = 0; i < this.zoomLevels.length; i++) {\n                if (range/this.zoomLevels[i].reduction < MAX_DATA_POINTS) {\n                    view = this.getZoomedView(i);\n                    break;\n                }\n            }\n        }\n\n        return view.readWigData(chrName, min, max);\n    }\n\n    BigWig.prototype.getUnzoomedView = function() {\n        if (!this.unzoomedView) {\n            var cirLen = 4000;\n            var nzl = this.zoomLevels[0];\n            if (nzl) {\n                cirLen = this.zoomLevels[0].dataOffset - this.unzoomedIndexOffset;\n            }\n            this.unzoomedView = new BigWigView(this, this.unzoomedIndexOffset, cirLen, false);\n        }\n        return this.unzoomedView;\n    }\n\n    BigWig.prototype.getZoomedView = function(z) {\n        var zh = this.zoomLevels[z];\n        if (!zh.view) {\n            zh.view = new BigWigView(this, zh.indexOffset, /* this.zoomLevels[z + 1].dataOffset - zh.indexOffset */ 4000, true);\n        }\n        return zh.view;\n    }\n\n    /**\n     * Create a BigWig object using a URL to a bigwig/bigbed file. Returns a promise\n     * that resolves to the object when it's available.\n     */\n    function makeBwg(url) {\n        var promise = $.Deferred(),\n        bwg = new BigWig();\n        bwg.url = url;\n\n        // Read and parse bigwig header, including chrom tree.\n        $.when(read(bwg.url, 0, 512)).then(function(result) {\n            if (!result) {\n                return promise.resolve(null, \"Couldn't fetch file\");\n            }\n\n            var header = result;\n            var ba = new Uint8Array(header);\n            var sa = new Int16Array(header);\n            var la = new Int32Array(header);\n            var magic = ba[0] + (M1 * ba[1]) + (M2 * ba[2]) + (M3 * ba[3]);\n            if (magic == BIG_WIG_MAGIC) {\n                bwg.type = 'bigwig';\n            } else if (magic == BIG_BED_MAGIC) {\n                bwg.type = 'bigbed';\n            } else if (magic == BIG_WIG_MAGIC_BE || magic == BIG_BED_MAGIC_BE) {\n                return promise.resolve(null, \"Currently don't support big-endian BBI files\");\n\n            } else {\n                return promise.resolve(null, \"Not a supported format, magic=0x\" + magic.toString(16));\n\n            }\n\n            bwg.version = sa[2];             // 4\n            bwg.numZoomLevels = sa[3];       // 6\n            bwg.chromTreeOffset = bwg_readOffset(ba, 8);\n            bwg.unzoomedDataOffset = bwg_readOffset(ba, 16);\n            bwg.unzoomedIndexOffset = bwg_readOffset(ba, 24);\n            bwg.fieldCount = sa[16];         // 32\n            bwg.definedFieldCount = sa[17];  // 34\n            bwg.asOffset = bwg_readOffset(ba, 36);\n            bwg.totalSummaryOffset = bwg_readOffset(ba, 44);\n            bwg.uncompressBufSize = la[13];  // 52\n            bwg.extHeaderOffset = bwg_readOffset(ba, 56);\n\n            bwg.zoomLevels = [];\n            for (var zl = 0; zl < bwg.numZoomLevels; ++zl) {\n                var zlReduction = la[zl*6 + 16]\n                var zlData = bwg_readOffset(ba, zl*24 + 72);\n                var zlIndex = bwg_readOffset(ba, zl*24 + 80);\n                bwg.zoomLevels.push({reduction: zlReduction, dataOffset: zlData, indexOffset: zlIndex});\n            }\n\n            $.when(bwg.readChromTree()).then(function() {\n                bwg.getAutoSQL(function(as) {\n                    bwg.schema = as;\n                    return promise.resolve(bwg);\n                });\n            });\n        });\n\n        return promise;\n    }\n\n\n    BigWig.prototype._tsFetch = function(zoom, chr, min, max, callback) {\n        var bwg = this;\n        if (zoom >= this.zoomLevels.length - 1) {\n            if (!this.topLevelReductionCache) {\n                this.getZoomedView(this.zoomLevels.length - 1).readWigDataById(-1, 0, 300000000, function(feats) {\n                    bwg.topLevelReductionCache = feats;\n                    return bwg._tsFetch(zoom, chr, min, max, callback);\n                });\n            } else {\n                var f = [];\n                var c = this.topLevelReductionCache;\n                for (var fi = 0; fi < c.length; ++fi) {\n                    if (c[fi]._chromId == chr) {\n                        f.push(c[fi]);\n                    }\n                }\n                return callback(f);\n            }\n        } else {\n            var view;\n            if (zoom < 0) {\n                view = this.getUnzoomedView();\n            } else {\n                view = this.getZoomedView(zoom);\n            }\n            return view.readWigDataById(chr, min, max, callback);\n        }\n    }\n\n    BigWig.prototype.thresholdSearch = function(chrName, referencePoint, dir, threshold, callback) {\n        dir = (dir<0) ? -1 : 1;\n        var bwg = this;\n        var initialChr = this.chromsToIDs[chrName];\n        var candidates = [{chrOrd: 0, chr: initialChr, zoom: bwg.zoomLevels.length - 4, min: 0, max: 300000000, fromRef: true}]\n        for (var i = 1; i <= this.maxID + 1; ++i) {\n            var chrId = (initialChr + (dir*i)) % (this.maxID + 1);\n            if (chrId < 0)\n            chrId += (this.maxID + 1);\n            candidates.push({chrOrd: i, chr: chrId, zoom: bwg.zoomLevels.length - 1, min: 0, max: 300000000})\n        }\n\n        function fbThresholdSearchRecur() {\n            if (candidates.length == 0) {\n                return callback(null);\n            }\n            candidates.sort(function(c1, c2) {\n                var d = c1.zoom - c2.zoom;\n                if (d != 0)\n                return d;\n\n                d = c1.chrOrd - c2.chrOrd;\n                if (d != 0)\n                return d;\n                else\n                return c1.min - c2.min * dir;\n            });\n\n            var candidate = candidates.splice(0, 1)[0];\n            bwg._tsFetch(candidate.zoom, candidate.chr, candidate.min, candidate.max, function(feats) {\n                var rp = dir > 0 ? 0 : 300000000;\n                if (candidate.fromRef)\n                rp = referencePoint;\n\n                for (var fi = 0; fi < feats.length; ++fi) {\n                    var f = feats[fi];\n                    var score;\n                    if (f.maxScore != undefined)\n                    score = f.maxScore;\n                    else\n                    score = f.score;\n\n                    if (dir > 0) {\n                        if (score > threshold) {\n                            if (candidate.zoom < 0) {\n                                if (f.min > rp)\n                                return callback(f);\n                            } else if (f.max > rp) {\n                                candidates.push({chr: candidate.chr, chrOrd: candidate.chrOrd, zoom: candidate.zoom - 2, min: f.min, max: f.max, fromRef: candidate.fromRef});\n                            }\n                        }\n                    } else {\n                        if (score > threshold) {\n                            if (candidate.zoom < 0) {\n                                if (f.max < rp)\n                                return callback(f);\n                            } else if (f.min < rp) {\n                                candidates.push({chr: candidate.chr, chrOrd: candidate.chrOrd, zoom: candidate.zoom - 2, min: f.min, max: f.max, fromRef: candidate.fromRef});\n                            }\n                        }\n                    }\n                }\n                fbThresholdSearchRecur();\n            });\n        }\n\n        fbThresholdSearchRecur();\n    }\n\n    BigWig.prototype.getAutoSQL = function(callback) {\n        var thisB = this;\n        if (!this.asOffset)\n        return callback(null);\n\n        $.when(read(this.url, this.asOffset, 2048)).then(function(result) {\n            var ba = new Uint8Array(result);\n            var s = '';\n            for (var i = 0; i < ba.length; ++i) {\n                if (ba[i] == 0)\n                break;\n                s += String.fromCharCode(ba[i]);\n            }\n\n            /*\n            * Quick'n'dirty attempt to parse autoSql format.\n            * See: http://www.linuxjournal.com/files/linuxjournal.com/linuxjournal/articles/059/5949/5949l2.html\n            */\n\n            var header_re = /(\\w+)\\s+(\\w+)\\s+(\"([^\"]+)\")?\\s+\\(\\s*/;\n                var field_re = /([\\w\\[\\]]+)\\s+(\\w+)\\s*;\\s*(\"([^\"]+)\")?\\s*/g;\n\n            var headerMatch = header_re.exec(s);\n            if (headerMatch) {\n                var as = {\n                    declType: headerMatch[1],\n                    name: headerMatch[2],\n                    comment: headerMatch[4],\n\n                    fields: []\n                };\n\n                s = s.substring(headerMatch[0]);\n                for (var m = field_re.exec(s); m != null; m = field_re.exec(s)) {\n                    as.fields.push({type: m[1],\n                        name: m[2],\n                        comment: m[4]});\n                    }\n\n                    return callback(as);\n                }\n        });\n    };\n\n    BigWig.prototype.getExtraIndices = function(callback) {\n        var thisB = this;\n        if (this.version < 4 || this.extHeaderOffset == 0 || this.type != 'bigbed') {\n            return callback(null);\n        } else {\n            this.data.slice(this.extHeaderOffset, 64).fetch(function(result) {\n                if (!result) {\n                    return callback(null, \"Couldn't fetch extension header\");\n                }\n\n                var ba = new Uint8Array(result);\n                var sa = new Int16Array(result);\n                var la = new Int32Array(result);\n\n                var extHeaderSize = sa[0];\n                var extraIndexCount = sa[1];\n                var extraIndexListOffset = bwg_readOffset(ba, 4);\n\n                if (extraIndexCount == 0) {\n                    return callback(null);\n                }\n\n                // FIXME 20byte records only make sense for single-field indices.\n                // Right now, these seem to be the only things around, but the format\n                // is actually more general.\n                thisB.data.slice(extraIndexListOffset, extraIndexCount * 20).fetch(function(eil) {\n                    if (!eil) {\n                        return callback(null, \"Couldn't fetch index info\");\n                    }\n\n                    var ba = new Uint8Array(eil);\n                    var sa = new Int16Array(eil);\n                    var la = new Int32Array(eil);\n\n                    var indices = [];\n                    for (var ii = 0; ii < extraIndexCount; ++ii) {\n                        var eiType = sa[ii*10];\n                        var eiFieldCount = sa[ii*10 + 1];\n                        var eiOffset = bwg_readOffset(ba, ii*20 + 4);\n                        var eiField = sa[ii*10 + 8]\n                        var index = new BBIExtraIndex(thisB, eiType, eiFieldCount, eiOffset, eiField);\n                        indices.push(index);\n                    }\n                    callback(indices);\n                });\n            });\n        }\n    }\n\n    function BBIExtraIndex(bbi, type, fieldCount, offset, field) {\n        this.bbi = bbi;\n        this.type = type;\n        this.fieldCount = fieldCount;\n        this.offset = offset;\n        this.field = field;\n    }\n\n    BBIExtraIndex.prototype.lookup = function(name, callback) {\n        var thisB = this;\n\n        this.bbi.data.slice(this.offset, 32).fetch(function(bpt) {\n            var ba = new Uint8Array(bpt);\n            var sa = new Int16Array(bpt);\n            var la = new Int32Array(bpt);\n            var bptMagic = la[0];\n            var blockSize = la[1];\n            var keySize = la[2];\n            var valSize = la[3];\n            var itemCount = bwg_readOffset(ba, 16);\n            var rootNodeOffset = 32;\n\n            function bptReadNode(nodeOffset) {\n                thisB.bbi.data.slice(nodeOffset, 4 + (blockSize * (keySize + valSize))).fetch(function(node) {\n                    var ba = new Uint8Array(node);\n                    var sa = new Uint16Array(node);\n                    var la = new Uint32Array(node);\n\n                    var nodeType = ba[0];\n                    var cnt = sa[1];\n\n                    var offset = 4;\n                    if (nodeType == 0) {\n                        var lastChildOffset = null;\n                        for (var n = 0; n < cnt; ++n) {\n                            var key = '';\n                            for (var ki = 0; ki < keySize; ++ki) {\n                                var charCode = ba[offset++];\n                                if (charCode != 0) {\n                                    key += String.fromCharCode(charCode);\n                                }\n                            }\n\n                            var childOffset = bwg_readOffset(ba, offset);\n                            offset += 8;\n\n                            if (name.localeCompare(key) < 0 && lastChildOffset) {\n                                bptReadNode(lastChildOffset);\n                                return;\n                            }\n                            lastChildOffset = childOffset;\n                        }\n                        bptReadNode(lastChildOffset);\n                    } else {\n                        for (var n = 0; n < cnt; ++n) {\n                            var key = '';\n                            for (var ki = 0; ki < keySize; ++ki) {\n                                var charCode = ba[offset++];\n                                if (charCode != 0) {\n                                    key += String.fromCharCode(charCode);\n                                }\n                            }\n\n                            // Specific for EI case.\n                            if (key == name) {\n                                var start = bwg_readOffset(ba, offset);\n                                var length = readInt(ba, offset + 8);\n\n                                return thisB.bbi.getUnzoomedView().fetchFeatures(\n                                    function(chr, min, max, toks) {\n                                        if (toks && toks.length > thisB.field - 3)\n                                        return toks[thisB.field - 3] == name;\n                                    },\n                                    [{offset: start, size: length}],\n                                    callback);\n                                }\n                                offset += valSize;\n                            }\n                            return callback([]);\n                        }\n                    });\n                }\n\n                bptReadNode(thisB.offset + rootNodeOffset);\n        });\n    }\n\n    return {\n        makeBwg: makeBwg\n    };\n});\n"]}