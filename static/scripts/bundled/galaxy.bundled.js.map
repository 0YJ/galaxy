{"version":3,"sources":["webpack:///galaxy.bundled.js","webpack:///./galaxy/scripts/apps/galaxy.js","webpack:///./galaxy/scripts/galaxy-app-base.js","webpack:///./galaxy/scripts/utils/metrics-logger.js"],"names":["webpackJsonp","module","exports","__webpack_require__","GalaxyApp","window","console","debug",67,"__WEBPACK_AMD_DEFINE_ARRAY__","__WEBPACK_AMD_DEFINE_RESULT__","$","_","Backbone","BASE_MVC","userModel","metricsLogger","addLogging","localize","options","bootstrapped","self","this","_init","DEBUGGING_KEY","NAMESPACE_KEY","localDebugging","localStorage","getItem","storageErr","log","prototype","extend","Events","logger","_processOptions","root","_initConfig","config","_patchGalaxy","Galaxy","_initLogger","loggerOptions","_initLocale","_initUser","user","_setUpListeners","trigger","defaultOptions","patchExisting","defaults","k","hasOwnProperty","patchWith","consoleLogger","consoleLevel","MetricsLogger","ALL","consoleNamespaceWhitelist","split","LoggableMixin","_l","userJSON","User","currUser","lastAjax","document","bind","ev","xhr","data","JSON","parse","err","url","location","href","slice","debugging","setting","undefined","setItem","removeItem","debuggingNamespaces","namespaces","csv","newSettings","toString","userEmail","get","apply","call",125,"jQuery","userId","id","LoggingCache","LOG","DEBUG","INFO","WARN","ERROR","METRIC","NONE","logLevel","defaultNamespace","clientPrefix","maxCacheSize","postSize","addTime","cacheKeyPrefix","postUrl","delayPostInMs","getPingData","onServerResponse","_parseLevel","_sending","_waiting","_postSize","_initCache","cache","maxSize","key","_emitToConsole","level","type","upper","toUpperCase","Error","emit","namespace","logArguments","_addToCache","arguments","length","newLength","add","_buildEntry","_postCache","entry","args","time","Date","toISOString","when","count","entries","entriesLength","postData","metrics","stringify","post","always","fail","status","message","readyState","responseJSON","responseText","done","response","remove","_delayPost","setTimeout","whitelist","indexOf","Array","unshift","info","error","warn","metric","_hasStorage","_initStorage","test","e","empty","_cache","_fetchAndParse","overage","splice","push","_unparseAndStore","removed","print"],"mappings":"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","file":"galaxy.bundled.js","sourcesContent":["webpackJsonp([3],{\n\n/***/ 0:\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar GalaxyApp = __webpack_require__( 67 ).GalaxyApp;\n\twindow.GalaxyApp = GalaxyApp;\n\tconsole.debug( 'galaxy.js, GalaxyApp is now in window' );\n\texports = GalaxyApp;\n\n\n/***/ },\n\n/***/ 67:\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function($) {!(__WEBPACK_AMD_DEFINE_ARRAY__ = [\n\t    __webpack_require__(3),\n\t    __webpack_require__(2),\n\t    __webpack_require__(6),\n\t    __webpack_require__(59),\n\t    __webpack_require__(125),\n\t    __webpack_require__(63),\n\t    __webpack_require__(5)\n\t], __WEBPACK_AMD_DEFINE_RESULT__ = function( _, Backbone, BASE_MVC, userModel, metricsLogger, addLogging, localize ){\n\t\n\t// TODO: move into a singleton pattern and have dependents import Galaxy\n\t// ============================================================================\n\t/** Base galaxy client-side application.\n\t *      Iniitializes:\n\t *          logger      : the logger/metrics-logger\n\t *          localize    : the string localizer\n\t *          config      : the current configuration (any k/v in\n\t *              galaxy.ini available from the configuration API)\n\t *          user        : the current user (as a mvc/user/user-model)\n\t */\n\tfunction GalaxyApp( options, bootstrapped ){\n\t    console.debug( 'GalaxyApp:', options, bootstrapped );\n\t    var self = this;\n\t    return self._init( options || {}, bootstrapped || {} );\n\t}\n\t\n\t// add logging shortcuts for this object\n\taddLogging( GalaxyApp, 'GalaxyApp' );\n\t\n\t// a debug flag can be set via local storage and made available during script/page loading\n\tvar DEBUGGING_KEY = 'galaxy:debug',\n\t    NAMESPACE_KEY = DEBUGGING_KEY + ':namespaces',\n\t    localDebugging = false;\n\ttry {\n\t    localDebugging = localStorage.getItem( DEBUGGING_KEY ) == 'true';\n\t} catch( storageErr ){\n\t    console.log( localize( 'localStorage not available for debug flag retrieval' ) );\n\t}\n\t\n\t/** initalize options and sub-components */\n\tGalaxyApp.prototype._init = function __init( options, bootstrapped ){\n\t    var self = this;\n\t    _.extend( self, Backbone.Events );\n\t    if( localDebugging ){\n\t        self.logger = console;\n\t    }\n\t\n\t    self._processOptions( options );\n\t    self.debug( 'GalaxyApp.options: ', self.options );\n\t    // special case for root\n\t    self.root = options.root || '/';\n\t\n\t    self._initConfig( options.config || bootstrapped.config || {} );\n\t    self.debug( 'GalaxyApp.config: ', self.config );\n\t\n\t    self._patchGalaxy( window.Galaxy );\n\t\n\t    self._initLogger( self.options.loggerOptions || {} );\n\t    self.debug( 'GalaxyApp.logger: ', self.logger );\n\t\n\t    self._initLocale();\n\t    self.debug( 'GalaxyApp.localize: ', self.localize );\n\t\n\t    self.config = options.config || {};\n\t    self.debug( 'GalaxyApp.config: ', self.config );\n\t\n\t    self._initUser( options.user || {} );\n\t    self.debug( 'GalaxyApp.user: ', self.user );\n\t\n\t    self._setUpListeners();\n\t    self.trigger( 'ready', self );\n\t\n\t    return self;\n\t};\n\t\n\t/** default options */\n\tGalaxyApp.prototype.defaultOptions = {\n\t    /** monkey patch attributes from existing window.Galaxy object? */\n\t    patchExisting   : true,\n\t    /** root url of this app */\n\t    // move to self.root?\n\t    root            : '/'\n\t};\n\t\n\t/** add an option from options if the key matches an option in defaultOptions */\n\tGalaxyApp.prototype._processOptions = function _processOptions( options ){\n\t    var self = this,\n\t        defaults = self.defaultOptions;\n\t    self.debug( '_processOptions: ', options );\n\t\n\t    self.options = {};\n\t    for( var k in defaults ){\n\t        if( defaults.hasOwnProperty( k ) ){\n\t            self.options[ k ] = ( options.hasOwnProperty( k ) )?( options[ k ] ):( defaults[ k ] );\n\t        }\n\t    }\n\t    return self;\n\t};\n\t\n\t/** parse the config and any extra info derived from it */\n\tGalaxyApp.prototype._initConfig = function _initConfig( config ){\n\t    var self = this;\n\t    self.debug( '_initConfig: ', config );\n\t    self.config = config;\n\t\n\t    // give precendence to localdebugging for this setting\n\t    self.config.debug = localDebugging || self.config.debug;\n\t\n\t    return self;\n\t};\n\t\n\t/** add an option from options if the key matches an option in defaultOptions */\n\tGalaxyApp.prototype._patchGalaxy = function _patchGalaxy( patchWith ){\n\t    var self = this;\n\t    // in case req or plain script tag order has created a prev. version of the Galaxy obj...\n\t    if( self.options.patchExisting && patchWith ){\n\t        self.debug( 'found existing Galaxy object:', patchWith );\n\t        // ...(for now) monkey patch any added attributes that the previous Galaxy may have had\n\t        //TODO: move those attributes to more formal assignment in GalaxyApp\n\t        for( var k in patchWith ){\n\t            if( patchWith.hasOwnProperty( k ) ){\n\t                self.debug( '\\t patching in ' + k + ' to Galaxy' );\n\t                self[ k ] = patchWith[ k ];\n\t            }\n\t        }\n\t    }\n\t};\n\t\n\t/** set up the metrics logger (utils/metrics-logger) and pass loggerOptions */\n\tGalaxyApp.prototype._initLogger = function _initLogger( loggerOptions ){\n\t    var self = this;\n\t    // default to console logging at the debug level if the debug flag is set\n\t    if( self.config.debug ){\n\t        loggerOptions.consoleLogger = loggerOptions.consoleLogger || console;\n\t        loggerOptions.consoleLevel = loggerOptions.consoleLevel || metricsLogger.MetricsLogger.ALL;\n\t        // load any logging namespaces from localStorage if we can\n\t        try {\n\t            loggerOptions.consoleNamespaceWhitelist = localStorage.getItem( NAMESPACE_KEY ).split( ',' );\n\t        } catch( storageErr ){}\n\t    }\n\t    self.debug( '_initLogger:', loggerOptions );\n\t    self.logger = new metricsLogger.MetricsLogger( loggerOptions );\n\t\n\t    if( self.config.debug ){\n\t        // add this logger to mvc's loggable mixin so that all models can use the logger\n\t        BASE_MVC.LoggableMixin.logger = self.logger;\n\t    }\n\t    return self;\n\t};\n\t\n\t/** add the localize fn to this object and the window namespace (as '_l') */\n\tGalaxyApp.prototype._initLocale = function _initLocale( options ){\n\t    var self = this;\n\t    self.debug( '_initLocale:', options );\n\t    self.localize = localize;\n\t    // add to window as global shortened alias\n\t    window._l = self.localize;\n\t    return self;\n\t};\n\t\n\t/** set up the current user as a Backbone model (mvc/user/user-model) */\n\tGalaxyApp.prototype._initUser = function _initUser( userJSON ){\n\t    var self = this;\n\t    self.debug( '_initUser:', userJSON );\n\t    self.user = new userModel.User( userJSON );\n\t    self.user.logger = self.logger;\n\t    //TODO: temp - old alias\n\t    self.currUser = self.user;\n\t    return self;\n\t};\n\t\n\t/** Set up DOM/jQuery/Backbone event listeners enabled for all pages */\n\tGalaxyApp.prototype._setUpListeners = function _setUpListeners(){\n\t    var self = this;\n\t\n\t    // hook to jq beforeSend to record the most recent ajax call and cache some data about it\n\t    /** cached info about the last ajax call made through jQuery */\n\t    self.lastAjax = {};\n\t    $( document ).bind( 'ajaxSend', function( ev, xhr, options ){\n\t        var data = options.data;\n\t        try {\n\t            data = JSON.parse( data );\n\t        } catch( err ){}\n\t\n\t        self.lastAjax = {\n\t            url     : location.href.slice( 0, -1 ) + options.url,\n\t            data    : data\n\t        };\n\t        //TODO:?? we might somehow manage to *retry* ajax using either this hook or Backbone.sync\n\t    });\n\t    return self;\n\t};\n\t\n\t/** Turn debugging/console-output on/off by passing boolean. Pass nothing to get current setting. */\n\tGalaxyApp.prototype.debugging = function _debugging( setting ){\n\t    var self = this;\n\t    try {\n\t        if( setting === undefined ){\n\t            return localStorage.getItem( DEBUGGING_KEY ) === 'true';\n\t        }\n\t        if( setting ){\n\t            localStorage.setItem( DEBUGGING_KEY, true );\n\t            return true;\n\t        }\n\t\n\t        localStorage.removeItem( DEBUGGING_KEY );\n\t        // also remove all namespaces\n\t        self.debuggingNamespaces( null );\n\t\n\t    } catch( storageErr ){\n\t        console.log( localize( 'localStorage not available for debug flag retrieval' ) );\n\t    }\n\t    return false;\n\t};\n\t\n\t/** Add, remove, or clear namespaces from the debugging filters\n\t *  Pass no arguments to retrieve the existing namespaces as an array.\n\t *  Pass in null to clear all namespaces (all logging messages will show now).\n\t *  Pass in an array of strings or single string of the namespaces to filter to.\n\t *  Returns the new/current namespaces as an array;\n\t */\n\tGalaxyApp.prototype.debuggingNamespaces = function _debuggingNamespaces( namespaces ){\n\t    var self = this;\n\t    try {\n\t        if( namespaces === undefined ){\n\t            var csv = localStorage.getItem( NAMESPACE_KEY );\n\t            return typeof( csv ) === 'string'? csv.split( ',' ) : [];\n\t        } else if( namespaces === null ) {\n\t            localStorage.removeItem( NAMESPACE_KEY );\n\t        } else {\n\t            localStorage.setItem( NAMESPACE_KEY, namespaces );\n\t        }\n\t        var newSettings = self.debuggingNamespaces();\n\t        if( self.logger ){\n\t            self.logger.options.consoleNamespaceWhitelist = newSettings;\n\t        }\n\t        return newSettings;\n\t    } catch( storageErr ){\n\t        console.log( localize( 'localStorage not available for debug namespace retrieval' ) );\n\t    }\n\t};\n\t\n\t/** string rep */\n\tGalaxyApp.prototype.toString = function toString(){\n\t    var userEmail = this.user? ( this.user.get( 'email' ) || '(anonymous)' ) : 'uninitialized';\n\t    return 'GalaxyApp(' + userEmail + ')';\n\t};\n\t\n\t\n\t// ============================================================================\n\t    return {\n\t        GalaxyApp : GalaxyApp\n\t    };\n\t}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))\n\n/***/ },\n\n/***/ 125:\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(jQuery) {!(__WEBPACK_AMD_DEFINE_ARRAY__ = [\n\t], __WEBPACK_AMD_DEFINE_RESULT__ = function(){\n\t/*global window, jQuery, console */\n\t/*=============================================================================\n\tTODO:\n\t    while anon: logs saved to 'logs-null' - this will never post\n\t        unless we manually do so at/after login\n\t        OR prepend when userId and localStorage has 'logs-null'\n\t    wire up _delayPost and test\n\t\n\t=============================================================================*/\n\t/** @class MetricsLogger\n\t *\n\t *  Object to cache, output, and post log/metric messages to the server.\n\t *  Meant to be attached to the Galaxy object.\n\t *\n\t *  Log from objects by either attaching logger directly:\n\t *      panel.logger.metric( 'user dataset deletion', panel.user.id, hda.toJSON() )\n\t *  or using the LoggableMixin or addLogging function:\n\t *      MyBackboneModel.extend( LoggableMixin ).extend({ ... })\n\t *      addLogging( MyBackboneModel, 'my-backbone-model' )\n\t *\n\t *  Log from templates by calling directly from Galaxy object:\n\t *      Galaxy.logger.metric( 'template loaded', { ownedByUser : true });\n\t *\n\t *  If you attempt to log an un-serializable object (circular reference, window, etc.),\n\t *  that entry will not be cached (or sent). If you set consoleLevel and consoleLogger\n\t *  appropriately, a warning will be shown when this happens:\n\t *      > panel.metric( 'something weird with window', { window : window })\n\t *      !'Metrics logger could not stringify logArguments: ...'\n\t */\n\tfunction MetricsLogger( options ){\n\t    options = options || {};\n\t    var self = this;\n\t\n\t    ///** get the current user's id from bootstrapped data or options */\n\t    self.userId = ( window.bootstrapped && window.bootstrapped.user )? window.bootstrapped.user.id: null;\n\t    self.userId = self.userId || options.userId || null;\n\t\n\t    /** the (optional) console to emit logs to */\n\t    self.consoleLogger = options.consoleLogger || null;\n\t\n\t    self._init( options );\n\t    return self;\n\t}\n\t\n\t//----------------------------------------------------------------------------- defaults and constants\n\t// see: python std lib, logging\n\tMetricsLogger.ALL   =  0;\n\tMetricsLogger.LOG   =  0;\n\tMetricsLogger.DEBUG = 10;\n\tMetricsLogger.INFO  = 20;\n\tMetricsLogger.WARN  = 30;\n\tMetricsLogger.ERROR = 40;\n\t// metrics levels here?\n\t//MetricsLogger.MinorEvent  = 45;\n\t//MetricsLogger.MajorEvent  = 50;\n\tMetricsLogger.METRIC = 50;\n\tMetricsLogger.NONE = 100;\n\t\n\t/** default options - override these through the constructor */\n\tMetricsLogger.defaultOptions = {\n\t    /** if an incoming message has a level >= this, it will be cached - can also be a string (e.g. 'debug') */\n\t    logLevel            : MetricsLogger.NONE,\n\t    /** if an incoming message has a level >= this, it will be output to the console */\n\t    consoleLevel        : MetricsLogger.NONE,\n\t    /** the default 'namespace' or label associated with an incoming message (if none is passed) */\n\t    defaultNamespace    : 'Galaxy',\n\t    /** the namespaces output to the console (all namespaces will be output if this is falsy)\n\t     *  note: applies only to the console (not the event/metrics log/cache)\n\t     */\n\t    consoleNamespaceWhitelist : null,\n\t    /** the prefix attached to client-side logs to distinguish them in the metrics db */\n\t    clientPrefix        : 'client.',\n\t\n\t    /** the maximum number of messages the cache should hold; if exceeded older messages are removed first */\n\t    maxCacheSize        : 3000,\n\t    /** the number of messages accumulate before posting to the server; should be <= maxCacheSize */\n\t    postSize            : 1000,\n\t    /** T/F whether to add a timestamp to incoming cached messages */\n\t    addTime             : true,\n\t    /** string to prefix to userid for cache web storage */\n\t    cacheKeyPrefix      : 'logs-',\n\t\n\t    /** the relative url to post messages to */\n\t    postUrl             : '/api/metrics',\n\t    /** delay before trying post again after two failures */\n\t    delayPostInMs       : 1000 * 60 * 10,\n\t\n\t    /** an (optional) function that should return an object; used to send additional data with the metrics */\n\t    getPingData         : undefined,\n\t    /** an (optional) function that will handle the servers response after successfully posting messages */\n\t    onServerResponse    : undefined\n\t};\n\t\n\t//----------------------------------------------------------------------------- set up\n\t/** initialize the logger with options, set up instance vars and cache, and add onpageunload to window */\n\tMetricsLogger.prototype._init = function _init( options ){\n\t    var self = this;\n\t    self.options = {};\n\t    for( var k in MetricsLogger.defaultOptions ){\n\t        if( MetricsLogger.defaultOptions.hasOwnProperty( k ) ){\n\t            self.options[ k ] = ( options.hasOwnProperty( k ) )?( options[ k ] ):( MetricsLogger.defaultOptions[ k ] );\n\t        }\n\t    }\n\t    self.options.logLevel = self._parseLevel( self.options.logLevel );\n\t    self.options.consoleLevel = self._parseLevel( self.options.consoleLevel );\n\t    //self._emitToConsole( 'debug', 'MetricsLogger', 'MetricsLogger.options:', self.options );\n\t\n\t    /** is the logger currently sending? */\n\t    self._sending = false;\n\t    /** the setTimeout id if the logger POST has failed more than once */\n\t    self._waiting = null;\n\t    /** the current number of entries to send in a POST */\n\t    self._postSize = self.options.postSize;\n\t\n\t    self._initCache();\n\t\n\t    return self;\n\t};\n\t\n\t/** initialize the cache */\n\tMetricsLogger.prototype._initCache = function _initCache(){\n\t    try {\n\t        this.cache = new LoggingCache({\n\t            maxSize : this.options.maxCacheSize,\n\t            key     : this.options.cacheKeyPrefix + this.userId\n\t        });\n\t    } catch( err ){\n\t        this._emitToConsole( 'warn', 'MetricsLogger', [ 'Could not intitialize logging cache:', err ] );\n\t        this.options.logLevel = MetricsLogger.NONE;\n\t    }\n\t};\n\t\n\t/** return the numeric log level if level in 'none, debug, log, info, warn, error' */\n\tMetricsLogger.prototype._parseLevel = function _parseLevel( level ){\n\t    var type = typeof level;\n\t    if( type === 'number' ){ return level; }\n\t    if( type === 'string' ){\n\t        var upper = level.toUpperCase();\n\t        if( MetricsLogger.hasOwnProperty( upper ) ){\n\t            return MetricsLogger[ upper ];\n\t        }\n\t    }\n\t    throw new Error( 'Unknown log level: ' + level );\n\t};\n\t\n\t\n\t//----------------------------------------------------------------------------- main entry point\n\t/** record a log/message's arguments to the cache and/or the console based on level and namespace */\n\tMetricsLogger.prototype.emit = function emit( level, namespace, logArguments ){\n\t    //this._emitToConsole( 'debug', 'MetricsLogger', [ 'emit:', level, namespace, logArguments ]);\n\t    var self = this;\n\t    namespace = namespace || self.options.defaultNamespace;\n\t    if( !level || !logArguments ){\n\t        return self;\n\t    }\n\t    // add to cache if proper level\n\t    //TODO: respect do not track?\n\t    //if( !navigator.doNotTrack && level >= self.options.logLevel ){\n\t    level = self._parseLevel( level );\n\t    if( level >= self.options.logLevel ){\n\t        self._addToCache( level, namespace, logArguments );\n\t    }\n\t    // also emit to consoleLogger if proper level for that\n\t    if( self.consoleLogger && level >= self.options.consoleLevel ){\n\t        self._emitToConsole( level, namespace, logArguments );\n\t    }\n\t    return self;\n\t};\n\t\n\t//----------------------------------------------------------------------------- cache\n\t/** add a message to the cache and if messages.length is high enough post them to the server */\n\tMetricsLogger.prototype._addToCache = function _addToCache( level, namespace, logArguments ){\n\t    this._emitToConsole( 'debug', 'MetricsLogger',\n\t        [ '_addToCache:', arguments, this.options.addTime, this.cache.length() ]);\n\t    //this._emitToConsole( 'debug', 'MetricsLogger', [ '\\t logArguments:', logArguments ]);\n\t    var self = this;\n\t    // try add to the cache and if we've got _postSize number of entries, attempt to post them to the server\n\t    try {\n\t        var newLength = self.cache.add( self._buildEntry( level, namespace, logArguments ) );\n\t        if( newLength >= self._postSize ){\n\t            self._postCache();\n\t        }\n\t    // discard entry if an error occurs, but warn if level set to do so\n\t    } catch( err ){\n\t        self._emitToConsole( 'warn', 'MetricsLogger',\n\t            [ 'Metrics logger could not stringify logArguments:', namespace, logArguments ] );\n\t        self._emitToConsole( 'error', 'MetricsLogger', [ err ] );\n\t\n\t    }\n\t    return self;\n\t};\n\t\n\t/** build a log cache entry object from the given level, namespace, and arguments (optionally adding timestamp */\n\tMetricsLogger.prototype._buildEntry = function _buildEntry( level, namespace, logArguments ){\n\t    this._emitToConsole( 'debug', 'MetricsLogger', [ '_buildEntry:', arguments ]);\n\t    var entry = {\n\t            level       : level,\n\t            namespace   : this.options.clientPrefix + namespace,\n\t            args        : logArguments\n\t        };\n\t    if( this.options.addTime ){\n\t        entry.time = new Date().toISOString();\n\t    }\n\t    return entry;\n\t};\n\t\n\t/** post _postSize messages from the cache to the server, removing them if successful\n\t *      if the post fails, wait until maxCacheSize is accumulated instead and try again then\n\t *      in addition to the messages from the cache ('metrics'), any info from getPingData (if set) will be sent\n\t *      onServerResponse will be called (if set) with any response from the server\n\t */\n\tMetricsLogger.prototype._postCache = function _postCache( options ){\n\t    options = options || {};\n\t    this._emitToConsole( 'info', 'MetricsLogger', [ '_postCache', options, this._postSize ]);\n\t\n\t    // short circuit if we're already sending\n\t    if( !this.options.postUrl || this._sending ){\n\t        return jQuery.when({});\n\t    }\n\t\n\t    var self = this,\n\t        postSize = options.count || self._postSize,\n\t        // do not splice - remove after *successful* post\n\t        entries = self.cache.get( postSize ),\n\t        entriesLength = entries.length,\n\t        // use the optional getPingData to add any extra info we may want to send\n\t        postData = ( typeof self.options.getPingData === 'function' )?( self.options.getPingData() ):( {} );\n\t    //console.debug( postSize, entriesLength );\n\t\n\t    // add the metrics and send\n\t    postData.metrics = JSON.stringify( entries );\n\t    //console.debug( postData.metrics );\n\t    self._sending = true;\n\t    return jQuery.post( self.options.postUrl, postData )\n\t        .always( function(){\n\t            self._sending = false;\n\t        })\n\t        .fail( function( xhr, status, message ){\n\t            // if we failed the previous time, set the next post target to the max num of entries\n\t            self._postSize = self.options.maxCacheSize;\n\t//TODO:??\n\t            // log this failure to explain any gap in metrics\n\t            this.emit( 'error', 'MetricsLogger', [ '_postCache error:',\n\t                xhr.readyState, xhr.status, xhr.responseJSON || xhr.responseText ]);\n\t//TODO: still doesn't solve the problem that when cache == max, post will be tried on every emit\n\t//TODO: see _delayPost\n\t        })\n\t        .done( function( response ){\n\t            if( typeof self.options.onServerResponse === 'function' ){\n\t                self.options.onServerResponse( response );\n\t            }\n\t            // only remove if post successful\n\t            self.cache.remove( entriesLength );\n\t            //console.debug( 'removed entries:', entriesLength, 'size now:', self.cache.length() );\n\t            // if we succeeded, reset the post target to the normal num of entries\n\t            self._postSize = self.options.postSize;\n\t        });\n\t    // return the xhr promise\n\t};\n\t\n\t/** set _waiting to true and, after delayPostInMs, set it back to false */\n\tMetricsLogger.prototype._delayPost = function _delayPost(){\n\t//TODO: this won't work between pages\n\t    var self = this;\n\t    self._waiting = setTimeout( function(){\n\t        self._waiting = null;\n\t    }, self.options.delayPostInMs );\n\t};\n\t\n\t\n\t//----------------------------------------------------------------------------- console\n\t/** output message to console based on level and consoleLogger type */\n\tMetricsLogger.prototype._emitToConsole = function _emitToConsole( level, namespace, logArguments ){\n\t    //console.debug( '_emitToConsole:', level, namespace, logArguments );\n\t    var self = this,\n\t        whitelist = self.options.consoleNamespaceWhitelist;\n\t    if( !self.consoleLogger ){ return self; }\n\t    // if a whitelist for namespaces is set, bail if this namespace is not in the list\n\t    if( whitelist && whitelist.indexOf( namespace ) === -1 ){\n\t        return self;\n\t    }\n\t\n\t    var args = Array.prototype.slice.call( logArguments, 0 );\n\t    args.unshift( namespace );\n\t//TODO: script location and/or source maps?\n\t//TODO: branch on navigator.userAgent == AIIEEE - it only has log\n\t    if(        level >= MetricsLogger.METRIC && typeof( self.consoleLogger.info ) === 'function' ){\n\t        return self.consoleLogger.info.apply( self.consoleLogger, args );\n\t\n\t    } else if( level >= MetricsLogger.ERROR && typeof( self.consoleLogger.error ) === 'function' ){\n\t        return self.consoleLogger.error.apply( self.consoleLogger, args );\n\t    } else if( level >= MetricsLogger.WARN && typeof( self.consoleLogger.warn ) === 'function' ){\n\t        self.consoleLogger.warn.apply( self.consoleLogger, args );\n\t    } else if( level >= MetricsLogger.INFO && typeof( self.consoleLogger.info ) === 'function' ){\n\t        self.consoleLogger.info.apply( self.consoleLogger, args );\n\t    } else if( level >= MetricsLogger.DEBUG && typeof( self.consoleLogger.debug ) === 'function' ){\n\t        self.consoleLogger.debug.apply( self.consoleLogger, args );\n\t    } else if( typeof( self.consoleLogger.log ) === 'function' ){\n\t        self.consoleLogger.log.apply( self.consoleLogger, args );\n\t    }\n\t    return self;\n\t};\n\t\n\t//----------------------------------------------------------------------------- shortcuts\n\t// generic functions when logging from non-namespaced object (e.g. templates)\n\t/** log to default namespace */\n\tMetricsLogger.prototype.log = function log(){\n\t    this.emit( 1, this.options.defaultNamespace,\n\t        Array.prototype.slice.call( arguments, 0 ) );\n\t};\n\t\n\t/** debug to default namespace */\n\tMetricsLogger.prototype.debug = function debug(){\n\t    this.emit( MetricsLogger.DEBUG, this.options.defaultNamespace,\n\t        Array.prototype.slice.call( arguments, 0 ) );\n\t};\n\t\n\t/** info to default namespace */\n\tMetricsLogger.prototype.info = function info(){\n\t    this.emit( MetricsLogger.INFO, this.options.defaultNamespace,\n\t        Array.prototype.slice.call( arguments, 0 ) );\n\t};\n\t\n\t/** warn to default namespace */\n\tMetricsLogger.prototype.warn = function warn(){\n\t    this.emit( MetricsLogger.WARN, this.options.defaultNamespace,\n\t        Array.prototype.slice.call( arguments, 0 ) );\n\t};\n\t\n\t/** error to default namespace */\n\tMetricsLogger.prototype.error = function error(){\n\t    this.emit( MetricsLogger.ERROR, this.options.defaultNamespace,\n\t        Array.prototype.slice.call( arguments, 0 ) );\n\t};\n\t\n\t/** metric to default namespace */\n\tMetricsLogger.prototype.metric = function metric(){\n\t    this.emit( MetricsLogger.METRIC, this.options.defaultNamespace,\n\t        Array.prototype.slice.call( arguments, 0 ) );\n\t};\n\t\n\t\n\t/* ============================================================================\n\tTODO:\n\t    need a performance pass - the JSON un/parsing is a bit much\n\t\n\t============================================================================ */\n\t/** @class LoggingCache\n\t *  Simple implementation of cache wrapping an array.\n\t *\n\t *  Formats an entry before it's cached and only keeps options.maxSize number\n\t *  of entries. Older entries are deleted first.\n\t */\n\tfunction LoggingCache( options ){\n\t    var self = this;\n\t    return self._init( options || {} );\n\t}\n\t\n\t/** default options */\n\tLoggingCache.defaultOptions = {\n\t    /** maximum number of entries to keep before discarding oldest */\n\t    maxSize     : 5000\n\t};\n\t\n\t/** initialize with options */\n\tLoggingCache.prototype._init = function _init( options ){\n\t    if( !this._hasStorage() ){\n\t        //TODO: fall back to jstorage\n\t        throw new Error( 'LoggingCache needs localStorage' );\n\t    }\n\t    if( !options.key ){\n\t        throw new Error( 'LoggingCache needs key for localStorage' );\n\t    }\n\t    this.key = options.key;\n\t    this._initStorage();\n\t\n\t    this.maxSize = options.maxSize || LoggingCache.defaultOptions.maxSize;\n\t    return this;\n\t};\n\t\n\t/** tests for localStorage fns */\n\tLoggingCache.prototype._hasStorage = function _hasStorage(){\n\t//TODO: modernizr\n\t    var test = 'test';\n\t    try {\n\t        localStorage.setItem( test, test );\n\t        localStorage.removeItem( test );\n\t        return true;\n\t    } catch( e ){\n\t        return false;\n\t    }\n\t};\n\t\n\t/** if no localStorage set for key, initialize to empty array */\n\tLoggingCache.prototype._initStorage = function _initStorage(){\n\t    if( localStorage.getItem( this.key ) === null ){\n\t        return this.empty();\n\t    }\n\t    return this;\n\t};\n\t\n\t/** add an entry to the cache, removing the oldest beforehand if size >= maxSize */\n\tLoggingCache.prototype.add = function add( entry ){\n\t    var self = this,\n\t        _cache = self._fetchAndParse(),\n\t        overage = ( _cache.length + 1 ) - self.maxSize;\n\t    if( overage > 0 ){\n\t        _cache.splice( 0, overage );\n\t    }\n\t    _cache.push( entry );\n\t    self._unparseAndStore( _cache );\n\t    return _cache.length;\n\t};\n\t\n\t/** get the entries from localStorage and parse them */\n\tLoggingCache.prototype._fetchAndParse = function _fetchAndParse(){\n\t    var self = this;\n\t    return JSON.parse( localStorage.getItem( self.key ) );\n\t};\n\t\n\t/** stringify the entries and put them in localStorage */\n\tLoggingCache.prototype._unparseAndStore = function _unparseAndStore( entries ){\n\t    var self = this;\n\t    return localStorage.setItem( self.key, JSON.stringify( entries ) );\n\t};\n\t\n\t///** process the entry before caching */\n\t//LoggingCache.prototype._preprocessEntry = function _preprocessEntry( entry ){\n\t//    return JSON.stringify( entry );\n\t//};\n\t\n\t/** return the length --- oh, getters where are you? */\n\tLoggingCache.prototype.length = function length(){\n\t    return this._fetchAndParse().length;\n\t};\n\t\n\t/** get count number of entries starting with the oldest */\n\tLoggingCache.prototype.get = function get( count ){\n\t    return this._fetchAndParse().slice( 0, count );\n\t};\n\t\n\t/** remove count number of entries starting with the oldest */\n\tLoggingCache.prototype.remove = function remove( count ){\n\t    var _cache = this._fetchAndParse(),\n\t        removed = _cache.splice( 0, count );\n\t    this._unparseAndStore( _cache );\n\t    return removed;\n\t};\n\t\n\t/** empty/clear the entire cache */\n\tLoggingCache.prototype.empty = function empty(){\n\t    localStorage.setItem( this.key, '[]' );\n\t    return this;\n\t};\n\t\n\t/** stringify count number of entries (but do not remove) */\n\tLoggingCache.prototype.stringify = function stringify( count ){\n\t    return JSON.stringify( this.get( count ) );\n\t};\n\t\n\t/** outputs entire cache to console */\n\tLoggingCache.prototype.print = function print(){\n\t    // popup? (really, carl? a popup?) - easier to copy/paste\n\t    console.log( JSON.stringify( this._fetchAndParse(), null, '  ' ) );\n\t};\n\t\n\t\n\t//=============================================================================\n\t    return {\n\t        MetricsLogger  : MetricsLogger,\n\t        LoggingCache   : LoggingCache\n\t    };\n\t}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))\n\n/***/ }\n\n});\n\n\n/** WEBPACK FOOTER **\n ** galaxy.bundled.js\n **/","var GalaxyApp = require( '../galaxy-app-base' ).GalaxyApp;\nwindow.GalaxyApp = GalaxyApp;\nconsole.debug( 'galaxy.js, GalaxyApp is now in window' );\nexports = GalaxyApp;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./galaxy/scripts/apps/galaxy.js\n ** module id = 0\n ** module chunks = 3\n **/","define([\n    'libs/underscore',\n    'libs/backbone',\n    'mvc/base-mvc',\n    'mvc/user/user-model',\n    'utils/metrics-logger',\n    'utils/add-logging',\n    'utils/localization'\n], function( _, Backbone, BASE_MVC, userModel, metricsLogger, addLogging, localize ){\n\n// TODO: move into a singleton pattern and have dependents import Galaxy\n// ============================================================================\n/** Base galaxy client-side application.\n *      Iniitializes:\n *          logger      : the logger/metrics-logger\n *          localize    : the string localizer\n *          config      : the current configuration (any k/v in\n *              galaxy.ini available from the configuration API)\n *          user        : the current user (as a mvc/user/user-model)\n */\nfunction GalaxyApp( options, bootstrapped ){\n    console.debug( 'GalaxyApp:', options, bootstrapped );\n    var self = this;\n    return self._init( options || {}, bootstrapped || {} );\n}\n\n// add logging shortcuts for this object\naddLogging( GalaxyApp, 'GalaxyApp' );\n\n// a debug flag can be set via local storage and made available during script/page loading\nvar DEBUGGING_KEY = 'galaxy:debug',\n    NAMESPACE_KEY = DEBUGGING_KEY + ':namespaces',\n    localDebugging = false;\ntry {\n    localDebugging = localStorage.getItem( DEBUGGING_KEY ) == 'true';\n} catch( storageErr ){\n    console.log( localize( 'localStorage not available for debug flag retrieval' ) );\n}\n\n/** initalize options and sub-components */\nGalaxyApp.prototype._init = function __init( options, bootstrapped ){\n    var self = this;\n    _.extend( self, Backbone.Events );\n    if( localDebugging ){\n        self.logger = console;\n    }\n\n    self._processOptions( options );\n    self.debug( 'GalaxyApp.options: ', self.options );\n    // special case for root\n    self.root = options.root || '/';\n\n    self._initConfig( options.config || bootstrapped.config || {} );\n    self.debug( 'GalaxyApp.config: ', self.config );\n\n    self._patchGalaxy( window.Galaxy );\n\n    self._initLogger( self.options.loggerOptions || {} );\n    self.debug( 'GalaxyApp.logger: ', self.logger );\n\n    self._initLocale();\n    self.debug( 'GalaxyApp.localize: ', self.localize );\n\n    self.config = options.config || {};\n    self.debug( 'GalaxyApp.config: ', self.config );\n\n    self._initUser( options.user || {} );\n    self.debug( 'GalaxyApp.user: ', self.user );\n\n    self._setUpListeners();\n    self.trigger( 'ready', self );\n\n    return self;\n};\n\n/** default options */\nGalaxyApp.prototype.defaultOptions = {\n    /** monkey patch attributes from existing window.Galaxy object? */\n    patchExisting   : true,\n    /** root url of this app */\n    // move to self.root?\n    root            : '/'\n};\n\n/** add an option from options if the key matches an option in defaultOptions */\nGalaxyApp.prototype._processOptions = function _processOptions( options ){\n    var self = this,\n        defaults = self.defaultOptions;\n    self.debug( '_processOptions: ', options );\n\n    self.options = {};\n    for( var k in defaults ){\n        if( defaults.hasOwnProperty( k ) ){\n            self.options[ k ] = ( options.hasOwnProperty( k ) )?( options[ k ] ):( defaults[ k ] );\n        }\n    }\n    return self;\n};\n\n/** parse the config and any extra info derived from it */\nGalaxyApp.prototype._initConfig = function _initConfig( config ){\n    var self = this;\n    self.debug( '_initConfig: ', config );\n    self.config = config;\n\n    // give precendence to localdebugging for this setting\n    self.config.debug = localDebugging || self.config.debug;\n\n    return self;\n};\n\n/** add an option from options if the key matches an option in defaultOptions */\nGalaxyApp.prototype._patchGalaxy = function _patchGalaxy( patchWith ){\n    var self = this;\n    // in case req or plain script tag order has created a prev. version of the Galaxy obj...\n    if( self.options.patchExisting && patchWith ){\n        self.debug( 'found existing Galaxy object:', patchWith );\n        // ...(for now) monkey patch any added attributes that the previous Galaxy may have had\n        //TODO: move those attributes to more formal assignment in GalaxyApp\n        for( var k in patchWith ){\n            if( patchWith.hasOwnProperty( k ) ){\n                self.debug( '\\t patching in ' + k + ' to Galaxy' );\n                self[ k ] = patchWith[ k ];\n            }\n        }\n    }\n};\n\n/** set up the metrics logger (utils/metrics-logger) and pass loggerOptions */\nGalaxyApp.prototype._initLogger = function _initLogger( loggerOptions ){\n    var self = this;\n    // default to console logging at the debug level if the debug flag is set\n    if( self.config.debug ){\n        loggerOptions.consoleLogger = loggerOptions.consoleLogger || console;\n        loggerOptions.consoleLevel = loggerOptions.consoleLevel || metricsLogger.MetricsLogger.ALL;\n        // load any logging namespaces from localStorage if we can\n        try {\n            loggerOptions.consoleNamespaceWhitelist = localStorage.getItem( NAMESPACE_KEY ).split( ',' );\n        } catch( storageErr ){}\n    }\n    self.debug( '_initLogger:', loggerOptions );\n    self.logger = new metricsLogger.MetricsLogger( loggerOptions );\n\n    if( self.config.debug ){\n        // add this logger to mvc's loggable mixin so that all models can use the logger\n        BASE_MVC.LoggableMixin.logger = self.logger;\n    }\n    return self;\n};\n\n/** add the localize fn to this object and the window namespace (as '_l') */\nGalaxyApp.prototype._initLocale = function _initLocale( options ){\n    var self = this;\n    self.debug( '_initLocale:', options );\n    self.localize = localize;\n    // add to window as global shortened alias\n    window._l = self.localize;\n    return self;\n};\n\n/** set up the current user as a Backbone model (mvc/user/user-model) */\nGalaxyApp.prototype._initUser = function _initUser( userJSON ){\n    var self = this;\n    self.debug( '_initUser:', userJSON );\n    self.user = new userModel.User( userJSON );\n    self.user.logger = self.logger;\n    //TODO: temp - old alias\n    self.currUser = self.user;\n    return self;\n};\n\n/** Set up DOM/jQuery/Backbone event listeners enabled for all pages */\nGalaxyApp.prototype._setUpListeners = function _setUpListeners(){\n    var self = this;\n\n    // hook to jq beforeSend to record the most recent ajax call and cache some data about it\n    /** cached info about the last ajax call made through jQuery */\n    self.lastAjax = {};\n    $( document ).bind( 'ajaxSend', function( ev, xhr, options ){\n        var data = options.data;\n        try {\n            data = JSON.parse( data );\n        } catch( err ){}\n\n        self.lastAjax = {\n            url     : location.href.slice( 0, -1 ) + options.url,\n            data    : data\n        };\n        //TODO:?? we might somehow manage to *retry* ajax using either this hook or Backbone.sync\n    });\n    return self;\n};\n\n/** Turn debugging/console-output on/off by passing boolean. Pass nothing to get current setting. */\nGalaxyApp.prototype.debugging = function _debugging( setting ){\n    var self = this;\n    try {\n        if( setting === undefined ){\n            return localStorage.getItem( DEBUGGING_KEY ) === 'true';\n        }\n        if( setting ){\n            localStorage.setItem( DEBUGGING_KEY, true );\n            return true;\n        }\n\n        localStorage.removeItem( DEBUGGING_KEY );\n        // also remove all namespaces\n        self.debuggingNamespaces( null );\n\n    } catch( storageErr ){\n        console.log( localize( 'localStorage not available for debug flag retrieval' ) );\n    }\n    return false;\n};\n\n/** Add, remove, or clear namespaces from the debugging filters\n *  Pass no arguments to retrieve the existing namespaces as an array.\n *  Pass in null to clear all namespaces (all logging messages will show now).\n *  Pass in an array of strings or single string of the namespaces to filter to.\n *  Returns the new/current namespaces as an array;\n */\nGalaxyApp.prototype.debuggingNamespaces = function _debuggingNamespaces( namespaces ){\n    var self = this;\n    try {\n        if( namespaces === undefined ){\n            var csv = localStorage.getItem( NAMESPACE_KEY );\n            return typeof( csv ) === 'string'? csv.split( ',' ) : [];\n        } else if( namespaces === null ) {\n            localStorage.removeItem( NAMESPACE_KEY );\n        } else {\n            localStorage.setItem( NAMESPACE_KEY, namespaces );\n        }\n        var newSettings = self.debuggingNamespaces();\n        if( self.logger ){\n            self.logger.options.consoleNamespaceWhitelist = newSettings;\n        }\n        return newSettings;\n    } catch( storageErr ){\n        console.log( localize( 'localStorage not available for debug namespace retrieval' ) );\n    }\n};\n\n/** string rep */\nGalaxyApp.prototype.toString = function toString(){\n    var userEmail = this.user? ( this.user.get( 'email' ) || '(anonymous)' ) : 'uninitialized';\n    return 'GalaxyApp(' + userEmail + ')';\n};\n\n\n// ============================================================================\n    return {\n        GalaxyApp : GalaxyApp\n    };\n});\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./galaxy/scripts/galaxy-app-base.js\n ** module id = 67\n ** module chunks = 3\n **/","define([\n], function(){\n/*global window, jQuery, console */\n/*=============================================================================\nTODO:\n    while anon: logs saved to 'logs-null' - this will never post\n        unless we manually do so at/after login\n        OR prepend when userId and localStorage has 'logs-null'\n    wire up _delayPost and test\n\n=============================================================================*/\n/** @class MetricsLogger\n *\n *  Object to cache, output, and post log/metric messages to the server.\n *  Meant to be attached to the Galaxy object.\n *\n *  Log from objects by either attaching logger directly:\n *      panel.logger.metric( 'user dataset deletion', panel.user.id, hda.toJSON() )\n *  or using the LoggableMixin or addLogging function:\n *      MyBackboneModel.extend( LoggableMixin ).extend({ ... })\n *      addLogging( MyBackboneModel, 'my-backbone-model' )\n *\n *  Log from templates by calling directly from Galaxy object:\n *      Galaxy.logger.metric( 'template loaded', { ownedByUser : true });\n *\n *  If you attempt to log an un-serializable object (circular reference, window, etc.),\n *  that entry will not be cached (or sent). If you set consoleLevel and consoleLogger\n *  appropriately, a warning will be shown when this happens:\n *      > panel.metric( 'something weird with window', { window : window })\n *      !'Metrics logger could not stringify logArguments: ...'\n */\nfunction MetricsLogger( options ){\n    options = options || {};\n    var self = this;\n\n    ///** get the current user's id from bootstrapped data or options */\n    self.userId = ( window.bootstrapped && window.bootstrapped.user )? window.bootstrapped.user.id: null;\n    self.userId = self.userId || options.userId || null;\n\n    /** the (optional) console to emit logs to */\n    self.consoleLogger = options.consoleLogger || null;\n\n    self._init( options );\n    return self;\n}\n\n//----------------------------------------------------------------------------- defaults and constants\n// see: python std lib, logging\nMetricsLogger.ALL   =  0;\nMetricsLogger.LOG   =  0;\nMetricsLogger.DEBUG = 10;\nMetricsLogger.INFO  = 20;\nMetricsLogger.WARN  = 30;\nMetricsLogger.ERROR = 40;\n// metrics levels here?\n//MetricsLogger.MinorEvent  = 45;\n//MetricsLogger.MajorEvent  = 50;\nMetricsLogger.METRIC = 50;\nMetricsLogger.NONE = 100;\n\n/** default options - override these through the constructor */\nMetricsLogger.defaultOptions = {\n    /** if an incoming message has a level >= this, it will be cached - can also be a string (e.g. 'debug') */\n    logLevel            : MetricsLogger.NONE,\n    /** if an incoming message has a level >= this, it will be output to the console */\n    consoleLevel        : MetricsLogger.NONE,\n    /** the default 'namespace' or label associated with an incoming message (if none is passed) */\n    defaultNamespace    : 'Galaxy',\n    /** the namespaces output to the console (all namespaces will be output if this is falsy)\n     *  note: applies only to the console (not the event/metrics log/cache)\n     */\n    consoleNamespaceWhitelist : null,\n    /** the prefix attached to client-side logs to distinguish them in the metrics db */\n    clientPrefix        : 'client.',\n\n    /** the maximum number of messages the cache should hold; if exceeded older messages are removed first */\n    maxCacheSize        : 3000,\n    /** the number of messages accumulate before posting to the server; should be <= maxCacheSize */\n    postSize            : 1000,\n    /** T/F whether to add a timestamp to incoming cached messages */\n    addTime             : true,\n    /** string to prefix to userid for cache web storage */\n    cacheKeyPrefix      : 'logs-',\n\n    /** the relative url to post messages to */\n    postUrl             : '/api/metrics',\n    /** delay before trying post again after two failures */\n    delayPostInMs       : 1000 * 60 * 10,\n\n    /** an (optional) function that should return an object; used to send additional data with the metrics */\n    getPingData         : undefined,\n    /** an (optional) function that will handle the servers response after successfully posting messages */\n    onServerResponse    : undefined\n};\n\n//----------------------------------------------------------------------------- set up\n/** initialize the logger with options, set up instance vars and cache, and add onpageunload to window */\nMetricsLogger.prototype._init = function _init( options ){\n    var self = this;\n    self.options = {};\n    for( var k in MetricsLogger.defaultOptions ){\n        if( MetricsLogger.defaultOptions.hasOwnProperty( k ) ){\n            self.options[ k ] = ( options.hasOwnProperty( k ) )?( options[ k ] ):( MetricsLogger.defaultOptions[ k ] );\n        }\n    }\n    self.options.logLevel = self._parseLevel( self.options.logLevel );\n    self.options.consoleLevel = self._parseLevel( self.options.consoleLevel );\n    //self._emitToConsole( 'debug', 'MetricsLogger', 'MetricsLogger.options:', self.options );\n\n    /** is the logger currently sending? */\n    self._sending = false;\n    /** the setTimeout id if the logger POST has failed more than once */\n    self._waiting = null;\n    /** the current number of entries to send in a POST */\n    self._postSize = self.options.postSize;\n\n    self._initCache();\n\n    return self;\n};\n\n/** initialize the cache */\nMetricsLogger.prototype._initCache = function _initCache(){\n    try {\n        this.cache = new LoggingCache({\n            maxSize : this.options.maxCacheSize,\n            key     : this.options.cacheKeyPrefix + this.userId\n        });\n    } catch( err ){\n        this._emitToConsole( 'warn', 'MetricsLogger', [ 'Could not intitialize logging cache:', err ] );\n        this.options.logLevel = MetricsLogger.NONE;\n    }\n};\n\n/** return the numeric log level if level in 'none, debug, log, info, warn, error' */\nMetricsLogger.prototype._parseLevel = function _parseLevel( level ){\n    var type = typeof level;\n    if( type === 'number' ){ return level; }\n    if( type === 'string' ){\n        var upper = level.toUpperCase();\n        if( MetricsLogger.hasOwnProperty( upper ) ){\n            return MetricsLogger[ upper ];\n        }\n    }\n    throw new Error( 'Unknown log level: ' + level );\n};\n\n\n//----------------------------------------------------------------------------- main entry point\n/** record a log/message's arguments to the cache and/or the console based on level and namespace */\nMetricsLogger.prototype.emit = function emit( level, namespace, logArguments ){\n    //this._emitToConsole( 'debug', 'MetricsLogger', [ 'emit:', level, namespace, logArguments ]);\n    var self = this;\n    namespace = namespace || self.options.defaultNamespace;\n    if( !level || !logArguments ){\n        return self;\n    }\n    // add to cache if proper level\n    //TODO: respect do not track?\n    //if( !navigator.doNotTrack && level >= self.options.logLevel ){\n    level = self._parseLevel( level );\n    if( level >= self.options.logLevel ){\n        self._addToCache( level, namespace, logArguments );\n    }\n    // also emit to consoleLogger if proper level for that\n    if( self.consoleLogger && level >= self.options.consoleLevel ){\n        self._emitToConsole( level, namespace, logArguments );\n    }\n    return self;\n};\n\n//----------------------------------------------------------------------------- cache\n/** add a message to the cache and if messages.length is high enough post them to the server */\nMetricsLogger.prototype._addToCache = function _addToCache( level, namespace, logArguments ){\n    this._emitToConsole( 'debug', 'MetricsLogger',\n        [ '_addToCache:', arguments, this.options.addTime, this.cache.length() ]);\n    //this._emitToConsole( 'debug', 'MetricsLogger', [ '\\t logArguments:', logArguments ]);\n    var self = this;\n    // try add to the cache and if we've got _postSize number of entries, attempt to post them to the server\n    try {\n        var newLength = self.cache.add( self._buildEntry( level, namespace, logArguments ) );\n        if( newLength >= self._postSize ){\n            self._postCache();\n        }\n    // discard entry if an error occurs, but warn if level set to do so\n    } catch( err ){\n        self._emitToConsole( 'warn', 'MetricsLogger',\n            [ 'Metrics logger could not stringify logArguments:', namespace, logArguments ] );\n        self._emitToConsole( 'error', 'MetricsLogger', [ err ] );\n\n    }\n    return self;\n};\n\n/** build a log cache entry object from the given level, namespace, and arguments (optionally adding timestamp */\nMetricsLogger.prototype._buildEntry = function _buildEntry( level, namespace, logArguments ){\n    this._emitToConsole( 'debug', 'MetricsLogger', [ '_buildEntry:', arguments ]);\n    var entry = {\n            level       : level,\n            namespace   : this.options.clientPrefix + namespace,\n            args        : logArguments\n        };\n    if( this.options.addTime ){\n        entry.time = new Date().toISOString();\n    }\n    return entry;\n};\n\n/** post _postSize messages from the cache to the server, removing them if successful\n *      if the post fails, wait until maxCacheSize is accumulated instead and try again then\n *      in addition to the messages from the cache ('metrics'), any info from getPingData (if set) will be sent\n *      onServerResponse will be called (if set) with any response from the server\n */\nMetricsLogger.prototype._postCache = function _postCache( options ){\n    options = options || {};\n    this._emitToConsole( 'info', 'MetricsLogger', [ '_postCache', options, this._postSize ]);\n\n    // short circuit if we're already sending\n    if( !this.options.postUrl || this._sending ){\n        return jQuery.when({});\n    }\n\n    var self = this,\n        postSize = options.count || self._postSize,\n        // do not splice - remove after *successful* post\n        entries = self.cache.get( postSize ),\n        entriesLength = entries.length,\n        // use the optional getPingData to add any extra info we may want to send\n        postData = ( typeof self.options.getPingData === 'function' )?( self.options.getPingData() ):( {} );\n    //console.debug( postSize, entriesLength );\n\n    // add the metrics and send\n    postData.metrics = JSON.stringify( entries );\n    //console.debug( postData.metrics );\n    self._sending = true;\n    return jQuery.post( self.options.postUrl, postData )\n        .always( function(){\n            self._sending = false;\n        })\n        .fail( function( xhr, status, message ){\n            // if we failed the previous time, set the next post target to the max num of entries\n            self._postSize = self.options.maxCacheSize;\n//TODO:??\n            // log this failure to explain any gap in metrics\n            this.emit( 'error', 'MetricsLogger', [ '_postCache error:',\n                xhr.readyState, xhr.status, xhr.responseJSON || xhr.responseText ]);\n//TODO: still doesn't solve the problem that when cache == max, post will be tried on every emit\n//TODO: see _delayPost\n        })\n        .done( function( response ){\n            if( typeof self.options.onServerResponse === 'function' ){\n                self.options.onServerResponse( response );\n            }\n            // only remove if post successful\n            self.cache.remove( entriesLength );\n            //console.debug( 'removed entries:', entriesLength, 'size now:', self.cache.length() );\n            // if we succeeded, reset the post target to the normal num of entries\n            self._postSize = self.options.postSize;\n        });\n    // return the xhr promise\n};\n\n/** set _waiting to true and, after delayPostInMs, set it back to false */\nMetricsLogger.prototype._delayPost = function _delayPost(){\n//TODO: this won't work between pages\n    var self = this;\n    self._waiting = setTimeout( function(){\n        self._waiting = null;\n    }, self.options.delayPostInMs );\n};\n\n\n//----------------------------------------------------------------------------- console\n/** output message to console based on level and consoleLogger type */\nMetricsLogger.prototype._emitToConsole = function _emitToConsole( level, namespace, logArguments ){\n    //console.debug( '_emitToConsole:', level, namespace, logArguments );\n    var self = this,\n        whitelist = self.options.consoleNamespaceWhitelist;\n    if( !self.consoleLogger ){ return self; }\n    // if a whitelist for namespaces is set, bail if this namespace is not in the list\n    if( whitelist && whitelist.indexOf( namespace ) === -1 ){\n        return self;\n    }\n\n    var args = Array.prototype.slice.call( logArguments, 0 );\n    args.unshift( namespace );\n//TODO: script location and/or source maps?\n//TODO: branch on navigator.userAgent == AIIEEE - it only has log\n    if(        level >= MetricsLogger.METRIC && typeof( self.consoleLogger.info ) === 'function' ){\n        return self.consoleLogger.info.apply( self.consoleLogger, args );\n\n    } else if( level >= MetricsLogger.ERROR && typeof( self.consoleLogger.error ) === 'function' ){\n        return self.consoleLogger.error.apply( self.consoleLogger, args );\n    } else if( level >= MetricsLogger.WARN && typeof( self.consoleLogger.warn ) === 'function' ){\n        self.consoleLogger.warn.apply( self.consoleLogger, args );\n    } else if( level >= MetricsLogger.INFO && typeof( self.consoleLogger.info ) === 'function' ){\n        self.consoleLogger.info.apply( self.consoleLogger, args );\n    } else if( level >= MetricsLogger.DEBUG && typeof( self.consoleLogger.debug ) === 'function' ){\n        self.consoleLogger.debug.apply( self.consoleLogger, args );\n    } else if( typeof( self.consoleLogger.log ) === 'function' ){\n        self.consoleLogger.log.apply( self.consoleLogger, args );\n    }\n    return self;\n};\n\n//----------------------------------------------------------------------------- shortcuts\n// generic functions when logging from non-namespaced object (e.g. templates)\n/** log to default namespace */\nMetricsLogger.prototype.log = function log(){\n    this.emit( 1, this.options.defaultNamespace,\n        Array.prototype.slice.call( arguments, 0 ) );\n};\n\n/** debug to default namespace */\nMetricsLogger.prototype.debug = function debug(){\n    this.emit( MetricsLogger.DEBUG, this.options.defaultNamespace,\n        Array.prototype.slice.call( arguments, 0 ) );\n};\n\n/** info to default namespace */\nMetricsLogger.prototype.info = function info(){\n    this.emit( MetricsLogger.INFO, this.options.defaultNamespace,\n        Array.prototype.slice.call( arguments, 0 ) );\n};\n\n/** warn to default namespace */\nMetricsLogger.prototype.warn = function warn(){\n    this.emit( MetricsLogger.WARN, this.options.defaultNamespace,\n        Array.prototype.slice.call( arguments, 0 ) );\n};\n\n/** error to default namespace */\nMetricsLogger.prototype.error = function error(){\n    this.emit( MetricsLogger.ERROR, this.options.defaultNamespace,\n        Array.prototype.slice.call( arguments, 0 ) );\n};\n\n/** metric to default namespace */\nMetricsLogger.prototype.metric = function metric(){\n    this.emit( MetricsLogger.METRIC, this.options.defaultNamespace,\n        Array.prototype.slice.call( arguments, 0 ) );\n};\n\n\n/* ============================================================================\nTODO:\n    need a performance pass - the JSON un/parsing is a bit much\n\n============================================================================ */\n/** @class LoggingCache\n *  Simple implementation of cache wrapping an array.\n *\n *  Formats an entry before it's cached and only keeps options.maxSize number\n *  of entries. Older entries are deleted first.\n */\nfunction LoggingCache( options ){\n    var self = this;\n    return self._init( options || {} );\n}\n\n/** default options */\nLoggingCache.defaultOptions = {\n    /** maximum number of entries to keep before discarding oldest */\n    maxSize     : 5000\n};\n\n/** initialize with options */\nLoggingCache.prototype._init = function _init( options ){\n    if( !this._hasStorage() ){\n        //TODO: fall back to jstorage\n        throw new Error( 'LoggingCache needs localStorage' );\n    }\n    if( !options.key ){\n        throw new Error( 'LoggingCache needs key for localStorage' );\n    }\n    this.key = options.key;\n    this._initStorage();\n\n    this.maxSize = options.maxSize || LoggingCache.defaultOptions.maxSize;\n    return this;\n};\n\n/** tests for localStorage fns */\nLoggingCache.prototype._hasStorage = function _hasStorage(){\n//TODO: modernizr\n    var test = 'test';\n    try {\n        localStorage.setItem( test, test );\n        localStorage.removeItem( test );\n        return true;\n    } catch( e ){\n        return false;\n    }\n};\n\n/** if no localStorage set for key, initialize to empty array */\nLoggingCache.prototype._initStorage = function _initStorage(){\n    if( localStorage.getItem( this.key ) === null ){\n        return this.empty();\n    }\n    return this;\n};\n\n/** add an entry to the cache, removing the oldest beforehand if size >= maxSize */\nLoggingCache.prototype.add = function add( entry ){\n    var self = this,\n        _cache = self._fetchAndParse(),\n        overage = ( _cache.length + 1 ) - self.maxSize;\n    if( overage > 0 ){\n        _cache.splice( 0, overage );\n    }\n    _cache.push( entry );\n    self._unparseAndStore( _cache );\n    return _cache.length;\n};\n\n/** get the entries from localStorage and parse them */\nLoggingCache.prototype._fetchAndParse = function _fetchAndParse(){\n    var self = this;\n    return JSON.parse( localStorage.getItem( self.key ) );\n};\n\n/** stringify the entries and put them in localStorage */\nLoggingCache.prototype._unparseAndStore = function _unparseAndStore( entries ){\n    var self = this;\n    return localStorage.setItem( self.key, JSON.stringify( entries ) );\n};\n\n///** process the entry before caching */\n//LoggingCache.prototype._preprocessEntry = function _preprocessEntry( entry ){\n//    return JSON.stringify( entry );\n//};\n\n/** return the length --- oh, getters where are you? */\nLoggingCache.prototype.length = function length(){\n    return this._fetchAndParse().length;\n};\n\n/** get count number of entries starting with the oldest */\nLoggingCache.prototype.get = function get( count ){\n    return this._fetchAndParse().slice( 0, count );\n};\n\n/** remove count number of entries starting with the oldest */\nLoggingCache.prototype.remove = function remove( count ){\n    var _cache = this._fetchAndParse(),\n        removed = _cache.splice( 0, count );\n    this._unparseAndStore( _cache );\n    return removed;\n};\n\n/** empty/clear the entire cache */\nLoggingCache.prototype.empty = function empty(){\n    localStorage.setItem( this.key, '[]' );\n    return this;\n};\n\n/** stringify count number of entries (but do not remove) */\nLoggingCache.prototype.stringify = function stringify( count ){\n    return JSON.stringify( this.get( count ) );\n};\n\n/** outputs entire cache to console */\nLoggingCache.prototype.print = function print(){\n    // popup? (really, carl? a popup?) - easier to copy/paste\n    console.log( JSON.stringify( this._fetchAndParse(), null, '  ' ) );\n};\n\n\n//=============================================================================\n    return {\n        MetricsLogger  : MetricsLogger,\n        LoggingCache   : LoggingCache\n    };\n});\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./galaxy/scripts/utils/metrics-logger.js\n ** module id = 125\n ** module chunks = 3\n **/"],"sourceRoot":""}