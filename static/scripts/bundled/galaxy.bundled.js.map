{"version":3,"sources":["webpack:///galaxy.bundled.js","webpack:///./galaxy/scripts/apps/galaxy.js","webpack:///./galaxy/scripts/mvc/user/user-model.js?e6b2","webpack:///./galaxy/scripts/galaxy-app-base.js","webpack:///./galaxy/scripts/utils/metrics-logger.js"],"names":["webpackJsonp",0,"module","exports","__webpack_require__","GalaxyApp","window",65,"__WEBPACK_AMD_DEFINE_ARRAY__","__WEBPACK_AMD_DEFINE_RESULT__","_","Backbone","baseMVC","_l","logNamespace","User","Model","extend","LoggableMixin","_logNamespace","urlRoot","Galaxy","root","defaults","id","username","email","total_disk_usage","nice_total_disk_usage","quota_percent","is_admin","initialize","data","this","log","on","model","resp","changes","isAnonymous","get","isAdmin","loadFromApi","idOrCurrent","options","CURRENT_ID_STR","userFn","success","newModel","response","trigger","url","prototype","fetch","call","clearSessionStorage","key","sessionStorage","indexOf","removeItem","toString","userInfo","unshift","push","join","getCurrentUserFromApi","currentUser","Collection","apply","undefined",117,"$","BASE_MVC","userModel","metricsLogger","addLogging","localize","bootstrapped","self","_init","DEBUGGING_KEY","NAMESPACE_KEY","localDebugging","localStorage","getItem","storageErr","console","Events","logger","debug","_processOptions","_initConfig","config","_patchGalaxy","_initLogger","loggerOptions","_initLocale","_initUser","user","_setUpListeners","defaultOptions","patchExisting","k","hasOwnProperty","patchWith","consoleLogger","consoleLevel","MetricsLogger","ALL","consoleNamespaceWhitelist","split","emit","map","i","arguments","Array","slice","userJSON","lastAjax","document","bind","ev","xhr","JSON","parse","err","location","href","debugging","setting","setItem","debuggingNamespaces","namespaces","csv","newSettings","userEmail",146,"jQuery","userId","LoggingCache","LOG","DEBUG","INFO","WARN","ERROR","METRIC","NONE","logLevel","defaultNamespace","clientPrefix","maxCacheSize","postSize","addTime","cacheKeyPrefix","postUrl","delayPostInMs","getPingData","onServerResponse","_parseLevel","_sending","_waiting","_postSize","_initCache","cache","maxSize","_emitToConsole","level","type","upper","toUpperCase","Error","namespace","logArguments","_addToCache","length","newLength","add","_buildEntry","_postCache","entry","args","time","Date","toISOString","when","count","entries","entriesLength","postData","metrics","stringify","post","always","fail","status","message","readyState","responseJSON","responseText","done","remove","_delayPost","setTimeout","whitelist","info","error","warn","metric","_hasStorage","_initStorage","test","e","empty","_cache","_fetchAndParse","overage","splice","_unparseAndStore","removed","print"],"mappings":"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","file":"galaxy.bundled.js","sourcesContent":["webpackJsonp([5],{\n\n/***/ 0:\n/***/ function(module, exports, __webpack_require__) {\n\n\t//TODO: remove this\n\tvar GalaxyApp = __webpack_require__( 117 ).GalaxyApp;\n\twindow.GalaxyApp = GalaxyApp;\n\texports = GalaxyApp;\n\n\n/***/ },\n\n/***/ 65:\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [\n\t    __webpack_require__(3),\n\t    __webpack_require__(2),\n\t    __webpack_require__(6),\n\t    __webpack_require__(5)\n\t], __WEBPACK_AMD_DEFINE_RESULT__ = function( _, Backbone, baseMVC, _l ){\n\t\n\tvar logNamespace = 'user';\n\t//==============================================================================\n\t/** @class Model for a Galaxy user (including anonymous users).\n\t *  @name User\n\t */\n\tvar User = Backbone.Model.extend( baseMVC.LoggableMixin ).extend(\n\t/** @lends User.prototype */{\n\t    _logNamespace : logNamespace,\n\t\n\t    /** API location for this resource */\n\t    urlRoot : function(){ return Galaxy.root + 'api/users'; },\n\t\n\t    /** Model defaults\n\t     *  Note: don't check for anon-users with the username as the default is '(anonymous user)'\n\t     *      a safer method is if( !user.get( 'email' ) ) -> anon user\n\t     */\n\t    defaults : /** @lends User.prototype */{\n\t        id                      : null,\n\t        username                : '(' + _l( \"anonymous user\" ) + ')',\n\t        email                   : \"\",\n\t        total_disk_usage        : 0,\n\t        nice_total_disk_usage   : \"\",\n\t        quota_percent           : null,\n\t        is_admin                : false\n\t    },\n\t\n\t    /** Set up and bind events\n\t     *  @param {Object} data Initial model data.\n\t     */\n\t    initialize : function( data ){\n\t        this.log( 'User.initialize:', data );\n\t\n\t        this.on( 'loaded', function( model, resp ){ this.log( this + ' has loaded:', model, resp ); });\n\t        this.on( 'change', function( model, data ){ this.log( this + ' has changed:', model, data.changes ); });\n\t    },\n\t\n\t    isAnonymous : function(){\n\t        return ( !this.get( 'email' ) );\n\t    },\n\t\n\t    isAdmin : function(){\n\t        return ( this.get( 'is_admin' ) );\n\t    },\n\t\n\t    /** Load a user with the API using an id.\n\t     *      If getting an anonymous user or no access to a user id, pass the User.CURRENT_ID_STR\n\t     *      (e.g. 'current') and the API will return the current transaction's user data.\n\t     *  @param {String} idOrCurrent encoded user id or the User.CURRENT_ID_STR\n\t     *  @param {Object} options hash to pass to Backbone.Model.fetch. Can contain success, error fns.\n\t     *  @fires loaded when the model has been loaded from the API, passing the newModel and AJAX response.\n\t     */\n\t    loadFromApi : function( idOrCurrent, options ){\n\t        idOrCurrent = idOrCurrent || User.CURRENT_ID_STR;\n\t\n\t        options = options || {};\n\t        var model = this,\n\t            userFn = options.success;\n\t\n\t        /** @ignore */\n\t        options.success = function( newModel, response ){\n\t            model.trigger( 'loaded', newModel, response );\n\t            if( userFn ){ userFn( newModel, response ); }\n\t        };\n\t\n\t        // requests for the current user must have a sep. constructed url (fetch don't work, ma)\n\t        if( idOrCurrent === User.CURRENT_ID_STR ){\n\t            options.url = this.urlRoot + '/' + User.CURRENT_ID_STR;\n\t        }\n\t        return Backbone.Model.prototype.fetch.call( this, options );\n\t    },\n\t\n\t    /** Clears all data from the sessionStorage.\n\t     */\n\t    clearSessionStorage : function(){\n\t        for( var key in sessionStorage ){\n\t            //TODO: store these under the user key so we don't have to do this\n\t            // currently only history\n\t            if( key.indexOf( 'history:' ) === 0 ){\n\t                sessionStorage.removeItem( key );\n\t\n\t            } else if( key === 'history-panel' ){\n\t                sessionStorage.removeItem( key );\n\t            }\n\t        }\n\t    },\n\t\n\t    /** string representation */\n\t    toString : function(){\n\t        var userInfo = [ this.get( 'username' ) ];\n\t        if( this.get( 'id' ) ){\n\t            userInfo.unshift( this.get( 'id' ) );\n\t            userInfo.push( this.get( 'email' ) );\n\t        }\n\t        return 'User(' + userInfo.join( ':' ) + ')';\n\t    }\n\t});\n\t\n\t// string to send to tell server to return this transaction's user (see api/users.py)\n\tUser.CURRENT_ID_STR = 'current';\n\t\n\t// class method to load the current user via the api and return that model\n\tUser.getCurrentUserFromApi = function( options ){\n\t    var currentUser = new User();\n\t    currentUser.loadFromApi( User.CURRENT_ID_STR, options );\n\t    return currentUser;\n\t};\n\t\n\t// (stub) collection for users (shouldn't be common unless admin UI)\n\tvar UserCollection = Backbone.Collection.extend( baseMVC.LoggableMixin ).extend({\n\t    model   : User,\n\t    urlRoot : function(){ return Galaxy.root + 'api/users'; },\n\t    //logger  : console,\n\t});\n\t\n\t\n\t//==============================================================================\n\treturn {\n\t    User : User\n\t};}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n\n/***/ },\n\n/***/ 117:\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function($) {!(__WEBPACK_AMD_DEFINE_ARRAY__ = [\n\t    __webpack_require__(3),\n\t    __webpack_require__(2),\n\t    __webpack_require__(6),\n\t    __webpack_require__(65),\n\t    __webpack_require__(146),\n\t    __webpack_require__(111),\n\t    __webpack_require__(5)\n\t], __WEBPACK_AMD_DEFINE_RESULT__ = function( _, Backbone, BASE_MVC, userModel, metricsLogger, addLogging, localize ){\n\t\n\t// TODO: move into a singleton pattern and have dependents import Galaxy\n\t// ============================================================================\n\t/** Base galaxy client-side application.\n\t *      Iniitializes:\n\t *          logger      : the logger/metrics-logger\n\t *          localize    : the string localizer\n\t *          config      : the current configuration (any k/v in\n\t *              galaxy.ini available from the configuration API)\n\t *          user        : the current user (as a mvc/user/user-model)\n\t */\n\tfunction GalaxyApp( options, bootstrapped ){\n\t    var self = this;\n\t    return self._init( options || {}, bootstrapped || {} );\n\t}\n\t\n\t// add logging shortcuts for this object\n\taddLogging( GalaxyApp, 'GalaxyApp' );\n\t\n\t// a debug flag can be set via local storage and made available during script/page loading\n\tvar DEBUGGING_KEY = 'galaxy:debug',\n\t    NAMESPACE_KEY = DEBUGGING_KEY + ':namespaces',\n\t    localDebugging = false;\n\ttry {\n\t    localDebugging = localStorage.getItem( DEBUGGING_KEY ) == 'true';\n\t} catch( storageErr ){\n\t    console.log( localize( 'localStorage not available for debug flag retrieval' ) );\n\t}\n\t\n\t/** initalize options and sub-components */\n\tGalaxyApp.prototype._init = function __init( options, bootstrapped ){\n\t    var self = this;\n\t    _.extend( self, Backbone.Events );\n\t    if( localDebugging ){\n\t        self.logger = console;\n\t        console.debug( 'debugging galaxy:', 'options:', options, 'bootstrapped:', bootstrapped );\n\t    }\n\t\n\t    self._processOptions( options );\n\t    // special case for root\n\t    self.root = options.root || '/';\n\t\n\t    self._initConfig( options.config || bootstrapped.config || {} );\n\t    self._patchGalaxy( window.Galaxy );\n\t\n\t    self._initLogger( self.options.loggerOptions || {} );\n\t    // at this point, either logging or not and namespaces are enabled - chat it up\n\t    self.debug( 'GalaxyApp.options: ', self.options );\n\t    self.debug( 'GalaxyApp.config: ', self.config );\n\t    self.debug( 'GalaxyApp.logger: ', self.logger );\n\t\n\t    self._initLocale();\n\t    self.debug( 'GalaxyApp.localize: ', self.localize );\n\t\n\t    self.config = options.config || {};\n\t    self.debug( 'GalaxyApp.config: ', self.config );\n\t\n\t    self._initUser( options.user || {} );\n\t    self.debug( 'GalaxyApp.user: ', self.user );\n\t\n\t    self._setUpListeners();\n\t    self.trigger( 'ready', self );\n\t\n\t    return self;\n\t};\n\t\n\t/** default options */\n\tGalaxyApp.prototype.defaultOptions = {\n\t    /** monkey patch attributes from existing window.Galaxy object? */\n\t    patchExisting   : true,\n\t    /** root url of this app */\n\t    root            : '/'\n\t};\n\t\n\t/** add an option from options if the key matches an option in defaultOptions */\n\tGalaxyApp.prototype._processOptions = function _processOptions( options ){\n\t    var self = this,\n\t        defaults = self.defaultOptions;\n\t\n\t    self.options = {};\n\t    for( var k in defaults ){\n\t        if( defaults.hasOwnProperty( k ) ){\n\t            self.options[ k ] = ( options.hasOwnProperty( k ) )?( options[ k ] ):( defaults[ k ] );\n\t        }\n\t    }\n\t    return self;\n\t};\n\t\n\t/** parse the config and any extra info derived from it */\n\tGalaxyApp.prototype._initConfig = function _initConfig( config ){\n\t    var self = this;\n\t    self.config = config;\n\t\n\t    // give precendence to localdebugging for this setting\n\t    self.config.debug = localDebugging || self.config.debug;\n\t\n\t    return self;\n\t};\n\t\n\t/** add an option from options if the key matches an option in defaultOptions */\n\tGalaxyApp.prototype._patchGalaxy = function _patchGalaxy( patchWith ){\n\t    var self = this;\n\t    // in case req or plain script tag order has created a prev. version of the Galaxy obj...\n\t    if( self.options.patchExisting && patchWith ){\n\t        // self.debug( 'found existing Galaxy object:', patchWith );\n\t        // ...(for now) monkey patch any added attributes that the previous Galaxy may have had\n\t        //TODO: move those attributes to more formal assignment in GalaxyApp\n\t        for( var k in patchWith ){\n\t            if( patchWith.hasOwnProperty( k ) ){\n\t                // self.debug( '\\t patching in ' + k + ' to Galaxy:', self[ k ] );\n\t                self[ k ] = patchWith[ k ];\n\t            }\n\t        }\n\t    }\n\t};\n\t\n\t/** set up the metrics logger (utils/metrics-logger) and pass loggerOptions */\n\tGalaxyApp.prototype._initLogger = function _initLogger( loggerOptions ){\n\t    var self = this;\n\t    // default to console logging at the debug level if the debug flag is set\n\t    if( self.config.debug ){\n\t        loggerOptions.consoleLogger = loggerOptions.consoleLogger || console;\n\t        loggerOptions.consoleLevel = loggerOptions.consoleLevel || metricsLogger.MetricsLogger.ALL;\n\t        // load any logging namespaces from localStorage if we can\n\t        try {\n\t            loggerOptions.consoleNamespaceWhitelist = localStorage.getItem( NAMESPACE_KEY ).split( ',' );\n\t        } catch( storageErr ){}\n\t    }\n\t    self.logger = new metricsLogger.MetricsLogger( loggerOptions );\n\t    self.emit = {};\n\t    [ 'log', 'debug', 'info', 'warn', 'error', 'metric' ].map(function( i ) {\n\t        self.emit[ i ] = function( data ){\n\t            self.logger.emit( i, arguments[ 0 ], Array.prototype.slice.call( arguments, 1 ) );\n\t        };\n\t    });\n\t\n\t    if( self.config.debug ){\n\t        // add this logger to mvc's loggable mixin so that all models can use the logger\n\t        BASE_MVC.LoggableMixin.logger = self.logger;\n\t    }\n\t    return self;\n\t};\n\t\n\t/** add the localize fn to this object and the window namespace (as '_l') */\n\tGalaxyApp.prototype._initLocale = function _initLocale( options ){\n\t    var self = this;\n\t    self.debug( '_initLocale:', options );\n\t    self.localize = localize;\n\t    // add to window as global shortened alias\n\t    // TODO: temporary - remove when can require for plugins\n\t    window._l = self.localize;\n\t    return self;\n\t};\n\t\n\t/** set up the current user as a Backbone model (mvc/user/user-model) */\n\tGalaxyApp.prototype._initUser = function _initUser( userJSON ){\n\t    var self = this;\n\t    self.debug( '_initUser:', userJSON );\n\t    self.user = new userModel.User( userJSON );\n\t    self.user.logger = self.logger;\n\t    return self;\n\t};\n\t\n\t/** Set up DOM/jQuery/Backbone event listeners enabled for all pages */\n\tGalaxyApp.prototype._setUpListeners = function _setUpListeners(){\n\t    var self = this;\n\t\n\t    // hook to jq beforeSend to record the most recent ajax call and cache some data about it\n\t    /** cached info about the last ajax call made through jQuery */\n\t    self.lastAjax = {};\n\t    $( document ).bind( 'ajaxSend', function( ev, xhr, options ){\n\t        var data = options.data;\n\t        try {\n\t            data = JSON.parse( data );\n\t        } catch( err ){}\n\t\n\t        self.lastAjax = {\n\t            url     : location.href.slice( 0, -1 ) + options.url,\n\t            data    : data\n\t        };\n\t        //TODO:?? we might somehow manage to *retry* ajax using either this hook or Backbone.sync\n\t    });\n\t    return self;\n\t};\n\t\n\t/** Turn debugging/console-output on/off by passing boolean. Pass nothing to get current setting. */\n\tGalaxyApp.prototype.debugging = function _debugging( setting ){\n\t    var self = this;\n\t    try {\n\t        if( setting === undefined ){\n\t            return localStorage.getItem( DEBUGGING_KEY ) === 'true';\n\t        }\n\t        if( setting ){\n\t            localStorage.setItem( DEBUGGING_KEY, true );\n\t            return true;\n\t        }\n\t\n\t        localStorage.removeItem( DEBUGGING_KEY );\n\t        // also remove all namespaces\n\t        self.debuggingNamespaces( null );\n\t\n\t    } catch( storageErr ){\n\t        console.log( localize( 'localStorage not available for debug flag retrieval' ) );\n\t    }\n\t    return false;\n\t};\n\t\n\t/** Add, remove, or clear namespaces from the debugging filters\n\t *  Pass no arguments to retrieve the existing namespaces as an array.\n\t *  Pass in null to clear all namespaces (all logging messages will show now).\n\t *  Pass in an array of strings or single string of the namespaces to filter to.\n\t *  Returns the new/current namespaces as an array;\n\t */\n\tGalaxyApp.prototype.debuggingNamespaces = function _debuggingNamespaces( namespaces ){\n\t    var self = this;\n\t    try {\n\t        if( namespaces === undefined ){\n\t            var csv = localStorage.getItem( NAMESPACE_KEY );\n\t            return typeof( csv ) === 'string'? csv.split( ',' ) : [];\n\t        } else if( namespaces === null ) {\n\t            localStorage.removeItem( NAMESPACE_KEY );\n\t        } else {\n\t            localStorage.setItem( NAMESPACE_KEY, namespaces );\n\t        }\n\t        var newSettings = self.debuggingNamespaces();\n\t        if( self.logger ){\n\t            self.logger.options.consoleNamespaceWhitelist = newSettings;\n\t        }\n\t        return newSettings;\n\t    } catch( storageErr ){\n\t        console.log( localize( 'localStorage not available for debug namespace retrieval' ) );\n\t    }\n\t};\n\t\n\t/** string rep */\n\tGalaxyApp.prototype.toString = function toString(){\n\t    var userEmail = this.user? ( this.user.get( 'email' ) || '(anonymous)' ) : 'uninitialized';\n\t    return 'GalaxyApp(' + userEmail + ')';\n\t};\n\t\n\t// ============================================================================\n\t    return {\n\t        GalaxyApp : GalaxyApp\n\t    };\n\t}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))\n\n/***/ },\n\n/***/ 146:\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(jQuery) {!(__WEBPACK_AMD_DEFINE_ARRAY__ = [\n\t], __WEBPACK_AMD_DEFINE_RESULT__ = function(){\n\t/*global window, jQuery, console */\n\t/*=============================================================================\n\tTODO:\n\t    while anon: logs saved to 'logs-null' - this will never post\n\t        unless we manually do so at/after login\n\t        OR prepend when userId and localStorage has 'logs-null'\n\t    wire up _delayPost and test\n\t\n\t=============================================================================*/\n\t/** @class MetricsLogger\n\t *\n\t *  Object to cache, output, and post log/metric messages to the server.\n\t *  Meant to be attached to the Galaxy object.\n\t *\n\t *  Log from objects by either attaching logger directly:\n\t *      panel.logger.metric( 'user dataset deletion', panel.user.id, hda.toJSON() )\n\t *  or using the LoggableMixin or addLogging function:\n\t *      MyBackboneModel.extend( LoggableMixin ).extend({ ... })\n\t *      addLogging( MyBackboneModel, 'my-backbone-model' )\n\t *\n\t *  Log from templates by calling directly from Galaxy object:\n\t *      Galaxy.logger.metric( 'template loaded', { ownedByUser : true });\n\t *\n\t *  If you attempt to log an un-serializable object (circular reference, window, etc.),\n\t *  that entry will not be cached (or sent). If you set consoleLevel and consoleLogger\n\t *  appropriately, a warning will be shown when this happens:\n\t *      > panel.metric( 'something weird with window', { window : window })\n\t *      !'Metrics logger could not stringify logArguments: ...'\n\t */\n\tfunction MetricsLogger( options ){\n\t    options = options || {};\n\t    var self = this;\n\t\n\t    ///** get the current user's id from bootstrapped data or options */\n\t    self.userId = ( window.bootstrapped && window.bootstrapped.user )? window.bootstrapped.user.id: null;\n\t    self.userId = self.userId || options.userId || null;\n\t\n\t    /** the (optional) console to emit logs to */\n\t    self.consoleLogger = options.consoleLogger || null;\n\t\n\t    self._init( options );\n\t    return self;\n\t}\n\t\n\t//----------------------------------------------------------------------------- defaults and constants\n\t// see: python std lib, logging\n\tMetricsLogger.ALL   =  0;\n\tMetricsLogger.LOG   =  0;\n\tMetricsLogger.DEBUG = 10;\n\tMetricsLogger.INFO  = 20;\n\tMetricsLogger.WARN  = 30;\n\tMetricsLogger.ERROR = 40;\n\t// metrics levels here?\n\t//MetricsLogger.MinorEvent  = 45;\n\t//MetricsLogger.MajorEvent  = 50;\n\tMetricsLogger.METRIC = 50;\n\tMetricsLogger.NONE = 100;\n\t\n\t/** default options - override these through the constructor */\n\tMetricsLogger.defaultOptions = {\n\t    /** if an incoming message has a level >= this, it will be cached - can also be a string (e.g. 'debug') */\n\t    logLevel            : MetricsLogger.NONE,\n\t    /** if an incoming message has a level >= this, it will be output to the console */\n\t    consoleLevel        : MetricsLogger.NONE,\n\t    /** the default 'namespace' or label associated with an incoming message (if none is passed) */\n\t    defaultNamespace    : 'Galaxy',\n\t    /** the namespaces output to the console (all namespaces will be output if this is falsy)\n\t     *  note: applies only to the console (not the event/metrics log/cache)\n\t     */\n\t    consoleNamespaceWhitelist : null,\n\t    /** the prefix attached to client-side logs to distinguish them in the metrics db */\n\t    clientPrefix        : 'client.',\n\t\n\t    /** the maximum number of messages the cache should hold; if exceeded older messages are removed first */\n\t    maxCacheSize        : 3000,\n\t    /** the number of messages accumulate before posting to the server; should be <= maxCacheSize */\n\t    postSize            : 1000,\n\t    /** T/F whether to add a timestamp to incoming cached messages */\n\t    addTime             : true,\n\t    /** string to prefix to userid for cache web storage */\n\t    cacheKeyPrefix      : 'logs-',\n\t\n\t    /** the relative url to post messages to */\n\t    postUrl             : '/api/metrics',\n\t    /** delay before trying post again after two failures */\n\t    delayPostInMs       : 1000 * 60 * 10,\n\t\n\t    /** an (optional) function that should return an object; used to send additional data with the metrics */\n\t    getPingData         : undefined,\n\t    /** an (optional) function that will handle the servers response after successfully posting messages */\n\t    onServerResponse    : undefined\n\t};\n\t\n\t//----------------------------------------------------------------------------- set up\n\t/** initialize the logger with options, set up instance vars and cache, and add onpageunload to window */\n\tMetricsLogger.prototype._init = function _init( options ){\n\t    var self = this;\n\t    self.options = {};\n\t    for( var k in MetricsLogger.defaultOptions ){\n\t        if( MetricsLogger.defaultOptions.hasOwnProperty( k ) ){\n\t            self.options[ k ] = ( options.hasOwnProperty( k ) )?( options[ k ] ):( MetricsLogger.defaultOptions[ k ] );\n\t        }\n\t    }\n\t    self.options.logLevel = self._parseLevel( self.options.logLevel );\n\t    self.options.consoleLevel = self._parseLevel( self.options.consoleLevel );\n\t    //self._emitToConsole( 'debug', 'MetricsLogger', 'MetricsLogger.options:', self.options );\n\t\n\t    /** is the logger currently sending? */\n\t    self._sending = false;\n\t    /** the setTimeout id if the logger POST has failed more than once */\n\t    self._waiting = null;\n\t    /** the current number of entries to send in a POST */\n\t    self._postSize = self.options.postSize;\n\t\n\t    self._initCache();\n\t\n\t    return self;\n\t};\n\t\n\t/** initialize the cache */\n\tMetricsLogger.prototype._initCache = function _initCache(){\n\t    try {\n\t        this.cache = new LoggingCache({\n\t            maxSize : this.options.maxCacheSize,\n\t            key     : this.options.cacheKeyPrefix + this.userId\n\t        });\n\t    } catch( err ){\n\t        this._emitToConsole( 'warn', 'MetricsLogger', [ 'Could not intitialize logging cache:', err ] );\n\t        this.options.logLevel = MetricsLogger.NONE;\n\t    }\n\t};\n\t\n\t/** return the numeric log level if level in 'none, debug, log, info, warn, error' */\n\tMetricsLogger.prototype._parseLevel = function _parseLevel( level ){\n\t    var type = typeof level;\n\t    if( type === 'number' ){ return level; }\n\t    if( type === 'string' ){\n\t        var upper = level.toUpperCase();\n\t        if( MetricsLogger.hasOwnProperty( upper ) ){\n\t            return MetricsLogger[ upper ];\n\t        }\n\t    }\n\t    throw new Error( 'Unknown log level: ' + level );\n\t};\n\t\n\t\n\t//----------------------------------------------------------------------------- main entry point\n\t/** record a log/message's arguments to the cache and/or the console based on level and namespace */\n\tMetricsLogger.prototype.emit = function emit( level, namespace, logArguments ){\n\t    //this._emitToConsole( 'debug', 'MetricsLogger', [ 'emit:', level, namespace, logArguments ]);\n\t    var self = this;\n\t    namespace = namespace || self.options.defaultNamespace;\n\t    if( !level || !logArguments ){\n\t        return self;\n\t    }\n\t    // add to cache if proper level\n\t    //TODO: respect do not track?\n\t    //if( !navigator.doNotTrack && level >= self.options.logLevel ){\n\t    level = self._parseLevel( level );\n\t    if( level >= self.options.logLevel ){\n\t        self._addToCache( level, namespace, logArguments );\n\t    }\n\t    // also emit to consoleLogger if proper level for that\n\t    if( self.consoleLogger && level >= self.options.consoleLevel ){\n\t        self._emitToConsole( level, namespace, logArguments );\n\t    }\n\t    return self;\n\t};\n\t\n\t//----------------------------------------------------------------------------- cache\n\t/** add a message to the cache and if messages.length is high enough post them to the server */\n\tMetricsLogger.prototype._addToCache = function _addToCache( level, namespace, logArguments ){\n\t    this._emitToConsole( 'debug', 'MetricsLogger',\n\t        [ '_addToCache:', arguments, this.options.addTime, this.cache.length() ]);\n\t    //this._emitToConsole( 'debug', 'MetricsLogger', [ '\\t logArguments:', logArguments ]);\n\t    var self = this;\n\t    // try add to the cache and if we've got _postSize number of entries, attempt to post them to the server\n\t    try {\n\t        var newLength = self.cache.add( self._buildEntry( level, namespace, logArguments ) );\n\t        if( newLength >= self._postSize ){\n\t            self._postCache();\n\t        }\n\t    // discard entry if an error occurs, but warn if level set to do so\n\t    } catch( err ){\n\t        self._emitToConsole( 'warn', 'MetricsLogger',\n\t            [ 'Metrics logger could not stringify logArguments:', namespace, logArguments ] );\n\t        self._emitToConsole( 'error', 'MetricsLogger', [ err ] );\n\t\n\t    }\n\t    return self;\n\t};\n\t\n\t/** build a log cache entry object from the given level, namespace, and arguments (optionally adding timestamp */\n\tMetricsLogger.prototype._buildEntry = function _buildEntry( level, namespace, logArguments ){\n\t    this._emitToConsole( 'debug', 'MetricsLogger', [ '_buildEntry:', arguments ]);\n\t    var entry = {\n\t            level       : level,\n\t            namespace   : this.options.clientPrefix + namespace,\n\t            args        : logArguments\n\t        };\n\t    if( this.options.addTime ){\n\t        entry.time = new Date().toISOString();\n\t    }\n\t    return entry;\n\t};\n\t\n\t/** post _postSize messages from the cache to the server, removing them if successful\n\t *      if the post fails, wait until maxCacheSize is accumulated instead and try again then\n\t *      in addition to the messages from the cache ('metrics'), any info from getPingData (if set) will be sent\n\t *      onServerResponse will be called (if set) with any response from the server\n\t */\n\tMetricsLogger.prototype._postCache = function _postCache( options ){\n\t    options = options || {};\n\t    this._emitToConsole( 'info', 'MetricsLogger', [ '_postCache', options, this._postSize ]);\n\t\n\t    // short circuit if we're already sending\n\t    if( !this.options.postUrl || this._sending ){\n\t        return jQuery.when({});\n\t    }\n\t\n\t    var self = this,\n\t        postSize = options.count || self._postSize,\n\t        // do not splice - remove after *successful* post\n\t        entries = self.cache.get( postSize ),\n\t        entriesLength = entries.length,\n\t        // use the optional getPingData to add any extra info we may want to send\n\t        postData = ( typeof self.options.getPingData === 'function' )?( self.options.getPingData() ):( {} );\n\t    //console.debug( postSize, entriesLength );\n\t\n\t    // add the metrics and send\n\t    postData.metrics = JSON.stringify( entries );\n\t    //console.debug( postData.metrics );\n\t    self._sending = true;\n\t    return jQuery.post( self.options.postUrl, postData )\n\t        .always( function(){\n\t            self._sending = false;\n\t        })\n\t        .fail( function( xhr, status, message ){\n\t            // if we failed the previous time, set the next post target to the max num of entries\n\t            self._postSize = self.options.maxCacheSize;\n\t//TODO:??\n\t            // log this failure to explain any gap in metrics\n\t            this.emit( 'error', 'MetricsLogger', [ '_postCache error:',\n\t                xhr.readyState, xhr.status, xhr.responseJSON || xhr.responseText ]);\n\t//TODO: still doesn't solve the problem that when cache == max, post will be tried on every emit\n\t//TODO: see _delayPost\n\t        })\n\t        .done( function( response ){\n\t            if( typeof self.options.onServerResponse === 'function' ){\n\t                self.options.onServerResponse( response );\n\t            }\n\t            // only remove if post successful\n\t            self.cache.remove( entriesLength );\n\t            //console.debug( 'removed entries:', entriesLength, 'size now:', self.cache.length() );\n\t            // if we succeeded, reset the post target to the normal num of entries\n\t            self._postSize = self.options.postSize;\n\t        });\n\t    // return the xhr promise\n\t};\n\t\n\t/** set _waiting to true and, after delayPostInMs, set it back to false */\n\tMetricsLogger.prototype._delayPost = function _delayPost(){\n\t//TODO: this won't work between pages\n\t    var self = this;\n\t    self._waiting = setTimeout( function(){\n\t        self._waiting = null;\n\t    }, self.options.delayPostInMs );\n\t};\n\t\n\t\n\t//----------------------------------------------------------------------------- console\n\t/** output message to console based on level and consoleLogger type */\n\tMetricsLogger.prototype._emitToConsole = function _emitToConsole( level, namespace, logArguments ){\n\t    //console.debug( '_emitToConsole:', level, namespace, logArguments );\n\t    var self = this,\n\t        whitelist = self.options.consoleNamespaceWhitelist;\n\t    if( !self.consoleLogger ){ return self; }\n\t    // if a whitelist for namespaces is set, bail if this namespace is not in the list\n\t    if( whitelist && whitelist.indexOf( namespace ) === -1 ){\n\t        return self;\n\t    }\n\t\n\t    var args = Array.prototype.slice.call( logArguments, 0 );\n\t    args.unshift( namespace );\n\t//TODO: script location and/or source maps?\n\t//TODO: branch on navigator.userAgent == AIIEEE - it only has log\n\t    if(        level >= MetricsLogger.METRIC && typeof( self.consoleLogger.info ) === 'function' ){\n\t        return self.consoleLogger.info.apply( self.consoleLogger, args );\n\t\n\t    } else if( level >= MetricsLogger.ERROR && typeof( self.consoleLogger.error ) === 'function' ){\n\t        return self.consoleLogger.error.apply( self.consoleLogger, args );\n\t    } else if( level >= MetricsLogger.WARN && typeof( self.consoleLogger.warn ) === 'function' ){\n\t        self.consoleLogger.warn.apply( self.consoleLogger, args );\n\t    } else if( level >= MetricsLogger.INFO && typeof( self.consoleLogger.info ) === 'function' ){\n\t        self.consoleLogger.info.apply( self.consoleLogger, args );\n\t    } else if( level >= MetricsLogger.DEBUG && typeof( self.consoleLogger.debug ) === 'function' ){\n\t        self.consoleLogger.debug.apply( self.consoleLogger, args );\n\t    } else if( typeof( self.consoleLogger.log ) === 'function' ){\n\t        self.consoleLogger.log.apply( self.consoleLogger, args );\n\t    }\n\t    return self;\n\t};\n\t\n\t//----------------------------------------------------------------------------- shortcuts\n\t// generic functions when logging from non-namespaced object (e.g. templates)\n\t/** log to default namespace */\n\tMetricsLogger.prototype.log = function log(){\n\t    this.emit( 1, this.options.defaultNamespace,\n\t        Array.prototype.slice.call( arguments, 0 ) );\n\t};\n\t\n\t/** debug to default namespace */\n\tMetricsLogger.prototype.debug = function debug(){\n\t    this.emit( MetricsLogger.DEBUG, this.options.defaultNamespace,\n\t        Array.prototype.slice.call( arguments, 0 ) );\n\t};\n\t\n\t/** info to default namespace */\n\tMetricsLogger.prototype.info = function info(){\n\t    this.emit( MetricsLogger.INFO, this.options.defaultNamespace,\n\t        Array.prototype.slice.call( arguments, 0 ) );\n\t};\n\t\n\t/** warn to default namespace */\n\tMetricsLogger.prototype.warn = function warn(){\n\t    this.emit( MetricsLogger.WARN, this.options.defaultNamespace,\n\t        Array.prototype.slice.call( arguments, 0 ) );\n\t};\n\t\n\t/** error to default namespace */\n\tMetricsLogger.prototype.error = function error(){\n\t    this.emit( MetricsLogger.ERROR, this.options.defaultNamespace,\n\t        Array.prototype.slice.call( arguments, 0 ) );\n\t};\n\t\n\t/** metric to default namespace */\n\tMetricsLogger.prototype.metric = function metric(){\n\t    this.emit( MetricsLogger.METRIC, this.options.defaultNamespace,\n\t        Array.prototype.slice.call( arguments, 0 ) );\n\t};\n\t\n\t\n\t/* ============================================================================\n\tTODO:\n\t    need a performance pass - the JSON un/parsing is a bit much\n\t\n\t============================================================================ */\n\t/** @class LoggingCache\n\t *  Simple implementation of cache wrapping an array.\n\t *\n\t *  Formats an entry before it's cached and only keeps options.maxSize number\n\t *  of entries. Older entries are deleted first.\n\t */\n\tfunction LoggingCache( options ){\n\t    var self = this;\n\t    return self._init( options || {} );\n\t}\n\t\n\t/** default options */\n\tLoggingCache.defaultOptions = {\n\t    /** maximum number of entries to keep before discarding oldest */\n\t    maxSize     : 5000\n\t};\n\t\n\t/** initialize with options */\n\tLoggingCache.prototype._init = function _init( options ){\n\t    if( !this._hasStorage() ){\n\t        //TODO: fall back to jstorage\n\t        throw new Error( 'LoggingCache needs localStorage' );\n\t    }\n\t    if( !options.key ){\n\t        throw new Error( 'LoggingCache needs key for localStorage' );\n\t    }\n\t    this.key = options.key;\n\t    this._initStorage();\n\t\n\t    this.maxSize = options.maxSize || LoggingCache.defaultOptions.maxSize;\n\t    return this;\n\t};\n\t\n\t/** tests for localStorage fns */\n\tLoggingCache.prototype._hasStorage = function _hasStorage(){\n\t//TODO: modernizr\n\t    var test = 'test';\n\t    try {\n\t        localStorage.setItem( test, test );\n\t        localStorage.removeItem( test );\n\t        return true;\n\t    } catch( e ){\n\t        return false;\n\t    }\n\t};\n\t\n\t/** if no localStorage set for key, initialize to empty array */\n\tLoggingCache.prototype._initStorage = function _initStorage(){\n\t    if( localStorage.getItem( this.key ) === null ){\n\t        return this.empty();\n\t    }\n\t    return this;\n\t};\n\t\n\t/** add an entry to the cache, removing the oldest beforehand if size >= maxSize */\n\tLoggingCache.prototype.add = function add( entry ){\n\t    var self = this,\n\t        _cache = self._fetchAndParse(),\n\t        overage = ( _cache.length + 1 ) - self.maxSize;\n\t    if( overage > 0 ){\n\t        _cache.splice( 0, overage );\n\t    }\n\t    _cache.push( entry );\n\t    self._unparseAndStore( _cache );\n\t    return _cache.length;\n\t};\n\t\n\t/** get the entries from localStorage and parse them */\n\tLoggingCache.prototype._fetchAndParse = function _fetchAndParse(){\n\t    var self = this;\n\t    return JSON.parse( localStorage.getItem( self.key ) );\n\t};\n\t\n\t/** stringify the entries and put them in localStorage */\n\tLoggingCache.prototype._unparseAndStore = function _unparseAndStore( entries ){\n\t    var self = this;\n\t    return localStorage.setItem( self.key, JSON.stringify( entries ) );\n\t};\n\t\n\t///** process the entry before caching */\n\t//LoggingCache.prototype._preprocessEntry = function _preprocessEntry( entry ){\n\t//    return JSON.stringify( entry );\n\t//};\n\t\n\t/** return the length --- oh, getters where are you? */\n\tLoggingCache.prototype.length = function length(){\n\t    return this._fetchAndParse().length;\n\t};\n\t\n\t/** get count number of entries starting with the oldest */\n\tLoggingCache.prototype.get = function get( count ){\n\t    return this._fetchAndParse().slice( 0, count );\n\t};\n\t\n\t/** remove count number of entries starting with the oldest */\n\tLoggingCache.prototype.remove = function remove( count ){\n\t    var _cache = this._fetchAndParse(),\n\t        removed = _cache.splice( 0, count );\n\t    this._unparseAndStore( _cache );\n\t    return removed;\n\t};\n\t\n\t/** empty/clear the entire cache */\n\tLoggingCache.prototype.empty = function empty(){\n\t    localStorage.setItem( this.key, '[]' );\n\t    return this;\n\t};\n\t\n\t/** stringify count number of entries (but do not remove) */\n\tLoggingCache.prototype.stringify = function stringify( count ){\n\t    return JSON.stringify( this.get( count ) );\n\t};\n\t\n\t/** outputs entire cache to console */\n\tLoggingCache.prototype.print = function print(){\n\t    // popup? (really, carl? a popup?) - easier to copy/paste\n\t    console.log( JSON.stringify( this._fetchAndParse(), null, '  ' ) );\n\t};\n\t\n\t\n\t//=============================================================================\n\t    return {\n\t        MetricsLogger  : MetricsLogger,\n\t        LoggingCache   : LoggingCache\n\t    };\n\t}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))\n\n/***/ }\n\n});\n\n\n/** WEBPACK FOOTER **\n ** galaxy.bundled.js\n **/","//TODO: remove this\nvar GalaxyApp = require( '../galaxy-app-base' ).GalaxyApp;\nwindow.GalaxyApp = GalaxyApp;\nexports = GalaxyApp;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./galaxy/scripts/apps/galaxy.js\n ** module id = 0\n ** module chunks = 5\n **/","define([\n    'libs/underscore',\n    'libs/backbone',\n    'mvc/base-mvc',\n    'utils/localization'\n], function( _, Backbone, baseMVC, _l ){\n\nvar logNamespace = 'user';\n//==============================================================================\n/** @class Model for a Galaxy user (including anonymous users).\n *  @name User\n */\nvar User = Backbone.Model.extend( baseMVC.LoggableMixin ).extend(\n/** @lends User.prototype */{\n    _logNamespace : logNamespace,\n\n    /** API location for this resource */\n    urlRoot : function(){ return Galaxy.root + 'api/users'; },\n\n    /** Model defaults\n     *  Note: don't check for anon-users with the username as the default is '(anonymous user)'\n     *      a safer method is if( !user.get( 'email' ) ) -> anon user\n     */\n    defaults : /** @lends User.prototype */{\n        id                      : null,\n        username                : '(' + _l( \"anonymous user\" ) + ')',\n        email                   : \"\",\n        total_disk_usage        : 0,\n        nice_total_disk_usage   : \"\",\n        quota_percent           : null,\n        is_admin                : false\n    },\n\n    /** Set up and bind events\n     *  @param {Object} data Initial model data.\n     */\n    initialize : function( data ){\n        this.log( 'User.initialize:', data );\n\n        this.on( 'loaded', function( model, resp ){ this.log( this + ' has loaded:', model, resp ); });\n        this.on( 'change', function( model, data ){ this.log( this + ' has changed:', model, data.changes ); });\n    },\n\n    isAnonymous : function(){\n        return ( !this.get( 'email' ) );\n    },\n\n    isAdmin : function(){\n        return ( this.get( 'is_admin' ) );\n    },\n\n    /** Load a user with the API using an id.\n     *      If getting an anonymous user or no access to a user id, pass the User.CURRENT_ID_STR\n     *      (e.g. 'current') and the API will return the current transaction's user data.\n     *  @param {String} idOrCurrent encoded user id or the User.CURRENT_ID_STR\n     *  @param {Object} options hash to pass to Backbone.Model.fetch. Can contain success, error fns.\n     *  @fires loaded when the model has been loaded from the API, passing the newModel and AJAX response.\n     */\n    loadFromApi : function( idOrCurrent, options ){\n        idOrCurrent = idOrCurrent || User.CURRENT_ID_STR;\n\n        options = options || {};\n        var model = this,\n            userFn = options.success;\n\n        /** @ignore */\n        options.success = function( newModel, response ){\n            model.trigger( 'loaded', newModel, response );\n            if( userFn ){ userFn( newModel, response ); }\n        };\n\n        // requests for the current user must have a sep. constructed url (fetch don't work, ma)\n        if( idOrCurrent === User.CURRENT_ID_STR ){\n            options.url = this.urlRoot + '/' + User.CURRENT_ID_STR;\n        }\n        return Backbone.Model.prototype.fetch.call( this, options );\n    },\n\n    /** Clears all data from the sessionStorage.\n     */\n    clearSessionStorage : function(){\n        for( var key in sessionStorage ){\n            //TODO: store these under the user key so we don't have to do this\n            // currently only history\n            if( key.indexOf( 'history:' ) === 0 ){\n                sessionStorage.removeItem( key );\n\n            } else if( key === 'history-panel' ){\n                sessionStorage.removeItem( key );\n            }\n        }\n    },\n\n    /** string representation */\n    toString : function(){\n        var userInfo = [ this.get( 'username' ) ];\n        if( this.get( 'id' ) ){\n            userInfo.unshift( this.get( 'id' ) );\n            userInfo.push( this.get( 'email' ) );\n        }\n        return 'User(' + userInfo.join( ':' ) + ')';\n    }\n});\n\n// string to send to tell server to return this transaction's user (see api/users.py)\nUser.CURRENT_ID_STR = 'current';\n\n// class method to load the current user via the api and return that model\nUser.getCurrentUserFromApi = function( options ){\n    var currentUser = new User();\n    currentUser.loadFromApi( User.CURRENT_ID_STR, options );\n    return currentUser;\n};\n\n// (stub) collection for users (shouldn't be common unless admin UI)\nvar UserCollection = Backbone.Collection.extend( baseMVC.LoggableMixin ).extend({\n    model   : User,\n    urlRoot : function(){ return Galaxy.root + 'api/users'; },\n    //logger  : console,\n});\n\n\n//==============================================================================\nreturn {\n    User : User\n};});\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./galaxy/scripts/mvc/user/user-model.js\n ** module id = 65\n ** module chunks = 3 5\n **/","define([\n    'libs/underscore',\n    'libs/backbone',\n    'mvc/base-mvc',\n    'mvc/user/user-model',\n    'utils/metrics-logger',\n    'utils/add-logging',\n    'utils/localization'\n], function( _, Backbone, BASE_MVC, userModel, metricsLogger, addLogging, localize ){\n\n// TODO: move into a singleton pattern and have dependents import Galaxy\n// ============================================================================\n/** Base galaxy client-side application.\n *      Iniitializes:\n *          logger      : the logger/metrics-logger\n *          localize    : the string localizer\n *          config      : the current configuration (any k/v in\n *              galaxy.ini available from the configuration API)\n *          user        : the current user (as a mvc/user/user-model)\n */\nfunction GalaxyApp( options, bootstrapped ){\n    var self = this;\n    return self._init( options || {}, bootstrapped || {} );\n}\n\n// add logging shortcuts for this object\naddLogging( GalaxyApp, 'GalaxyApp' );\n\n// a debug flag can be set via local storage and made available during script/page loading\nvar DEBUGGING_KEY = 'galaxy:debug',\n    NAMESPACE_KEY = DEBUGGING_KEY + ':namespaces',\n    localDebugging = false;\ntry {\n    localDebugging = localStorage.getItem( DEBUGGING_KEY ) == 'true';\n} catch( storageErr ){\n    console.log( localize( 'localStorage not available for debug flag retrieval' ) );\n}\n\n/** initalize options and sub-components */\nGalaxyApp.prototype._init = function __init( options, bootstrapped ){\n    var self = this;\n    _.extend( self, Backbone.Events );\n    if( localDebugging ){\n        self.logger = console;\n        console.debug( 'debugging galaxy:', 'options:', options, 'bootstrapped:', bootstrapped );\n    }\n\n    self._processOptions( options );\n    // special case for root\n    self.root = options.root || '/';\n\n    self._initConfig( options.config || bootstrapped.config || {} );\n    self._patchGalaxy( window.Galaxy );\n\n    self._initLogger( self.options.loggerOptions || {} );\n    // at this point, either logging or not and namespaces are enabled - chat it up\n    self.debug( 'GalaxyApp.options: ', self.options );\n    self.debug( 'GalaxyApp.config: ', self.config );\n    self.debug( 'GalaxyApp.logger: ', self.logger );\n\n    self._initLocale();\n    self.debug( 'GalaxyApp.localize: ', self.localize );\n\n    self.config = options.config || {};\n    self.debug( 'GalaxyApp.config: ', self.config );\n\n    self._initUser( options.user || {} );\n    self.debug( 'GalaxyApp.user: ', self.user );\n\n    self._setUpListeners();\n    self.trigger( 'ready', self );\n\n    return self;\n};\n\n/** default options */\nGalaxyApp.prototype.defaultOptions = {\n    /** monkey patch attributes from existing window.Galaxy object? */\n    patchExisting   : true,\n    /** root url of this app */\n    root            : '/'\n};\n\n/** add an option from options if the key matches an option in defaultOptions */\nGalaxyApp.prototype._processOptions = function _processOptions( options ){\n    var self = this,\n        defaults = self.defaultOptions;\n\n    self.options = {};\n    for( var k in defaults ){\n        if( defaults.hasOwnProperty( k ) ){\n            self.options[ k ] = ( options.hasOwnProperty( k ) )?( options[ k ] ):( defaults[ k ] );\n        }\n    }\n    return self;\n};\n\n/** parse the config and any extra info derived from it */\nGalaxyApp.prototype._initConfig = function _initConfig( config ){\n    var self = this;\n    self.config = config;\n\n    // give precendence to localdebugging for this setting\n    self.config.debug = localDebugging || self.config.debug;\n\n    return self;\n};\n\n/** add an option from options if the key matches an option in defaultOptions */\nGalaxyApp.prototype._patchGalaxy = function _patchGalaxy( patchWith ){\n    var self = this;\n    // in case req or plain script tag order has created a prev. version of the Galaxy obj...\n    if( self.options.patchExisting && patchWith ){\n        // self.debug( 'found existing Galaxy object:', patchWith );\n        // ...(for now) monkey patch any added attributes that the previous Galaxy may have had\n        //TODO: move those attributes to more formal assignment in GalaxyApp\n        for( var k in patchWith ){\n            if( patchWith.hasOwnProperty( k ) ){\n                // self.debug( '\\t patching in ' + k + ' to Galaxy:', self[ k ] );\n                self[ k ] = patchWith[ k ];\n            }\n        }\n    }\n};\n\n/** set up the metrics logger (utils/metrics-logger) and pass loggerOptions */\nGalaxyApp.prototype._initLogger = function _initLogger( loggerOptions ){\n    var self = this;\n    // default to console logging at the debug level if the debug flag is set\n    if( self.config.debug ){\n        loggerOptions.consoleLogger = loggerOptions.consoleLogger || console;\n        loggerOptions.consoleLevel = loggerOptions.consoleLevel || metricsLogger.MetricsLogger.ALL;\n        // load any logging namespaces from localStorage if we can\n        try {\n            loggerOptions.consoleNamespaceWhitelist = localStorage.getItem( NAMESPACE_KEY ).split( ',' );\n        } catch( storageErr ){}\n    }\n    self.logger = new metricsLogger.MetricsLogger( loggerOptions );\n    self.emit = {};\n    [ 'log', 'debug', 'info', 'warn', 'error', 'metric' ].map(function( i ) {\n        self.emit[ i ] = function( data ){\n            self.logger.emit( i, arguments[ 0 ], Array.prototype.slice.call( arguments, 1 ) );\n        };\n    });\n\n    if( self.config.debug ){\n        // add this logger to mvc's loggable mixin so that all models can use the logger\n        BASE_MVC.LoggableMixin.logger = self.logger;\n    }\n    return self;\n};\n\n/** add the localize fn to this object and the window namespace (as '_l') */\nGalaxyApp.prototype._initLocale = function _initLocale( options ){\n    var self = this;\n    self.debug( '_initLocale:', options );\n    self.localize = localize;\n    // add to window as global shortened alias\n    // TODO: temporary - remove when can require for plugins\n    window._l = self.localize;\n    return self;\n};\n\n/** set up the current user as a Backbone model (mvc/user/user-model) */\nGalaxyApp.prototype._initUser = function _initUser( userJSON ){\n    var self = this;\n    self.debug( '_initUser:', userJSON );\n    self.user = new userModel.User( userJSON );\n    self.user.logger = self.logger;\n    return self;\n};\n\n/** Set up DOM/jQuery/Backbone event listeners enabled for all pages */\nGalaxyApp.prototype._setUpListeners = function _setUpListeners(){\n    var self = this;\n\n    // hook to jq beforeSend to record the most recent ajax call and cache some data about it\n    /** cached info about the last ajax call made through jQuery */\n    self.lastAjax = {};\n    $( document ).bind( 'ajaxSend', function( ev, xhr, options ){\n        var data = options.data;\n        try {\n            data = JSON.parse( data );\n        } catch( err ){}\n\n        self.lastAjax = {\n            url     : location.href.slice( 0, -1 ) + options.url,\n            data    : data\n        };\n        //TODO:?? we might somehow manage to *retry* ajax using either this hook or Backbone.sync\n    });\n    return self;\n};\n\n/** Turn debugging/console-output on/off by passing boolean. Pass nothing to get current setting. */\nGalaxyApp.prototype.debugging = function _debugging( setting ){\n    var self = this;\n    try {\n        if( setting === undefined ){\n            return localStorage.getItem( DEBUGGING_KEY ) === 'true';\n        }\n        if( setting ){\n            localStorage.setItem( DEBUGGING_KEY, true );\n            return true;\n        }\n\n        localStorage.removeItem( DEBUGGING_KEY );\n        // also remove all namespaces\n        self.debuggingNamespaces( null );\n\n    } catch( storageErr ){\n        console.log( localize( 'localStorage not available for debug flag retrieval' ) );\n    }\n    return false;\n};\n\n/** Add, remove, or clear namespaces from the debugging filters\n *  Pass no arguments to retrieve the existing namespaces as an array.\n *  Pass in null to clear all namespaces (all logging messages will show now).\n *  Pass in an array of strings or single string of the namespaces to filter to.\n *  Returns the new/current namespaces as an array;\n */\nGalaxyApp.prototype.debuggingNamespaces = function _debuggingNamespaces( namespaces ){\n    var self = this;\n    try {\n        if( namespaces === undefined ){\n            var csv = localStorage.getItem( NAMESPACE_KEY );\n            return typeof( csv ) === 'string'? csv.split( ',' ) : [];\n        } else if( namespaces === null ) {\n            localStorage.removeItem( NAMESPACE_KEY );\n        } else {\n            localStorage.setItem( NAMESPACE_KEY, namespaces );\n        }\n        var newSettings = self.debuggingNamespaces();\n        if( self.logger ){\n            self.logger.options.consoleNamespaceWhitelist = newSettings;\n        }\n        return newSettings;\n    } catch( storageErr ){\n        console.log( localize( 'localStorage not available for debug namespace retrieval' ) );\n    }\n};\n\n/** string rep */\nGalaxyApp.prototype.toString = function toString(){\n    var userEmail = this.user? ( this.user.get( 'email' ) || '(anonymous)' ) : 'uninitialized';\n    return 'GalaxyApp(' + userEmail + ')';\n};\n\n// ============================================================================\n    return {\n        GalaxyApp : GalaxyApp\n    };\n});\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./galaxy/scripts/galaxy-app-base.js\n ** module id = 117\n ** module chunks = 5\n **/","define([\n], function(){\n/*global window, jQuery, console */\n/*=============================================================================\nTODO:\n    while anon: logs saved to 'logs-null' - this will never post\n        unless we manually do so at/after login\n        OR prepend when userId and localStorage has 'logs-null'\n    wire up _delayPost and test\n\n=============================================================================*/\n/** @class MetricsLogger\n *\n *  Object to cache, output, and post log/metric messages to the server.\n *  Meant to be attached to the Galaxy object.\n *\n *  Log from objects by either attaching logger directly:\n *      panel.logger.metric( 'user dataset deletion', panel.user.id, hda.toJSON() )\n *  or using the LoggableMixin or addLogging function:\n *      MyBackboneModel.extend( LoggableMixin ).extend({ ... })\n *      addLogging( MyBackboneModel, 'my-backbone-model' )\n *\n *  Log from templates by calling directly from Galaxy object:\n *      Galaxy.logger.metric( 'template loaded', { ownedByUser : true });\n *\n *  If you attempt to log an un-serializable object (circular reference, window, etc.),\n *  that entry will not be cached (or sent). If you set consoleLevel and consoleLogger\n *  appropriately, a warning will be shown when this happens:\n *      > panel.metric( 'something weird with window', { window : window })\n *      !'Metrics logger could not stringify logArguments: ...'\n */\nfunction MetricsLogger( options ){\n    options = options || {};\n    var self = this;\n\n    ///** get the current user's id from bootstrapped data or options */\n    self.userId = ( window.bootstrapped && window.bootstrapped.user )? window.bootstrapped.user.id: null;\n    self.userId = self.userId || options.userId || null;\n\n    /** the (optional) console to emit logs to */\n    self.consoleLogger = options.consoleLogger || null;\n\n    self._init( options );\n    return self;\n}\n\n//----------------------------------------------------------------------------- defaults and constants\n// see: python std lib, logging\nMetricsLogger.ALL   =  0;\nMetricsLogger.LOG   =  0;\nMetricsLogger.DEBUG = 10;\nMetricsLogger.INFO  = 20;\nMetricsLogger.WARN  = 30;\nMetricsLogger.ERROR = 40;\n// metrics levels here?\n//MetricsLogger.MinorEvent  = 45;\n//MetricsLogger.MajorEvent  = 50;\nMetricsLogger.METRIC = 50;\nMetricsLogger.NONE = 100;\n\n/** default options - override these through the constructor */\nMetricsLogger.defaultOptions = {\n    /** if an incoming message has a level >= this, it will be cached - can also be a string (e.g. 'debug') */\n    logLevel            : MetricsLogger.NONE,\n    /** if an incoming message has a level >= this, it will be output to the console */\n    consoleLevel        : MetricsLogger.NONE,\n    /** the default 'namespace' or label associated with an incoming message (if none is passed) */\n    defaultNamespace    : 'Galaxy',\n    /** the namespaces output to the console (all namespaces will be output if this is falsy)\n     *  note: applies only to the console (not the event/metrics log/cache)\n     */\n    consoleNamespaceWhitelist : null,\n    /** the prefix attached to client-side logs to distinguish them in the metrics db */\n    clientPrefix        : 'client.',\n\n    /** the maximum number of messages the cache should hold; if exceeded older messages are removed first */\n    maxCacheSize        : 3000,\n    /** the number of messages accumulate before posting to the server; should be <= maxCacheSize */\n    postSize            : 1000,\n    /** T/F whether to add a timestamp to incoming cached messages */\n    addTime             : true,\n    /** string to prefix to userid for cache web storage */\n    cacheKeyPrefix      : 'logs-',\n\n    /** the relative url to post messages to */\n    postUrl             : '/api/metrics',\n    /** delay before trying post again after two failures */\n    delayPostInMs       : 1000 * 60 * 10,\n\n    /** an (optional) function that should return an object; used to send additional data with the metrics */\n    getPingData         : undefined,\n    /** an (optional) function that will handle the servers response after successfully posting messages */\n    onServerResponse    : undefined\n};\n\n//----------------------------------------------------------------------------- set up\n/** initialize the logger with options, set up instance vars and cache, and add onpageunload to window */\nMetricsLogger.prototype._init = function _init( options ){\n    var self = this;\n    self.options = {};\n    for( var k in MetricsLogger.defaultOptions ){\n        if( MetricsLogger.defaultOptions.hasOwnProperty( k ) ){\n            self.options[ k ] = ( options.hasOwnProperty( k ) )?( options[ k ] ):( MetricsLogger.defaultOptions[ k ] );\n        }\n    }\n    self.options.logLevel = self._parseLevel( self.options.logLevel );\n    self.options.consoleLevel = self._parseLevel( self.options.consoleLevel );\n    //self._emitToConsole( 'debug', 'MetricsLogger', 'MetricsLogger.options:', self.options );\n\n    /** is the logger currently sending? */\n    self._sending = false;\n    /** the setTimeout id if the logger POST has failed more than once */\n    self._waiting = null;\n    /** the current number of entries to send in a POST */\n    self._postSize = self.options.postSize;\n\n    self._initCache();\n\n    return self;\n};\n\n/** initialize the cache */\nMetricsLogger.prototype._initCache = function _initCache(){\n    try {\n        this.cache = new LoggingCache({\n            maxSize : this.options.maxCacheSize,\n            key     : this.options.cacheKeyPrefix + this.userId\n        });\n    } catch( err ){\n        this._emitToConsole( 'warn', 'MetricsLogger', [ 'Could not intitialize logging cache:', err ] );\n        this.options.logLevel = MetricsLogger.NONE;\n    }\n};\n\n/** return the numeric log level if level in 'none, debug, log, info, warn, error' */\nMetricsLogger.prototype._parseLevel = function _parseLevel( level ){\n    var type = typeof level;\n    if( type === 'number' ){ return level; }\n    if( type === 'string' ){\n        var upper = level.toUpperCase();\n        if( MetricsLogger.hasOwnProperty( upper ) ){\n            return MetricsLogger[ upper ];\n        }\n    }\n    throw new Error( 'Unknown log level: ' + level );\n};\n\n\n//----------------------------------------------------------------------------- main entry point\n/** record a log/message's arguments to the cache and/or the console based on level and namespace */\nMetricsLogger.prototype.emit = function emit( level, namespace, logArguments ){\n    //this._emitToConsole( 'debug', 'MetricsLogger', [ 'emit:', level, namespace, logArguments ]);\n    var self = this;\n    namespace = namespace || self.options.defaultNamespace;\n    if( !level || !logArguments ){\n        return self;\n    }\n    // add to cache if proper level\n    //TODO: respect do not track?\n    //if( !navigator.doNotTrack && level >= self.options.logLevel ){\n    level = self._parseLevel( level );\n    if( level >= self.options.logLevel ){\n        self._addToCache( level, namespace, logArguments );\n    }\n    // also emit to consoleLogger if proper level for that\n    if( self.consoleLogger && level >= self.options.consoleLevel ){\n        self._emitToConsole( level, namespace, logArguments );\n    }\n    return self;\n};\n\n//----------------------------------------------------------------------------- cache\n/** add a message to the cache and if messages.length is high enough post them to the server */\nMetricsLogger.prototype._addToCache = function _addToCache( level, namespace, logArguments ){\n    this._emitToConsole( 'debug', 'MetricsLogger',\n        [ '_addToCache:', arguments, this.options.addTime, this.cache.length() ]);\n    //this._emitToConsole( 'debug', 'MetricsLogger', [ '\\t logArguments:', logArguments ]);\n    var self = this;\n    // try add to the cache and if we've got _postSize number of entries, attempt to post them to the server\n    try {\n        var newLength = self.cache.add( self._buildEntry( level, namespace, logArguments ) );\n        if( newLength >= self._postSize ){\n            self._postCache();\n        }\n    // discard entry if an error occurs, but warn if level set to do so\n    } catch( err ){\n        self._emitToConsole( 'warn', 'MetricsLogger',\n            [ 'Metrics logger could not stringify logArguments:', namespace, logArguments ] );\n        self._emitToConsole( 'error', 'MetricsLogger', [ err ] );\n\n    }\n    return self;\n};\n\n/** build a log cache entry object from the given level, namespace, and arguments (optionally adding timestamp */\nMetricsLogger.prototype._buildEntry = function _buildEntry( level, namespace, logArguments ){\n    this._emitToConsole( 'debug', 'MetricsLogger', [ '_buildEntry:', arguments ]);\n    var entry = {\n            level       : level,\n            namespace   : this.options.clientPrefix + namespace,\n            args        : logArguments\n        };\n    if( this.options.addTime ){\n        entry.time = new Date().toISOString();\n    }\n    return entry;\n};\n\n/** post _postSize messages from the cache to the server, removing them if successful\n *      if the post fails, wait until maxCacheSize is accumulated instead and try again then\n *      in addition to the messages from the cache ('metrics'), any info from getPingData (if set) will be sent\n *      onServerResponse will be called (if set) with any response from the server\n */\nMetricsLogger.prototype._postCache = function _postCache( options ){\n    options = options || {};\n    this._emitToConsole( 'info', 'MetricsLogger', [ '_postCache', options, this._postSize ]);\n\n    // short circuit if we're already sending\n    if( !this.options.postUrl || this._sending ){\n        return jQuery.when({});\n    }\n\n    var self = this,\n        postSize = options.count || self._postSize,\n        // do not splice - remove after *successful* post\n        entries = self.cache.get( postSize ),\n        entriesLength = entries.length,\n        // use the optional getPingData to add any extra info we may want to send\n        postData = ( typeof self.options.getPingData === 'function' )?( self.options.getPingData() ):( {} );\n    //console.debug( postSize, entriesLength );\n\n    // add the metrics and send\n    postData.metrics = JSON.stringify( entries );\n    //console.debug( postData.metrics );\n    self._sending = true;\n    return jQuery.post( self.options.postUrl, postData )\n        .always( function(){\n            self._sending = false;\n        })\n        .fail( function( xhr, status, message ){\n            // if we failed the previous time, set the next post target to the max num of entries\n            self._postSize = self.options.maxCacheSize;\n//TODO:??\n            // log this failure to explain any gap in metrics\n            this.emit( 'error', 'MetricsLogger', [ '_postCache error:',\n                xhr.readyState, xhr.status, xhr.responseJSON || xhr.responseText ]);\n//TODO: still doesn't solve the problem that when cache == max, post will be tried on every emit\n//TODO: see _delayPost\n        })\n        .done( function( response ){\n            if( typeof self.options.onServerResponse === 'function' ){\n                self.options.onServerResponse( response );\n            }\n            // only remove if post successful\n            self.cache.remove( entriesLength );\n            //console.debug( 'removed entries:', entriesLength, 'size now:', self.cache.length() );\n            // if we succeeded, reset the post target to the normal num of entries\n            self._postSize = self.options.postSize;\n        });\n    // return the xhr promise\n};\n\n/** set _waiting to true and, after delayPostInMs, set it back to false */\nMetricsLogger.prototype._delayPost = function _delayPost(){\n//TODO: this won't work between pages\n    var self = this;\n    self._waiting = setTimeout( function(){\n        self._waiting = null;\n    }, self.options.delayPostInMs );\n};\n\n\n//----------------------------------------------------------------------------- console\n/** output message to console based on level and consoleLogger type */\nMetricsLogger.prototype._emitToConsole = function _emitToConsole( level, namespace, logArguments ){\n    //console.debug( '_emitToConsole:', level, namespace, logArguments );\n    var self = this,\n        whitelist = self.options.consoleNamespaceWhitelist;\n    if( !self.consoleLogger ){ return self; }\n    // if a whitelist for namespaces is set, bail if this namespace is not in the list\n    if( whitelist && whitelist.indexOf( namespace ) === -1 ){\n        return self;\n    }\n\n    var args = Array.prototype.slice.call( logArguments, 0 );\n    args.unshift( namespace );\n//TODO: script location and/or source maps?\n//TODO: branch on navigator.userAgent == AIIEEE - it only has log\n    if(        level >= MetricsLogger.METRIC && typeof( self.consoleLogger.info ) === 'function' ){\n        return self.consoleLogger.info.apply( self.consoleLogger, args );\n\n    } else if( level >= MetricsLogger.ERROR && typeof( self.consoleLogger.error ) === 'function' ){\n        return self.consoleLogger.error.apply( self.consoleLogger, args );\n    } else if( level >= MetricsLogger.WARN && typeof( self.consoleLogger.warn ) === 'function' ){\n        self.consoleLogger.warn.apply( self.consoleLogger, args );\n    } else if( level >= MetricsLogger.INFO && typeof( self.consoleLogger.info ) === 'function' ){\n        self.consoleLogger.info.apply( self.consoleLogger, args );\n    } else if( level >= MetricsLogger.DEBUG && typeof( self.consoleLogger.debug ) === 'function' ){\n        self.consoleLogger.debug.apply( self.consoleLogger, args );\n    } else if( typeof( self.consoleLogger.log ) === 'function' ){\n        self.consoleLogger.log.apply( self.consoleLogger, args );\n    }\n    return self;\n};\n\n//----------------------------------------------------------------------------- shortcuts\n// generic functions when logging from non-namespaced object (e.g. templates)\n/** log to default namespace */\nMetricsLogger.prototype.log = function log(){\n    this.emit( 1, this.options.defaultNamespace,\n        Array.prototype.slice.call( arguments, 0 ) );\n};\n\n/** debug to default namespace */\nMetricsLogger.prototype.debug = function debug(){\n    this.emit( MetricsLogger.DEBUG, this.options.defaultNamespace,\n        Array.prototype.slice.call( arguments, 0 ) );\n};\n\n/** info to default namespace */\nMetricsLogger.prototype.info = function info(){\n    this.emit( MetricsLogger.INFO, this.options.defaultNamespace,\n        Array.prototype.slice.call( arguments, 0 ) );\n};\n\n/** warn to default namespace */\nMetricsLogger.prototype.warn = function warn(){\n    this.emit( MetricsLogger.WARN, this.options.defaultNamespace,\n        Array.prototype.slice.call( arguments, 0 ) );\n};\n\n/** error to default namespace */\nMetricsLogger.prototype.error = function error(){\n    this.emit( MetricsLogger.ERROR, this.options.defaultNamespace,\n        Array.prototype.slice.call( arguments, 0 ) );\n};\n\n/** metric to default namespace */\nMetricsLogger.prototype.metric = function metric(){\n    this.emit( MetricsLogger.METRIC, this.options.defaultNamespace,\n        Array.prototype.slice.call( arguments, 0 ) );\n};\n\n\n/* ============================================================================\nTODO:\n    need a performance pass - the JSON un/parsing is a bit much\n\n============================================================================ */\n/** @class LoggingCache\n *  Simple implementation of cache wrapping an array.\n *\n *  Formats an entry before it's cached and only keeps options.maxSize number\n *  of entries. Older entries are deleted first.\n */\nfunction LoggingCache( options ){\n    var self = this;\n    return self._init( options || {} );\n}\n\n/** default options */\nLoggingCache.defaultOptions = {\n    /** maximum number of entries to keep before discarding oldest */\n    maxSize     : 5000\n};\n\n/** initialize with options */\nLoggingCache.prototype._init = function _init( options ){\n    if( !this._hasStorage() ){\n        //TODO: fall back to jstorage\n        throw new Error( 'LoggingCache needs localStorage' );\n    }\n    if( !options.key ){\n        throw new Error( 'LoggingCache needs key for localStorage' );\n    }\n    this.key = options.key;\n    this._initStorage();\n\n    this.maxSize = options.maxSize || LoggingCache.defaultOptions.maxSize;\n    return this;\n};\n\n/** tests for localStorage fns */\nLoggingCache.prototype._hasStorage = function _hasStorage(){\n//TODO: modernizr\n    var test = 'test';\n    try {\n        localStorage.setItem( test, test );\n        localStorage.removeItem( test );\n        return true;\n    } catch( e ){\n        return false;\n    }\n};\n\n/** if no localStorage set for key, initialize to empty array */\nLoggingCache.prototype._initStorage = function _initStorage(){\n    if( localStorage.getItem( this.key ) === null ){\n        return this.empty();\n    }\n    return this;\n};\n\n/** add an entry to the cache, removing the oldest beforehand if size >= maxSize */\nLoggingCache.prototype.add = function add( entry ){\n    var self = this,\n        _cache = self._fetchAndParse(),\n        overage = ( _cache.length + 1 ) - self.maxSize;\n    if( overage > 0 ){\n        _cache.splice( 0, overage );\n    }\n    _cache.push( entry );\n    self._unparseAndStore( _cache );\n    return _cache.length;\n};\n\n/** get the entries from localStorage and parse them */\nLoggingCache.prototype._fetchAndParse = function _fetchAndParse(){\n    var self = this;\n    return JSON.parse( localStorage.getItem( self.key ) );\n};\n\n/** stringify the entries and put them in localStorage */\nLoggingCache.prototype._unparseAndStore = function _unparseAndStore( entries ){\n    var self = this;\n    return localStorage.setItem( self.key, JSON.stringify( entries ) );\n};\n\n///** process the entry before caching */\n//LoggingCache.prototype._preprocessEntry = function _preprocessEntry( entry ){\n//    return JSON.stringify( entry );\n//};\n\n/** return the length --- oh, getters where are you? */\nLoggingCache.prototype.length = function length(){\n    return this._fetchAndParse().length;\n};\n\n/** get count number of entries starting with the oldest */\nLoggingCache.prototype.get = function get( count ){\n    return this._fetchAndParse().slice( 0, count );\n};\n\n/** remove count number of entries starting with the oldest */\nLoggingCache.prototype.remove = function remove( count ){\n    var _cache = this._fetchAndParse(),\n        removed = _cache.splice( 0, count );\n    this._unparseAndStore( _cache );\n    return removed;\n};\n\n/** empty/clear the entire cache */\nLoggingCache.prototype.empty = function empty(){\n    localStorage.setItem( this.key, '[]' );\n    return this;\n};\n\n/** stringify count number of entries (but do not remove) */\nLoggingCache.prototype.stringify = function stringify( count ){\n    return JSON.stringify( this.get( count ) );\n};\n\n/** outputs entire cache to console */\nLoggingCache.prototype.print = function print(){\n    // popup? (really, carl? a popup?) - easier to copy/paste\n    console.log( JSON.stringify( this._fetchAndParse(), null, '  ' ) );\n};\n\n\n//=============================================================================\n    return {\n        MetricsLogger  : MetricsLogger,\n        LoggingCache   : LoggingCache\n    };\n});\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./galaxy/scripts/utils/metrics-logger.js\n ** module id = 146\n ** module chunks = 5\n **/"],"sourceRoot":""}