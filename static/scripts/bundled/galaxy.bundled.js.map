{"version":3,"sources":["webpack:///./galaxy/scripts/apps/galaxy.js","webpack:///./galaxy/scripts/mvc/user/user-model.js?e6b2","webpack:///./galaxy/scripts/galaxy-app-base.js","webpack:///./galaxy/scripts/utils/metrics-logger.js"],"names":[],"mappings":";;;;;;;;AAAA;AACA;AACA;AACA;;;;;;;;;;;iECHA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,0BAAyB,kCAAkC,EAAE;;AAE7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA,iBAAgB,OAAO;AACvB;AACA;AACA;;AAEA,oDAAmD,gDAAgD,EAAE;AACrG,oDAAmD,yDAAyD,EAAE;AAC9G,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA,iBAAgB,OAAO;AACvB,iBAAgB,OAAO;AACvB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,0BAAyB,8BAA8B;AACvD;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,cAAa;AACb;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;;AAED;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,0BAAyB,kCAAkC,EAAE;AAC7D;AACA,EAAC;;;AAGD;AACA;AACA;AACA,IAAG;;;;;;;;;;;0GC7HH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAoC,oBAAoB;AACxD;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;AACD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,kEAAiE;AACjE;;AAEA,uDAAsD;AACtD;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,uCAAsC;AACtC;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;;AAET;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,MAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,EAAC;;;;;;;;;;;;+GC9PD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAwD,MAAM;AAC9D;AACA;AACA;AACA,mDAAkD,qBAAqB;AACvE;AACA;AACA;AACA;AACA,yDAAwD,kBAAkB;AAC1E;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,8DAA6D;AAC7D;AACA,wEAAuE;AACvE;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,6DAA4D;AAC5D;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT,MAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,6BAA4B,cAAc;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,8BAA6B;AAC7B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,0GAAyG;AACzG;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA8B,aAAa;AAC3C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,MAAK;AACL;AACA,MAAK;AACL;AACA,MAAK;AACL;AACA,MAAK;AACL;AACA,MAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAoC;AACpC;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA,EAAC","file":"galaxy.bundled.js","sourcesContent":["//TODO: remove this\nvar GalaxyApp = require( '../galaxy-app-base' ).GalaxyApp;\nwindow.GalaxyApp = GalaxyApp;\nexports = GalaxyApp;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./galaxy/scripts/apps/galaxy.js\n ** module id = 0\n ** module chunks = 4\n **/","define([\n    'libs/underscore',\n    'libs/backbone',\n    'mvc/base-mvc',\n    'utils/localization'\n], function( _, Backbone, baseMVC, _l ){\n\nvar logNamespace = 'user';\n//==============================================================================\n/** @class Model for a Galaxy user (including anonymous users).\n *  @name User\n */\nvar User = Backbone.Model.extend( baseMVC.LoggableMixin ).extend(\n/** @lends User.prototype */{\n    _logNamespace : logNamespace,\n\n    /** API location for this resource */\n    urlRoot : function(){ return Galaxy.root + 'api/users'; },\n\n    /** Model defaults\n     *  Note: don't check for anon-users with the username as the default is '(anonymous user)'\n     *      a safer method is if( !user.get( 'email' ) ) -> anon user\n     */\n    defaults : /** @lends User.prototype */{\n        id                      : null,\n        username                : '(' + _l( \"anonymous user\" ) + ')',\n        email                   : \"\",\n        total_disk_usage        : 0,\n        nice_total_disk_usage   : \"\",\n        quota_percent           : null,\n        is_admin                : false\n    },\n\n    /** Set up and bind events\n     *  @param {Object} data Initial model data.\n     */\n    initialize : function( data ){\n        this.log( 'User.initialize:', data );\n\n        this.on( 'loaded', function( model, resp ){ this.log( this + ' has loaded:', model, resp ); });\n        this.on( 'change', function( model, data ){ this.log( this + ' has changed:', model, data.changes ); });\n    },\n\n    isAnonymous : function(){\n        return ( !this.get( 'email' ) );\n    },\n\n    isAdmin : function(){\n        return ( this.get( 'is_admin' ) );\n    },\n\n    /** Load a user with the API using an id.\n     *      If getting an anonymous user or no access to a user id, pass the User.CURRENT_ID_STR\n     *      (e.g. 'current') and the API will return the current transaction's user data.\n     *  @param {String} idOrCurrent encoded user id or the User.CURRENT_ID_STR\n     *  @param {Object} options hash to pass to Backbone.Model.fetch. Can contain success, error fns.\n     *  @fires loaded when the model has been loaded from the API, passing the newModel and AJAX response.\n     */\n    loadFromApi : function( idOrCurrent, options ){\n        idOrCurrent = idOrCurrent || User.CURRENT_ID_STR;\n\n        options = options || {};\n        var model = this,\n            userFn = options.success;\n\n        /** @ignore */\n        options.success = function( newModel, response ){\n            model.trigger( 'loaded', newModel, response );\n            if( userFn ){ userFn( newModel, response ); }\n        };\n\n        // requests for the current user must have a sep. constructed url (fetch don't work, ma)\n        if( idOrCurrent === User.CURRENT_ID_STR ){\n            options.url = this.urlRoot + '/' + User.CURRENT_ID_STR;\n        }\n        return Backbone.Model.prototype.fetch.call( this, options );\n    },\n\n    /** Clears all data from the sessionStorage.\n     */\n    clearSessionStorage : function(){\n        for( var key in sessionStorage ){\n            //TODO: store these under the user key so we don't have to do this\n            // currently only history\n            if( key.indexOf( 'history:' ) === 0 ){\n                sessionStorage.removeItem( key );\n\n            } else if( key === 'history-panel' ){\n                sessionStorage.removeItem( key );\n            }\n        }\n    },\n\n    /** string representation */\n    toString : function(){\n        var userInfo = [ this.get( 'username' ) ];\n        if( this.get( 'id' ) ){\n            userInfo.unshift( this.get( 'id' ) );\n            userInfo.push( this.get( 'email' ) );\n        }\n        return 'User(' + userInfo.join( ':' ) + ')';\n    }\n});\n\n// string to send to tell server to return this transaction's user (see api/users.py)\nUser.CURRENT_ID_STR = 'current';\n\n// class method to load the current user via the api and return that model\nUser.getCurrentUserFromApi = function( options ){\n    var currentUser = new User();\n    currentUser.loadFromApi( User.CURRENT_ID_STR, options );\n    return currentUser;\n};\n\n// (stub) collection for users (shouldn't be common unless admin UI)\nvar UserCollection = Backbone.Collection.extend( baseMVC.LoggableMixin ).extend({\n    model   : User,\n    urlRoot : function(){ return Galaxy.root + 'api/users'; },\n    //logger  : console,\n});\n\n\n//==============================================================================\nreturn {\n    User : User\n};});\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./galaxy/scripts/mvc/user/user-model.js\n ** module id = 108\n ** module chunks = 0 4\n **/","define([\n    'libs/underscore',\n    'libs/backbone',\n    'mvc/base-mvc',\n    'mvc/user/user-model',\n    'utils/metrics-logger',\n    'utils/add-logging',\n    'utils/localization'\n], function( _, Backbone, BASE_MVC, userModel, metricsLogger, addLogging, localize ){\n\n// TODO: move into a singleton pattern and have dependents import Galaxy\n// ============================================================================\n/** Base galaxy client-side application.\n *      Iniitializes:\n *          logger      : the logger/metrics-logger\n *          localize    : the string localizer\n *          config      : the current configuration (any k/v in\n *              galaxy.ini available from the configuration API)\n *          user        : the current user (as a mvc/user/user-model)\n */\nfunction GalaxyApp( options, bootstrapped ){\n    var self = this;\n    return self._init( options || {}, bootstrapped || {} );\n}\n\n// add logging shortcuts for this object\naddLogging( GalaxyApp, 'GalaxyApp' );\n\n// a debug flag can be set via local storage and made available during script/page loading\nvar DEBUGGING_KEY = 'galaxy:debug',\n    NAMESPACE_KEY = DEBUGGING_KEY + ':namespaces',\n    localDebugging = false;\ntry {\n    localDebugging = localStorage.getItem( DEBUGGING_KEY ) == 'true';\n} catch( storageErr ){\n    console.log( localize( 'localStorage not available for debug flag retrieval' ) );\n}\n\n/** initalize options and sub-components */\nGalaxyApp.prototype._init = function __init( options, bootstrapped ){\n    var self = this;\n    _.extend( self, Backbone.Events );\n    if( localDebugging ){\n        self.logger = console;\n        console.debug( 'debugging galaxy:', 'options:', options, 'bootstrapped:', bootstrapped );\n    }\n\n    self._processOptions( options );\n    // special case for root\n    self.root = options.root || '/';\n\n    self._initConfig( options.config || bootstrapped.config || {} );\n    self._patchGalaxy( window.Galaxy );\n\n    self._initLogger( self.options.loggerOptions || {} );\n    // at this point, either logging or not and namespaces are enabled - chat it up\n    self.debug( 'GalaxyApp.options: ', self.options );\n    self.debug( 'GalaxyApp.config: ', self.config );\n    self.debug( 'GalaxyApp.logger: ', self.logger );\n\n    self._initLocale();\n    self.debug( 'GalaxyApp.localize: ', self.localize );\n\n    self.config = options.config || {};\n    self.debug( 'GalaxyApp.config: ', self.config );\n\n    self._initUser( options.user || {} );\n    self.debug( 'GalaxyApp.user: ', self.user );\n\n    self._setUpListeners();\n    self.trigger( 'ready', self );\n\n    return self;\n};\n\n/** default options */\nGalaxyApp.prototype.defaultOptions = {\n    /** monkey patch attributes from existing window.Galaxy object? */\n    patchExisting   : true,\n    /** root url of this app */\n    // move to self.root?\n    root            : '/'\n};\n\n/** add an option from options if the key matches an option in defaultOptions */\nGalaxyApp.prototype._processOptions = function _processOptions( options ){\n    var self = this,\n        defaults = self.defaultOptions;\n\n    self.options = {};\n    for( var k in defaults ){\n        if( defaults.hasOwnProperty( k ) ){\n            self.options[ k ] = ( options.hasOwnProperty( k ) )?( options[ k ] ):( defaults[ k ] );\n        }\n    }\n    return self;\n};\n\n/** parse the config and any extra info derived from it */\nGalaxyApp.prototype._initConfig = function _initConfig( config ){\n    var self = this;\n    self.config = config;\n\n    // give precendence to localdebugging for this setting\n    self.config.debug = localDebugging || self.config.debug;\n\n    return self;\n};\n\n/** add an option from options if the key matches an option in defaultOptions */\nGalaxyApp.prototype._patchGalaxy = function _patchGalaxy( patchWith ){\n    var self = this;\n    // in case req or plain script tag order has created a prev. version of the Galaxy obj...\n    if( self.options.patchExisting && patchWith ){\n        // self.debug( 'found existing Galaxy object:', patchWith );\n        // ...(for now) monkey patch any added attributes that the previous Galaxy may have had\n        //TODO: move those attributes to more formal assignment in GalaxyApp\n        for( var k in patchWith ){\n            if( patchWith.hasOwnProperty( k ) ){\n                // self.debug( '\\t patching in ' + k + ' to Galaxy:', self[ k ] );\n                self[ k ] = patchWith[ k ];\n            }\n        }\n    }\n};\n\n/** set up the metrics logger (utils/metrics-logger) and pass loggerOptions */\nGalaxyApp.prototype._initLogger = function _initLogger( loggerOptions ){\n    var self = this;\n    // default to console logging at the debug level if the debug flag is set\n    if( self.config.debug ){\n        loggerOptions.consoleLogger = loggerOptions.consoleLogger || console;\n        loggerOptions.consoleLevel = loggerOptions.consoleLevel || metricsLogger.MetricsLogger.ALL;\n        // load any logging namespaces from localStorage if we can\n        try {\n            loggerOptions.consoleNamespaceWhitelist = localStorage.getItem( NAMESPACE_KEY ).split( ',' );\n        } catch( storageErr ){}\n    }\n    self.logger = new metricsLogger.MetricsLogger( loggerOptions );\n    self.emit = {};\n    [ 'log', 'debug', 'info', 'warn', 'error', 'metric' ].map(function( i ) {\n        self.emit[ i ] = function( data ){\n            self.logger.emit( i, arguments[ 0 ], Array.prototype.slice.call( arguments, 1 ) );\n        };\n    });\n\n    if( self.config.debug ){\n        // add this logger to mvc's loggable mixin so that all models can use the logger\n        BASE_MVC.LoggableMixin.logger = self.logger;\n    }\n    return self;\n};\n\n/** add the localize fn to this object and the window namespace (as '_l') */\nGalaxyApp.prototype._initLocale = function _initLocale( options ){\n    var self = this;\n    self.debug( '_initLocale:', options );\n    self.localize = localize;\n    // add to window as global shortened alias\n    // TODO: temporary - remove when can require for plugins\n    window._l = self.localize;\n    return self;\n};\n\n/** set up the current user as a Backbone model (mvc/user/user-model) */\nGalaxyApp.prototype._initUser = function _initUser( userJSON ){\n    var self = this;\n    self.debug( '_initUser:', userJSON );\n    self.user = new userModel.User( userJSON );\n    self.user.logger = self.logger;\n    return self;\n};\n\n/** Set up DOM/jQuery/Backbone event listeners enabled for all pages */\nGalaxyApp.prototype._setUpListeners = function _setUpListeners(){\n    var self = this;\n\n    // hook to jq beforeSend to record the most recent ajax call and cache some data about it\n    /** cached info about the last ajax call made through jQuery */\n    self.lastAjax = {};\n    $( document ).bind( 'ajaxSend', function( ev, xhr, options ){\n        var data = options.data;\n        try {\n            data = JSON.parse( data );\n        } catch( err ){}\n\n        self.lastAjax = {\n            url     : location.href.slice( 0, -1 ) + options.url,\n            data    : data\n        };\n        //TODO:?? we might somehow manage to *retry* ajax using either this hook or Backbone.sync\n    });\n    return self;\n};\n\n/** Turn debugging/console-output on/off by passing boolean. Pass nothing to get current setting. */\nGalaxyApp.prototype.debugging = function _debugging( setting ){\n    var self = this;\n    try {\n        if( setting === undefined ){\n            return localStorage.getItem( DEBUGGING_KEY ) === 'true';\n        }\n        if( setting ){\n            localStorage.setItem( DEBUGGING_KEY, true );\n            return true;\n        }\n\n        localStorage.removeItem( DEBUGGING_KEY );\n        // also remove all namespaces\n        self.debuggingNamespaces( null );\n\n    } catch( storageErr ){\n        console.log( localize( 'localStorage not available for debug flag retrieval' ) );\n    }\n    return false;\n};\n\n/** Add, remove, or clear namespaces from the debugging filters\n *  Pass no arguments to retrieve the existing namespaces as an array.\n *  Pass in null to clear all namespaces (all logging messages will show now).\n *  Pass in an array of strings or single string of the namespaces to filter to.\n *  Returns the new/current namespaces as an array;\n */\nGalaxyApp.prototype.debuggingNamespaces = function _debuggingNamespaces( namespaces ){\n    var self = this;\n    try {\n        if( namespaces === undefined ){\n            var csv = localStorage.getItem( NAMESPACE_KEY );\n            return typeof( csv ) === 'string'? csv.split( ',' ) : [];\n        } else if( namespaces === null ) {\n            localStorage.removeItem( NAMESPACE_KEY );\n        } else {\n            localStorage.setItem( NAMESPACE_KEY, namespaces );\n        }\n        var newSettings = self.debuggingNamespaces();\n        if( self.logger ){\n            self.logger.options.consoleNamespaceWhitelist = newSettings;\n        }\n        return newSettings;\n    } catch( storageErr ){\n        console.log( localize( 'localStorage not available for debug namespace retrieval' ) );\n    }\n};\n\n/** string rep */\nGalaxyApp.prototype.toString = function toString(){\n    var userEmail = this.user? ( this.user.get( 'email' ) || '(anonymous)' ) : 'uninitialized';\n    return 'GalaxyApp(' + userEmail + ')';\n};\n\n// ============================================================================\n    return {\n        GalaxyApp : GalaxyApp\n    };\n});\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./galaxy/scripts/galaxy-app-base.js\n ** module id = 141\n ** module chunks = 4\n **/","define([\n], function(){\n/*global window, jQuery, console */\n/*=============================================================================\nTODO:\n    while anon: logs saved to 'logs-null' - this will never post\n        unless we manually do so at/after login\n        OR prepend when userId and localStorage has 'logs-null'\n    wire up _delayPost and test\n\n=============================================================================*/\n/** @class MetricsLogger\n *\n *  Object to cache, output, and post log/metric messages to the server.\n *  Meant to be attached to the Galaxy object.\n *\n *  Log from objects by either attaching logger directly:\n *      panel.logger.metric( 'user dataset deletion', panel.user.id, hda.toJSON() )\n *  or using the LoggableMixin or addLogging function:\n *      MyBackboneModel.extend( LoggableMixin ).extend({ ... })\n *      addLogging( MyBackboneModel, 'my-backbone-model' )\n *\n *  Log from templates by calling directly from Galaxy object:\n *      Galaxy.logger.metric( 'template loaded', { ownedByUser : true });\n *\n *  If you attempt to log an un-serializable object (circular reference, window, etc.),\n *  that entry will not be cached (or sent). If you set consoleLevel and consoleLogger\n *  appropriately, a warning will be shown when this happens:\n *      > panel.metric( 'something weird with window', { window : window })\n *      !'Metrics logger could not stringify logArguments: ...'\n */\nfunction MetricsLogger( options ){\n    options = options || {};\n    var self = this;\n\n    ///** get the current user's id from bootstrapped data or options */\n    self.userId = ( window.bootstrapped && window.bootstrapped.user )? window.bootstrapped.user.id: null;\n    self.userId = self.userId || options.userId || null;\n\n    /** the (optional) console to emit logs to */\n    self.consoleLogger = options.consoleLogger || null;\n\n    self._init( options );\n    return self;\n}\n\n//----------------------------------------------------------------------------- defaults and constants\n// see: python std lib, logging\nMetricsLogger.ALL   =  0;\nMetricsLogger.LOG   =  0;\nMetricsLogger.DEBUG = 10;\nMetricsLogger.INFO  = 20;\nMetricsLogger.WARN  = 30;\nMetricsLogger.ERROR = 40;\n// metrics levels here?\n//MetricsLogger.MinorEvent  = 45;\n//MetricsLogger.MajorEvent  = 50;\nMetricsLogger.METRIC = 50;\nMetricsLogger.NONE = 100;\n\n/** default options - override these through the constructor */\nMetricsLogger.defaultOptions = {\n    /** if an incoming message has a level >= this, it will be cached - can also be a string (e.g. 'debug') */\n    logLevel            : MetricsLogger.NONE,\n    /** if an incoming message has a level >= this, it will be output to the console */\n    consoleLevel        : MetricsLogger.NONE,\n    /** the default 'namespace' or label associated with an incoming message (if none is passed) */\n    defaultNamespace    : 'Galaxy',\n    /** the namespaces output to the console (all namespaces will be output if this is falsy)\n     *  note: applies only to the console (not the event/metrics log/cache)\n     */\n    consoleNamespaceWhitelist : null,\n    /** the prefix attached to client-side logs to distinguish them in the metrics db */\n    clientPrefix        : 'client.',\n\n    /** the maximum number of messages the cache should hold; if exceeded older messages are removed first */\n    maxCacheSize        : 3000,\n    /** the number of messages accumulate before posting to the server; should be <= maxCacheSize */\n    postSize            : 1000,\n    /** T/F whether to add a timestamp to incoming cached messages */\n    addTime             : true,\n    /** string to prefix to userid for cache web storage */\n    cacheKeyPrefix      : 'logs-',\n\n    /** the relative url to post messages to */\n    postUrl             : '/api/metrics',\n    /** delay before trying post again after two failures */\n    delayPostInMs       : 1000 * 60 * 10,\n\n    /** an (optional) function that should return an object; used to send additional data with the metrics */\n    getPingData         : undefined,\n    /** an (optional) function that will handle the servers response after successfully posting messages */\n    onServerResponse    : undefined\n};\n\n//----------------------------------------------------------------------------- set up\n/** initialize the logger with options, set up instance vars and cache, and add onpageunload to window */\nMetricsLogger.prototype._init = function _init( options ){\n    var self = this;\n    self.options = {};\n    for( var k in MetricsLogger.defaultOptions ){\n        if( MetricsLogger.defaultOptions.hasOwnProperty( k ) ){\n            self.options[ k ] = ( options.hasOwnProperty( k ) )?( options[ k ] ):( MetricsLogger.defaultOptions[ k ] );\n        }\n    }\n    self.options.logLevel = self._parseLevel( self.options.logLevel );\n    self.options.consoleLevel = self._parseLevel( self.options.consoleLevel );\n    //self._emitToConsole( 'debug', 'MetricsLogger', 'MetricsLogger.options:', self.options );\n\n    /** is the logger currently sending? */\n    self._sending = false;\n    /** the setTimeout id if the logger POST has failed more than once */\n    self._waiting = null;\n    /** the current number of entries to send in a POST */\n    self._postSize = self.options.postSize;\n\n    self._initCache();\n\n    return self;\n};\n\n/** initialize the cache */\nMetricsLogger.prototype._initCache = function _initCache(){\n    try {\n        this.cache = new LoggingCache({\n            maxSize : this.options.maxCacheSize,\n            key     : this.options.cacheKeyPrefix + this.userId\n        });\n    } catch( err ){\n        this._emitToConsole( 'warn', 'MetricsLogger', [ 'Could not intitialize logging cache:', err ] );\n        this.options.logLevel = MetricsLogger.NONE;\n    }\n};\n\n/** return the numeric log level if level in 'none, debug, log, info, warn, error' */\nMetricsLogger.prototype._parseLevel = function _parseLevel( level ){\n    var type = typeof level;\n    if( type === 'number' ){ return level; }\n    if( type === 'string' ){\n        var upper = level.toUpperCase();\n        if( MetricsLogger.hasOwnProperty( upper ) ){\n            return MetricsLogger[ upper ];\n        }\n    }\n    throw new Error( 'Unknown log level: ' + level );\n};\n\n\n//----------------------------------------------------------------------------- main entry point\n/** record a log/message's arguments to the cache and/or the console based on level and namespace */\nMetricsLogger.prototype.emit = function emit( level, namespace, logArguments ){\n    //this._emitToConsole( 'debug', 'MetricsLogger', [ 'emit:', level, namespace, logArguments ]);\n    var self = this;\n    namespace = namespace || self.options.defaultNamespace;\n    if( !level || !logArguments ){\n        return self;\n    }\n    // add to cache if proper level\n    //TODO: respect do not track?\n    //if( !navigator.doNotTrack && level >= self.options.logLevel ){\n    level = self._parseLevel( level );\n    if( level >= self.options.logLevel ){\n        self._addToCache( level, namespace, logArguments );\n    }\n    // also emit to consoleLogger if proper level for that\n    if( self.consoleLogger && level >= self.options.consoleLevel ){\n        self._emitToConsole( level, namespace, logArguments );\n    }\n    return self;\n};\n\n//----------------------------------------------------------------------------- cache\n/** add a message to the cache and if messages.length is high enough post them to the server */\nMetricsLogger.prototype._addToCache = function _addToCache( level, namespace, logArguments ){\n    this._emitToConsole( 'debug', 'MetricsLogger',\n        [ '_addToCache:', arguments, this.options.addTime, this.cache.length() ]);\n    //this._emitToConsole( 'debug', 'MetricsLogger', [ '\\t logArguments:', logArguments ]);\n    var self = this;\n    // try add to the cache and if we've got _postSize number of entries, attempt to post them to the server\n    try {\n        var newLength = self.cache.add( self._buildEntry( level, namespace, logArguments ) );\n        if( newLength >= self._postSize ){\n            self._postCache();\n        }\n    // discard entry if an error occurs, but warn if level set to do so\n    } catch( err ){\n        self._emitToConsole( 'warn', 'MetricsLogger',\n            [ 'Metrics logger could not stringify logArguments:', namespace, logArguments ] );\n        self._emitToConsole( 'error', 'MetricsLogger', [ err ] );\n\n    }\n    return self;\n};\n\n/** build a log cache entry object from the given level, namespace, and arguments (optionally adding timestamp */\nMetricsLogger.prototype._buildEntry = function _buildEntry( level, namespace, logArguments ){\n    this._emitToConsole( 'debug', 'MetricsLogger', [ '_buildEntry:', arguments ]);\n    var entry = {\n            level       : level,\n            namespace   : this.options.clientPrefix + namespace,\n            args        : logArguments\n        };\n    if( this.options.addTime ){\n        entry.time = new Date().toISOString();\n    }\n    return entry;\n};\n\n/** post _postSize messages from the cache to the server, removing them if successful\n *      if the post fails, wait until maxCacheSize is accumulated instead and try again then\n *      in addition to the messages from the cache ('metrics'), any info from getPingData (if set) will be sent\n *      onServerResponse will be called (if set) with any response from the server\n */\nMetricsLogger.prototype._postCache = function _postCache( options ){\n    options = options || {};\n    this._emitToConsole( 'info', 'MetricsLogger', [ '_postCache', options, this._postSize ]);\n\n    // short circuit if we're already sending\n    if( !this.options.postUrl || this._sending ){\n        return jQuery.when({});\n    }\n\n    var self = this,\n        postSize = options.count || self._postSize,\n        // do not splice - remove after *successful* post\n        entries = self.cache.get( postSize ),\n        entriesLength = entries.length,\n        // use the optional getPingData to add any extra info we may want to send\n        postData = ( typeof self.options.getPingData === 'function' )?( self.options.getPingData() ):( {} );\n    //console.debug( postSize, entriesLength );\n\n    // add the metrics and send\n    postData.metrics = JSON.stringify( entries );\n    //console.debug( postData.metrics );\n    self._sending = true;\n    return jQuery.post( self.options.postUrl, postData )\n        .always( function(){\n            self._sending = false;\n        })\n        .fail( function( xhr, status, message ){\n            // if we failed the previous time, set the next post target to the max num of entries\n            self._postSize = self.options.maxCacheSize;\n//TODO:??\n            // log this failure to explain any gap in metrics\n            this.emit( 'error', 'MetricsLogger', [ '_postCache error:',\n                xhr.readyState, xhr.status, xhr.responseJSON || xhr.responseText ]);\n//TODO: still doesn't solve the problem that when cache == max, post will be tried on every emit\n//TODO: see _delayPost\n        })\n        .done( function( response ){\n            if( typeof self.options.onServerResponse === 'function' ){\n                self.options.onServerResponse( response );\n            }\n            // only remove if post successful\n            self.cache.remove( entriesLength );\n            //console.debug( 'removed entries:', entriesLength, 'size now:', self.cache.length() );\n            // if we succeeded, reset the post target to the normal num of entries\n            self._postSize = self.options.postSize;\n        });\n    // return the xhr promise\n};\n\n/** set _waiting to true and, after delayPostInMs, set it back to false */\nMetricsLogger.prototype._delayPost = function _delayPost(){\n//TODO: this won't work between pages\n    var self = this;\n    self._waiting = setTimeout( function(){\n        self._waiting = null;\n    }, self.options.delayPostInMs );\n};\n\n\n//----------------------------------------------------------------------------- console\n/** output message to console based on level and consoleLogger type */\nMetricsLogger.prototype._emitToConsole = function _emitToConsole( level, namespace, logArguments ){\n    //console.debug( '_emitToConsole:', level, namespace, logArguments );\n    var self = this,\n        whitelist = self.options.consoleNamespaceWhitelist;\n    if( !self.consoleLogger ){ return self; }\n    // if a whitelist for namespaces is set, bail if this namespace is not in the list\n    if( whitelist && whitelist.indexOf( namespace ) === -1 ){\n        return self;\n    }\n\n    var args = Array.prototype.slice.call( logArguments, 0 );\n    args.unshift( namespace );\n//TODO: script location and/or source maps?\n//TODO: branch on navigator.userAgent == AIIEEE - it only has log\n    if(        level >= MetricsLogger.METRIC && typeof( self.consoleLogger.info ) === 'function' ){\n        return self.consoleLogger.info.apply( self.consoleLogger, args );\n\n    } else if( level >= MetricsLogger.ERROR && typeof( self.consoleLogger.error ) === 'function' ){\n        return self.consoleLogger.error.apply( self.consoleLogger, args );\n    } else if( level >= MetricsLogger.WARN && typeof( self.consoleLogger.warn ) === 'function' ){\n        self.consoleLogger.warn.apply( self.consoleLogger, args );\n    } else if( level >= MetricsLogger.INFO && typeof( self.consoleLogger.info ) === 'function' ){\n        self.consoleLogger.info.apply( self.consoleLogger, args );\n    } else if( level >= MetricsLogger.DEBUG && typeof( self.consoleLogger.debug ) === 'function' ){\n        self.consoleLogger.debug.apply( self.consoleLogger, args );\n    } else if( typeof( self.consoleLogger.log ) === 'function' ){\n        self.consoleLogger.log.apply( self.consoleLogger, args );\n    }\n    return self;\n};\n\n//----------------------------------------------------------------------------- shortcuts\n// generic functions when logging from non-namespaced object (e.g. templates)\n/** log to default namespace */\nMetricsLogger.prototype.log = function log(){\n    this.emit( 1, this.options.defaultNamespace,\n        Array.prototype.slice.call( arguments, 0 ) );\n};\n\n/** debug to default namespace */\nMetricsLogger.prototype.debug = function debug(){\n    this.emit( MetricsLogger.DEBUG, this.options.defaultNamespace,\n        Array.prototype.slice.call( arguments, 0 ) );\n};\n\n/** info to default namespace */\nMetricsLogger.prototype.info = function info(){\n    this.emit( MetricsLogger.INFO, this.options.defaultNamespace,\n        Array.prototype.slice.call( arguments, 0 ) );\n};\n\n/** warn to default namespace */\nMetricsLogger.prototype.warn = function warn(){\n    this.emit( MetricsLogger.WARN, this.options.defaultNamespace,\n        Array.prototype.slice.call( arguments, 0 ) );\n};\n\n/** error to default namespace */\nMetricsLogger.prototype.error = function error(){\n    this.emit( MetricsLogger.ERROR, this.options.defaultNamespace,\n        Array.prototype.slice.call( arguments, 0 ) );\n};\n\n/** metric to default namespace */\nMetricsLogger.prototype.metric = function metric(){\n    this.emit( MetricsLogger.METRIC, this.options.defaultNamespace,\n        Array.prototype.slice.call( arguments, 0 ) );\n};\n\n\n/* ============================================================================\nTODO:\n    need a performance pass - the JSON un/parsing is a bit much\n\n============================================================================ */\n/** @class LoggingCache\n *  Simple implementation of cache wrapping an array.\n *\n *  Formats an entry before it's cached and only keeps options.maxSize number\n *  of entries. Older entries are deleted first.\n */\nfunction LoggingCache( options ){\n    var self = this;\n    return self._init( options || {} );\n}\n\n/** default options */\nLoggingCache.defaultOptions = {\n    /** maximum number of entries to keep before discarding oldest */\n    maxSize     : 5000\n};\n\n/** initialize with options */\nLoggingCache.prototype._init = function _init( options ){\n    if( !this._hasStorage() ){\n        //TODO: fall back to jstorage\n        throw new Error( 'LoggingCache needs localStorage' );\n    }\n    if( !options.key ){\n        throw new Error( 'LoggingCache needs key for localStorage' );\n    }\n    this.key = options.key;\n    this._initStorage();\n\n    this.maxSize = options.maxSize || LoggingCache.defaultOptions.maxSize;\n    return this;\n};\n\n/** tests for localStorage fns */\nLoggingCache.prototype._hasStorage = function _hasStorage(){\n//TODO: modernizr\n    var test = 'test';\n    try {\n        localStorage.setItem( test, test );\n        localStorage.removeItem( test );\n        return true;\n    } catch( e ){\n        return false;\n    }\n};\n\n/** if no localStorage set for key, initialize to empty array */\nLoggingCache.prototype._initStorage = function _initStorage(){\n    if( localStorage.getItem( this.key ) === null ){\n        return this.empty();\n    }\n    return this;\n};\n\n/** add an entry to the cache, removing the oldest beforehand if size >= maxSize */\nLoggingCache.prototype.add = function add( entry ){\n    var self = this,\n        _cache = self._fetchAndParse(),\n        overage = ( _cache.length + 1 ) - self.maxSize;\n    if( overage > 0 ){\n        _cache.splice( 0, overage );\n    }\n    _cache.push( entry );\n    self._unparseAndStore( _cache );\n    return _cache.length;\n};\n\n/** get the entries from localStorage and parse them */\nLoggingCache.prototype._fetchAndParse = function _fetchAndParse(){\n    var self = this;\n    return JSON.parse( localStorage.getItem( self.key ) );\n};\n\n/** stringify the entries and put them in localStorage */\nLoggingCache.prototype._unparseAndStore = function _unparseAndStore( entries ){\n    var self = this;\n    return localStorage.setItem( self.key, JSON.stringify( entries ) );\n};\n\n///** process the entry before caching */\n//LoggingCache.prototype._preprocessEntry = function _preprocessEntry( entry ){\n//    return JSON.stringify( entry );\n//};\n\n/** return the length --- oh, getters where are you? */\nLoggingCache.prototype.length = function length(){\n    return this._fetchAndParse().length;\n};\n\n/** get count number of entries starting with the oldest */\nLoggingCache.prototype.get = function get( count ){\n    return this._fetchAndParse().slice( 0, count );\n};\n\n/** remove count number of entries starting with the oldest */\nLoggingCache.prototype.remove = function remove( count ){\n    var _cache = this._fetchAndParse(),\n        removed = _cache.splice( 0, count );\n    this._unparseAndStore( _cache );\n    return removed;\n};\n\n/** empty/clear the entire cache */\nLoggingCache.prototype.empty = function empty(){\n    localStorage.setItem( this.key, '[]' );\n    return this;\n};\n\n/** stringify count number of entries (but do not remove) */\nLoggingCache.prototype.stringify = function stringify( count ){\n    return JSON.stringify( this.get( count ) );\n};\n\n/** outputs entire cache to console */\nLoggingCache.prototype.print = function print(){\n    // popup? (really, carl? a popup?) - easier to copy/paste\n    console.log( JSON.stringify( this._fetchAndParse(), null, '  ' ) );\n};\n\n\n//=============================================================================\n    return {\n        MetricsLogger  : MetricsLogger,\n        LoggingCache   : LoggingCache\n    };\n});\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./galaxy/scripts/utils/metrics-logger.js\n ** module id = 142\n ** module chunks = 4\n **/"],"sourceRoot":""}